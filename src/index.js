/* global SillyTavern */

const MODULE_NAME = 'MazeMaster';

// Factory defaults version - increment this when you update DEFAULT_* constants
// and want all users to get the updated factory defaults
const FACTORY_DEFAULTS_VERSION = 15;

// Dynamically detect the extension folder name from the script URL
// This handles both 'MazeMaster' and 'SillyTavern-MazeMaster' folder names
let EXTENSION_FOLDER_NAME = MODULE_NAME;
try {
    // import.meta.url gives us the current script's URL in ES modules
    const scriptUrl = import.meta.url;
    const match = scriptUrl.match(/\/scripts\/extensions\/third-party\/([^/]+)\//);
    if (match && match[1]) {
        EXTENSION_FOLDER_NAME = match[1];
    }
} catch (e) {
    // Fallback: search for our script in document
    const scripts = document.querySelectorAll('script[src*="MazeMaster"]');
    for (const script of scripts) {
        const match = script.src.match(/\/scripts\/extensions\/third-party\/([^/]+)\//);
        if (match && match[1]) {
            EXTENSION_FOLDER_NAME = match[1];
            break;
        }
    }
}

const {
    saveSettingsDebounced,
    SlashCommandParser,
    SlashCommand,
    ARGUMENT_TYPE,
    SlashCommandNamedArgument,
    executeSlashCommandsWithOptions,
    getRequestHeaders,
    callGenericPopup,
    POPUP_TYPE,
    generateQuietPrompt,
    getPresetManager,
    mainApi,
} = SillyTavern.getContext();

// =============================================================================
// CONSTANTS
// =============================================================================

const WHEEL_COLORS = [
    '#e74c3c', '#3498db', '#2ecc71', '#f39c12',
    '#9b59b6', '#1abc9c', '#e67e22', '#34495e',
    '#e91e63', '#00bcd4', '#8bc34a', '#ff5722',
];

const SIZE_UNITS = {
    fraction: 1,
    halfseg: 0.5,
    doubleseg: 2,
};

const SIZE_OPTIONS = ['fraction', 'halfseg', 'doubleseg'];

// Battlebar difficulty: continuous 1-10 scale
// Lower = bigger zone + slower speed, Higher = smaller zone + faster speed
// Maze profiles can apply a difficulty multiplier on top of this
const BATTLEBAR_DIFFICULTY_RANGE = {
    minZoneWidth: 0.10,   // Hardest (difficulty 10)
    maxZoneWidth: 0.45,   // Easiest (difficulty 1)
    minTraverseTime: 1200, // Fastest (difficulty 10)
    maxTraverseTime: 4000, // Slowest (difficulty 1)
};

/**
 * Calculate battlebar settings from difficulty value (1-10)
 * @param {number} difficulty - Base difficulty 1-10 from battlebar profile
 * @param {number} multiplier - Difficulty multiplier from maze profile (default 1.0)
 * @returns {{ zoneWidth: number, traverseTime: number }}
 */
function getBattlebarDifficultySettings(difficulty = 5, multiplier = 1.0) {
    // Apply multiplier to difficulty (higher multiplier = harder)
    const effectiveDifficulty = Math.max(1, Math.min(10, difficulty * multiplier));
    // Convert 1-10 to 0-1 scale
    const t = (effectiveDifficulty - 1) / 9;
    // Interpolate: at t=0 (easy) use max values, at t=1 (hard) use min values
    const range = BATTLEBAR_DIFFICULTY_RANGE;
    const zoneWidth = range.maxZoneWidth - (t * (range.maxZoneWidth - range.minZoneWidth));
    const traverseTime = range.maxTraverseTime - (t * (range.maxTraverseTime - range.minTraverseTime));
    return { zoneWidth, traverseTime: Math.round(traverseTime) };
}

// Legacy compatibility: map old 1-5 scale to new 1-10 scale
const BATTLEBAR_DIFFICULTY_LEGACY = { 1: 2, 2: 4, 3: 5, 4: 7, 5: 9 };

// Default timeout for STScript execution (10 seconds)
const STSCRIPT_TIMEOUT_MS = 10000;

// Difficulty tier configurations for full scaling
const DIFFICULTY_TIERS = {
    // v1.6.0: Expanded to 6 tiers with full feature integration
    tutorial: {
        name: 'Tutorial',
        description: 'Learn the basics with maximum assistance',
        gridSizeRange: { min: 4, max: 6 },
        // Core multipliers
        encounterDensityMult: 0.3,
        trapFrequencyMult: 0.0,
        battlebarZoneMult: 1.5,
        battlebarSpeedMult: 0.6,
        inventoryStartMult: 2.0,
        minionAggressionMult: 0.0,
        chestLootMult: 2.0,
        // HP System multipliers
        hpMult: 1.5,
        damageMult: 0.3,
        healMult: 2.0,
        // v1.6.0: Multi-floor & Zones
        floors: 1,
        zonesPerFloor: 1,
        zoneUnlockMethod: 'none',
        zoneUnlockThreshold: 0,
        // v1.6.0: Feature profiles
        visionProfile: 'fullvisibility',
        combatMechanicsProfile: 'none',
        factionEnabled: false,
        permadeathAllowed: false,
        permadeathRequired: false,
        vfxIntensity: 0.5,
        // v1.6.0: Find Early
        findEarly: {
            radius: 6,
            items: ['lantern', 'torch', 'healingPotion', 'mapFragment', 'key', 'strike'],
            itemsPerChest: 3,
        },
    },
    easy: {
        name: 'Easy',
        description: 'Relaxed exploration with generous resources',
        gridSizeRange: { min: 6, max: 10 },
        // Core multipliers
        encounterDensityMult: 0.7,
        trapFrequencyMult: 0.3,
        battlebarZoneMult: 1.3,
        battlebarSpeedMult: 0.8,
        inventoryStartMult: 1.5,
        minionAggressionMult: 0.5,
        chestLootMult: 1.3,
        // HP System multipliers
        hpMult: 1.3,
        damageMult: 0.7,
        healMult: 1.3,
        // v1.6.0: Multi-floor & Zones
        floors: 1,
        zonesPerFloor: 2,
        zoneUnlockMethod: 'clear',
        zoneUnlockThreshold: 0.5,
        // v1.6.0: Feature profiles
        visionProfile: 'explorer',
        combatMechanicsProfile: 'simple',
        factionEnabled: false,
        permadeathAllowed: false,
        permadeathRequired: false,
        vfxIntensity: 0.7,
        // v1.6.0: Find Early
        findEarly: {
            radius: 5,
            items: ['lantern', 'torch', 'healingPotion', 'mapFragment'],
            itemsPerChest: 2,
        },
    },
    normal: {
        name: 'Normal',
        description: 'Balanced challenge for most players',
        gridSizeRange: { min: 8, max: 14 },
        // Core multipliers
        encounterDensityMult: 1.0,
        trapFrequencyMult: 1.0,
        battlebarZoneMult: 1.0,
        battlebarSpeedMult: 1.0,
        inventoryStartMult: 1.0,
        minionAggressionMult: 1.0,
        chestLootMult: 1.0,
        // HP System multipliers
        hpMult: 1.0,
        damageMult: 1.0,
        healMult: 1.0,
        // v1.6.0: Multi-floor & Zones
        floors: 2,
        zonesPerFloor: 3,
        zoneUnlockMethod: 'clear',
        zoneUnlockThreshold: 0.75,
        // v1.6.0: Feature profiles
        visionProfile: 'default',
        combatMechanicsProfile: 'default',
        factionEnabled: true,
        permadeathAllowed: false,
        permadeathRequired: false,
        vfxIntensity: 1.0,
        // v1.6.0: Find Early
        findEarly: {
            radius: 4,
            items: ['torch', 'healingPotion', 'mapFragment'],
            itemsPerChest: 1,
        },
    },
    hard: {
        name: 'Hard',
        description: 'Demanding combat and resource scarcity',
        gridSizeRange: { min: 10, max: 16 },
        // Core multipliers
        encounterDensityMult: 1.4,
        trapFrequencyMult: 1.5,
        battlebarZoneMult: 0.8,
        battlebarSpeedMult: 1.2,
        inventoryStartMult: 0.7,
        minionAggressionMult: 1.5,
        chestLootMult: 0.8,
        // HP System multipliers
        hpMult: 0.8,
        damageMult: 1.3,
        healMult: 0.8,
        // v1.6.0: Multi-floor & Zones
        floors: 3,
        zonesPerFloor: 4,
        zoneUnlockMethod: 'clear',
        zoneUnlockThreshold: 0.9,
        // v1.6.0: Feature profiles
        visionProfile: 'survival',
        combatMechanicsProfile: 'default',
        factionEnabled: true,
        permadeathAllowed: true,
        permadeathRequired: false,
        vfxIntensity: 1.0,
        // v1.6.0: Find Early
        findEarly: {
            radius: 3,
            items: ['torch', 'healingPotion'],
            itemsPerChest: 1,
        },
    },
    nightmare: {
        name: 'Nightmare',
        description: 'Brutal survival with minimal margin for error',
        gridSizeRange: { min: 12, max: 18 },
        // Core multipliers
        encounterDensityMult: 1.8,
        trapFrequencyMult: 2.0,
        battlebarZoneMult: 0.6,
        battlebarSpeedMult: 1.4,
        inventoryStartMult: 0.4,
        minionAggressionMult: 2.0,
        chestLootMult: 0.6,
        // HP System multipliers
        hpMult: 0.6,
        damageMult: 1.6,
        healMult: 0.6,
        // v1.6.0: Multi-floor & Zones
        floors: 4,
        zonesPerFloor: 4,
        zoneUnlockMethod: 'boss',
        zoneUnlockThreshold: 1.0,
        // v1.6.0: Feature profiles
        visionProfile: 'survival',
        combatMechanicsProfile: 'aggressive',
        factionEnabled: true,
        permadeathAllowed: true,
        permadeathRequired: true,
        vfxIntensity: 1.2,
        // v1.6.0: Find Early
        findEarly: {
            radius: 2,
            items: ['torch'],
            itemsPerChest: 1,
        },
    },
    apocalypse: {
        name: 'Apocalypse',
        description: 'Permadeath mandatory. Only legends survive.',
        gridSizeRange: { min: 14, max: 20 },
        // Core multipliers
        encounterDensityMult: 2.2,
        trapFrequencyMult: 2.5,
        battlebarZoneMult: 0.5,
        battlebarSpeedMult: 1.6,
        inventoryStartMult: 0.2,
        minionAggressionMult: 2.5,
        chestLootMult: 0.5,
        // HP System multipliers
        hpMult: 0.5,
        damageMult: 2.0,
        healMult: 0.4,
        // v1.6.0: Multi-floor & Zones
        floors: 5,
        zonesPerFloor: 5,
        zoneUnlockMethod: 'boss',
        zoneUnlockThreshold: 1.0,
        requireFloorKey: true,
        // v1.6.0: Feature profiles
        visionProfile: 'survival',
        combatMechanicsProfile: 'lethal',
        factionEnabled: true,
        permadeathAllowed: true,
        permadeathRequired: true,
        vfxIntensity: 1.5,
        // v1.6.0: Find Early
        findEarly: {
            radius: 0,
            items: [],
            itemsPerChest: 0,
        },
    },
};

// Scenario themes for flavor text and naming
const SCENARIO_THEMES = {
    fantasy: {
        name: 'Fantasy',
        tileMappings: {
            wall: 'stone wall',
            floor: 'dungeon floor',
            chest: 'treasure chest',
            exit: 'portal to freedom',
            portal: 'mystic gateway',
            trap: 'arcane trap',
            stairUp: 'ascending staircase',
            stairDown: 'descending staircase',
            minion: 'creature',
        },
        itemAliases: {
            key: 'Iron Key',
            stealth: 'Cloak of Shadows',
            strike: 'Battle Fury',
            execute: 'Divine Wrath',
            floorKey: 'Stairway Key',
            portalStone: 'Portal Stone',
            minionBane: 'Monster Bane',
            mapFragment: 'Ancient Map',
            timeShard: 'Time Crystal',
            voidWalk: 'Ghost Step Potion',
        },
        flavorMessages: {
            chestFind: 'You discover an ancient treasure chest!',
            portalUse: 'The mystic gateway shimmers and pulls you through!',
            trapTrigger: 'An arcane glyph activates beneath your feet!',
            stairUp: 'You ascend the ancient staircase...',
            stairDown: 'You descend into the depths below...',
            victory: 'Glory! You have conquered the dungeon!',
            defeat: 'The darkness claims another soul...',
        },
        colors: {
            primary: '#2ecc71',
            secondary: '#27ae60',
            accent: '#f1c40f',
        },
    },
    horror: {
        name: 'Horror',
        tileMappings: {
            wall: 'blood-stained wall',
            floor: 'creaking floorboard',
            chest: 'ominous coffin',
            exit: 'escape route',
            portal: 'dark rift',
            trap: 'deadly snare',
            stairUp: 'rickety ladder up',
            stairDown: 'descending pit',
            minion: 'abomination',
        },
        itemAliases: {
            key: 'Rusty Key',
            stealth: 'Shadow Shroud',
            strike: 'Adrenaline Rush',
            execute: 'Survival Instinct',
            floorKey: 'Cellar Key',
            portalStone: 'Dark Crystal',
            minionBane: 'Banishment Charm',
            mapFragment: 'Torn Note',
            timeShard: 'Slowing Serum',
            voidWalk: 'Phase Vial',
        },
        flavorMessages: {
            chestFind: 'A decrepit coffin... dare you open it?',
            portalUse: 'The rift tears open, pulling you into darkness!',
            trapTrigger: 'You hear a click... then screaming.',
            stairUp: 'The ladder groans under your weight...',
            stairDown: 'You descend into the suffocating darkness...',
            victory: 'You escape... but the nightmares will follow.',
            defeat: 'Your screams echo eternally in the void...',
        },
        colors: {
            primary: '#c0392b',
            secondary: '#8e1b1b',
            accent: '#7f8c8d',
        },
    },
    scifi: {
        name: 'Sci-Fi',
        tileMappings: {
            wall: 'reinforced bulkhead',
            floor: 'metal grating',
            chest: 'supply crate',
            exit: 'escape pod',
            portal: 'warp gate',
            trap: 'security system',
            stairUp: 'elevator up',
            stairDown: 'elevator down',
            minion: 'hostile entity',
        },
        itemAliases: {
            key: 'Access Card',
            stealth: 'Cloaking Device',
            strike: 'Combat Stim',
            execute: 'Overdrive Module',
            floorKey: 'Deck Keycard',
            portalStone: 'Teleport Beacon',
            minionBane: 'EMP Grenade',
            mapFragment: 'Data Pad',
            timeShard: 'Temporal Disruptor',
            voidWalk: 'Phase Shifter',
        },
        flavorMessages: {
            chestFind: 'A sealed supply crate. Contents unknown.',
            portalUse: 'Warp gate activated. Brace for teleportation.',
            trapTrigger: 'SECURITY ALERT: Hostile detected!',
            stairUp: 'Elevator ascending to upper deck...',
            stairDown: 'Elevator descending to lower deck...',
            victory: 'Mission complete. Extraction successful.',
            defeat: 'SYSTEM FAILURE: Life signs terminated.',
        },
        colors: {
            primary: '#3498db',
            secondary: '#2980b9',
            accent: '#1abc9c',
        },
    },
    action: {
        name: 'Action',
        tileMappings: {
            wall: 'concrete barrier',
            floor: 'worn tile',
            chest: 'ammo crate',
            exit: 'extraction point',
            portal: 'fast rope insertion',
            trap: 'booby trap',
            stairUp: 'ladder up',
            stairDown: 'ladder down',
            minion: 'hostile',
        },
        itemAliases: {
            key: 'Master Key',
            stealth: 'Smoke Grenade',
            strike: 'Adrenaline Shot',
            execute: 'Air Strike',
            floorKey: 'Building Key',
            portalStone: 'Zip Line',
            minionBane: 'Flashbang',
            mapFragment: 'Intel Report',
            timeShard: 'Slow-Mo Serum',
            voidWalk: 'Breach Charge',
        },
        flavorMessages: {
            chestFind: 'Supply cache located. Check for booby traps.',
            portalUse: 'Moving to new position!',
            trapTrigger: 'Contact! Hostile fire!',
            stairUp: 'Moving up! Watch your six!',
            stairDown: 'Descending! Stay frosty!',
            victory: 'Area secured. Good work, soldier.',
            defeat: 'Man down! Mission failed.',
        },
        colors: {
            primary: '#e67e22',
            secondary: '#d35400',
            accent: '#95a5a6',
        },
    },
    cyberpunk: {
        name: 'Cyberpunk',
        tileMappings: {
            wall: 'neon-lit barrier',
            floor: 'chrome plating',
            chest: 'data cache',
            exit: 'extraction node',
            portal: 'netrunner jack',
            trap: 'ICE protocol',
            stairUp: 'mag-lift up',
            stairDown: 'mag-lift down',
            minion: 'cyborg',
        },
        itemAliases: {
            key: 'Access Chip',
            stealth: 'Optical Camo',
            strike: 'Combat Stims',
            execute: 'Berserker Mode',
            floorKey: 'Elevator Override',
            portalStone: 'Fast Travel Chip',
            minionBane: 'System Crash',
            mapFragment: 'Hacked Schematic',
            timeShard: 'Reflex Booster',
            voidWalk: 'Ghost Protocol',
        },
        flavorMessages: {
            chestFind: 'Data cache detected. Initiating decrypt...',
            portalUse: 'Jacking in... connection established.',
            trapTrigger: 'ICE DETECTED! Countermeasures active!',
            stairUp: 'Mag-lift ascending to upper level...',
            stairDown: 'Mag-lift descending to sub-level...',
            victory: 'Run complete. Payout received, choom.',
            defeat: 'Flatlined. Your chrome belongs to the corp now.',
        },
        colors: {
            primary: '#ff00ff',
            secondary: '#00ffff',
            accent: '#ffff00',
        },
    },
    noir: {
        name: 'Noir',
        tileMappings: {
            wall: 'rain-streaked wall',
            floor: 'wet pavement',
            chest: 'locked safe',
            exit: 'back alley exit',
            portal: 'secret passage',
            trap: 'hidden wire',
            stairUp: 'fire escape up',
            stairDown: 'cellar stairs',
            minion: 'goon',
        },
        itemAliases: {
            key: 'Skeleton Key',
            stealth: 'Trench Coat',
            strike: 'Brass Knuckles',
            execute: 'Tommy Gun',
            floorKey: 'Service Key',
            portalStone: 'Secret Map',
            minionBane: 'Blackmail File',
            mapFragment: 'Case Notes',
            timeShard: 'Pocket Watch',
            voidWalk: 'Shadow Step',
        },
        flavorMessages: {
            chestFind: 'A safe in the shadows. Someone has secrets...',
            portalUse: 'The bookcase slides aside, revealing a passage.',
            trapTrigger: 'You hear a click. This was a setup.',
            stairUp: 'The fire escape groans in the rain...',
            stairDown: 'Down into the cellar. Watch your back.',
            victory: 'Case closed. Time for a drink.',
            defeat: 'Another gumshoe lost to the city...',
        },
        colors: {
            primary: '#4a4a4a',
            secondary: '#2c2c2c',
            accent: '#c9a227',
        },
    },
    postapoc: {
        name: 'Post-Apocalyptic',
        tileMappings: {
            wall: 'crumbling rubble',
            floor: 'irradiated ground',
            chest: 'salvage pile',
            exit: 'safe zone',
            portal: 'collapsed tunnel',
            trap: 'radiation hotspot',
            stairUp: 'rusted ladder up',
            stairDown: 'crater descent',
            minion: 'mutant',
        },
        itemAliases: {
            key: 'Vault Keycard',
            stealth: 'Ghillie Wrap',
            strike: 'Rad-X Boost',
            execute: 'Mini Nuke',
            floorKey: 'Bunker Code',
            portalStone: 'Signal Flare',
            minionBane: 'Purifier',
            mapFragment: 'Scavenged Map',
            timeShard: 'Stasis Field',
            voidWalk: 'Hazmat Suit',
        },
        flavorMessages: {
            chestFind: 'A salvage cache from the old world...',
            portalUse: 'You squeeze through the collapsed tunnel.',
            trapTrigger: 'GEIGER SPIKE! Radiation flooding the area!',
            stairUp: 'The rusted ladder holds... barely.',
            stairDown: 'Descending into the crater...',
            victory: 'You survived. For now.',
            defeat: 'The wasteland claims another soul...',
        },
        colors: {
            primary: '#8b7355',
            secondary: '#556b2f',
            accent: '#cd853f',
        },
    },
    comedy: {
        name: 'Comedy',
        tileMappings: {
            wall: 'suspiciously normal wall',
            floor: 'slightly sticky floor',
            chest: 'mystery box',
            exit: 'extremely obvious exit',
            portal: 'plot hole',
            trap: 'banana peel',
            stairUp: 'escalator (broken)',
            stairDown: 'slide',
            minion: 'weirdo',
        },
        itemAliases: {
            key: 'Comically Large Key',
            stealth: 'Cardboard Box',
            strike: 'Energy Drink',
            execute: 'Power of Friendship',
            floorKey: 'Janitor\'s Master Key',
            portalStone: 'Plot Device',
            minionBane: 'Bad Pun',
            mapFragment: 'Napkin Drawing',
            timeShard: 'Dramatic Pause',
            voidWalk: 'Fourth Wall Break',
        },
        flavorMessages: {
            chestFind: 'Ooh, a mystery box! It could be anything!',
            portalUse: 'You fall through a plot hole!',
            trapTrigger: 'Classic banana peel. You saw it coming.',
            stairUp: 'The escalator is broken. Guess it\'s just stairs now.',
            stairDown: 'WHEEE! *slide noises*',
            victory: 'You win! The crowd goes mild!',
            defeat: 'Wah wah wahhh... Game Over, buddy.',
        },
        colors: {
            primary: '#ff6b6b',
            secondary: '#feca57',
            accent: '#48dbfb',
        },
    },
    western: {
        name: 'Western',
        tileMappings: {
            wall: 'wooden planks',
            floor: 'dusty floorboards',
            chest: 'strongbox',
            exit: 'town limits',
            portal: 'mine shaft',
            trap: 'rattlesnake den',
            stairUp: 'rickety stairs up',
            stairDown: 'cellar hatch',
            minion: 'outlaw',
        },
        itemAliases: {
            key: 'Skeleton Key',
            stealth: 'Poncho',
            strike: 'Whiskey Courage',
            execute: 'Dynamite Bundle',
            floorKey: 'Mine Key',
            portalStone: 'Treasure Map',
            minionBane: 'Silver Bullet',
            mapFragment: 'Wanted Poster',
            timeShard: 'High Noon Focus',
            voidWalk: 'Tumbleweed Roll',
        },
        flavorMessages: {
            chestFind: 'A locked strongbox. Could be gold inside...',
            portalUse: 'You duck into the old mine shaft.',
            trapTrigger: 'RATTLESNAKES! Draw!',
            stairUp: 'The stairs creak with every step...',
            stairDown: 'Down into the root cellar...',
            victory: 'You ride off into the sunset, partner.',
            defeat: 'This town wasn\'t big enough for both of ya.',
        },
        colors: {
            primary: '#d2691e',
            secondary: '#8b4513',
            accent: '#ffd700',
        },
    },
};

// =============================================================================
// ROOM NAME GENERATION SYSTEM (v1.2.1)
// =============================================================================

/**
 * Theme modifiers applied on top of base mapStyle room names
 */
const THEME_MODIFIERS = {
    fantasy: { adjectives: ['Ancient', 'Mystical', 'Enchanted', 'Arcane', 'Forgotten'] },
    horror: { adjectives: ['Blood-Stained', 'Haunted', 'Cursed', 'Rotting', 'Whispering'] },
    scifi: { adjectives: ['Automated', 'Sterile', 'Malfunctioning', 'Quarantined', 'Pressurized'] },
    action: { adjectives: ['Reinforced', 'Tactical', 'Fortified', 'Hostile', 'Secured'] },
    cyberpunk: { adjectives: ['Neon-Lit', 'Chrome', 'Glitched', 'Hacked', 'Blackmarket'] },
    noir: { adjectives: ['Shadowy', 'Smoky', 'Rain-Soaked', 'Dimly-Lit', 'Forgotten'] },
    postapoc: { adjectives: ['Ruined', 'Overgrown', 'Irradiated', 'Collapsed', 'Scavenged'] },
    comedy: { adjectives: ['Suspiciously Normal', 'Slightly Damp', 'Questionable', 'Overdecorated', 'Poorly Labeled'] },
    western: { adjectives: ['Dusty', 'Sun-Bleached', 'Weathered', 'Abandoned', 'Rickety'] },
};

/**
 * Default structure for custom themes created by users
 */
const CUSTOM_THEME_DEFAULTS = {
    name: '',
    displayName: '',
    tags: [],                    // Atmosphere tags for LLM context
    atmosphere: '',              // Atmospheric description for LLM
    adjectives: [],              // Room name modifiers (30% chance)
    roomTypes: {
        small: [],               // Room types for small rooms (≤4 tiles)
        medium: [],              // Room types for medium rooms (≤9 tiles)
        large: [],               // Room types for large rooms (>9 tiles)
        special: []              // Special/boss room types
    },
    flavorMessages: {
        chestFind: '',
        trapTrigger: '',
        victory: '',
        defeat: ''
    },
    colors: {
        primary: '#8b0000',
        secondary: '#2d1f1f',
        accent: '#ff4444'
    }
};

/**
 * v2.0.0: Default theme profiles (factory defaults)
 * These appear in the Themes dropdown alongside custom themes
 */
const DEFAULT_THEME_PROFILES = {
    fantasy: {
        name: 'fantasy',
        displayName: 'Fantasy',
        tags: ['medieval', 'magical', 'dungeon', 'adventure'],
        atmosphere: 'A realm of ancient stone and flickering torchlight, where magic lingers in the shadows.',
        adjectives: ['Ancient', 'Mystical', 'Forgotten', 'Enchanted', 'Cursed'],
        roomTypes: {
            small: ['Alcove', 'Nook', 'Chamber'],
            medium: ['Hall', 'Gallery', 'Sanctum'],
            large: ['Great Hall', 'Throne Room', 'Cathedral'],
            special: ['Dragon\'s Lair', 'Wizard\'s Tower', 'Sacred Grove']
        },
        flavorMessages: {
            chestFind: 'You discover an ornate treasure chest, its lock rusted with age.',
            trapTrigger: 'Ancient magic springs to life, unleashing a deadly trap!',
            victory: 'The foe falls before your blade. Victory is yours!',
            defeat: 'Darkness claims you as your strength fades...'
        },
        colors: { primary: '#8b4513', secondary: '#2d1f1f', accent: '#ffd700' }
    },
    horror: {
        name: 'horror',
        displayName: 'Horror',
        tags: ['dark', 'terrifying', 'supernatural', 'dread'],
        atmosphere: 'Shadows writhe in corners as unspeakable horrors lurk just beyond sight.',
        adjectives: ['Bloodstained', 'Twisted', 'Nightmarish', 'Rotting', 'Haunted'],
        roomTypes: {
            small: ['Crawlspace', 'Closet', 'Cell'],
            medium: ['Morgue', 'Chapel', 'Study'],
            large: ['Ballroom', 'Asylum Ward', 'Crypt'],
            special: ['Ritual Chamber', 'Mass Grave', 'The Pit']
        },
        flavorMessages: {
            chestFind: 'A decrepit box sits in the gloom, something scratches from within...',
            trapTrigger: 'Pain explodes through your body as the trap activates!',
            victory: 'The creature shrieks as it dissolves into shadow.',
            defeat: 'Your screams echo into the darkness...'
        },
        colors: { primary: '#8b0000', secondary: '#1a0a0a', accent: '#ff0000' }
    },
    scifi: {
        name: 'scifi',
        displayName: 'Sci-Fi',
        tags: ['futuristic', 'technological', 'space', 'advanced'],
        atmosphere: 'Humming machinery and sterile corridors of an advanced technological facility.',
        adjectives: ['Automated', 'Damaged', 'Secure', 'Experimental', 'Quarantined'],
        roomTypes: {
            small: ['Access Shaft', 'Storage Pod', 'Maintenance Bay'],
            medium: ['Control Room', 'Laboratory', 'Crew Quarters'],
            large: ['Hangar Bay', 'Command Bridge', 'Reactor Core'],
            special: ['AI Core', 'Xenobiology Lab', 'Escape Pod Bay']
        },
        flavorMessages: {
            chestFind: 'A sealed container awaits, its biometric lock flickering.',
            trapTrigger: 'Security systems activate with deadly precision!',
            victory: 'Target eliminated. Threat neutralized.',
            defeat: 'Critical system failure... consciousness fading...'
        },
        colors: { primary: '#0066cc', secondary: '#1a1a2e', accent: '#00ffff' }
    },
    cyberpunk: {
        name: 'cyberpunk',
        displayName: 'Cyberpunk',
        tags: ['neon', 'corporate', 'hackers', 'dystopian'],
        atmosphere: 'Neon-lit streets and chrome-plated megastructures hide corporate conspiracies.',
        adjectives: ['Hacked', 'Corrupted', 'Black-Market', 'Augmented', 'Underground'],
        roomTypes: {
            small: ['Server Closet', 'Smuggler\'s Cache', 'Wire Nest'],
            medium: ['Hacker Den', 'Chop Shop', 'Black Clinic'],
            large: ['Data Center', 'Combat Arena', 'Corporate Plaza'],
            special: ['CEO Suite', 'AI Mainframe', 'Rebel Base']
        },
        flavorMessages: {
            chestFind: 'A secured stash, probably hot. Worth the risk.',
            trapTrigger: 'ICE protocols engage! Neural feedback imminent!',
            victory: 'Target flatlined. Time to ghost.',
            defeat: 'System crash... your wetware is fried...'
        },
        colors: { primary: '#ff00ff', secondary: '#0a0a1a', accent: '#00ff00' }
    },
    western: {
        name: 'western',
        displayName: 'Western',
        tags: ['frontier', 'dusty', 'lawless', 'rugged'],
        atmosphere: 'Sun-baked desert towns where outlaws and lawmen play deadly games.',
        adjectives: ['Dusty', 'Abandoned', 'Lawless', 'Frontier', 'Sun-bleached'],
        roomTypes: {
            small: ['Jail Cell', 'Supply Closet', 'Stable'],
            medium: ['Saloon', 'Sheriff\'s Office', 'General Store'],
            large: ['Town Square', 'Mine Shaft', 'Cattle Yard'],
            special: ['Bank Vault', 'Outlaw Hideout', 'Boot Hill']
        },
        flavorMessages: {
            chestFind: 'An old strongbox, probably from a stagecoach robbery.',
            trapTrigger: 'You trigger a hidden tripwire - dynamite!',
            victory: 'Another notch on your gunbelt, partner.',
            defeat: 'You\'ve drawn your last breath in the dust...'
        },
        colors: { primary: '#cd853f', secondary: '#2d2416', accent: '#daa520' }
    },
    action: {
        name: 'action',
        displayName: 'Action',
        tags: ['explosive', 'tactical', 'military', 'intense'],
        atmosphere: 'High-stakes combat zones where every second counts and danger lurks around corners.',
        adjectives: ['Fortified', 'Hostile', 'Tactical', 'Compromised', 'Hot'],
        roomTypes: {
            small: ['Armory', 'Comm Station', 'Bunker'],
            medium: ['Barracks', 'War Room', 'Motor Pool'],
            large: ['Battlefield', 'Command Center', 'Extraction Zone'],
            special: ['Bomb Site', 'HVT Location', 'Evac Point']
        },
        flavorMessages: {
            chestFind: 'Supply crate located. Could contain valuable intel.',
            trapTrigger: 'IED detected too late! Brace for impact!',
            victory: 'Hostile down. Area secured.',
            defeat: 'Mission failed. We\'ll get \'em next time...'
        },
        colors: { primary: '#4a5c3c', secondary: '#1a1f1a', accent: '#ff6600' }
    }
};

/**
 * Default structure for custom map styles created by users
 */
const CUSTOM_STYLE_DEFAULTS = {
    name: '',
    displayName: '',
    roomNames: {
        common: { prefixes: [], nouns: [], descriptions: [] },
        junction: { prefixes: [], nouns: [], descriptions: [] },
        deadend: { prefixes: [], nouns: [], descriptions: [] },
        staircase: { names: [], descriptions: [] },
        portal: { names: [], descriptions: [] },
        chest: { names: [], descriptions: [] },
        minion: { names: [], descriptions: [] },
        trap: { names: [], descriptions: [] },
        exit: { names: [], descriptions: [] },
        start: { names: [], descriptions: [] }
    },
    bspConfig: {
        minRoomSize: 2,
        maxRoomSize: 5,
        minSplitSize: 4,
        splitVariance: 0.3,
        corridorWidth: 1,
        roomPadding: 1,
        extraConnections: 0.1,
        branchChance: 0.3,
        preferSquareRooms: false,
        gridAlign: false,
        windingCorridors: false,
        modularRooms: false
    }
};

/**
 * Room name data organized by mapStyle and roomType
 * Room types: common, junction, deadend, staircase, portal, chest, minion, trap, exit, start
 */
const ROOM_NAME_DATA = {
    maze: {
        common: {
            prefixes: ['Winding', 'Narrow', 'Long', 'Dark', 'Quiet'],
            nouns: ['Corridor', 'Passage', 'Hallway', 'Path', 'Tunnel'],
            descriptions: ['The walls press in from both sides.', 'Echoes fade into the distance.', 'The path stretches onward.'],
        },
        junction: {
            prefixes: ['Central', 'Open', 'Connecting', 'Main'],
            nouns: ['Junction', 'Crossroads', 'Intersection', 'Hub'],
            descriptions: ['Multiple paths branch from here.', 'A decision point in the maze.', 'Which way to go?'],
        },
        deadend: {
            prefixes: ['Sealed', 'Blocked', 'Empty', 'Forgotten'],
            nouns: ['Dead End', 'Alcove', 'Nook', 'Corner'],
            descriptions: ['No way forward from here.', 'A quiet corner of the maze.', 'Time to backtrack.'],
        },
        staircase: {
            names: ['The Spiral Path', 'Winding Stairs', 'The Descent', 'Stone Steps'],
            descriptions: ['Worn steps lead to another level.', 'The stairway beckons.'],
        },
        portal: {
            names: ['Mystic Gateway', 'Shimmering Portal', 'The Threshold', 'Warp Point'],
            descriptions: ['Reality bends here.', 'Step through to somewhere else.'],
        },
        chest: {
            names: ['Treasure Alcove', 'Hidden Cache', 'Fortune\'s Corner', 'The Vault'],
            descriptions: ['Something valuable awaits.', 'A promising discovery.'],
        },
        minion: {
            names: ['Guardian\'s Post', 'The Confrontation', 'Danger Zone', 'Enemy Territory'],
            descriptions: ['You sense a presence.', 'Something stirs ahead.'],
        },
        trap: {
            names: ['Treacherous Ground', 'The Snare', 'Danger Ahead', 'False Safety'],
            descriptions: ['The floor seems unstable.', 'Something feels wrong here.'],
        },
        exit: {
            names: ['The Final Gate', 'Freedom\'s Door', 'The End', 'Escape Route'],
            descriptions: ['The exit is within reach!', 'Almost there...'],
        },
        start: {
            names: ['The Beginning', 'Starting Point', 'Entry Hall', 'The Origin'],
            descriptions: ['Your journey begins here.', 'The entrance to the maze.'],
        },
    },
    dungeon: {
        common: {
            prefixes: ['Damp', 'Crumbling', 'Moss-Covered', 'Torch-Lit', 'Stone'],
            nouns: ['Corridor', 'Passage', 'Chamber', 'Tunnel', 'Crypt'],
            descriptions: ['Water drips from the ceiling.', 'Ancient stones line the walls.', 'The air is thick and musty.'],
        },
        junction: {
            prefixes: ['Grand', 'Central', 'Ruined', 'Pillared'],
            nouns: ['Hall', 'Atrium', 'Chamber', 'Rotunda'],
            descriptions: ['Pillars support the vaulted ceiling.', 'Several passages meet here.'],
        },
        deadend: {
            prefixes: ['Collapsed', 'Sealed', 'Empty', 'Forgotten'],
            nouns: ['Tomb', 'Cell', 'Alcove', 'Crypt'],
            descriptions: ['The way is blocked by rubble.', 'Nothing but bones and dust.'],
        },
        staircase: {
            names: ['The Spiral Descent', 'Stone Stairwell', 'Dungeon Steps', 'The Deep Stairs'],
            descriptions: ['Worn steps descend into darkness.', 'Each step echoes ominously.'],
        },
        portal: {
            names: ['Arcane Circle', 'The Dark Rift', 'Summoning Chamber', 'Void Gate'],
            descriptions: ['Strange runes glow on the floor.', 'The air crackles with energy.'],
        },
        chest: {
            names: ['Treasure Vault', 'Burial Cache', 'Hidden Hoard', 'Ancient Coffer'],
            descriptions: ['Gold glimmers in the torchlight.', 'What treasures lie within?'],
        },
        minion: {
            names: ['Guardian\'s Lair', 'The Beast\'s Den', 'Cursed Chamber', 'Haunted Hall'],
            descriptions: ['Something lurks in the shadows.', 'Eyes watch from the darkness.'],
        },
        trap: {
            names: ['Pressure Plates', 'Spike Corridor', 'The Gauntlet', 'Death Trap'],
            descriptions: ['The floor has suspicious tiles.', 'Previous adventurers weren\'t so lucky.'],
        },
        exit: {
            names: ['Dungeon Gate', 'Surface Access', 'The Way Out', 'Freedom\'s Light'],
            descriptions: ['Daylight streams through ahead!', 'The exit awaits!'],
        },
        start: {
            names: ['Dungeon Entrance', 'The First Chamber', 'Entry Vault', 'Beginning of the End'],
            descriptions: ['You enter the dungeon depths.', 'Adventure awaits within.'],
        },
    },
    city: {
        common: {
            prefixes: ['Narrow', 'Crowded', 'Busy', 'Quiet', 'Back'],
            nouns: ['Street', 'Alley', 'Lane', 'Road', 'Avenue'],
            descriptions: ['Buildings tower on either side.', 'The city hums around you.', 'Footsteps echo on cobblestones.'],
        },
        junction: {
            prefixes: ['Main', 'Central', 'Open', 'Market'],
            nouns: ['Square', 'Plaza', 'Intersection', 'Crossroads'],
            descriptions: ['Several streets converge here.', 'A bustling urban hub.'],
        },
        deadend: {
            prefixes: ['Blocked', 'Private', 'Forgotten', 'Secluded'],
            nouns: ['Courtyard', 'Dead End', 'Cul-de-sac', 'Alley'],
            descriptions: ['No way through here.', 'A quiet corner of the city.'],
        },
        staircase: {
            names: ['Fire Escape', 'Metro Stairs', 'Building Access', 'Service Stairwell'],
            descriptions: ['Metal stairs lead up or down.', 'An urban vertical passage.'],
        },
        portal: {
            names: ['Subway Entrance', 'Secret Door', 'Hidden Passage', 'Underground Access'],
            descriptions: ['A way to move quickly.', 'Not everyone knows about this.'],
        },
        chest: {
            names: ['Supply Cache', 'Abandoned Stash', 'Hidden Storage', 'Drop Point'],
            descriptions: ['Someone left supplies here.', 'Could be useful items inside.'],
        },
        minion: {
            names: ['Gang Territory', 'Hostile Zone', 'Ambush Point', 'Danger Zone'],
            descriptions: ['This area isn\'t safe.', 'Watch your back.'],
        },
        trap: {
            names: ['Construction Zone', 'Hazard Area', 'Unstable Ground', 'Danger Zone'],
            descriptions: ['Caution signs litter the area.', 'Something\'s not right here.'],
        },
        exit: {
            names: ['City Limits', 'The Way Out', 'Freedom Boulevard', 'Exit Gate'],
            descriptions: ['Safety is just ahead!', 'Almost out of the city!'],
        },
        start: {
            names: ['Downtown Drop', 'Starting Block', 'Entry Point', 'Ground Zero'],
            descriptions: ['Your urban adventure begins.', 'The city awaits.'],
        },
    },
    forest: {
        common: {
            prefixes: ['Overgrown', 'Shaded', 'Winding', 'Mossy', 'Dense'],
            nouns: ['Path', 'Trail', 'Grove', 'Thicket', 'Clearing'],
            descriptions: ['Leaves rustle overhead.', 'Sunlight filters through the canopy.', 'The forest is alive with sounds.'],
        },
        junction: {
            prefixes: ['Central', 'Open', 'Sunny', 'Ancient'],
            nouns: ['Clearing', 'Glade', 'Meadow', 'Crossroads'],
            descriptions: ['Several paths diverge here.', 'A peaceful clearing in the woods.'],
        },
        deadend: {
            prefixes: ['Tangled', 'Blocked', 'Overgrown', 'Dense'],
            nouns: ['Thicket', 'Dead End', 'Brush', 'Undergrowth'],
            descriptions: ['The vegetation is too thick to pass.', 'No way through this tangle.'],
        },
        staircase: {
            names: ['Root Steps', 'Cliff Path', 'Tree Ladder', 'Natural Stairs'],
            descriptions: ['Natural formations create a path up or down.', 'The terrain changes elevation.'],
        },
        portal: {
            names: ['Fairy Ring', 'Ancient Tree', 'Spirit Gate', 'Enchanted Grove'],
            descriptions: ['Magic lingers in this place.', 'The veil between worlds is thin here.'],
        },
        chest: {
            names: ['Hollow Tree', 'Hidden Cache', 'Nature\'s Gift', 'Forest Bounty'],
            descriptions: ['Something hidden among the roots.', 'The forest provides.'],
        },
        minion: {
            names: ['Beast\'s Territory', 'Predator\'s Ground', 'Wild Zone', 'Creature\'s Lair'],
            descriptions: ['Something territorial lives here.', 'The wildlife seems hostile.'],
        },
        trap: {
            names: ['Quicksand', 'Poison Ivy Patch', 'Hunter\'s Snare', 'Treacherous Ground'],
            descriptions: ['The ground looks unstable.', 'Nature can be dangerous.'],
        },
        exit: {
            names: ['Forest Edge', 'The Clearing', 'Open Fields', 'Way Out'],
            descriptions: ['The tree line ends ahead!', 'Almost out of the forest!'],
        },
        start: {
            names: ['Forest Entrance', 'Trail Head', 'Woods Edge', 'Into the Wild'],
            descriptions: ['The forest path begins here.', 'Adventure awaits in the trees.'],
        },
    },
    outpost: {
        common: {
            prefixes: ['Dusty', 'Wooden', 'Fortified', 'Patrol', 'Guard'],
            nouns: ['Walkway', 'Corridor', 'Passage', 'Path', 'Route'],
            descriptions: ['Wooden planks creak underfoot.', 'The outpost feels hastily constructed.', 'Frontier life is rough.'],
        },
        junction: {
            prefixes: ['Central', 'Main', 'Command', 'Trading'],
            nouns: ['Courtyard', 'Square', 'Hub', 'Plaza'],
            descriptions: ['The heart of the outpost.', 'People gather here.'],
        },
        deadend: {
            prefixes: ['Storage', 'Private', 'Blocked', 'Abandoned'],
            nouns: ['Corner', 'Area', 'Section', 'Alcove'],
            descriptions: ['This area is off-limits.', 'Nothing to see here.'],
        },
        staircase: {
            names: ['Watchtower Ladder', 'Rampart Stairs', 'Cellar Access', 'Tower Steps'],
            descriptions: ['Rough-hewn steps lead up or down.', 'A vertical route through the outpost.'],
        },
        portal: {
            names: ['Secret Tunnel', 'Escape Route', 'Hidden Exit', 'Underground Path'],
            descriptions: ['A hidden way to move quickly.', 'Not on any official maps.'],
        },
        chest: {
            names: ['Supply Crate', 'Armory Cache', 'Provisions Store', 'Trade Goods'],
            descriptions: ['Frontier supplies are valuable.', 'Someone stockpiled resources here.'],
        },
        minion: {
            names: ['Hostile Territory', 'Raider Camp', 'Enemy Ground', 'Danger Zone'],
            descriptions: ['This area isn\'t friendly.', 'Hostiles have been spotted here.'],
        },
        trap: {
            names: ['Perimeter Defense', 'Booby Trap', 'Defensive Line', 'Warning Zone'],
            descriptions: ['The outpost has defenses.', 'Watch where you step.'],
        },
        exit: {
            names: ['Main Gate', 'Frontier Exit', 'The Way Out', 'Open Plains'],
            descriptions: ['The frontier awaits beyond!', 'Almost to safety!'],
        },
        start: {
            names: ['Outpost Gate', 'Arrival Point', 'Entry Post', 'Checkpoint'],
            descriptions: ['Welcome to the frontier.', 'Your mission begins here.'],
        },
    },
    spacestation: {
        common: {
            prefixes: ['Pressurized', 'Maintenance', 'Crew', 'Service', 'Transit'],
            nouns: ['Corridor', 'Deck', 'Section', 'Tube', 'Passageway'],
            descriptions: ['The hum of life support fills the air.', 'Zero-G handles line the walls.', 'Status lights blink in sequence.'],
        },
        junction: {
            prefixes: ['Central', 'Main', 'Command', 'Hub'],
            nouns: ['Atrium', 'Nexus', 'Hub', 'Junction'],
            descriptions: ['Multiple decks connect here.', 'The station\'s central point.'],
        },
        deadend: {
            prefixes: ['Sealed', 'Depressurized', 'Locked', 'Abandoned'],
            nouns: ['Airlock', 'Module', 'Section', 'Bay'],
            descriptions: ['This section is sealed off.', 'No access beyond this point.'],
        },
        staircase: {
            names: ['Deck Ladder', 'Gravity Lift', 'Access Tube', 'Inter-deck Transit'],
            descriptions: ['Vertical transit between decks.', 'Watch your head in zero-G.'],
        },
        portal: {
            names: ['Teleport Pad', 'Warp Gate', 'Transit Pod', 'Instant Travel'],
            descriptions: ['Advanced technology enables instant travel.', 'Step on the pad to teleport.'],
        },
        chest: {
            names: ['Supply Locker', 'Cargo Pod', 'Equipment Bay', 'Resource Cache'],
            descriptions: ['Standard station supplies.', 'Emergency equipment stored here.'],
        },
        minion: {
            names: ['Hostile Sector', 'Quarantine Zone', 'Breach Area', 'Danger Zone'],
            descriptions: ['Security protocols are active.', 'Something hostile is aboard.'],
        },
        trap: {
            names: ['Radiation Leak', 'Decompression Risk', 'Electrical Hazard', 'System Failure'],
            descriptions: ['Warning lights flash urgently.', 'Safety systems are offline.'],
        },
        exit: {
            names: ['Escape Pod Bay', 'Extraction Point', 'Docking Ring', 'The Way Out'],
            descriptions: ['Rescue is just ahead!', 'Almost to the escape pods!'],
        },
        start: {
            names: ['Docking Bay', 'Arrival Deck', 'Entry Point', 'Station Access'],
            descriptions: ['Welcome aboard the station.', 'Your mission begins here.'],
        },
    },
    college: {
        common: {
            prefixes: ['Main', 'Academic', 'Student', 'Faculty', 'Campus'],
            nouns: ['Hallway', 'Corridor', 'Wing', 'Path', 'Walkway'],
            descriptions: ['Lockers line the walls.', 'Motivational posters are everywhere.', 'The smell of cafeteria food lingers.'],
        },
        junction: {
            prefixes: ['Central', 'Main', 'Student', 'Campus'],
            nouns: ['Quad', 'Commons', 'Atrium', 'Hub'],
            descriptions: ['Students gather between classes.', 'The heart of campus life.'],
        },
        deadend: {
            prefixes: ['Maintenance', 'Staff Only', 'Locked', 'Private'],
            nouns: ['Closet', 'Office', 'Room', 'Storage'],
            descriptions: ['This area is restricted.', 'Faculty only beyond this point.'],
        },
        staircase: {
            names: ['Main Stairwell', 'Fire Stairs', 'Back Stairs', 'Service Access'],
            descriptions: ['Standard institutional stairs.', 'Watch out for students rushing to class.'],
        },
        portal: {
            names: ['Secret Passage', 'Underground Tunnel', 'Maintenance Route', 'Shortcut'],
            descriptions: ['Not on the official campus map.', 'Students pass down secret knowledge.'],
        },
        chest: {
            names: ['Lost and Found', 'Supply Closet', 'Locker', 'Hidden Stash'],
            descriptions: ['Someone left something behind.', 'Might find something useful.'],
        },
        minion: {
            names: ['Bully Territory', 'Staff Patrol', 'Security Zone', 'No-Go Area'],
            descriptions: ['Best to avoid this area.', 'Someone unfriendly is here.'],
        },
        trap: {
            names: ['Wet Floor', 'Construction Zone', 'Prank Setup', 'Hazard Area'],
            descriptions: ['Watch your step.', 'Something seems off here.'],
        },
        exit: {
            names: ['Main Exit', 'Campus Gate', 'Front Doors', 'Freedom'],
            descriptions: ['School\'s out!', 'Almost to freedom!'],
        },
        start: {
            names: ['Main Entrance', 'Welcome Hall', 'Registration', 'Starting Point'],
            descriptions: ['Welcome to campus.', 'Your academic adventure begins.'],
        },
    },
    apartment: {
        common: {
            prefixes: ['Narrow', 'Dimly-Lit', 'Carpeted', 'Quiet', 'Long'],
            nouns: ['Hallway', 'Corridor', 'Landing', 'Passage', 'Floor'],
            descriptions: ['Apartment doors line both sides.', 'The building is eerily quiet.', 'Fluorescent lights flicker.'],
        },
        junction: {
            prefixes: ['Main', 'Central', 'Elevator', 'Stair'],
            nouns: ['Lobby', 'Landing', 'Foyer', 'Hub'],
            descriptions: ['Multiple hallways branch from here.', 'The building\'s central area.'],
        },
        deadend: {
            prefixes: ['Locked', 'Private', 'Utility', 'Maintenance'],
            nouns: ['Apartment', 'Room', 'Closet', 'Unit'],
            descriptions: ['This unit is locked.', 'No access here.'],
        },
        staircase: {
            names: ['Fire Stairs', 'Main Stairwell', 'Back Stairs', 'Service Stairs'],
            descriptions: ['Concrete steps echo with each footfall.', 'Standard apartment building stairs.'],
        },
        portal: {
            names: ['Dumbwaiter', 'Laundry Chute', 'Hidden Panel', 'Secret Room'],
            descriptions: ['A hidden way through the building.', 'Not everyone knows about this.'],
        },
        chest: {
            names: ['Storage Unit', 'Abandoned Locker', 'Supply Closet', 'Hidden Cache'],
            descriptions: ['Someone left something behind.', 'Might contain useful items.'],
        },
        minion: {
            names: ['Hostile Unit', 'Occupied Floor', 'Danger Zone', 'Unfriendly Neighbors'],
            descriptions: ['Something unfriendly lives here.', 'Best to be careful.'],
        },
        trap: {
            names: ['Broken Floor', 'Electrical Hazard', 'Gas Leak', 'Structural Damage'],
            descriptions: ['The building isn\'t safe here.', 'Watch your step.'],
        },
        exit: {
            names: ['Main Exit', 'Front Door', 'Fire Exit', 'Street Access'],
            descriptions: ['The street is just ahead!', 'Almost out of the building!'],
        },
        start: {
            names: ['Building Entrance', 'Main Lobby', 'Entry Hall', 'Ground Floor'],
            descriptions: ['You enter the apartment building.', 'Your urban exploration begins.'],
        },
    },
    neotokyo: {
        common: {
            prefixes: ['Neon', 'Crowded', 'Rain-Slicked', 'Holographic', 'Bustling'],
            nouns: ['Street', 'Alley', 'Arcade', 'Passage', 'Lane'],
            descriptions: ['Neon signs reflect off wet pavement.', 'Holographic ads fill the air.', 'The city never sleeps.'],
        },
        junction: {
            prefixes: ['Central', 'Shibuya-Style', 'Main', 'Mega'],
            nouns: ['Crossing', 'Plaza', 'Square', 'Hub'],
            descriptions: ['Thousands of screens illuminate the area.', 'A sensory overload of lights and sounds.'],
        },
        deadend: {
            prefixes: ['Sealed', 'Private', 'VIP', 'Restricted'],
            nouns: ['Booth', 'Room', 'Alley', 'Zone'],
            descriptions: ['No access without credentials.', 'This area is off-limits.'],
        },
        staircase: {
            names: ['Gravity Lift', 'Mag-Rail', 'Sky Bridge', 'Vertical Transit'],
            descriptions: ['High-tech vertical transportation.', 'The city builds upward.'],
        },
        portal: {
            names: ['VR Hub', 'Data Port', 'Network Node', 'Fast Travel'],
            descriptions: ['Jack in to move instantly.', 'The network connects all.'],
        },
        chest: {
            names: ['Vending Cache', 'Data Stash', 'Loot Box', 'Street Vendor'],
            descriptions: ['Even garbage has value here.', 'Credits can buy anything.'],
        },
        minion: {
            names: ['Yakuza Turf', 'Corp Security', 'Gang Territory', 'Hostile Zone'],
            descriptions: ['Someone owns this block.', 'You\'re not welcome here.'],
        },
        trap: {
            names: ['ICE Node', 'Security Grid', 'Drone Patrol', 'Surveillance Zone'],
            descriptions: ['Automated defenses are active.', 'Big Brother is watching.'],
        },
        exit: {
            names: ['City Limits', 'Extraction Point', 'Safe House', 'The Way Out'],
            descriptions: ['Almost out of the neon jungle!', 'Freedom awaits beyond!'],
        },
        start: {
            names: ['Drop Zone', 'Street Level', 'Entry Point', 'Ground Zero'],
            descriptions: ['Welcome to the future.', 'Your cyberpunk adventure begins.'],
        },
    },
    arena: {
        common: {
            prefixes: ['Stone', 'Sandy', 'Blood-Stained', 'Gladiator', 'Battle'],
            nouns: ['Corridor', 'Passage', 'Tunnel', 'Path', 'Way'],
            descriptions: ['The roar of the crowd echoes.', 'Sand and blood mix underfoot.', 'Glory or death awaits.'],
        },
        junction: {
            prefixes: ['Central', 'Main', 'Grand', 'Champion\'s'],
            nouns: ['Arena', 'Ring', 'Pit', 'Stage'],
            descriptions: ['The fighting grounds await.', 'All paths lead to battle.'],
        },
        deadend: {
            prefixes: ['Holding', 'Recovery', 'Equipment', 'Fighter\'s'],
            nouns: ['Cell', 'Room', 'Bay', 'Quarters'],
            descriptions: ['A moment of rest between fights.', 'Prepare for the next battle.'],
        },
        staircase: {
            names: ['Gladiator\'s Rise', 'Champion\'s Lift', 'Arena Access', 'Victory Steps'],
            descriptions: ['The path to glory.', 'Rise to meet your opponent.'],
        },
        portal: {
            names: ['Fighter\'s Gate', 'Champion Portal', 'Mystery Entrance', 'Wild Card'],
            descriptions: ['Where will you emerge?', 'The crowd loves surprises.'],
        },
        chest: {
            names: ['Weapon Rack', 'Prize Cache', 'Spoils of War', 'Victor\'s Reward'],
            descriptions: ['The strong deserve rewards.', 'Claim your prize.'],
        },
        minion: {
            names: ['Fighter\'s Corner', 'Beast Pit', 'Champion\'s Ground', 'Battle Zone'],
            descriptions: ['An opponent awaits.', 'Prepare for combat!'],
        },
        trap: {
            names: ['Spike Pit', 'Fire Trap', 'Collapsing Floor', 'Arena Hazard'],
            descriptions: ['The arena is dangerous.', 'Watch your footing!'],
        },
        exit: {
            names: ['Victor\'s Gate', 'Champion\'s Exit', 'Freedom Gate', 'The Way Out'],
            descriptions: ['Glory awaits the victor!', 'Survive and escape!'],
        },
        start: {
            names: ['Challenger\'s Gate', 'Fighter\'s Entrance', 'Arena Entry', 'The Beginning'],
            descriptions: ['The crowd awaits.', 'Prove your worth!'],
        },
    },
    hospital: {
        common: {
            prefixes: ['Sterile', 'White', 'Quiet', 'Flickering', 'Abandoned'],
            nouns: ['Corridor', 'Hallway', 'Ward', 'Wing', 'Section'],
            descriptions: ['The smell of antiseptic lingers.', 'Medical equipment lies scattered.', 'Fluorescent lights hum overhead.'],
        },
        junction: {
            prefixes: ['Central', 'Main', 'Nurse\'s', 'Reception'],
            nouns: ['Station', 'Hub', 'Desk', 'Lobby'],
            descriptions: ['Multiple wards connect here.', 'The hospital\'s central hub.'],
        },
        deadend: {
            prefixes: ['Private', 'Quarantine', 'Restricted', 'Sealed'],
            nouns: ['Room', 'Bay', 'Ward', 'Unit'],
            descriptions: ['This area is restricted.', 'No access without clearance.'],
        },
        staircase: {
            names: ['Emergency Stairs', 'Service Elevator', 'Staff Access', 'Fire Stairs'],
            descriptions: ['Standard hospital vertical access.', 'Watch for gurneys.'],
        },
        portal: {
            names: ['Morgue Tunnel', 'Utility Access', 'Hidden Passage', 'Underground Route'],
            descriptions: ['Not on the hospital map.', 'A hidden way through.'],
        },
        chest: {
            names: ['Supply Closet', 'Medical Storage', 'Equipment Room', 'Pharmacy Cache'],
            descriptions: ['Medical supplies could be useful.', 'Someone stockpiled resources.'],
        },
        minion: {
            names: ['Quarantine Zone', 'Infected Ward', 'Danger Area', 'Hostile Section'],
            descriptions: ['Something isn\'t right here.', 'Proceed with caution.'],
        },
        trap: {
            names: ['Biohazard Zone', 'Contaminated Area', 'Structural Damage', 'Hazmat Zone'],
            descriptions: ['Warning signs are everywhere.', 'This area isn\'t safe.'],
        },
        exit: {
            names: ['Emergency Exit', 'Main Entrance', 'Ambulance Bay', 'The Way Out'],
            descriptions: ['Fresh air awaits!', 'Almost out of the hospital!'],
        },
        start: {
            names: ['ER Entrance', 'Main Lobby', 'Admission', 'Ground Floor'],
            descriptions: ['You enter the hospital.', 'Something feels wrong here.'],
        },
    },
    highrise: {
        common: {
            prefixes: ['Dusty', 'Abandoned', 'Crumbling', 'Empty', 'Dark'],
            nouns: ['Hallway', 'Floor', 'Corridor', 'Office', 'Suite'],
            descriptions: ['Abandoned furniture gathers dust.', 'The building creaks in the wind.', 'Nature reclaims the space.'],
        },
        junction: {
            prefixes: ['Main', 'Central', 'Executive', 'Open'],
            nouns: ['Lobby', 'Atrium', 'Floor', 'Hub'],
            descriptions: ['Once a place of business.', 'Multiple paths through the floor.'],
        },
        deadend: {
            prefixes: ['Collapsed', 'Sealed', 'Blocked', 'Destroyed'],
            nouns: ['Office', 'Room', 'Section', 'Area'],
            descriptions: ['The way is impassable.', 'Structural damage blocks the path.'],
        },
        staircase: {
            names: ['Fire Stairs', 'Emergency Exit', 'Service Stairs', 'Broken Elevator'],
            descriptions: ['Concrete stairs wind upward.', 'The elevator hasn\'t worked in years.'],
        },
        portal: {
            names: ['Window Ledge', 'Broken Wall', 'Collapsed Floor', 'Vent Shaft'],
            descriptions: ['An unconventional route.', 'Not for the faint of heart.'],
        },
        chest: {
            names: ['Old Safe', 'Forgotten Cache', 'Executive Stash', 'Supply Closet'],
            descriptions: ['Something was left behind.', 'Previous occupants stored valuables.'],
        },
        minion: {
            names: ['Squatter\'s Territory', 'Hostile Floor', 'Danger Zone', 'Occupied Area'],
            descriptions: ['Someone else calls this home.', 'You\'re not alone here.'],
        },
        trap: {
            names: ['Weak Floor', 'Broken Glass', 'Falling Debris', 'Structural Collapse'],
            descriptions: ['The building is unstable.', 'Every step could be your last.'],
        },
        exit: {
            names: ['Ground Floor', 'Street Exit', 'Fire Escape', 'The Way Out'],
            descriptions: ['Solid ground awaits!', 'Almost out of the building!'],
        },
        start: {
            names: ['Rooftop Access', 'Upper Floor', 'Entry Point', 'The Beginning'],
            descriptions: ['You enter the abandoned building.', 'Urban exploration begins.'],
        },
    },
};

/**
 * v2.0.0: Default style profiles that combine BSP config with room names
 * These appear in the Styles tab alongside custom styles
 */
const DEFAULT_STYLE_PROFILES = {
    maze: {
        name: 'maze',
        displayName: 'Maze',
        bspConfig: {
            minRoomSize: 2,
            maxRoomSize: 2,
            minSplitSize: 2,
            splitVariance: 0.3,
            corridorWidth: 1,
            roomPadding: 0,
            extraConnections: 1.0,
            branchChance: 0.7,
            preferSquareRooms: true,
            gridAlign: false,
            windingCorridors: false,
            modularRooms: false,
        },
        roomNames: ROOM_NAME_DATA.maze,
    },
    dungeon: {
        name: 'dungeon',
        displayName: 'Dungeon',
        bspConfig: {
            minRoomSize: 2,
            maxRoomSize: 3,
            minSplitSize: 2,
            splitVariance: 0.3,
            corridorWidth: 1,
            roomPadding: 0,
            extraConnections: 0.9,
            branchChance: 0.65,
            preferSquareRooms: false,
            gridAlign: false,
            windingCorridors: false,
            modularRooms: false,
        },
        roomNames: ROOM_NAME_DATA.dungeon,
    },
    city: {
        name: 'city',
        displayName: 'City',
        bspConfig: {
            minRoomSize: 2,
            maxRoomSize: 3,
            minSplitSize: 2,
            splitVariance: 0.25,
            corridorWidth: 1,
            roomPadding: 0,
            extraConnections: 0.95,
            branchChance: 0.6,
            preferSquareRooms: false,
            gridAlign: true,
            windingCorridors: false,
            modularRooms: false,
        },
        roomNames: ROOM_NAME_DATA.city,
    },
    forest: {
        name: 'forest',
        displayName: 'Forest',
        bspConfig: {
            minRoomSize: 2,
            maxRoomSize: 3,
            minSplitSize: 2,
            splitVariance: 0.35,
            corridorWidth: 1,
            roomPadding: 0,
            extraConnections: 0.9,
            branchChance: 0.7,
            preferSquareRooms: false,
            gridAlign: false,
            windingCorridors: true,
            modularRooms: false,
        },
        roomNames: ROOM_NAME_DATA.forest,
    },
    spaceship: {
        name: 'spaceship',
        displayName: 'Spaceship',
        bspConfig: {
            minRoomSize: 2,
            maxRoomSize: 3,
            minSplitSize: 2,
            splitVariance: 0.2,
            corridorWidth: 1,
            roomPadding: 0,
            extraConnections: 0.85,
            branchChance: 0.6,
            preferSquareRooms: true,
            gridAlign: false,
            windingCorridors: false,
            modularRooms: true,
        },
        roomNames: ROOM_NAME_DATA.spaceship,
    },
    arena: {
        name: 'arena',
        displayName: 'Arena',
        bspConfig: {
            minRoomSize: 2,
            maxRoomSize: 3,
            minSplitSize: 2,
            splitVariance: 0.3,
            corridorWidth: 1,
            roomPadding: 0,
            extraConnections: 0.9,
            branchChance: 0.65,
            preferSquareRooms: true,
            gridAlign: false,
            windingCorridors: false,
            modularRooms: false,
        },
        roomNames: ROOM_NAME_DATA.maze, // Arena uses maze-style room names
    },
    hospital: {
        name: 'hospital',
        displayName: 'Hospital',
        bspConfig: {
            minRoomSize: 2,
            maxRoomSize: 3,
            minSplitSize: 2,
            splitVariance: 0.2,
            corridorWidth: 1,
            roomPadding: 0,
            extraConnections: 0.85,
            branchChance: 0.6,
            preferSquareRooms: false,
            gridAlign: true,
            windingCorridors: false,
            modularRooms: false,
        },
        roomNames: ROOM_NAME_DATA.maze, // Hospital uses generic room names
    },
    college: {
        name: 'college',
        displayName: 'College',
        bspConfig: {
            minRoomSize: 2,
            maxRoomSize: 3,
            minSplitSize: 2,
            splitVariance: 0.2,
            corridorWidth: 1,
            roomPadding: 0,
            extraConnections: 0.85,
            branchChance: 0.6,
            preferSquareRooms: false,
            gridAlign: true,
            windingCorridors: false,
            modularRooms: false,
        },
        roomNames: ROOM_NAME_DATA.college,
    },
    apartment: {
        name: 'apartment',
        displayName: 'Apartment',
        bspConfig: {
            minRoomSize: 2,
            maxRoomSize: 3,
            minSplitSize: 2,
            splitVariance: 0.25,
            corridorWidth: 1,
            roomPadding: 0,
            extraConnections: 0.95,
            branchChance: 0.6,
            preferSquareRooms: false,
            gridAlign: true,
            windingCorridors: false,
            modularRooms: false,
        },
        roomNames: ROOM_NAME_DATA.apartment,
    },
    highrise: {
        name: 'highrise',
        displayName: 'Highrise',
        bspConfig: {
            minRoomSize: 2,
            maxRoomSize: 3,
            minSplitSize: 2,
            splitVariance: 0.25,
            corridorWidth: 1,
            roomPadding: 0,
            extraConnections: 0.95,
            branchChance: 0.6,
            preferSquareRooms: false,
            gridAlign: true,
            windingCorridors: false,
            modularRooms: false,
        },
        roomNames: ROOM_NAME_DATA.highrise,
    },
};

/**
 * Determine the room type based on cell properties
 * @param {object} cell - The cell to analyze
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 * @param {number} size - Grid size
 * @param {number} exitX - Exit X coordinate
 * @param {number} exitY - Exit Y coordinate
 * @returns {string} Room type identifier
 */
function determineRoomType(cell, x, y, size, exitX, exitY) {
    // Check for special tiles first (priority order)
    if (x === 0 && y === 0) return 'start';
    if (x === exitX && y === exitY) return 'exit';
    if (cell.staircase) return 'staircase';
    if (cell.portal) return 'portal';
    if (cell.chest) return 'chest';
    if (cell.minion) return 'minion';
    if (cell.trap) return 'trap';

    // Count open exits (no walls)
    const exits = [!cell.walls.top, !cell.walls.right, !cell.walls.bottom, !cell.walls.left].filter(Boolean).length;

    if (exits >= 3) return 'junction';
    if (exits === 1) return 'deadend';
    return 'common';
}

/**
 * Generate room info (name and description) for a cell
 * @param {object} cell - The cell to generate info for
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 * @param {object} profile - The maze profile with theme and mapStyle
 * @param {number} size - Grid size
 * @param {number} exitX - Exit X coordinate
 * @param {number} exitY - Exit Y coordinate
 * @returns {object} { name, description, roomType }
 */
function generateRoomInfo(cell, x, y, profile, size, exitX, exitY) {
    const theme = profile.theme || 'fantasy';
    const mapStyle = profile.mapStyle || 'maze';
    const roomType = determineRoomType(cell, x, y, size, exitX, exitY);

    // Get room data for this mapStyle and roomType, fallback to maze/common
    const styleData = ROOM_NAME_DATA[mapStyle] || ROOM_NAME_DATA.maze;
    const roomData = styleData[roomType] || styleData.common;
    const themeModifier = THEME_MODIFIERS[theme] || THEME_MODIFIERS.fantasy;

    let name, description;

    if (roomData.names) {
        // Special room type with predefined names
        name = roomData.names[Math.floor(Math.random() * roomData.names.length)];
    } else {
        // Common room type with prefix + noun construction
        const prefix = roomData.prefixes[Math.floor(Math.random() * roomData.prefixes.length)];
        const noun = roomData.nouns[Math.floor(Math.random() * roomData.nouns.length)];

        // 30% chance to add a theme modifier adjective
        if (Math.random() < 0.3 && themeModifier.adjectives) {
            const themeAdj = themeModifier.adjectives[Math.floor(Math.random() * themeModifier.adjectives.length)];
            name = `${themeAdj} ${prefix} ${noun}`;
        } else {
            name = `${prefix} ${noun}`;
        }
    }

    // Pick a random description
    description = roomData.descriptions[Math.floor(Math.random() * roomData.descriptions.length)];

    return { name, description, roomType };
}

/**
 * Generate room info for all cells in a floor grid
 * @param {array} grid - The floor grid
 * @param {object} profile - The maze profile
 * @param {number} size - Grid size
 * @param {number} exitX - Exit X coordinate
 * @param {number} exitY - Exit Y coordinate
 */
function generateRoomInfoForGrid(grid, profile, size, exitX, exitY) {
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const cell = grid[y][x];
            cell.roomInfo = generateRoomInfo(cell, x, y, profile, size, exitX, exitY);
        }
    }
}

// =============================================================================
// PLUGGABLE RENDERER SYSTEM (v1.2.0)
// =============================================================================

/**
 * Base MazeRenderer interface - all renderers must implement these methods
 * This abstraction allows swapping between CSS Grid, Canvas, WebGL, Isometric, etc.
 */
class MazeRenderer {
    constructor(options = {}) {
        this.options = options;
        this.container = null;
        this.initialized = false;
    }

    /**
     * Get the renderer type identifier
     * @returns {string}
     */
    getType() {
        return 'base';
    }

    /**
     * Initialize the renderer with a container element
     * @param {HTMLElement} container - The container to render into
     * @param {Object} mazeState - Initial maze state
     */
    init(container, mazeState) {
        this.container = container;
        this.initialized = true;
    }

    /**
     * Get the HTML template for the grid container
     * @param {number} size - Grid size
     * @returns {string} HTML string
     */
    getGridHTML(size) {
        throw new Error('getGridHTML must be implemented by subclass');
    }

    /**
     * Get the HTML for the player overlay element
     * @param {number} cellSize - Size of each cell
     * @returns {string} HTML string
     */
    getPlayerOverlayHTML(cellSize) {
        throw new Error('getPlayerOverlayHTML must be implemented by subclass');
    }

    /**
     * Calculate cell size based on grid size
     * @param {number} gridSize - Number of cells per side
     * @returns {number} Cell size in pixels
     */
    getCellSize(gridSize) {
        // Larger cells for desktop - map area has more space now
        if (gridSize <= 5) return 50;
        if (gridSize <= 7) return 45;
        if (gridSize <= 10) return 38;
        if (gridSize <= 12) return 32;
        if (gridSize <= 15) return 26;
        return 22;
    }

    /**
     * Render the entire maze grid
     * @param {Object} mazeState - Current maze state
     */
    render(mazeState) {
        throw new Error('render must be implemented by subclass');
    }

    /**
     * Update player position with optional animation
     * @param {number} x - Player X coordinate
     * @param {number} y - Player Y coordinate
     * @param {boolean} animate - Whether to animate the movement
     * @param {number} cellSize - Size of each cell
     */
    updatePlayerPosition(x, y, animate, cellSize) {
        throw new Error('updatePlayerPosition must be implemented by subclass');
    }

    /**
     * Highlight a cell (for encounters, selection, etc.)
     * @param {number} x - Cell X coordinate
     * @param {number} y - Cell Y coordinate
     * @param {string} type - Highlight type (encounter, selected, path, etc.)
     */
    highlightCell(x, y, type) {
        // Optional - base implementation does nothing
    }

    /**
     * Clear all highlights
     */
    clearHighlights() {
        // Optional - base implementation does nothing
    }

    /**
     * Play a visual effect at a cell
     * @param {number} x - Cell X coordinate
     * @param {number} y - Cell Y coordinate
     * @param {string} effect - Effect name (teleport, damage, heal, etc.)
     */
    playEffect(x, y, effect) {
        // Optional - base implementation does nothing
    }

    /**
     * Get CSS styles required by this renderer
     * @returns {string} CSS styles string
     */
    getStyles() {
        return '';
    }

    /**
     * Clean up renderer resources
     */
    cleanup() {
        this.initialized = false;
        this.container = null;
    }
}

/**
 * CSS Grid Renderer - Current default renderer using CSS Grid layout
 * Simple, fast, works everywhere, easy to style with CSS
 */
class CSSGridRenderer extends MazeRenderer {
    getType() {
        return 'css-grid';
    }

    /**
     * Get CSS filter and color for map style differentiation
     */
    getStyleCSS(mapStyle) {
        const styles = {
            dungeon: { filter: 'saturate(0.7)', bg: '#1a1520', accent: '#6b5b7a' },
            maze: { filter: 'hue-rotate(20deg)', bg: '#1a1828', accent: '#7866a0' },
            forest: { filter: 'saturate(1.4) hue-rotate(-15deg)', bg: '#0d1a0d', accent: '#4a7a4a' },
            city: { filter: 'saturate(0.6) contrast(1.1)', bg: '#161820', accent: '#6a7080' },
            spacestation: { filter: 'saturate(1.2) hue-rotate(200deg)', bg: '#0d1525', accent: '#4080b0' },
            college: { filter: 'sepia(0.3)', bg: '#1a1510', accent: '#9a8060' },
            apartment: { filter: 'sepia(0.2)', bg: '#1a1612', accent: '#8a7660' },
            neotokyo: { filter: 'saturate(1.5) hue-rotate(300deg)', bg: '#1a0d18', accent: '#b040a0' },
            arena: { filter: 'hue-rotate(25deg) saturate(1.2)', bg: '#1a1408', accent: '#b07040' },
            hospital: { filter: 'saturate(0.5) brightness(1.1)', bg: '#141a1a', accent: '#60a0a0' },
            highrise: { filter: 'saturate(0.4) contrast(1.2)', bg: '#12121a', accent: '#606080' },
            outpost: { filter: 'sepia(0.4) hue-rotate(15deg)', bg: '#1a1508', accent: '#a08040' },
        };
        return styles[mapStyle] || styles.dungeon;
    }

    getGridHTML(size) {
        const cellSize = this.getCellSize(size);
        return `
            <div id="maze_grid" class="maze-grid" style="
                display: grid;
                grid-template-columns: repeat(${size}, ${cellSize}px);
                gap: 0;
                position: relative;
            "></div>
        `;
    }

    getPlayerOverlayHTML(cellSize) {
        return `
            <div id="maze_player_overlay" class="maze-player-overlay" style="width: ${cellSize}px; height: ${cellSize}px;">
                <div class="maze-player-marker"></div>
            </div>
        `;
    }

    render(mazeState) {
        const { grid, size, playerX, playerY, visited, exitX, exitY, isVictory, profile, currentFloor, totalFloors } = mazeState;
        const gridEl = document.getElementById('maze_grid');
        if (!gridEl) return;

        const cellSize = this.getCellSize(size);
        // Map visibility: 'showAll', 'fogOfWar', 'hideUnexplored' (backward compat with fogOfWar boolean)
        const mapVisibility = profile?.mapVisibility || (profile?.fogOfWar === false ? 'showAll' : 'fogOfWar');
        gridEl.style.gridTemplateColumns = `repeat(${size}, ${cellSize}px)`;
        gridEl.innerHTML = '';

        // Apply aggressive map style coloring
        const styleCSS = this.getStyleCSS(profile?.mapStyle);
        gridEl.style.filter = styleCSS.filter;
        gridEl.style.backgroundColor = styleCSS.bg;
        gridEl.style.setProperty('--map-accent', styleCSS.accent);

        // Build visited key - always use floor prefix for consistency
        const floorPrefix = `${currentFloor}:`;

        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const cell = grid[y][x];
                const cellEl = document.createElement('div');
                cellEl.className = 'maze-cell';
                cellEl.style.width = `${cellSize}px`;
                cellEl.style.height = `${cellSize}px`;

                // Check visited status (support both old and new format)
                const keyNew = `${floorPrefix}${x},${y}`;
                const keyOld = `${x},${y}`;
                const isVisited = visited.has(keyNew) || visited.has(keyOld);
                const isPlayer = x === playerX && y === playerY;
                const isExit = x === exitX && y === exitY;

                // Determine visibility based on mapVisibility setting
                let showAsVisited = false;
                let hideCompletely = false;
                if (mapVisibility === 'showAll') {
                    showAsVisited = true;
                } else if (mapVisibility === 'hideUnexplored') {
                    showAsVisited = isVisited || isPlayer; // Always show player cell
                    hideCompletely = !isVisited && !isPlayer;
                } else { // fogOfWar (default)
                    showAsVisited = isVisited || isPlayer;
                }

                // Hide unexplored mode: completely hide unvisited cells
                if (hideCompletely) {
                    cellEl.classList.add('completely-hidden');
                } else if (!showAsVisited) {
                    // Fog of war mode: show "?" for unvisited
                    cellEl.classList.add('hidden');
                } else {
                    cellEl.classList.add('visited');
                    if (cell.walls.top) cellEl.classList.add('wall-top');
                    if (cell.walls.right) cellEl.classList.add('wall-right');
                    if (cell.walls.bottom) cellEl.classList.add('wall-bottom');
                    if (cell.walls.left) cellEl.classList.add('wall-left');
                }

                if (isPlayer) cellEl.classList.add('player');
                const isFinalFloor = currentFloor === totalFloors - 1;
                if (isExit && showAsVisited && isFinalFloor) {
                    cellEl.classList.add('exit');
                    if (isVictory) cellEl.classList.add('victory-glow');
                }

                // Minion indicators
                if (cell.minion && showAsVisited) {
                    cellEl.classList.add('has-minion');
                    if (cell.minion.triggered) {
                        cellEl.classList.add('minion-triggered');
                    }
                }

                // Chest indicators
                if (cell.chest && showAsVisited) {
                    cellEl.classList.add('has-chest');
                    if (cell.chest.type === 'locked') cellEl.classList.add('chest-locked');
                    if (cell.chest.opened) cellEl.classList.add('chest-opened');

                    // Custom chest image
                    if (profile?.chestImage && !cell.chest.opened) {
                        cellEl.classList.add('has-custom-chest');
                        const chestImg = document.createElement('img');
                        chestImg.src = getExtensionImagePath(profile.chestImage);
                        chestImg.className = 'maze-chest-img';
                        chestImg.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 70%; height: 70%; object-fit: cover; border-radius: 3px; z-index: 1;';
                        if (cell.chest.type === 'locked') chestImg.style.filter = 'grayscale(50%)';
                        cellEl.appendChild(chestImg);
                    }
                }

                // Trap indicators
                if (cell.trap && showAsVisited) {
                    cellEl.classList.add('has-trap');
                    if (cell.trap.triggered) cellEl.classList.add('trap-triggered');
                }

                // Portal indicators
                if (cell.portal && showAsVisited) {
                    cellEl.classList.add('has-portal');
                    cellEl.dataset.portalColor = cell.portal.color || '#9b59b6';
                    cellEl.style.setProperty('--portal-color', cell.portal.color || '#9b59b6');
                    if (!cell.portal.bidirectional && !cell.portal.isStart) {
                        cellEl.classList.add('portal-exit-only');
                    }
                }

                // Staircase indicators
                if (cell.staircase && showAsVisited) {
                    cellEl.classList.add('has-staircase');
                    cellEl.classList.add(cell.staircase.direction === 'up' ? 'staircase-up' : 'staircase-down');
                    if (cell.staircase.requireKey) cellEl.classList.add('staircase-locked');
                }

                // Safe room indicator (healing zone)
                if (cell.safeRoom && !cell.safeRoom.exhausted && showAsVisited) {
                    cellEl.classList.add('safe-room');
                }

                // Store coordinates for event handling
                cellEl.dataset.x = x;
                cellEl.dataset.y = y;

                gridEl.appendChild(cellEl);
            }
        }
    }

    updatePlayerPosition(x, y, animate, cellSize) {
        const overlay = document.getElementById('maze_player_overlay');
        if (!overlay) return;

        const pixelX = x * cellSize;
        const pixelY = y * cellSize;

        if (!animate) {
            overlay.style.transition = 'none';
        } else {
            overlay.style.transition = 'transform 0.15s ease-out';
        }

        overlay.style.transform = `translate(${pixelX}px, ${pixelY}px)`;

        if (!animate) {
            requestAnimationFrame(() => {
                overlay.style.transition = 'transform 0.15s ease-out';
            });
        }
    }

    highlightCell(x, y, type) {
        const cell = document.querySelector(`.maze-cell[data-x="${x}"][data-y="${y}"]`);
        if (cell) {
            cell.classList.add(`highlight-${type}`);
        }
    }

    clearHighlights() {
        document.querySelectorAll('.maze-cell[class*="highlight-"]').forEach(cell => {
            cell.className = cell.className.replace(/highlight-\w+/g, '').trim();
        });
    }

    playEffect(x, y, effect) {
        const cell = document.querySelector(`.maze-cell[data-x="${x}"][data-y="${y}"]`);
        if (!cell) return;

        cell.classList.add(`effect-${effect}`);
        setTimeout(() => {
            cell.classList.remove(`effect-${effect}`);
        }, 500);
    }
}

/**
 * Get theme-based minion color for 2D rendering
 * v1.4.2: Shared helper for theme-based minion recoloring
 */
function getThemeMinionColor(theme) {
    const colors = {
        fantasy: '#ef4444',   // Red
        horror: '#5a5a6a',    // Gray/purple undead
        scifi: '#06b6d4',     // Cyan
        cyberpunk: '#ec4899', // Hot pink
        western: '#92400e',   // Brown/rust
        action: '#dc2626',    // Bright red
        comedy: '#84cc16',    // Lime green
        postapoc: '#78716c',  // Ash gray
    };
    return colors[theme] || colors.fantasy;
}

/**
 * Canvas Renderer - Placeholder for future sprite-based 2.5D rendering
 * Will use HTML5 Canvas for tile/sprite rendering
 */
class CanvasRenderer extends MazeRenderer {
    constructor(options = {}) {
        super(options);
        this.canvas = null;
        this.ctx = null;
        this.sprites = {};
        this.tileSize = options.tileSize || 32;
    }

    getType() {
        return 'canvas';
    }

    getGridHTML(size) {
        const canvasSize = size * this.tileSize;
        return `
            <canvas id="maze_canvas" width="${canvasSize}" height="${canvasSize}" style="
                display: block;
                image-rendering: pixelated;
            "></canvas>
        `;
    }

    getPlayerOverlayHTML(cellSize) {
        // Canvas renderer doesn't use overlay - player is drawn on canvas
        return '';
    }

    async loadSprites(spriteMap) {
        // spriteMap: { floor: 'url', wall: 'url', player: 'url', ... }
        const loadPromises = Object.entries(spriteMap).map(async ([key, url]) => {
            const img = new Image();
            img.src = url;
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
            });
            this.sprites[key] = img;
        });
        await Promise.all(loadPromises);
    }

    init(container, mazeState) {
        super.init(container, mazeState);
        this.canvas = document.getElementById('maze_canvas');
        if (this.canvas) {
            this.ctx = this.canvas.getContext('2d');
        }
    }

    render(mazeState) {
        if (!this.ctx) return;

        const { grid, size, playerX, playerY, visited, exitX, exitY, profile, currentFloor, totalFloors } = mazeState;
        const ts = this.tileSize;
        // Map visibility: 'showAll', 'fogOfWar', 'hideUnexplored' (backward compat with fogOfWar boolean)
        const mapVisibility = profile?.mapVisibility || (profile?.fogOfWar === false ? 'showAll' : 'fogOfWar');

        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw tiles
        // Build visited key - always use floor prefix for consistency
        const floorPrefix = `${currentFloor}:`;

        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const cell = grid[y][x];
                const keyNew = `${floorPrefix}${x},${y}`;
                const keyOld = `${x},${y}`;
                const isVisited = visited.has(keyNew) || visited.has(keyOld);
                const isPlayer = x === playerX && y === playerY;

                // Determine visibility based on mapVisibility setting
                let showAsVisited = false;
                let hideCompletely = false;
                if (mapVisibility === 'showAll') {
                    showAsVisited = true;
                } else if (mapVisibility === 'hideUnexplored') {
                    showAsVisited = isVisited || isPlayer; // Always show player cell
                    hideCompletely = !isVisited && !isPlayer;
                } else { // fogOfWar (default)
                    showAsVisited = isVisited || isPlayer;
                }

                if (hideCompletely) {
                    // Hide unexplored - draw nothing (transparent/black)
                    continue;
                } else if (!showAsVisited) {
                    // Fog of war - draw dark with "?" hint
                    this.ctx.fillStyle = '#1a1a2e';
                    this.ctx.fillRect(x * ts, y * ts, ts, ts);
                } else {
                    // Draw floor sprite or fallback color
                    if (this.sprites.floor) {
                        this.ctx.drawImage(this.sprites.floor, x * ts, y * ts, ts, ts);
                    } else {
                        this.ctx.fillStyle = '#2d2d44';
                        this.ctx.fillRect(x * ts, y * ts, ts, ts);
                    }

                    // Draw walls
                    this.ctx.strokeStyle = '#8b5cf6';
                    this.ctx.lineWidth = 2;
                    if (cell.walls.top) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x * ts, y * ts);
                        this.ctx.lineTo((x + 1) * ts, y * ts);
                        this.ctx.stroke();
                    }
                    if (cell.walls.right) {
                        this.ctx.beginPath();
                        this.ctx.moveTo((x + 1) * ts, y * ts);
                        this.ctx.lineTo((x + 1) * ts, (y + 1) * ts);
                        this.ctx.stroke();
                    }
                    if (cell.walls.bottom) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x * ts, (y + 1) * ts);
                        this.ctx.lineTo((x + 1) * ts, (y + 1) * ts);
                        this.ctx.stroke();
                    }
                    if (cell.walls.left) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x * ts, y * ts);
                        this.ctx.lineTo(x * ts, (y + 1) * ts);
                        this.ctx.stroke();
                    }

                    // Draw exit (only on final floor)
                    const isFinalFloor = currentFloor === totalFloors - 1;
                    if (x === exitX && y === exitY && isFinalFloor) {
                        if (this.sprites.exit) {
                            this.ctx.drawImage(this.sprites.exit, x * ts, y * ts, ts, ts);
                        } else {
                            this.ctx.fillStyle = '#22c55e';
                            this.ctx.fillRect(x * ts + 4, y * ts + 4, ts - 8, ts - 8);
                        }
                    }

                    // Draw entities
                    if (cell.chest && !cell.chest.opened) {
                        if (this.sprites.chest) {
                            this.ctx.drawImage(this.sprites.chest, x * ts, y * ts, ts, ts);
                        } else {
                            this.ctx.fillStyle = '#f59e0b';
                            this.ctx.fillRect(x * ts + 6, y * ts + 6, ts - 12, ts - 12);
                        }
                    }

                    if (cell.minion && !cell.minion.triggered) {
                        // v1.4.2: Theme-based minion coloring
                        const minionColor = getThemeMinionColor(profile?.theme);
                        if (this.sprites.minion) {
                            this.ctx.drawImage(this.sprites.minion, x * ts, y * ts, ts, ts);
                        } else {
                            this.ctx.fillStyle = minionColor;
                            this.ctx.beginPath();
                            this.ctx.arc(x * ts + ts/2, y * ts + ts/2, ts/4, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
            }
        }

        // Draw player
        if (this.sprites.player) {
            this.ctx.drawImage(this.sprites.player, playerX * ts, playerY * ts, ts, ts);
        } else {
            this.ctx.fillStyle = '#3b82f6';
            this.ctx.beginPath();
            this.ctx.arc(playerX * ts + ts/2, playerY * ts + ts/2, ts/3, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    updatePlayerPosition(x, y, animate, cellSize) {
        // Canvas renderer re-renders everything, no separate update needed
        // Animation would be handled via requestAnimationFrame in a real implementation
    }

    getCellSize(gridSize) {
        return this.tileSize;
    }
}

/**
 * Isometric Renderer - Full 2.5D isometric rendering with programmatic sprites
 * Supports both generated placeholders and loaded sprite assets
 */
class IsometricRenderer extends CanvasRenderer {
    constructor(options = {}) {
        super(options);
        this.tileWidth = options.tileWidth || 64;
        this.tileHeight = options.tileHeight || 32;
        this.wallHeight = options.wallHeight || 24;
        this.spriteCache = {};
        this.spritesLoaded = false;
        this.spritesLoading = false;
        this.currentMapStyle = 'dungeon';

        // Generate sprite paths based on mapStyle
        this.spritePaths = this.getSpritePathsForStyle(this.currentMapStyle);

        // Fallback color palette for procedural sprites (used if sprites not loaded)
        this.palette = {
            floor: { top: '#3d3d5c', light: '#4a4a6a', dark: '#2d2d44' },
            wall: { top: '#6b5b95', light: '#8b7bb5', dark: '#4b3b75' },
            fog: { top: '#2a2a4e', light: '#3a3a6a', dark: '#1a1a3a' },
            exit: { top: '#22c55e', light: '#4ade80', dark: '#16a34a' },
            chest: { top: '#f59e0b', light: '#fbbf24', dark: '#d97706' },
            chestOpen: { top: '#78716c', light: '#a8a29e', dark: '#57534e' },
            minion: { top: '#ef4444', light: '#f87171', dark: '#dc2626' },
            trap: { top: '#a855f7', light: '#c084fc', dark: '#9333ea' },
            portal: { top: '#06b6d4', light: '#22d3ee', dark: '#0891b2' },
            stairUp: { top: '#10b981', light: '#34d399', dark: '#059669' },
            stairDown: { top: '#f97316', light: '#fb923c', dark: '#ea580c' },
            player: { top: '#3b82f6', light: '#60a5fa', dark: '#2563eb' },
            safeRoom: { top: '#2dd4bf', light: '#5eead4', dark: '#14b8a6' }, // Teal for healing zones
        };
    }

    getType() {
        return 'isometric';
    }

    /**
     * Generate sprite paths for a given map style
     */
    getSpritePathsForStyle(mapStyle) {
        const style = mapStyle || 'dungeon';
        return {
            floor: `assets/isometric/${style}/floor.png`,
            wall: `assets/isometric/${style}/wall.png`,
            wallCorner: `assets/isometric/${style}/wall_corner.png`,
            fog: `assets/isometric/${style}/fog.png`,
            exit: `assets/isometric/${style}/exit.png`,
            chest: `assets/isometric/${style}/chest_closed.png`,
            chestOpen: `assets/isometric/${style}/chest_open.png`,
            portal: `assets/isometric/${style}/portal.png`,
            trap: `assets/isometric/${style}/trap.png`,
            minion: `assets/isometric/${style}/minion.png`,
            player: `assets/isometric/${style}/player.png`,
            stairsUp: `assets/isometric/${style}/stairs_up.png`,
            stairsDown: `assets/isometric/${style}/stairs_down.png`,
        };
    }

    /**
     * Set map style and reload sprites if changed
     */
    setMapStyle(mapStyle) {
        const newStyle = mapStyle || 'dungeon';
        if (newStyle !== this.currentMapStyle) {
            this.currentMapStyle = newStyle;
            this.spritePaths = this.getSpritePathsForStyle(newStyle);
            this.spriteCache = {};
            this.spritesLoaded = false;
            this.spritesLoading = false;
            this.loadSprites();
        }
    }

    /**
     * Get ambient color tint for map style (applied as overlay)
     */
    getStyleTint(mapStyle) {
        // Aggressive color tints for strong visual differentiation
        const tints = {
            dungeon: { r: 40, g: 30, b: 50, a: 0.25 },       // Deep purple dungeon
            maze: { r: 60, g: 50, b: 80, a: 0.3 },           // Mystical purple
            forest: { r: 20, g: 100, b: 40, a: 0.35 },       // Vibrant green
            city: { r: 80, g: 90, b: 100, a: 0.3 },          // Cool gray-blue urban
            spacestation: { r: 30, g: 60, b: 120, a: 0.4 },  // Strong sci-fi blue
            college: { r: 100, g: 80, b: 50, a: 0.25 },      // Warm sepia academic
            apartment: { r: 90, g: 70, b: 50, a: 0.3 },      // Warm cozy indoor
            neotokyo: { r: 140, g: 40, b: 100, a: 0.4 },     // Intense neon pink
            arena: { r: 120, g: 60, b: 30, a: 0.35 },        // Hot sandy/orange
            hospital: { r: 60, g: 100, b: 100, a: 0.35 },    // Cold teal sterile
            highrise: { r: 50, g: 50, b: 70, a: 0.4 },       // Dark slate concrete
            outpost: { r: 100, g: 80, b: 40, a: 0.35 },      // Dusty desert tan
        };
        return tints[mapStyle] || tints.dungeon;
    }

    /**
     * Get aggressive CSS filter for minion sprites based on theme
     * v1.4.2: Theme-based minion recoloring
     */
    getThemeMinionFilter(theme) {
        const filters = {
            fantasy: 'hue-rotate(0deg) saturate(1.2) brightness(1.0)',           // Default warm colors
            horror: 'hue-rotate(270deg) saturate(0.4) brightness(0.7) contrast(1.3)',  // Desaturated purple/gray, dark
            scifi: 'hue-rotate(180deg) saturate(1.5) brightness(1.2)',           // Cyan/teal shift
            cyberpunk: 'hue-rotate(300deg) saturate(2.0) brightness(1.1) contrast(1.2)', // Hot pink/magenta
            western: 'hue-rotate(30deg) saturate(0.8) sepia(0.5) brightness(1.0)', // Sepia/dusty brown
            action: 'hue-rotate(0deg) saturate(1.4) contrast(1.3) brightness(1.1)', // High contrast, vivid
            comedy: 'hue-rotate(60deg) saturate(2.0) brightness(1.3)',           // Bright yellow/green shift
            postapoc: 'hue-rotate(20deg) saturate(0.5) sepia(0.4) brightness(0.8)', // Muted brown/rust
        };
        return filters[theme] || filters.fantasy;
    }

    /**
     * Get minion palette colors based on theme
     * v1.4.2: Theme-based minion recoloring for fallback sprites
     */
    getThemeMinionPalette(theme) {
        const palettes = {
            fantasy: { top: '#ef4444', light: '#f87171', dark: '#dc2626' },      // Red (default)
            horror: { top: '#4a4a5a', light: '#6a6a7a', dark: '#2a2a3a' },        // Gray/purple undead
            scifi: { top: '#06b6d4', light: '#22d3ee', dark: '#0891b2' },         // Cyan/teal
            cyberpunk: { top: '#ec4899', light: '#f472b6', dark: '#db2777' },     // Hot pink
            western: { top: '#92400e', light: '#b45309', dark: '#78350f' },       // Brown/rust
            action: { top: '#dc2626', light: '#ef4444', dark: '#b91c1c' },        // Bright red
            comedy: { top: '#84cc16', light: '#a3e635', dark: '#65a30d' },        // Lime green
            postapoc: { top: '#78716c', light: '#a8a29e', dark: '#57534e' },      // Ash gray
        };
        return palettes[theme] || palettes.fantasy;
    }

    /**
     * Get CSS filter string for aggressive style differentiation
     */
    getStyleFilter(mapStyle) {
        const filters = {
            dungeon: 'saturate(0.7) contrast(1.1)',
            maze: 'saturate(0.8) hue-rotate(20deg)',
            forest: 'saturate(1.4) hue-rotate(-20deg) brightness(1.1)',
            city: 'saturate(0.6) contrast(1.2) brightness(0.9)',
            spacestation: 'saturate(1.2) hue-rotate(200deg) brightness(1.1)',
            college: 'saturate(0.9) sepia(0.3) brightness(1.1)',
            apartment: 'saturate(0.8) sepia(0.2) contrast(1.05)',
            neotokyo: 'saturate(1.5) hue-rotate(300deg) contrast(1.2) brightness(1.1)',
            arena: 'saturate(1.3) hue-rotate(30deg) contrast(1.15)',
            hospital: 'saturate(0.5) brightness(1.2) contrast(0.9)',
            highrise: 'saturate(0.4) contrast(1.3) brightness(0.7)',
            outpost: 'saturate(1.1) sepia(0.4) hue-rotate(15deg)',
        };
        return filters[mapStyle] || filters.dungeon;
    }

    /**
     * Get background color for each map style
     */
    getStyleBackground(mapStyle) {
        const backgrounds = {
            dungeon: '#0a0815',      // Deep purple-black
            maze: '#0d0a18',         // Mystical dark
            forest: '#050d05',       // Forest night
            city: '#0a0c10',         // Urban dark
            spacestation: '#050812', // Space blue-black
            college: '#0f0c08',      // Warm dark
            apartment: '#0c0a08',    // Cozy dark
            neotokyo: '#0f050a',     // Neon dark
            arena: '#100a05',        // Sandy dark
            hospital: '#080c0c',     // Sterile dark
            highrise: '#080810',     // Concrete dark
            outpost: '#0d0a06',      // Desert dark
        };
        return backgrounds[mapStyle] || backgrounds.dungeon;
    }

    /**
     * Load all sprite images asynchronously
     */
    async loadSprites() {
        if (this.spritesLoaded || this.spritesLoading) return;
        this.spritesLoading = true;

        const extensionPath = '/scripts/extensions/third-party/SillyTavern-MazeMaster/';
        const loadPromises = Object.entries(this.spritePaths).map(async ([key, path]) => {
            try {
                const img = new Image();
                img.src = extensionPath + path;
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                });
                this.spriteCache[key] = img;
            } catch (e) {
                console.warn(`[MazeMaster] Failed to load sprite: ${path}`);
            }
        });

        await Promise.all(loadPromises);
        this.spritesLoaded = true;
        this.spritesLoading = false;
        console.log('[MazeMaster] Isometric sprites loaded:', Object.keys(this.spriteCache));

        // Re-render with sprites now that they're loaded
        if (this.lastMazeState) {
            this.render(this.lastMazeState);
        }
    }

    gridToIso(x, y) {
        return {
            x: (x - y) * (this.tileWidth / 2),
            y: (x + y) * (this.tileHeight / 2),
        };
    }

    isoToGrid(screenX, screenY) {
        const x = (screenX / (this.tileWidth / 2) + screenY / (this.tileHeight / 2)) / 2;
        const y = (screenY / (this.tileHeight / 2) - screenX / (this.tileWidth / 2)) / 2;
        return { x: Math.floor(x), y: Math.floor(y) };
    }

    getGridHTML(size) {
        // Pre-compute tile sizes based on grid size (same logic as init)
        const tileWidth = this.getCellSize(size);
        const tileHeight = tileWidth / 2;
        const spriteHeight = tileWidth * 2; // Kenney sprites are 256x512 (2:1 aspect)

        const canvasWidth = (size + 1) * tileWidth;
        const canvasHeight = size * tileHeight + spriteHeight + tileHeight;
        return `
            <canvas id="maze_canvas" width="${canvasWidth}" height="${canvasHeight}" style="
                display: block;
                image-rendering: crisp-edges;
                max-width: 100%;
            "></canvas>
        `;
    }

    getPlayerOverlayHTML() {
        return ''; // Player drawn on canvas
    }

    getCellSize(gridSize) {
        // Balanced tile sizes for visibility
        if (gridSize <= 7) return 76;
        if (gridSize <= 10) return 64;
        if (gridSize <= 15) return 52;
        if (gridSize <= 20) return 44;
        return 36;
    }

    init(container, mazeState) {
        // Adjust tile size based on maze size
        if (mazeState?.size) {
            const newSize = this.getCellSize(mazeState.size);
            this.tileWidth = newSize;
            this.tileHeight = newSize / 2;
            this.wallHeight = newSize * 0.375;
        }
        // Set map style from profile (triggers sprite reload if changed)
        if (mazeState?.profile?.mapStyle) {
            this.setMapStyle(mazeState.profile.mapStyle);
        }
        super.init(container, mazeState);
        // Start loading sprites (async, will be ready for next render)
        this.loadSprites();
    }

    /**
     * Draw a sprite at isometric position, scaled to tile size
     * Kenney sprites are 256x512 with the isometric tile at the bottom ~1/4 of image
     */
    drawSprite(spriteName, x, y, scale = 1) {
        const sprite = this.spriteCache[spriteName];
        if (!sprite) return false;

        // Kenney sprites are 256x512, we scale to fit tile width
        const spriteAspect = sprite.height / sprite.width; // ~2 for Kenney
        const w = this.tileWidth * scale;
        const h = w * spriteAspect;

        // The isometric diamond in Kenney sprites is at the bottom ~25% of the image
        // Position so the diamond part aligns with the tile position
        // Bottom of sprite should be at y + tileHeight/2 (bottom of isometric diamond)
        const drawX = x - w / 2;
        const drawY = y + this.tileHeight / 2 - h;

        this.ctx.drawImage(sprite, drawX, drawY, w, h);
        return true;
    }

    drawSpriteDirectional(spriteName, x, y, scale = 1, direction = 'south') {
        const sprite = this.spriteCache[spriteName];
        if (!sprite) return false;

        // Kenney sprites are 256x512, we scale to fit tile width
        const spriteAspect = sprite.height / sprite.width;
        const w = this.tileWidth * scale;
        const h = w * spriteAspect;

        const drawX = x - w / 2;
        const drawY = y + this.tileHeight / 2 - h;

        // In isometric view, flip horizontally for west/north directions
        // Default sprite faces down-right (south/east), flipped faces down-left (north/west)
        const shouldFlip = direction === 'west' || direction === 'north';

        if (shouldFlip) {
            this.ctx.save();
            // Flip around the sprite's center
            this.ctx.translate(x, drawY + h / 2);
            this.ctx.scale(-1, 1);
            this.ctx.translate(-x, -(drawY + h / 2));
            this.ctx.drawImage(sprite, drawX, drawY, w, h);
            this.ctx.restore();
        } else {
            this.ctx.drawImage(sprite, drawX, drawY, w, h);
        }
        return true;
    }

    render(mazeState) {
        if (!this.ctx) {
            this.canvas = document.getElementById('maze_canvas');
            if (this.canvas) this.ctx = this.canvas.getContext('2d');
            if (!this.ctx) return;
        }

        // Store for re-rendering after sprites load
        this.lastMazeState = mazeState;

        const { grid, size, playerX, playerY, visited, exitX, exitY, isVictory, currentFloor, totalFloors, profile, playerDirection } = mazeState;
        // Map visibility: 'showAll', 'fogOfWar', 'hideUnexplored' (backward compat with fogOfWar boolean)
        const mapVisibility = profile?.mapVisibility || (profile?.fogOfWar === false ? 'showAll' : 'fogOfWar');

        // Kenney sprites are 256x512 (2:1 aspect), so sprite height = tileWidth * 2
        const spriteHeight = this.tileWidth * 2;

        // Canvas needs extra height at top for tall sprites
        const canvasWidth = (size + 1) * this.tileWidth;
        const canvasHeight = size * this.tileHeight + spriteHeight + this.tileHeight;
        if (this.canvas.width !== canvasWidth || this.canvas.height !== canvasHeight) {
            this.canvas.width = canvasWidth;
            this.canvas.height = canvasHeight;
        }

        // Clear with style-specific background color
        const bgColor = this.getStyleBackground(profile?.mapStyle);
        this.ctx.fillStyle = bgColor;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Match container background to canvas (no visible edges when zooming)
        const mazeArea = document.querySelector('.mazemaster-maze-area');
        if (mazeArea) mazeArea.style.backgroundColor = bgColor;

        // Apply aggressive style filter for visual differentiation
        const styleFilter = this.getStyleFilter(profile?.mapStyle);
        this.ctx.filter = styleFilter;

        const offsetX = this.canvas.width / 2;
        // Offset Y needs room for tall sprites at the top
        const offsetY = spriteHeight;

        // Build visited key - always use floor prefix for consistency
        const floorPrefix = `${currentFloor}:`;

        // Draw in isometric order (back to front)
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const cell = grid[y][x];
                const keyNew = `${floorPrefix}${x},${y}`;
                const keyOld = `${x},${y}`;
                const isVisited = visited.has(keyNew) || visited.has(keyOld);
                const iso = this.gridToIso(x, y);
                const drawX = iso.x + offsetX;
                const drawY = iso.y + offsetY;

                // Determine visibility based on mapVisibility setting
                const isPlayer = x === playerX && y === playerY;
                let showAsVisited = false;
                let hideCompletely = false;
                if (mapVisibility === 'showAll') {
                    showAsVisited = true;
                } else if (mapVisibility === 'hideUnexplored') {
                    showAsVisited = isVisited || isPlayer; // Always show player cell
                    hideCompletely = !isVisited && !isPlayer;
                } else { // fogOfWar (default)
                    showAsVisited = isVisited || isPlayer;
                }

                if (hideCompletely) {
                    // Hide unexplored - draw nothing (skip this cell entirely)
                    continue;
                } else if (!showAsVisited) {
                    // Fog of war - draw a raised fog block with question mark
                    this.drawIsoBlock(drawX, drawY, this.palette.fog, 4);
                    // Draw question mark on fog
                    this.ctx.fillStyle = '#5a5a8a';
                    this.ctx.font = `bold ${Math.floor(this.tileWidth / 3)}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('?', drawX, drawY - 2);
                } else {
                    // Draw floor
                    if (!this.drawSprite('floor', drawX, drawY)) {
                        this.drawIsoDiamond(drawX, drawY, this.palette.floor);
                    }

                    // Draw safe room overlay (healing zone indicator)
                    if (cell.safeRoom && !cell.safeRoom.exhausted) {
                        this.drawSafeRoomIndicator(drawX, drawY);
                    }

                    // Draw walls - ISOMETRIC MAPPING (based on gridToIso transform):
                    // walls.left (West/x-1) blocks UP-LEFT → TOP-LEFT edge (drawWallLeft)
                    // walls.top (North/y-1) blocks UP-RIGHT → TOP-RIGHT edge (drawWallTop)
                    // walls.right (East/x+1) blocks DOWN-RIGHT → BOTTOM-RIGHT edge (drawWallRight)
                    // walls.bottom (South/y+1) blocks DOWN-LEFT → BOTTOM-LEFT edge (drawWallBottom)

                    // Draw "back" walls (left and top in grid)
                    if (cell.walls.left) {
                        this.drawWallLeft(drawX, drawY, this.palette.wall);
                    }
                    if (cell.walls.top) {
                        this.drawWallTop(drawX, drawY, this.palette.wall);
                    }

                    // Draw "front" walls only when adjacent cell won't draw them
                    // Check if right cell (East/x+1) will draw its own left wall
                    const isRightEdge = x >= size - 1;
                    const rightCellKeyNew = `${floorPrefix}${x + 1},${y}`;
                    const rightCellKeyOld = `${x + 1},${y}`;
                    const rightCellVisited = visited.has(rightCellKeyNew) || visited.has(rightCellKeyOld);
                    const rightCellWillDraw = !isRightEdge && (mapVisibility === 'showAll' || rightCellVisited);

                    // Check if bottom cell (South/y+1) will draw its own top wall
                    const isBottomEdge = y >= size - 1;
                    const bottomCellKeyNew = `${floorPrefix}${x},${y + 1}`;
                    const bottomCellKeyOld = `${x},${y + 1}`;
                    const bottomCellVisited = visited.has(bottomCellKeyNew) || visited.has(bottomCellKeyOld);
                    const bottomCellWillDraw = !isBottomEdge && (mapVisibility === 'showAll' || bottomCellVisited);

                    // Draw right wall if we have one AND the right cell won't draw its left
                    if (cell.walls.right && !rightCellWillDraw) {
                        this.drawWallRight(drawX, drawY, this.palette.wall);
                    }

                    // Draw bottom wall if we have one AND the bottom cell won't draw its top
                    if (cell.walls.bottom && !bottomCellWillDraw) {
                        this.drawWallBottom(drawX, drawY, this.palette.wall);
                    }

                    // Draw entities on top of floor
                    const isExit = x === exitX && y === exitY;
                    const isFinalFloor = currentFloor === totalFloors - 1;

                    // Only render exit on final floor
                    if (isExit && isFinalFloor) {
                        if (!this.drawSprite('exit', drawX, drawY, 1.0)) {
                            this.drawIsoBlock(drawX, drawY - 2, isVictory ? this.palette.stairUp : this.palette.exit, 4);
                        }
                    }

                    if (cell.staircase) {
                        const stairSprite = cell.staircase.direction === 'up' ? 'stairsUp' : 'stairsDown';
                        if (!this.drawSprite(stairSprite, drawX, drawY, 1.0)) {
                            const pal = cell.staircase.direction === 'up' ? this.palette.stairUp : this.palette.stairDown;
                            this.drawIsoBlock(drawX, drawY - 2, pal, 6);
                            this.drawStairIcon(drawX, drawY - 6, cell.staircase.direction);
                        }
                    }

                    if (cell.portal) {
                        if (!this.drawSprite('portal', drawX, drawY, 0.8)) {
                            this.drawPortal(drawX, drawY);
                        }
                    }

                    if (cell.chest) {
                        const chestSprite = cell.chest.opened ? 'chestOpen' : 'chest';
                        if (!this.drawSprite(chestSprite, drawX, drawY, 0.8)) {
                            const pal = cell.chest.opened ? this.palette.chestOpen : this.palette.chest;
                            this.drawChest(drawX, drawY, pal, cell.chest.opened);
                        }
                    }

                    if (cell.trap && !cell.trap.triggered) {
                        if (!this.drawSprite('trap', drawX, drawY, 1.0)) {
                            this.drawTrap(drawX, drawY);
                        }
                    }

                    if (cell.minion && !cell.minion.triggered) {
                        // v1.4.2: Apply theme-based minion tinting
                        const theme = profile?.theme || 'fantasy';
                        this.ctx.filter = this.getThemeMinionFilter(theme);

                        if (!this.drawSprite('minion', drawX, drawY, 1.0)) {
                            // Use theme-specific palette for fallback minion
                            const origPalette = this.palette.minion;
                            this.palette.minion = this.getThemeMinionPalette(theme);
                            this.drawMinion(drawX, drawY);
                            this.palette.minion = origPalette;
                        }

                        // Reset filter after minion
                        this.ctx.filter = 'none';
                    }

                    if (isPlayer) {
                        // Draw player sprite slightly larger for visibility, facing movement direction
                        const facing = playerDirection || 'south';
                        if (!this.drawSpriteDirectional('player', drawX, drawY, 1.15, facing)) {
                            this.drawPlayerDirectional(drawX, drawY, facing);
                        }
                        // Draw floating indicator above player
                        this.drawPlayerIndicator(drawX, drawY);
                    }
                }
            }
        }

        // Reset filter before tint overlay
        this.ctx.filter = 'none';

        // Apply map style color tint overlay with screen blend for atmospheric effect
        const tint = this.getStyleTint(profile?.mapStyle);
        if (tint.a > 0) {
            // Use multiply blend for richer color grading
            this.ctx.globalCompositeOperation = 'multiply';
            this.ctx.fillStyle = `rgba(${tint.r + 100}, ${tint.g + 100}, ${tint.b + 100}, ${tint.a * 0.6})`;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // Add color overlay for stronger tint
            this.ctx.globalCompositeOperation = 'overlay';
            this.ctx.fillStyle = `rgba(${tint.r}, ${tint.g}, ${tint.b}, ${tint.a * 0.4})`;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // Reset blend mode
            this.ctx.globalCompositeOperation = 'source-over';
        }
    }

    drawIsoDiamond(x, y, palette) {
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;

        this.ctx.fillStyle = palette.top;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - hh);
        this.ctx.lineTo(x + hw, y);
        this.ctx.lineTo(x, y + hh);
        this.ctx.lineTo(x - hw, y);
        this.ctx.closePath();
        this.ctx.fill();
    }

    drawIsoBlock(x, y, palette, height = 8) {
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;

        // Left face
        this.ctx.fillStyle = palette.dark;
        this.ctx.beginPath();
        this.ctx.moveTo(x - hw, y);
        this.ctx.lineTo(x, y + hh);
        this.ctx.lineTo(x, y + hh + height);
        this.ctx.lineTo(x - hw, y + height);
        this.ctx.closePath();
        this.ctx.fill();

        // Right face
        this.ctx.fillStyle = palette.light;
        this.ctx.beginPath();
        this.ctx.moveTo(x + hw, y);
        this.ctx.lineTo(x, y + hh);
        this.ctx.lineTo(x, y + hh + height);
        this.ctx.lineTo(x + hw, y + height);
        this.ctx.closePath();
        this.ctx.fill();

        // Top face
        this.drawIsoDiamond(x, y, palette);
    }

    drawWallLeft(x, y, palette) {
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;
        const h = this.wallHeight;

        this.ctx.fillStyle = palette.dark;
        this.ctx.beginPath();
        this.ctx.moveTo(x - hw, y);
        this.ctx.lineTo(x - hw, y - h);
        this.ctx.lineTo(x, y - hh - h);
        this.ctx.lineTo(x, y - hh);
        this.ctx.closePath();
        this.ctx.fill();

        // Top edge
        this.ctx.fillStyle = palette.top;
        this.ctx.fillRect(x - hw - 1, y - h - 2, 4, 4);
    }

    drawWallTop(x, y, palette) {
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;
        const h = this.wallHeight;

        this.ctx.fillStyle = palette.light;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - hh);
        this.ctx.lineTo(x, y - hh - h);
        this.ctx.lineTo(x + hw, y - h);
        this.ctx.lineTo(x + hw, y);
        this.ctx.closePath();
        this.ctx.fill();

        // Top edge
        this.ctx.fillStyle = palette.top;
        this.ctx.fillRect(x + hw - 2, y - h - 2, 4, 4);
    }

    // Draw wall on right edge (for edge cells only - normally this is drawn by the adjacent cell's left wall)
    drawWallRight(x, y, palette) {
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;
        const h = this.wallHeight;

        // Right wall faces the "front" of isometric view, use light color
        this.ctx.fillStyle = palette.light;
        this.ctx.beginPath();
        this.ctx.moveTo(x + hw, y);
        this.ctx.lineTo(x + hw, y - h);
        this.ctx.lineTo(x, y + hh - h);
        this.ctx.lineTo(x, y + hh);
        this.ctx.closePath();
        this.ctx.fill();

        // Top edge
        this.ctx.fillStyle = palette.top;
        this.ctx.fillRect(x + hw - 2, y - h - 2, 4, 4);
    }

    // Draw wall on bottom edge (for edge cells only - normally this is drawn by the adjacent cell's top wall)
    drawWallBottom(x, y, palette) {
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;
        const h = this.wallHeight;

        // Bottom wall faces the "front" of isometric view, use dark color (shadow side)
        this.ctx.fillStyle = palette.dark;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y + hh);
        this.ctx.lineTo(x, y + hh - h);
        this.ctx.lineTo(x - hw, y - h);
        this.ctx.lineTo(x - hw, y);
        this.ctx.closePath();
        this.ctx.fill();

        // Top edge
        this.ctx.fillStyle = palette.top;
        this.ctx.fillRect(x - hw - 1, y - h - 2, 4, 4);
    }

    drawPlayer(x, y) {
        const pal = this.palette.player;
        const r = this.tileWidth / 5;

        // Shadow
        this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
        this.ctx.beginPath();
        this.ctx.ellipse(x, y + 2, r, r/2, 0, 0, Math.PI * 2);
        this.ctx.fill();

        // Body (sphere-ish)
        const gradient = this.ctx.createRadialGradient(x - r/3, y - r - r/2, 0, x, y - r/2, r * 1.5);
        gradient.addColorStop(0, pal.light);
        gradient.addColorStop(0.5, pal.top);
        gradient.addColorStop(1, pal.dark);
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(x, y - r/2, r, 0, Math.PI * 2);
        this.ctx.fill();

        // Highlight
        this.ctx.fillStyle = 'rgba(255,255,255,0.4)';
        this.ctx.beginPath();
        this.ctx.arc(x - r/3, y - r, r/4, 0, Math.PI * 2);
        this.ctx.fill();
    }

    drawPlayerDirectional(x, y, direction = 'south') {
        const pal = this.palette.player;
        const r = this.tileWidth / 5;

        // Shadow
        this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
        this.ctx.beginPath();
        this.ctx.ellipse(x, y + 2, r, r/2, 0, 0, Math.PI * 2);
        this.ctx.fill();

        // Body (sphere-ish)
        const gradient = this.ctx.createRadialGradient(x - r/3, y - r - r/2, 0, x, y - r/2, r * 1.5);
        gradient.addColorStop(0, pal.light);
        gradient.addColorStop(0.5, pal.top);
        gradient.addColorStop(1, pal.dark);
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(x, y - r/2, r, 0, Math.PI * 2);
        this.ctx.fill();

        // Directional highlight - shift based on facing direction
        // In isometric: east/south = down-right, west/north = down-left
        const highlightOffset = (direction === 'west' || direction === 'north') ? r/3 : -r/3;
        this.ctx.fillStyle = 'rgba(255,255,255,0.4)';
        this.ctx.beginPath();
        this.ctx.arc(x + highlightOffset, y - r, r/4, 0, Math.PI * 2);
        this.ctx.fill();

        // Small direction indicator dot
        const dotOffsets = {
            north: { dx: 0, dy: -r * 1.3 },
            south: { dx: 0, dy: r * 0.3 },
            east: { dx: r * 0.9, dy: -r * 0.4 },
            west: { dx: -r * 0.9, dy: -r * 0.4 }
        };
        const dot = dotOffsets[direction] || dotOffsets.south;
        this.ctx.fillStyle = pal.light;
        this.ctx.beginPath();
        this.ctx.arc(x + dot.dx, y - r/2 + dot.dy, r/6, 0, Math.PI * 2);
        this.ctx.fill();
    }

    drawChest(x, y, palette, opened) {
        const w = this.tileWidth / 3;
        const h = this.tileHeight / 2;

        // Chest body
        this.ctx.fillStyle = palette.dark;
        this.ctx.fillRect(x - w/2, y - h, w, h);
        this.ctx.fillStyle = palette.top;
        this.ctx.fillRect(x - w/2, y - h, w, h/3);

        if (!opened) {
            // Lock
            this.ctx.fillStyle = '#ffd700';
            this.ctx.fillRect(x - 2, y - h/2 - 2, 4, 4);
        } else {
            // Open lid
            this.ctx.fillStyle = palette.light;
            this.ctx.fillRect(x - w/2, y - h - 4, w, 4);
        }
    }

    drawMinion(x, y) {
        const pal = this.palette.minion;
        const r = this.tileWidth / 6;

        // Shadow
        this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
        this.ctx.beginPath();
        this.ctx.ellipse(x, y + 2, r, r/2, 0, 0, Math.PI * 2);
        this.ctx.fill();

        // Body
        this.ctx.fillStyle = pal.top;
        this.ctx.beginPath();
        this.ctx.arc(x, y - r/2, r, 0, Math.PI * 2);
        this.ctx.fill();

        // Eyes
        this.ctx.fillStyle = '#fff';
        this.ctx.beginPath();
        this.ctx.arc(x - 3, y - r/2, 2, 0, Math.PI * 2);
        this.ctx.arc(x + 3, y - r/2, 2, 0, Math.PI * 2);
        this.ctx.fill();
    }

    /**
     * Draw floating indicator above player
     * v1.4.9: Shows animated "thinking" dots when LLM is generating, diamond when idle
     */
    drawPlayerIndicator(x, y) {
        const time = Date.now() / 300;
        const isGenerating = isLLMGenerating;

        this.ctx.save();

        if (isGenerating) {
            // v1.4.9: Draw animated "thinking" indicator (three pulsing dots)
            const baseY = y - this.tileHeight - 20;
            const dotSpacing = 10;
            const dotRadius = 4;

            // Draw thought bubble background
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            this.ctx.shadowColor = '#f97316';
            this.ctx.shadowBlur = 12;
            this.ctx.beginPath();
            this.ctx.roundRect(x - 22, baseY - 8, 44, 20, 8);
            this.ctx.fill();

            // Draw three animated dots
            for (let i = 0; i < 3; i++) {
                const dotX = x - dotSpacing + (i * dotSpacing);
                // Staggered wave animation for each dot
                const phase = time * 2 + i * 0.8;
                const scale = 0.6 + Math.sin(phase) * 0.4;
                const alpha = 0.5 + Math.sin(phase) * 0.5;

                this.ctx.fillStyle = `rgba(251, 146, 60, ${alpha})`; // Orange
                this.ctx.shadowColor = '#fb923c';
                this.ctx.shadowBlur = 8;
                this.ctx.beginPath();
                this.ctx.arc(dotX, baseY + 2, dotRadius * scale, 0, Math.PI * 2);
                this.ctx.fill();
            }

            // Small tail pointing to player
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            this.ctx.shadowBlur = 0;
            this.ctx.beginPath();
            this.ctx.moveTo(x - 4, baseY + 12);
            this.ctx.lineTo(x, baseY + 18);
            this.ctx.lineTo(x + 4, baseY + 12);
            this.ctx.closePath();
            this.ctx.fill();
        } else {
            // Normal state: bouncing diamond
            const bounce = Math.sin(time) * 4;
            const indicatorY = y - this.tileHeight - 25 + bounce;

            this.ctx.shadowColor = '#3b82f6';
            this.ctx.shadowBlur = 10;

            // Diamond shape pointing down
            const size = 8;
            this.ctx.fillStyle = '#60a5fa';
            this.ctx.beginPath();
            this.ctx.moveTo(x, indicatorY + size * 2);  // Bottom point
            this.ctx.lineTo(x - size, indicatorY + size);
            this.ctx.lineTo(x, indicatorY);  // Top point
            this.ctx.lineTo(x + size, indicatorY + size);
            this.ctx.closePath();
            this.ctx.fill();

            // Inner highlight
            this.ctx.fillStyle = '#93c5fd';
            this.ctx.beginPath();
            this.ctx.moveTo(x, indicatorY + size * 1.5);
            this.ctx.lineTo(x - size/2, indicatorY + size);
            this.ctx.lineTo(x, indicatorY + size/2);
            this.ctx.lineTo(x + size/2, indicatorY + size);
            this.ctx.closePath();
            this.ctx.fill();
        }

        this.ctx.restore();

        // Trigger re-render for animation (throttled)
        if (!this._animationFrame) {
            this._animationFrame = requestAnimationFrame(() => {
                this._animationFrame = null;
                if (this.lastMazeState) {
                    this.render(this.lastMazeState);
                }
            });
        }
    }

    drawTrap(x, y) {
        const pal = this.palette.trap;
        this.ctx.fillStyle = pal.top;

        // Spikes pattern
        for (let i = -1; i <= 1; i++) {
            this.ctx.beginPath();
            this.ctx.moveTo(x + i * 6 - 2, y);
            this.ctx.lineTo(x + i * 6, y - 6);
            this.ctx.lineTo(x + i * 6 + 2, y);
            this.ctx.fill();
        }
    }

    drawSafeRoomIndicator(x, y) {
        const pal = this.palette.safeRoom;
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;

        // Draw glowing teal diamond overlay
        const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, hw);
        gradient.addColorStop(0, pal.light + 'aa');
        gradient.addColorStop(0.6, pal.top + '66');
        gradient.addColorStop(1, 'transparent');
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - hh);
        this.ctx.lineTo(x + hw, y);
        this.ctx.lineTo(x, y + hh);
        this.ctx.lineTo(x - hw, y);
        this.ctx.closePath();
        this.ctx.fill();

        // Draw heart icon (healing symbol)
        this.ctx.fillStyle = pal.top;
        this.ctx.font = `bold ${Math.floor(this.tileWidth / 4)}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText('♥', x, y - 2);
    }

    drawPortal(x, y) {
        const pal = this.palette.portal;
        const r = this.tileWidth / 4;

        // Glow
        const gradient = this.ctx.createRadialGradient(x, y - r/2, 0, x, y - r/2, r * 1.5);
        gradient.addColorStop(0, pal.light);
        gradient.addColorStop(0.5, pal.top + '88');
        gradient.addColorStop(1, 'transparent');
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(x, y - r/2, r * 1.5, 0, Math.PI * 2);
        this.ctx.fill();

        // Core
        this.ctx.fillStyle = pal.top;
        this.ctx.beginPath();
        this.ctx.arc(x, y - r/2, r/2, 0, Math.PI * 2);
        this.ctx.fill();
    }

    drawStairIcon(x, y, direction) {
        this.ctx.fillStyle = '#fff';
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(direction === 'up' ? '▲' : '▼', x, y);
    }

    updatePlayerPosition(x, y, animate, cellSize) {
        // Canvas re-renders everything, animation handled in render
    }
}

/**
 * Renderer Registry - Factory for creating and switching renderers
 */
const RendererRegistry = {
    renderers: {
        'css-grid': CSSGridRenderer,
        'canvas': CanvasRenderer,
        'isometric': IsometricRenderer,
    },

    currentRenderer: null,
    currentType: 'isometric',

    /**
     * Register a new renderer type
     */
    register(type, RendererClass) {
        this.renderers[type] = RendererClass;
    },

    /**
     * Create a renderer instance
     */
    create(type, options = {}) {
        const RendererClass = this.renderers[type];
        if (!RendererClass) {
            console.warn(`[MazeMaster] Unknown renderer type: ${type}, falling back to css-grid`);
            return new CSSGridRenderer(options);
        }
        return new RendererClass(options);
    },

    /**
     * Get or create the current active renderer
     */
    getRenderer(type = null) {
        // If no type specified, check settings for renderer preference
        if (!type && typeof extensionSettings !== 'undefined' && extensionSettings?.rendererType) {
            type = extensionSettings.rendererType;
        }

        if (type && type !== this.currentType) {
            if (this.currentRenderer) {
                this.currentRenderer.cleanup();
            }
            this.currentType = type;
            this.currentRenderer = this.create(type);
        }

        if (!this.currentRenderer) {
            this.currentRenderer = this.create(this.currentType);
        }

        return this.currentRenderer;
    },

    /**
     * Get list of available renderer types
     */
    getAvailableTypes() {
        return Object.keys(this.renderers);
    },
};

// =============================================================================
// LAYOUT MODE SYSTEM (v1.2.0)
// =============================================================================

/**
 * Detect if we're on a mobile/portrait device
 * @returns {'mobile' | 'desktop'}
 */
function detectLayoutMode() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    const isPortrait = height > width;
    const isSmallScreen = width < 768;

    // Mobile if portrait OR small screen
    return (isPortrait || isSmallScreen) ? 'mobile' : 'desktop';
}

/**
 * Get the current layout mode based on settings
 * @returns {'mobile' | 'desktop'}
 */
function getLayoutMode() {
    const mode = extensionSettings?.layoutMode || 'desktop';
    if (mode === 'auto') {
        return detectLayoutMode();
    }
    return mode;
}

/**
 * Apply layout mode CSS classes to maze modal
 */
function applyLayoutMode() {
    const modal = document.getElementById('mazemaster_maze_modal');
    if (!modal) return;

    const mode = getLayoutMode();
    modal.classList.remove('layout-mobile', 'layout-desktop');
    modal.classList.add(`layout-${mode}`);

    // Also update the main container if it exists
    const container = modal.querySelector('.maze-modal-container');
    if (container) {
        container.classList.remove('layout-mobile', 'layout-desktop');
        container.classList.add(`layout-${mode}`);
    }
}

// Listen for orientation/resize changes
if (typeof window !== 'undefined') {
    window.addEventListener('resize', () => {
        if (extensionSettings?.layoutMode === 'auto') {
            applyLayoutMode();
        }
    });
}

// Default maze profile fields for backwards compatibility
const MAZE_PROFILE_DEFAULTS = {
    difficulty: 'normal',
    theme: 'fantasy',
    mapStyle: 'maze',
    floors: 1,
    mapVisibility: 'fogOfWar', // 'showAll', 'fogOfWar', or 'hideUnexplored'
    // STScript hooks
    onMove: '',
    onMilestone: '',
    onExploreComplete: '',
    onItemAdd: '',
    onItemRemove: '',
    onChestOpen: '',
    onTrade: '',
    onEnemyMove: '',
    onTeleport: '',
    onObjectiveProgress: '',
    onObjectiveComplete: '',
    onAllObjectivesComplete: '',
    onDifficultySet: '',
    onStatUpdate: '',
    // New features
    portals: [],
    objectives: [],
    // HP System (v1.3.0)
    hpEnabled: true,
    maxHP: 100,
    battlebarDamageMultiplier: 1.0,      // Multiplier applied to battlebar profile damage
    battlebarDifficultyMultiplier: 1.0,  // Multiplier applied to battlebar difficulty (affects speed/zone)
    onDeath: 'respawn',        // 'respawn', 'respawnPenalty', 'gameover'
    respawnHPPercent: 50,
    safeRoomCount: 3,          // Number of safe rooms per floor
    safeRoomHealPercent: 100,  // % of HP healed when using a safe room
    safeRoomUseLLM: false,     // Use LLM for themed safe room messages
    // Rest mechanic
    restEnabled: true,         // Enable rest button
    restHealPercent: 20,       // % of HP restored when resting
    restCooldown: 3,           // Turns before can rest again
    restInterruptChance: 0,    // % chance rest is interrupted (0 = always safe)
    restInterruptScript: '',   // STScript on interrupt (empty = random encounter)
    // HP STScript hooks
    onDamage: '',
    onHeal: '',
    onPlayerDeath: '',
    // v1.5.0: Equipment STScript hooks
    onEquip: '',           // Fired when item equipped: {{itemId}}, {{name}}, {{slot}}, {{attack}}, {{defense}}
    onUnequip: '',         // Fired when item unequipped: {{itemId}}, {{name}}, {{slot}}
    onEquipmentFound: '',  // Fired when equipment dropped: {{itemId}}, {{name}}, {{slot}}, {{rarity}}
    equipmentDropChance: 15, // % chance for equipment drop on combat victory
    // v1.5.0: XP & Leveling STScript hooks
    onXpGain: '',          // Fired when XP gained: {{amount}}, {{source}}, {{totalXp}}, {{level}}
    onLevelUp: '',         // Fired on level up: {{newLevel}}, {{skillPointsAvailable}}, {{stats}}
    // v1.5.0: Skills STScript hooks
    onSkillLearn: '',      // Fired when skill learned: {{skillId}}, {{skillName}}, {{rank}}, {{tree}}
    onSkillUse: '',        // Fired when skill used: {{skillId}}, {{skillName}}, {{rank}}, {{effect}}
    // v1.4.7: Fairness system (pity mechanics)
    fairness: {
        enabled: true,              // Enable fairness modifiers
        keyPityThreshold: 3,        // Chests without key before boost
        healingPityThreshold: 4,    // Chests without healing before boost
        lowHpThreshold: 0.4,        // HP % below which healing boost activates
        mercyUnlock: true,          // Allow locked chests to mercy-unlock
        mercyUnlockThreshold: 2,    // Skipped locked chests before mercy unlock
    },
    // v1.4.8: LLM Room Enhancement
    llmEnhanceRooms: true,          // Use LLM to enhance room descriptions on first entry
    llmMaxTokens: 250,              // Max tokens for LLM chat responses
    llmRoomPrompt: 'Describe this {{roomType}} room in 1-2 vivid sentences. Theme: {{theme}}. Context: {{sessionNotes}}',
    // v1.7.0: Quest Profiles
    questProfile: 'none',           // Reference to a quest profile by name
    questGatingEnabled: false,      // When true, quests gate zones/floors instead of room clearing
    // v2.0.3: XP Configuration (profile-specific XP rates)
    xpConfig: {
        combatVictory: 25,          // Base XP for winning combat
        combatDifficultyBonus: 5,   // Additional XP per difficulty level
        lockedChest: 20,            // Opening a locked chest
        normalChest: 10,            // Opening a normal chest
        exploration10: 20,          // Every 10% of map explored
        objectiveComplete: 50,      // Completing an objective
        bossDefeat: 75,             // Defeating a boss minion
        puzzleSolved: 30,           // Solving a puzzle encounter
        trapDisarmed: 15,           // Disarming a trap
        questComplete: 100,         // Completing a quest
    },
    // v2.0.5: Level-up skill point dice
    skillPointDice: '1d3',          // Dice notation for skill points per level (e.g., 1d3, 2d2, 1d4)
};

/**
 * Roll dice using standard notation (e.g., "2d6+3", "1d20", "3d4-1")
 * @param {string} notation - Dice notation string
 * @returns {number} - Total roll result
 */
function rollDice(notation) {
    // Parse dice notation: XdY+Z or XdY-Z or XdY
    const match = notation.match(/^(\d+)d(\d+)([+-]\d+)?$/i);
    if (!match) {
        console.warn(`[MazeMaster] Invalid dice notation: ${notation}`);
        return 0;
    }

    const numDice = parseInt(match[1], 10);
    const sides = parseInt(match[2], 10);
    const modifier = match[3] ? parseInt(match[3], 10) : 0;

    let total = 0;
    for (let i = 0; i < numDice; i++) {
        total += Math.floor(Math.random() * sides) + 1;
    }
    total += modifier;

    console.log(`[MazeMaster] Rolled ${notation}: ${total}`);
    return Math.max(0, total); // Ensure non-negative result
}

/**
 * Process MazeMaster custom macros in a string
 * Supports: {{roll:XdY+Z}}, {{random:min:max}}
 * @param {string} text - Text containing macros
 * @returns {string} - Text with macros replaced
 */
function processMazeMasterMacros(text) {
    if (!text || typeof text !== 'string') return text;

    // Process {{roll:XdY+Z}} macros
    text = text.replace(/\{\{roll:([^}]+)\}\}/gi, (match, notation) => {
        return String(rollDice(notation.trim()));
    });

    // Process {{random:min:max}} macros
    text = text.replace(/\{\{random:(\d+):(\d+)\}\}/gi, (match, min, max) => {
        const minVal = parseInt(min, 10);
        const maxVal = parseInt(max, 10);
        return String(Math.floor(Math.random() * (maxVal - minVal + 1)) + minVal);
    });

    return text;
}

/**
 * Execute STScript command with timeout protection
 * Prevents hanging if a script takes too long or gets stuck
 * @param {string} command - The STScript command to execute
 * @param {number} timeoutMs - Timeout in milliseconds (default: 10000)
 * @returns {Promise<any>} - Result of the command or null if timed out
 */
async function executeWithTimeout(command, timeoutMs = STSCRIPT_TIMEOUT_MS) {
    if (!command || typeof command !== 'string' || command.trim() === '') {
        return null;
    }

    // Process MazeMaster macros before execution
    command = processMazeMasterMacros(command);

    try {
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error(`STScript timed out after ${timeoutMs}ms`)), timeoutMs);
        });

        const result = await Promise.race([
            executeSlashCommandsWithOptions(command),
            timeoutPromise
        ]);

        return result;
    } catch (err) {
        if (err.message?.includes('timed out')) {
            console.warn(`[MazeMaster] STScript timed out: ${command.substring(0, 50)}...`);
        } else {
            console.error('[MazeMaster] STScript error:', err);
        }
        return null;
    }
}

/**
 * Fire an STScript hook with parameter substitution
 * @param {string} hookName - The hook name (e.g., 'onMove', 'onItemAdd')
 * @param {Object} params - Parameters to substitute (e.g., {x: 1, y: 2})
 */
async function fireHook(hookName, params = {}) {
    const profile = currentMaze?.profile;
    if (!profile) return;

    let command = profile[hookName];
    if (!command || typeof command !== 'string' || !command.trim()) return;

    // Replace template variables {{varName}} with values
    for (const [key, value] of Object.entries(params)) {
        command = command.replaceAll(`{{${key}}}`, String(value));
    }

    await executeWithTimeout(command);
}

/**
 * Get difficulty tier settings for a profile
 * @param {Object|string} profileOrDifficulty - Profile object or difficulty string
 * @returns {Object} Difficulty tier configuration
 */
function getDifficultySettings(profileOrDifficulty) {
    const difficulty = typeof profileOrDifficulty === 'string'
        ? profileOrDifficulty
        : (profileOrDifficulty?.difficulty || 'normal');
    return DIFFICULTY_TIERS[difficulty] || DIFFICULTY_TIERS.normal;
}

/**
 * Get maze profile with defaults merged in for backwards compatibility
 * @param {string} name - Profile name
 * @returns {Object|null} Profile with defaults merged
 */
function getMazeProfileWithDefaults(name) {
    // Check user's saved profiles first, then fall back to built-in defaults
    const profile = extensionSettings.mazeProfiles?.[name] || DEFAULT_MAZE_PROFILE[name];
    if (!profile) return null;
    return { ...MAZE_PROFILE_DEFAULTS, ...profile };
}

// =============================================================================
// HP SYSTEM (v1.3.0)
// =============================================================================

/**
 * Initialize HP for a new maze based on profile and difficulty settings
 * @param {Object} profile - The maze profile
 * @returns {Object} HP state object
 */
function initHP(profile) {
    const difficulty = getDifficultySettings(profile);
    const hpMult = difficulty.hpMult || 1.0;
    const baseMax = profile.maxHP || 100;
    const maxHP = Math.round(baseMax * hpMult);

    return {
        current: maxHP,
        max: maxHP,
        maxBonus: 0,
        reviveCharges: 0,
    };
}

/**
 * Try to absorb damage with equipment items (e.g., Iron Guard)
 * v1.7.0: Checks for equipment with absorption charges
 * v1.9.7: Also checks equipped armor for absorb special
 * @param {number} amount - The damage amount
 * @param {string} source - The damage source
 * @returns {Promise<{fullyAbsorbed: boolean, remainingDamage: number}>}
 */
async function tryAbsorbDamage(amount, source) {
    // v1.9.7: First check equipped armor for absorb special
    const equippedArmor = currentMaze?.equipment?.armor;
    if (equippedArmor?.special?.type === 'absorb') {
        // Initialize charges tracking if not present
        if (typeof currentMaze.equipmentCharges === 'undefined') {
            currentMaze.equipmentCharges = {};
        }
        if (typeof currentMaze.equipmentCharges[equippedArmor.id] === 'undefined') {
            currentMaze.equipmentCharges[equippedArmor.id] = equippedArmor.special.charges || 3;
        }

        const chargesLeft = currentMaze.equipmentCharges[equippedArmor.id];
        if (chargesLeft > 0) {
            // Absorb the damage
            const absorbed = amount; // Full absorption
            currentMaze.equipmentCharges[equippedArmor.id]--;
            const remaining = currentMaze.equipmentCharges[equippedArmor.id];

            if (remaining > 0) {
                addMazeMessage('Shield', `${equippedArmor.name} absorbed ${absorbed} damage! (${remaining} charges left)`);
            } else {
                addMazeMessage('Shield', `${equippedArmor.name} absorbed ${absorbed} damage and shattered!`);
                // Unequip the broken armor
                currentMaze.equipment.armor = null;
                updateEquipmentDisplay();
            }

            return {
                fullyAbsorbed: true,
                remainingDamage: 0,
            };
        }
    }

    // v1.9.0: Dynamically find equipment items that can absorb damage from item profiles
    const absorbItems = getItemProfileIds().filter(itemId => {
        const profile = getItemProfile(itemId);
        return profile?.type === 'equipment' && profile?.absorbPercent > 0;
    });

    for (const itemId of absorbItems) {
        // Check if player has this item
        if (!currentMaze.inventory?.[itemId] || currentMaze.inventory[itemId] <= 0) continue;

        // Check if item can absorb this damage type
        if (!canItemAbsorbDamage(itemId, source)) continue;

        const profile = getItemProfile(itemId);
        if (!profile) continue;

        // Consume a charge
        const chargesRemaining = consumeItemCharge(itemId);
        const absorbPercent = profile.absorbPercent || 100;
        const absorbed = Math.floor(amount * (absorbPercent / 100));
        const remaining = amount - absorbed;

        // Get themed display name
        const theme = currentMaze.profile?.theme || 'fantasy';
        const displayName = getItemDisplayName(itemId, theme);

        // Show absorption message
        const totalCharges = getTotalItemCharges(itemId);
        if (chargesRemaining > 0) {
            addMazeMessage('Shield', `${displayName} absorbed ${absorbed} damage! (${chargesRemaining} charges left)`);
        } else {
            // Item broke - remove from inventory
            addMazeMessage('Shield', `${displayName} absorbed ${absorbed} damage and shattered!`);
            await removeFromInventory(itemId);

            // Fire onBreak hook if defined
            if (profile.onBreak) {
                await executeSTScript(profile.onBreak, { itemId, absorbed, source });
            }
        }

        // Fire onActivate hook if defined
        if (profile.onActivate) {
            await executeSTScript(profile.onActivate, { itemId, absorbed, chargesRemaining, source });
        }

        return {
            fullyAbsorbed: remaining <= 0,
            remainingDamage: Math.max(0, remaining),
        };
    }

    return { fullyAbsorbed: false, remainingDamage: amount };
}

/**
 * Apply damage to the player
 * @param {number} amount - Raw damage amount
 * @param {string} source - Damage source: 'battlebar', 'trap', 'contact', 'script'
 * @returns {Promise<boolean>} True if player survived, false if dead
 */
async function applyDamage(amount, source = 'unknown') {
    if (!currentMaze.hpEnabled || !currentMaze.hp) return true;

    // v1.7.0: Check for damage-absorbing equipment
    const absorbed = await tryAbsorbDamage(amount, source);
    if (absorbed.fullyAbsorbed) return true;
    amount = absorbed.remainingDamage;

    // If no damage remains after absorption, skip
    if (amount <= 0) return true;

    const prevHP = currentMaze.hp.current;
    currentMaze.hp.current = Math.max(0, currentMaze.hp.current - amount);

    // Update UI
    updateHPDisplay();
    updateRestButton(); // Update rest button when HP changes
    showDamageFlash();

    // Fire hook
    await fireHook('onDamage', {
        amount,
        source,
        previousHP: prevHP,
        currentHP: currentMaze.hp.current,
        maxHP: currentMaze.hp.max + currentMaze.hp.maxBonus,
    });

    // Log message
    addMazeMessage('Combat', `Took ${amount} damage! (${currentMaze.hp.current}/${currentMaze.hp.max + currentMaze.hp.maxBonus} HP)`);

    // Check for death
    if (currentMaze.hp.current <= 0) {
        await handlePlayerDeath(source);
        return false;
    }

    // Low HP warning at 25%
    const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;
    if (currentMaze.hp.current <= maxTotal * 0.25 && prevHP > maxTotal * 0.25) {
        addMazeMessage('Warning', 'Your health is critically low!');
    }

    return true;
}

/**
 * Heal the player
 * @param {number} amount - Amount to heal (raw or percentage based on isPercent)
 * @param {boolean} isPercent - If true, amount is percentage of max HP
 * @param {string} source - Heal source: 'potion', 'elixir', 'safeRoom', 'script'
 */
async function healPlayer(amount, isPercent = false, source = 'unknown') {
    if (!currentMaze.hpEnabled || !currentMaze.hp) return;

    const difficulty = getDifficultySettings(currentMaze.profile);
    const healMult = difficulty.healMult || 1.0;
    const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;

    let healAmount = isPercent
        ? Math.round((amount / 100) * maxTotal * healMult)
        : Math.round(amount * healMult);

    const prevHP = currentMaze.hp.current;
    currentMaze.hp.current = Math.min(maxTotal, currentMaze.hp.current + healAmount);
    const actualHeal = currentMaze.hp.current - prevHP;

    // Update UI
    updateHPDisplay();
    updateRestButton(); // Update rest button when HP changes
    if (actualHeal > 0) {
        showHealFlash();
    }

    // Fire hook
    await fireHook('onHeal', {
        amount: actualHeal,
        source,
        previousHP: prevHP,
        currentHP: currentMaze.hp.current,
        maxHP: maxTotal,
    });

    if (actualHeal > 0) {
        addMazeMessage('Healing', `Restored ${actualHeal} HP! (${currentMaze.hp.current}/${maxTotal} HP)`);
    }
}

/**
 * Handle player death
 * @param {string} source - What killed the player
 */
async function handlePlayerDeath(source) {
    console.log('[MazeMaster] handlePlayerDeath called, source:', source);

    // Check for revival charges (from revival charms)
    if (currentMaze.hp.reviveCharges > 0) {
        currentMaze.hp.reviveCharges--;
        const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;
        currentMaze.hp.current = Math.round(maxTotal * 0.25); // Revive at 25% HP

        updateHPDisplay();
        addMazeMessage('Revival', 'Your Revival Charm activates! You cheat death...');
        addSessionNote(`Revival charm activated! Cheated death from ${source}`, 'Death');
        console.log('[MazeMaster] Revival charm used, HP restored');
        return;
    }

    // Log death to session notes
    addSessionNote(`DEATH: Killed by ${source}`, 'Death');

    // Fire death hook
    await fireHook('onPlayerDeath', { source });

    // Handle based on profile setting
    const deathAction = currentMaze.profile?.onDeath || 'respawn';
    console.log('[MazeMaster] Death action:', deathAction, 'Profile onDeath:', currentMaze.profile?.onDeath);

    switch (deathAction) {
        case 'respawn':
            console.log('[MazeMaster] Respawning player');
            await respawnPlayerWithHP(100);
            break;
        case 'respawnPenalty':
            const respawnPercent = currentMaze.profile?.respawnHPPercent || 50;
            console.log('[MazeMaster] Respawning with penalty:', respawnPercent + '%');
            await respawnPlayerWithHP(respawnPercent);
            break;
        case 'gameover':
        default:
            console.log('[MazeMaster] Game over triggered');
            handleMazeLoss();
            break;
    }
}

/**
 * Respawn player at start with specified HP percentage
 * @param {number} hpPercent - Percentage of max HP to restore
 */
async function respawnPlayerWithHP(hpPercent) {
    // Move to start
    currentMaze.playerX = 0;
    currentMaze.playerY = 0;
    currentMaze.isPaused = false;
    currentMaze.pendingEncounter = null;
    currentMaze.pendingConfirmation = null;

    // Restore HP
    const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;
    currentMaze.hp.current = Math.round(maxTotal * (hpPercent / 100));
    updateHPDisplay();

    // Re-render
    renderMazeGrid();
    updateDpadFloorButtons();
    addMazeMessage('Respawn', `Returned to the start with ${hpPercent}% HP...`);

    // Smooth pan camera back to player at start position
    setTimeout(() => {
        if (typeof window.mazeCenterOnPlayer === 'function') {
            window.mazeCenterOnPlayer(true); // true = smooth animation
        }
    }, 100);

    // Update hero display
    const profile = currentMaze.profile;
    if (profile?.mainMinion) {
        const mainMinion = getMinion(profile.mainMinion);
        if (mainMinion) {
            currentMaze.currentMinion = {
                name: mainMinion.name,
                imagePath: mainMinion.imagePath,
                message: 'Back to the beginning with you!',
            };
            updateMazeHero();
        }
    }
}

/**
 * Increase max HP permanently (from items like Heart Crystal)
 * @param {number} amount - Amount to increase max HP by
 */
async function increaseMaxHP(amount) {
    if (!currentMaze.hpEnabled || !currentMaze.hp) return;

    currentMaze.hp.maxBonus += amount;
    currentMaze.hp.current += amount; // Also heal by that amount
    updateHPDisplay();

    addMazeMessage('Power Up', `Max HP increased by ${amount}!`);
}

// =============================================================================
// REST MECHANIC
// =============================================================================

/**
 * Handle rest action - consume turn to heal, with potential interruption
 */
async function handleRestAction() {
    if (!currentMaze.isOpen || currentMaze.isPaused || currentMaze.isVictory) return;
    if (!currentMaze.hpEnabled || !currentMaze.hp) return;

    const profile = currentMaze.profile || {};
    if (!profile.restEnabled) return;

    // Check cooldown
    if ((currentMaze.restCooldown || 0) > 0) {
        addMazeMessage('Rest', `Cannot rest yet. Wait ${currentMaze.restCooldown} more turn(s).`);
        return;
    }

    // Check if at full HP
    const maxTotal = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
    if (currentMaze.hp.current >= maxTotal) {
        addMazeMessage('Rest', 'You are already at full health.');
        return;
    }

    // Consume turn (count as a move)
    await incrementStat('moves', 1);

    // Check for interruption
    const interruptChance = profile.restInterruptChance ?? 0;
    if (interruptChance > 0) {
        const roll = Math.random() * 100;
        if (roll < interruptChance) {
            // Interrupted!
            console.log(`[MazeMaster] Rest interrupted (rolled ${roll.toFixed(1)} vs ${interruptChance}%)`);

            // Set cooldown anyway (attempted rest still uses the action)
            currentMaze.restCooldown = profile.restCooldown ?? 3;
            updateRestButton();

            // Run interrupt script or trigger random encounter
            if (profile.restInterruptScript && profile.restInterruptScript.trim()) {
                addMazeMessage('Interrupted!', 'Your rest is disturbed!');
                await executeWithTimeout(profile.restInterruptScript);
            } else {
                // Trigger random minion encounter from the profile's encounters
                await triggerRandomRestEncounter();
            }
            return;
        }
    }

    // Successful rest - heal
    const healPercent = profile.restHealPercent ?? 20;
    await healPlayer(healPercent, true, 'rest');

    // Set cooldown
    currentMaze.restCooldown = profile.restCooldown ?? 3;
    updateRestButton();

    addMazeMessage('Rest', `You take a moment to rest and recover ${healPercent}% HP.`);
}

/**
 * Trigger a random encounter when rest is interrupted
 */
async function triggerRandomRestEncounter() {
    const profile = currentMaze.profile || {};
    const encounters = profile.minionEncounters || [];

    if (encounters.length === 0) {
        addMazeMessage('Interrupted!', 'Something disturbs your rest, but nothing appears...');
        return;
    }

    // Pick a random minion from the profile's encounters
    const randomEncounter = encounters[Math.floor(Math.random() * encounters.length)];
    const minionId = randomEncounter.minionId;

    if (minionId) {
        addMazeMessage('Ambush!', 'You are caught off guard while resting!');
        await triggerMinionEncounter(minionId, currentMaze.playerX, currentMaze.playerY, true); // true = skip movement
    } else {
        addMazeMessage('Interrupted!', 'Your rest is disturbed by strange noises...');
    }
}

/**
 * Decrement rest cooldown (called after each player move)
 */
function decrementRestCooldown() {
    if (currentMaze.restCooldown && currentMaze.restCooldown > 0) {
        currentMaze.restCooldown--;
        updateRestButton();
    }
}

/**
 * Update rest button visibility and state
 */
function updateRestButton() {
    const restBtn = document.getElementById('maze_rest_btn');
    if (!restBtn) return;

    const profile = currentMaze.profile || {};

    // Show/hide based on HP system and rest enabled
    if (!currentMaze.hpEnabled || !profile.restEnabled) {
        restBtn.style.display = 'none';
        return;
    }

    restBtn.style.display = 'flex';

    // Update disabled state
    const cooldown = currentMaze.restCooldown || 0;
    const hpMax = currentMaze.hp?.max || 100;
    const hpMaxBonus = currentMaze.hp?.maxBonus || 0;
    const hpCurrent = currentMaze.hp?.current || 0;
    const maxTotal = hpMax + hpMaxBonus;
    const atFullHP = hpCurrent >= maxTotal;
    const onCooldown = cooldown > 0;

    restBtn.disabled = onCooldown || atFullHP || currentMaze.isPaused;

    // Update tooltip
    if (atFullHP) {
        restBtn.title = 'Already at full HP';
    } else if (onCooldown) {
        restBtn.title = `Rest available in ${cooldown} turn(s)`;
    } else {
        const healPercent = profile.restHealPercent ?? 20;
        restBtn.title = `Rest to recover ${healPercent}% HP`;
    }

    // Update cooldown badge
    const badge = restBtn.querySelector('.rest-cooldown-badge');
    if (badge) {
        if (onCooldown) {
            badge.style.display = 'flex';
            badge.textContent = cooldown;
        } else {
            badge.style.display = 'none';
        }
    }
}

/**
 * Update the HP display in the maze modal
 */
function updateHPDisplay() {
    if (!currentMaze.hpEnabled || !currentMaze.hp) return;

    const currentEl = document.getElementById('maze_hp_current');
    const maxEl = document.getElementById('maze_hp_max');
    const barEl = document.getElementById('maze_hp_bar');
    const container = document.querySelector('.mazemaster-maze-container');
    const hpOverlay = document.getElementById('maze_hp_overlay');

    const current = currentMaze.hp.current;
    const max = currentMaze.hp.max + currentMaze.hp.maxBonus;
    const percent = Math.round((current / max) * 100);

    if (currentEl) currentEl.textContent = current;
    if (maxEl) maxEl.textContent = max;

    if (barEl) {
        barEl.style.width = `${percent}%`;
        barEl.classList.remove('low', 'medium', 'high');
        if (percent <= 25) {
            barEl.classList.add('low');
        } else if (percent <= 50) {
            barEl.classList.add('medium');
        } else {
            barEl.classList.add('high');
        }
    }

    // Show/hide HP overlay based on hpEnabled
    if (hpOverlay) {
        hpOverlay.style.display = currentMaze.hpEnabled ? '' : 'none';
    }

    // Low HP container warning pulse
    if (container) {
        if (percent <= 25) {
            container.classList.add('low-hp');
        } else {
            container.classList.remove('low-hp');
        }
    }
}

/**
 * Show damage flash effect on screen
 */
function showDamageFlash() {
    const flash = document.createElement('div');
    flash.className = 'maze-hp-flash damage';
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), 300);
}

/**
 * Show heal flash effect on screen
 */
function showHealFlash() {
    const flash = document.createElement('div');
    flash.className = 'maze-hp-flash heal';
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), 300);
}

/**
 * Use an HP item from inventory
 * v1.9.0: Refactored to use item profile data instead of hardcoded values
 * @param {string} itemType - The HP item type
 */
async function useHPItem(itemType) {
    if (!currentMaze.hpEnabled || !currentMaze.hp) return;
    if (!currentMaze.inventory[itemType] || currentMaze.inventory[itemType] <= 0) return;

    const itemProfile = getItemProfile(itemType);
    if (!itemProfile) return;

    const theme = currentMaze.profile?.theme || 'fantasy';
    const displayName = getItemDisplayName(itemType, theme);

    // Handle items based on their profile type and properties
    if (itemProfile.type === 'potion' && itemProfile.healAmount) {
        // Healing potions - use healAmount and healIsPercent from profile
        await removeFromInventory(itemType);
        await healPlayer(itemProfile.healAmount, itemProfile.healIsPercent !== false, 'potion');
    } else if (itemProfile.type === 'equipment' && itemProfile.subtype === 'charm') {
        // Revival charms and similar passive death-prevention items
        if (itemProfile.triggers?.includes('death')) {
            currentMaze.hp.reviveCharges = (currentMaze.hp.reviveCharges || 0) + (itemProfile.charges || 1);
            await removeFromInventory(itemType);
            addMazeMessage('Item', `${displayName} ready. You will cheat death once.`);
        }
    } else {
        // Handle special cases for items not covered by profile data
        switch (itemType) {
            case 'heartCrystal':
                await removeFromInventory('heartCrystal');
                await increaseMaxHP(10);
                break;
        }
    }
}

/**
 * Use a visibility item from inventory
 * v1.9.0: Refactored to use item profile data instead of hardcoded values
 * @param {string} itemType - The visibility item type
 */
async function useVisibilityItem(itemType) {
    if (!currentMaze.isOpen) return;
    if (!currentMaze.inventory[itemType] || currentMaze.inventory[itemType] <= 0) return;

    const itemProfile = getItemProfile(itemType);
    if (!itemProfile) return;

    const theme = currentMaze.profile?.theme || 'fantasy';
    const displayName = getItemDisplayName(itemType, theme);

    // Ensure visibility object exists
    if (!currentMaze.visibility) {
        currentMaze.visibility = { baseRadius: 1, tempBonus: 0, tempMovesLeft: 0, permBonus: 0, floorRevealed: false };
    }

    // Handle based on item effect from profile
    const effect = itemProfile.effect;

    if (effect === 'tempVisibility') {
        // Temporary visibility boost (torch, etc.)
        await removeFromInventory(itemType);
        currentMaze.visibility.tempBonus = itemProfile.visibilityBonus || 2;
        currentMaze.visibility.tempMovesLeft = itemProfile.duration || 3;
        addMazeMessage('Item', `${displayName} lit! +${itemProfile.visibilityBonus || 2} visibility for ${itemProfile.duration || 3} moves.`);
    } else if (effect === 'revealFloor') {
        // Reveal entire floor (reveal scroll, etc.)
        await removeFromInventory(itemType);
        currentMaze.visibility.floorRevealed = true;
        const size = currentMaze.grid.length;
        const floorPrefix = `${currentMaze.currentFloor}:`;
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                currentMaze.visited.add(`${floorPrefix}${x},${y}`);
            }
        }
        addMazeMessage('Item', `The ${displayName} reveals the entire floor!`);
    } else if (effect === 'permanentVisibility' || itemType === 'sightPotion') {
        // Permanent visibility bonus
        await removeFromInventory(itemType);
        const bonus = itemProfile.visibilityBonus || 1;
        currentMaze.visibility.permBonus = (currentMaze.visibility.permBonus || 0) + bonus;
        addMazeMessage('Item', `Your vision sharpens! Permanent +${bonus} visibility.`);
    } else if (effect === 'revealMinions' || itemType === 'crystalBall') {
        // Reveal all minion positions
        await removeFromInventory(itemType);
        const minionsRevealed = [];
        const gridSize = currentMaze.grid.length;
        const currentFloorPrefix = `${currentMaze.currentFloor}:`;
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                const cell = currentMaze.grid[y][x];
                if (cell.minion && !cell.minion.triggered) {
                    currentMaze.visited.add(`${currentFloorPrefix}${x},${y}`);
                    minionsRevealed.push(cell.minion.name || 'Unknown');
                }
            }
        }
        if (minionsRevealed.length > 0) {
            addMazeMessage('Item', `${displayName} reveals ${minionsRevealed.length} minion(s)!`);
        } else {
            addMazeMessage('Item', `${displayName} shows no minions remain on this floor.`);
        }
    } else if (effect === 'passiveVisibility' || itemProfile.passive) {
        // Passive items (lantern, etc.) - just inform the player
        const bonus = itemProfile.visibilityBonus || 1;
        addMazeMessage('Info', `${displayName} provides passive +${bonus} visibility while held.`);
        return; // Don't consume
    }

    // Re-render the maze to show updated visibility
    renderMaze();
}

/**
 * Calculate current visibility radius based on items and buffs
 * v1.6.0: Enhanced to use vision profiles and lighting system
 * @returns {number} The current visibility radius
 */
function getVisibilityRadius() {
    if (!currentMaze.isOpen) return 1;

    // v1.6.0: Use enhanced lighting system if available
    if (currentMaze.lighting?.lightRadius) {
        return currentMaze.lighting.lightRadius;
    }

    // Fallback to legacy visibility system
    const vis = currentMaze.visibility || { baseRadius: 1, tempBonus: 0, permBonus: 0 };
    const lanternBonus = (currentMaze.inventory?.lantern || 0) > 0 ? 1 : 0;

    return vis.baseRadius + vis.tempBonus + vis.permBonus + lanternBonus;
}

/**
 * Check if movement between two adjacent cells is blocked by walls
 * @param {number} x1 - Start X
 * @param {number} y1 - Start Y
 * @param {number} x2 - End X
 * @param {number} y2 - End Y
 * @param {Array} grid - The maze grid
 * @returns {boolean} True if movement is blocked
 */
function isWallBlocking(x1, y1, x2, y2, grid) {
    const cell = grid[y1]?.[x1];
    const destCell = grid[y2]?.[x2];
    if (!cell) return true;

    const dx = x2 - x1;
    const dy = y2 - y1;

    // Check wall in movement direction from source cell
    if (dx === 1 && cell.walls.right) return true;
    if (dx === -1 && cell.walls.left) return true;
    if (dy === 1 && cell.walls.bottom) return true;
    if (dy === -1 && cell.walls.top) return true;

    // Also check from destination cell's perspective (walls should be symmetric but sometimes aren't)
    if (destCell) {
        if (dx === 1 && destCell.walls.left) return true;
        if (dx === -1 && destCell.walls.right) return true;
        if (dy === 1 && destCell.walls.top) return true;
        if (dy === -1 && destCell.walls.bottom) return true;
    }

    return false;
}

/**
 * Check if there's line of sight between two cells (no walls blocking)
 * Uses strict cell-by-cell path walking - if ANY wall blocks the path, visibility is blocked
 * @param {number} x1 - Start X
 * @param {number} y1 - Start Y
 * @param {number} x2 - End X
 * @param {number} y2 - End Y
 * @param {Array} grid - The maze grid
 * @returns {boolean} True if line of sight exists
 */
function hasLineOfSight(x1, y1, x2, y2, grid) {
    // Same cell - always visible
    if (x1 === x2 && y1 === y2) return true;

    const dx = x2 - x1;
    const dy = y2 - y1;
    const adx = Math.abs(dx);
    const ady = Math.abs(dy);
    const sx = dx > 0 ? 1 : dx < 0 ? -1 : 0;
    const sy = dy > 0 ? 1 : dy < 0 ? -1 : 0;

    // For straight lines (cardinal directions), check each cell along the path
    if (dx === 0 || dy === 0) {
        let cx = x1;
        let cy = y1;
        while (cx !== x2 || cy !== y2) {
            const nextX = cx + sx;
            const nextY = cy + sy;
            if (isWallBlocking(cx, cy, nextX, nextY, grid)) {
                return false;
            }
            cx = nextX;
            cy = nextY;
        }
        return true;
    }

    // For diagonal/angled lines, use Bresenham's algorithm and check walls strictly
    // We need BOTH L-shaped paths to be clear at each step for diagonal visibility
    let cx = x1;
    let cy = y1;
    let err = adx - ady;

    while (cx !== x2 || cy !== y2) {
        const e2 = 2 * err;
        let nextX = cx;
        let nextY = cy;
        let movedX = false;
        let movedY = false;

        if (e2 > -ady) {
            err -= ady;
            nextX += sx;
            movedX = true;
        }
        if (e2 < adx) {
            err += adx;
            nextY += sy;
            movedY = true;
        }

        // Check wall blocking based on movement type
        if (movedX && movedY) {
            // Diagonal movement - BOTH paths must be clear for visibility
            // Path A: horizontal then vertical
            const pathABlocked = isWallBlocking(cx, cy, cx + sx, cy, grid) ||
                                 isWallBlocking(cx + sx, cy, nextX, nextY, grid);
            // Path B: vertical then horizontal
            const pathBBlocked = isWallBlocking(cx, cy, cx, cy + sy, grid) ||
                                 isWallBlocking(cx, cy + sy, nextX, nextY, grid);
            // For visibility, require at least one clear path
            // But for strict fog-of-war, require BOTH to be blocked to block vision
            if (pathABlocked && pathBBlocked) {
                return false;
            }
        } else if (movedX) {
            if (isWallBlocking(cx, cy, nextX, nextY, grid)) {
                return false;
            }
        } else if (movedY) {
            if (isWallBlocking(cx, cy, nextX, nextY, grid)) {
                return false;
            }
        }

        cx = nextX;
        cy = nextY;
    }

    return true;
}

/**
 * Apply visibility at a given position (reveal tiles within radius)
 * Uses line-of-sight checking to prevent seeing through walls
 * @param {number} x - Player X position
 * @param {number} y - Player Y position
 * @param {number} gridSize - Size of the grid
 */
function applyVisibilityAtPosition(x, y, gridSize) {
    if (!currentMaze.isOpen) return;

    const visRadius = getVisibilityRadius();
    const floorPrefix = `${currentMaze.currentFloor}:`;

    // Get the current floor's grid
    const floorData = currentMaze.floorsData?.[currentMaze.currentFloor];
    const grid = floorData?.grid || currentMaze.grid;

    if (!grid) return;

    for (let vy = Math.max(0, y - visRadius); vy <= Math.min(gridSize - 1, y + visRadius); vy++) {
        for (let vx = Math.max(0, x - visRadius); vx <= Math.min(gridSize - 1, x + visRadius); vx++) {
            // Use Manhattan distance for visibility range
            if (Math.abs(vx - x) + Math.abs(vy - y) <= visRadius) {
                // Check line of sight - don't reveal through walls
                if (hasLineOfSight(x, y, vx, vy, grid)) {
                    currentMaze.visited.add(`${floorPrefix}${vx},${vy}`);
                }
            }
        }
    }
}

/**
 * Called after each move to update visibility timers
 */
function updateVisibilityOnMove() {
    if (!currentMaze.visibility) return;

    // Decrement temp bonus moves
    if (currentMaze.visibility.tempMovesLeft > 0) {
        currentMaze.visibility.tempMovesLeft--;
        if (currentMaze.visibility.tempMovesLeft <= 0) {
            currentMaze.visibility.tempBonus = 0;
            addMazeMessage('Info', 'Your torch burns out.');
        }
    }

    // Reset floor revealed flag (only lasts 1 move for display purposes)
    currentMaze.visibility.floorRevealed = false;
}

// =============================================================================
// STATISTICS TRACKING
// =============================================================================

/**
 * Initialize session stats for a new maze
 */
/**
 * Get current persona name from SillyTavern context
 * @returns {string} The current persona name or 'Default User'
 */
function getCurrentPersonaName() {
    try {
        const context = SillyTavern.getContext();
        // Try various context properties that might contain the persona name
        return context?.name1 || context?.persona || context?.user_avatar?.replace(/\.[^/.]+$/, '') || 'Default User';
    } catch (e) {
        console.warn('[MazeMaster] Could not get persona name:', e);
        return 'Default User';
    }
}

function initSessionStats() {
    return {
        startTime: Date.now(),
        moves: 0,
        encountersTotal: 0,
        encountersWon: 0,
        encountersLost: 0,
        chestsOpened: 0,
        trapsTriggered: 0,
        teleportsUsed: 0,
        itemsCollected: { key: 0, strike: 0, stealth: 0, execute: 0 },
    };
}

/**
 * Increment a stat and fire the onStatUpdate hook
 * @param {string} statName - Name of the stat to increment
 * @param {number} delta - Amount to add (default 1)
 */
async function incrementStat(statName, delta = 1) {
    if (!currentMaze?.stats) return;

    if (typeof currentMaze.stats[statName] === 'number') {
        currentMaze.stats[statName] += delta;
        updateStatsDisplay();
        await fireHook('onStatUpdate', { statName, value: currentMaze.stats[statName] });
    }
}

/**
 * Get current session stats
 * @returns {Object} Current session stats
 */
function getSessionStats() {
    if (!currentMaze?.stats) return null;
    return {
        ...currentMaze.stats,
        elapsedTime: getElapsedTime(),
        explorationPercent: getExplorationPercent(),
    };
}

/**
 * Get elapsed time as formatted string
 * @returns {string} Formatted time (M:SS or H:MM:SS)
 */
function getElapsedTime() {
    if (!currentMaze?.stats?.startTime) return '0:00';
    const elapsed = Math.floor((Date.now() - currentMaze.stats.startTime) / 1000);
    const hours = Math.floor(elapsed / 3600);
    const mins = Math.floor((elapsed % 3600) / 60);
    const secs = elapsed % 60;
    if (hours > 0) {
        return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Get exploration percentage
 * @returns {number} Exploration percentage (0-100)
 */
function getExplorationPercent() {
    if (!currentMaze?.visited || !currentMaze?.size) return 0;
    const totalFloors = currentMaze.totalFloors || 1;
    const totalCells = currentMaze.size * currentMaze.size * totalFloors;
    return Math.floor((currentMaze.visited.size / totalCells) * 100);
}

/**
 * Update the stats display in the maze modal
 */
function updateStatsDisplay() {
    const movesEl = document.getElementById('maze_stat_moves');
    const timeEl = document.getElementById('maze_stat_time');
    const exploreEl = document.getElementById('maze_stat_explore');

    if (movesEl) movesEl.textContent = currentMaze?.stats?.moves || 0;
    if (timeEl) timeEl.textContent = getElapsedTime();
    if (exploreEl) exploreEl.textContent = `${getExplorationPercent()}%`;

    // v1.4.0: Update zone display
    updateZoneDisplay();
}

/**
 * v1.4.0: Update the zone progress display in the maze modal
 * v1.7.0: Zone display is now hidden - progression is handled via Quest Profiles
 */
function updateZoneDisplay() {
    const zoneDisplayEl = document.getElementById('maze_zone_display');
    if (!zoneDisplayEl) return;

    // v1.7.0: Always hide zone display - progression is now quest-based
    zoneDisplayEl.style.display = 'none';
}

/**
 * Helper to update a stats object with game results
 * @param {Object} statsObj - The stats object to update
 * @param {string} profileName - The profile name
 * @param {string} result - 'win' or 'lose'
 * @param {number} elapsed - Elapsed time in ms
 * @param {number} moves - Number of moves
 */
function updateStatsObject(statsObj, profileName, result, elapsed, moves) {
    if (!statsObj.profileStats) {
        statsObj.profileStats = {};
    }

    // Update profile-specific stats
    const profileStats = statsObj.profileStats[profileName] || {
        totalGames: 0,
        wins: 0,
        losses: 0,
        bestTime: null,
        totalMoves: 0,
    };

    profileStats.totalGames++;
    if (result === 'win') {
        profileStats.wins++;
        if (profileStats.bestTime === null || elapsed < profileStats.bestTime) {
            profileStats.bestTime = elapsed;
        }
    } else {
        profileStats.losses++;
    }
    profileStats.totalMoves += moves;
    statsObj.profileStats[profileName] = profileStats;

    // Update aggregate stats
    statsObj.totalGames = (statsObj.totalGames || 0) + 1;
    if (result === 'win') {
        statsObj.wins = (statsObj.wins || 0) + 1;
        if (statsObj.bestTime === null || elapsed < statsObj.bestTime) {
            statsObj.bestTime = elapsed;
        }
    } else {
        statsObj.losses = (statsObj.losses || 0) + 1;
    }
    statsObj.totalMoves = (statsObj.totalMoves || 0) + moves;
}

/**
 * Migrate old stats format to new global/persona structure
 */
function migrateStatsToNewFormat() {
    if (!extensionSettings.mazeStats) return;

    // Check if already migrated (has global property)
    if (extensionSettings.mazeStats.global) return;

    // Old format: { profileStats: { ... } }
    // New format: { global: { profileStats: { ... }, ... }, personas: { ... } }
    const oldProfileStats = extensionSettings.mazeStats.profileStats || {};

    extensionSettings.mazeStats = {
        global: {
            totalGames: 0,
            wins: 0,
            losses: 0,
            bestTime: null,
            totalMoves: 0,
            profileStats: { ...oldProfileStats },
        },
        personas: {},
    };

    // Calculate aggregate totals from migrated profile stats
    for (const profileName in oldProfileStats) {
        const ps = oldProfileStats[profileName];
        extensionSettings.mazeStats.global.totalGames += ps.totalGames || 0;
        extensionSettings.mazeStats.global.wins += ps.wins || 0;
        extensionSettings.mazeStats.global.losses += ps.losses || 0;
        extensionSettings.mazeStats.global.totalMoves += ps.totalMoves || 0;
        if (ps.bestTime !== null) {
            if (extensionSettings.mazeStats.global.bestTime === null ||
                ps.bestTime < extensionSettings.mazeStats.global.bestTime) {
                extensionSettings.mazeStats.global.bestTime = ps.bestTime;
            }
        }
    }

    console.log('[MazeMaster] Migrated stats to new global/persona format');
    saveSettingsDebounced();
}

/**
 * Save persistent stats after game end
 * @param {string} result - 'win' or 'lose'
 */
function savePersistentStats(result) {
    if (!currentMaze?.profileName || !currentMaze?.stats) return;

    const profileName = currentMaze.profileName;
    const personaName = getCurrentPersonaName();
    const elapsed = Date.now() - currentMaze.stats.startTime;
    const moves = currentMaze.stats.moves;

    // Initialize mazeStats structure if needed
    if (!extensionSettings.mazeStats) {
        extensionSettings.mazeStats = {
            global: {
                totalGames: 0,
                wins: 0,
                losses: 0,
                bestTime: null,
                totalMoves: 0,
                profileStats: {},
            },
            personas: {},
        };
    }

    // Migrate old format if needed
    if (!extensionSettings.mazeStats.global) {
        migrateStatsToNewFormat();
    }

    // Update global stats
    updateStatsObject(extensionSettings.mazeStats.global, profileName, result, elapsed, moves);

    // Initialize persona stats if needed
    if (!extensionSettings.mazeStats.personas[personaName]) {
        extensionSettings.mazeStats.personas[personaName] = {
            totalGames: 0,
            wins: 0,
            losses: 0,
            bestTime: null,
            totalMoves: 0,
            profileStats: {},
        };
    }

    // Update persona-specific stats
    updateStatsObject(extensionSettings.mazeStats.personas[personaName], profileName, result, elapsed, moves);

    saveSettingsDebounced();
}

// Stats display update interval
let statsUpdateInterval = null;

function startStatsTimer() {
    if (statsUpdateInterval) clearInterval(statsUpdateInterval);
    statsUpdateInterval = setInterval(() => {
        if (currentMaze?.isOpen && !currentMaze?.isVictory) {
            updateStatsDisplay();
        } else {
            clearInterval(statsUpdateInterval);
            statsUpdateInterval = null;
        }
    }, 1000);
}

function stopStatsTimer() {
    if (statsUpdateInterval) {
        clearInterval(statsUpdateInterval);
        statsUpdateInterval = null;
    }
}

// =============================================================================
// THEME HELPER FUNCTIONS
// =============================================================================

/**
 * Get themed text for an element type
 * @param {string} elementType - Type of element (wall, floor, chest, exit, portal, trap, etc.)
 * @param {Object} profile - The maze profile
 * @returns {string} Themed text or original elementType
 */
function getThemedText(elementType, profile) {
    const themeName = profile?.theme || 'fantasy';
    const theme = SCENARIO_THEMES[themeName] || SCENARIO_THEMES.fantasy;
    return theme?.tileMappings?.[elementType] || elementType;
}

/**
 * Get themed item name
 * @param {string} itemId - The item ID (key, strike, stealth, etc.)
 * @param {Object} profile - The maze profile
 * @returns {string} Themed item name or original itemId
 */
function getThemedItemName(itemId, profile) {
    const themeName = profile?.theme || 'fantasy';
    const theme = SCENARIO_THEMES[themeName] || SCENARIO_THEMES.fantasy;
    return theme?.itemAliases?.[itemId] || itemId;
}

/**
 * Get themed flavor message
 * @param {string} messageType - Type of message (chestFind, portalUse, trapTrigger, etc.)
 * @param {Object} profile - The maze profile
 * @returns {string} Themed message or empty string
 */
function getThemedFlavorMessage(messageType, profile) {
    const themeName = profile?.theme || 'fantasy';
    const theme = SCENARIO_THEMES[themeName] || SCENARIO_THEMES.fantasy;
    return theme?.flavorMessages?.[messageType] || '';
}

/**
 * Get theme colors
 * @param {Object} profile - The maze profile
 * @returns {Object} Theme colors object with primary, secondary, accent
 */
function getThemeColors(profile) {
    const themeName = profile?.theme || 'fantasy';
    const theme = SCENARIO_THEMES[themeName] || SCENARIO_THEMES.fantasy;
    return theme?.colors || { primary: '#2ecc71', secondary: '#27ae60', accent: '#f1c40f' };
}

/**
 * Apply theme colors to maze UI as CSS variables
 * @param {Object} profile - The maze profile
 */
function applyThemeColors(profile) {
    const colors = getThemeColors(profile);
    const container = document.querySelector('.mazemaster-maze-container');
    if (container) {
        container.style.setProperty('--theme-primary', colors.primary);
        container.style.setProperty('--theme-secondary', colors.secondary);
        container.style.setProperty('--theme-accent', colors.accent);
    }
}

// =============================================================================
// D-PAD FUNCTIONALITY
// =============================================================================

/**
 * Initialize D-Pad drag functionality for floating mode
 */
function initDpadDrag() {
    const dpad = document.getElementById('maze_dpad');
    if (!dpad || !dpad.classList.contains('floating')) return;

    const handle = dpad.querySelector('.dpad-drag-handle');
    if (!handle) return;

    let isDragging = false;
    let offsetX = 0;
    let offsetY = 0;

    const startDrag = (clientX, clientY) => {
        isDragging = true;
        offsetX = clientX - dpad.offsetLeft;
        offsetY = clientY - dpad.offsetTop;
        dpad.style.cursor = 'grabbing';
    };

    const moveDrag = (clientX, clientY) => {
        if (!isDragging) return;
        const x = Math.max(0, Math.min(window.innerWidth - dpad.offsetWidth, clientX - offsetX));
        const y = Math.max(0, Math.min(window.innerHeight - dpad.offsetHeight, clientY - offsetY));
        dpad.style.left = `${x}px`;
        dpad.style.top = `${y}px`;
        dpad.style.right = 'auto';
        dpad.style.bottom = 'auto';
    };

    const endDrag = () => {
        if (isDragging) {
            isDragging = false;
            dpad.style.cursor = '';
            // Save position to settings
            if (!extensionSettings.dpadConfig) {
                extensionSettings.dpadConfig = { enabled: true, floating: true, position: {} };
            }
            extensionSettings.dpadConfig.position = {
                x: dpad.offsetLeft,
                y: dpad.offsetTop
            };
            saveSettingsDebounced();
        }
    };

    // Mouse events
    handle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        startDrag(e.clientX, e.clientY);
    });

    document.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
    document.addEventListener('mouseup', endDrag);

    // Touch events
    handle.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        startDrag(touch.clientX, touch.clientY);
    });

    document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        const touch = e.touches[0];
        moveDrag(touch.clientX, touch.clientY);
    });

    document.addEventListener('touchend', endDrag);
}

/**
 * Initialize pinch-zoom and pan/drag for the maze map area
 */
function initMapPanZoom() {
    const container = document.getElementById('maze_grid_container');
    const mazeArea = document.querySelector('.mazemaster-maze-area');
    if (!container || !mazeArea) return;

    // Calculate initial zoom based on grid size (larger grids need more zoom)
    const gridSize = currentMaze?.size || 10;
    let tileWidth;
    if (gridSize <= 7) tileWidth = 76;
    else if (gridSize <= 10) tileWidth = 64;
    else if (gridSize <= 15) tileWidth = 52;
    else if (gridSize <= 20) tileWidth = 44;
    else tileWidth = 36;

    // Scale up larger mazes to match visual size of reference (64px tiles)
    // v2.0.3: Increased base zoom from 1.5 to 2.0 for better visibility
    const referenceTileSize = 64;
    const baseScale = 2.0;
    const initialScale = baseScale * (referenceTileSize / tileWidth);

    let scale = initialScale;
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let startX = 0;
    let startY = 0;
    let lastTouchDist = 0;
    let lastScale = initialScale;

    const minScale = 0.5;
    const maxScale = 4; // Allow more zoom for large mazes

    // Apply transform without transition (for dragging)
    const applyTransform = (smooth = false) => {
        if (smooth) {
            container.style.transition = 'transform 0.3s ease-out';
        } else {
            container.style.transition = 'none';
        }
        container.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        container.style.transformOrigin = '0 0'; // Top-left origin for simpler math
    };

    // Calculate player screen position in isometric view (must match IsometricRenderer exactly)
    const getPlayerIsometricPosition = (canvas) => {
        if (!currentMaze || currentMaze.playerX === undefined) return null;

        // Get tile size based on grid size (must match IsometricRenderer.getCellSize)
        const gridSize = currentMaze.size || 10;
        let tileWidth;
        if (gridSize <= 7) tileWidth = 76;
        else if (gridSize <= 10) tileWidth = 64;
        else if (gridSize <= 15) tileWidth = 52;
        else if (gridSize <= 20) tileWidth = 44;
        else tileWidth = 36;

        const tileHeight = tileWidth / 2;
        const spriteHeight = tileWidth * 2;

        // Player maze coordinates
        const px = currentMaze.playerX;
        const py = currentMaze.playerY;

        // gridToIso formula (exact match to renderer)
        const isoX = (px - py) * (tileWidth / 2);
        const isoY = (px + py) * (tileHeight / 2);

        // Add canvas offsets (exact match to renderer)
        const offsetX = canvas.width / 2;
        const offsetY = spriteHeight;

        const drawX = isoX + offsetX;
        const drawY = isoY + offsetY;

        return { x: drawX, y: drawY };
    };

    // Center on player function - exposed globally for reuse
    const centerOnPlayer = (smooth = false) => {
        const playerEl = container.querySelector('.player-marker, .maze-cell.current');
        const canvas = container.querySelector('canvas');
        const areaRect = mazeArea.getBoundingClientRect();

        if (playerEl) {
            // CSS Grid renderer - find player cell
            const cellRect = playerEl.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            // Calculate offset to center the player
            const playerCenterX = cellRect.left + cellRect.width / 2 - containerRect.left;
            const playerCenterY = cellRect.top + cellRect.height / 2 - containerRect.top;
            const areaCenterX = areaRect.width / 2;
            const areaCenterY = areaRect.height / 2;

            panX = (areaCenterX - playerCenterX * scale);
            panY = (areaCenterY - playerCenterY * scale);
            applyTransform(smooth);
        } else if (canvas) {
            // Isometric renderer - calculate player position on canvas
            const playerPos = getPlayerIsometricPosition(canvas);

            if (playerPos) {
                // Center viewport on player's isometric position
                const areaCenterX = areaRect.width / 2;
                const areaCenterY = areaRect.height / 2;

                // Calculate pan to center player in view
                panX = areaCenterX - (playerPos.x * scale);
                panY = areaCenterY - (playerPos.y * scale);
                applyTransform(smooth);
            } else {
                // Fallback: center canvas generally
                const canvasHeight = canvas.height;
                const areaHeight = areaRect.height;
                panY = (areaHeight - canvasHeight * scale) / 2 + (canvasHeight * scale * 0.45);
                applyTransform(smooth);
            }
        }
    };

    // Store centerOnPlayer globally so it can be called after moves
    window.mazeCenterOnPlayer = (smooth = true) => centerOnPlayer(smooth);

    // Initial centering after canvas renders (multiple attempts for larger mazes)
    setTimeout(() => centerOnPlayer(false), 50);
    setTimeout(() => centerOnPlayer(false), 150);
    setTimeout(() => centerOnPlayer(false), 300); // Fallback for large mazes

    // Mouse wheel zoom (centered on player)
    mazeArea.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        scale = Math.max(minScale, Math.min(maxScale, scale * delta));
        centerOnPlayer(false); // Re-center on player when zooming
    }, { passive: false });

    // Mouse drag pan
    mazeArea.addEventListener('mousedown', (e) => {
        if (e.target.closest('.maze-cell, canvas')) {
            isPanning = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;
            mazeArea.style.cursor = 'grabbing';
            container.style.transition = 'none'; // Disable transition while dragging
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (!isPanning) return;
        panX = e.clientX - startX;
        panY = e.clientY - startY;
        applyTransform(false);
    });

    document.addEventListener('mouseup', () => {
        isPanning = false;
        mazeArea.style.cursor = '';
    });

    // Touch pinch zoom
    const getTouchDist = (touches) => {
        if (touches.length < 2) return 0;
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    };

    mazeArea.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            // Pinch start
            lastTouchDist = getTouchDist(e.touches);
            lastScale = scale;
        } else if (e.touches.length === 1) {
            // Pan start
            isPanning = true;
            startX = e.touches[0].clientX - panX;
            startY = e.touches[0].clientY - panY;
            container.style.transition = 'none'; // Disable transition while dragging
        }
    }, { passive: true });

    mazeArea.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            // Pinch zoom - stay centered on player
            e.preventDefault();
            const dist = getTouchDist(e.touches);
            if (lastTouchDist > 0) {
                const delta = dist / lastTouchDist;
                scale = Math.max(minScale, Math.min(maxScale, lastScale * delta));
                centerOnPlayer(false); // Re-center on player when zooming
            }
        } else if (e.touches.length === 1 && isPanning) {
            // Pan
            panX = e.touches[0].clientX - startX;
            panY = e.touches[0].clientY - startY;
            applyTransform(false);
        }
    }, { passive: false });

    mazeArea.addEventListener('touchend', () => {
        isPanning = false;
        lastTouchDist = 0;
        lastScale = scale;
    });

    // Double-tap to reset zoom and re-center on player
    let lastTap = 0;
    mazeArea.addEventListener('touchend', (e) => {
        const now = Date.now();
        if (now - lastTap < 300 && e.changedTouches.length === 1) {
            // Double tap - reset zoom to initial and center on player
            scale = initialScale;
            lastScale = initialScale;
            centerOnPlayer(true); // Smooth animation on double-tap reset
        }
        lastTap = now;
    });

    // Add cursor hint
    mazeArea.style.cursor = 'grab';
}

/**
 * Update D-Pad floor buttons visibility based on current position
 */
function updateDpadFloorButtons() {
    const upBtn = document.querySelector('.dpad-floor-up');
    const downBtn = document.querySelector('.dpad-floor-down');

    if (!upBtn || !downBtn || !currentMaze) {
        return;
    }

    // Check if player is on a staircase
    const cell = currentMaze.grid?.[currentMaze.playerY]?.[currentMaze.playerX];
    const staircase = cell?.staircase;

    if (staircase?.direction === 'up') {
        upBtn.classList.remove('hidden');
    } else {
        upBtn.classList.add('hidden');
    }

    if (staircase?.direction === 'down') {
        downBtn.classList.remove('hidden');
    } else {
        downBtn.classList.add('hidden');
    }
}

/**
 * Try to change floors via staircase
 * @param {string} direction - 'up' or 'down'
 */
async function tryFloorChange(direction) {
    if (!currentMaze?.isOpen || currentMaze.isPaused) return false;
    if (currentMaze.totalFloors <= 1) return false;
    // v1.4.9: Block floor change while LLM is generating room description
    if (isLLMGenerating) return false;

    const cell = currentMaze.grid?.[currentMaze.playerY]?.[currentMaze.playerX];
    if (!cell?.staircase) {
        console.log('[MazeMaster] Not on a staircase');
        return false;
    }

    if (cell.staircase.direction !== direction) {
        console.log('[MazeMaster] Staircase direction mismatch');
        return false;
    }

    // Check if floor key is required
    if (cell.staircase.requireKey && direction === 'up') {
        if (!hasFloorKey()) {
            currentMaze.currentMinion = {
                name: 'Locked Staircase',
                imagePath: '',
                message: 'This staircase is locked! You need a Floor Key to ascend.',
            };
            updateMazeHero();
            return false;
        }
        // Consume the floor key
        await consumeFloorKey();
    }

    const targetFloor = cell.staircase.targetFloor;
    const targetX = cell.staircase.targetX;
    const targetY = cell.staircase.targetY;

    // Validate target floor
    if (targetFloor < 0 || targetFloor >= currentMaze.totalFloors) {
        console.error('[MazeMaster] Invalid target floor');
        return false;
    }

    // Update floor and position
    currentMaze.currentFloor = targetFloor;
    currentMaze.grid = currentMaze.floors[targetFloor];
    currentMaze.playerX = targetX;
    currentMaze.playerY = targetY;

    // Mark new position as visited (with floor prefix for proper tracking)
    currentMaze.visited.add(`${targetFloor}:${targetX},${targetY}`);

    // Log floor change to session notes
    addSessionNote(`${direction === 'up' ? 'Ascended' : 'Descended'} to Floor ${targetFloor + 1}/${currentMaze.totalFloors}`, 'Floor');

    // Show transition message
    const theme = SCENARIO_THEMES[currentMaze.profile?.theme] || SCENARIO_THEMES.fantasy;
    const flavorMsg = direction === 'up'
        ? theme.flavorMessages.stairUp
        : theme.flavorMessages.stairDown;

    currentMaze.currentMinion = {
        name: direction === 'up' ? 'Ascending' : 'Descending',
        imagePath: '',
        message: flavorMsg || `You ${direction === 'up' ? 'ascend' : 'descend'} to floor ${targetFloor + 1}...`,
    };
    updateMazeHero();

    // Fire hook
    await fireHook('onMove', { x: targetX, y: targetY, direction: direction === 'up' ? 'floor-up' : 'floor-down', floor: targetFloor });

    // Re-render grid
    renderMazeGrid();
    updatePlayerPosition(false);
    updateStatsDisplay();
    updateDpadFloorButtons();
    updateFloorIndicator();

    // Re-render minimap for new floor
    renderMinimap();

    // Center camera on player (smooth pan)
    if (typeof window.mazeCenterOnPlayer === 'function') {
        window.mazeCenterOnPlayer(true);
    }

    // v1.4.9: Enhance new room description after floor change
    await enhanceRoomOnEntry(targetX, targetY);

    console.log(`[MazeMaster] Changed to floor ${targetFloor + 1}`);
    return true;
}

/**
 * Update floor indicator display
 */
function updateFloorIndicator() {
    const currentEl = document.getElementById('maze_floor_current');
    const totalEl = document.getElementById('maze_floor_total');
    const indicator = document.querySelector('.maze-floor-indicator');

    if (currentMaze.totalFloors <= 1) {
        if (indicator) indicator.style.display = 'none';
        return;
    }

    if (indicator) indicator.style.display = '';
    if (currentEl) currentEl.textContent = currentMaze.currentFloor + 1;
    if (totalEl) totalEl.textContent = currentMaze.totalFloors;
}

// =============================================================================
// v1.2.0 NEW ITEM USAGE FUNCTIONS
// =============================================================================

/**
 * Use a Map Fragment to reveal a 3x3 area around the player
 */
async function useMapFragment() {
    if (!currentMaze || currentMaze.isPaused) return false;
    if (!currentMaze.inventory.mapFragment || currentMaze.inventory.mapFragment <= 0) {
        console.log('[MazeMaster] No Map Fragments available');
        return false;
    }

    const { playerX, playerY, grid, size } = currentMaze;

    // Reveal 3x3 area around player
    let revealed = 0;
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            const x = playerX + dx;
            const y = playerY + dy;
            if (x >= 0 && x < size && y >= 0 && y < size) {
                const key = `${x},${y}`;
                if (!currentMaze.visited.has(key)) {
                    currentMaze.visited.add(key);
                    grid[y][x].visited = true;
                    revealed++;
                }
            }
        }
    }

    await removeFromInventory('mapFragment', 1);
    renderMazeGrid();

    // Show message
    currentMaze.currentMinion = {
        name: 'Map Fragment',
        imagePath: '',
        message: revealed > 0
            ? `The ancient map reveals ${revealed} hidden area${revealed > 1 ? 's' : ''}!`
            : 'The map shows only what you already knew.',
    };
    updateMazeHero();

    await fireHook('onItemRemove', { item: 'mapFragment', count: 1, total: currentMaze.inventory.mapFragment });
    return true;
}

/**
 * Use a Portal Stone to teleport to a revealed portal
 * Shows selection UI if multiple portals are available
 */
async function usePortalStone() {
    if (!currentMaze || currentMaze.isPaused) return false;
    if (!currentMaze.inventory.portalStone || currentMaze.inventory.portalStone <= 0) {
        console.log('[MazeMaster] No Portal Stones available');
        return false;
    }

    // Find all revealed portals (visited cells with portal)
    const revealedPortals = [];
    for (const key of currentMaze.visited) {
        const [x, y] = key.split(',').map(Number);
        const cell = currentMaze.grid[y]?.[x];
        if (cell?.portal && !(x === currentMaze.playerX && y === currentMaze.playerY)) {
            revealedPortals.push({ x, y, portal: cell.portal });
        }
    }

    if (revealedPortals.length === 0) {
        currentMaze.currentMinion = {
            name: 'Portal Stone',
            imagePath: '',
            message: 'No revealed portals to teleport to. Explore more to find portals first!',
        };
        updateMazeHero();
        return false;
    }

    // If only one portal, teleport directly
    if (revealedPortals.length === 1) {
        const target = revealedPortals[0];
        await executePortalStoneTeleport(target.x, target.y);
        return true;
    }

    // Multiple portals - show selection (simple first-found for now, TODO: selection UI)
    const target = revealedPortals[0];
    await executePortalStoneTeleport(target.x, target.y);
    return true;
}

/**
 * Execute portal stone teleportation
 */
async function executePortalStoneTeleport(targetX, targetY) {
    await removeFromInventory('portalStone', 1);

    // Teleport player
    currentMaze.playerX = targetX;
    currentMaze.playerY = targetY;
    currentMaze.visited.add(`${currentMaze.currentFloor}:${targetX},${targetY}`);

    updatePlayerPosition(true);
    renderMazeGrid();
    updateDpadFloorButtons();

    currentMaze.currentMinion = {
        name: 'Portal Stone',
        imagePath: '',
        message: 'The portal stone crumbles as you are whisked through space!',
    };
    updateMazeHero();

    await fireHook('onTeleport', { x: targetX, y: targetY, source: 'portalStone' });
}

/**
 * Activate Void Walk mode - next move can phase through a wall
 */
function activateVoidWalk() {
    if (!currentMaze || currentMaze.isPaused) return false;
    if (!currentMaze.inventory.voidWalk || currentMaze.inventory.voidWalk <= 0) {
        console.log('[MazeMaster] No Void Walk available');
        return false;
    }

    if (currentMaze.voidWalkActive) {
        console.log('[MazeMaster] Void Walk already active');
        return false;
    }

    currentMaze.voidWalkActive = true;

    // Visual indicator
    const dpad = document.getElementById('maze_dpad');
    if (dpad) dpad.classList.add('void-walk-active');

    currentMaze.currentMinion = {
        name: 'Void Walk',
        imagePath: '',
        message: 'You become ethereal... Your next move can phase through walls!',
    };
    updateMazeHero();

    return true;
}

/**
 * Consume void walk on successful wall phase
 */
async function consumeVoidWalk() {
    if (currentMaze?.voidWalkActive) {
        currentMaze.voidWalkActive = false;
        await removeFromInventory('voidWalk', 1);

        const dpad = document.getElementById('maze_dpad');
        if (dpad) dpad.classList.remove('void-walk-active');
    }
}

/**
 * Cancel void walk mode
 */
function cancelVoidWalk() {
    if (currentMaze?.voidWalkActive) {
        currentMaze.voidWalkActive = false;
        const dpad = document.getElementById('maze_dpad');
        if (dpad) dpad.classList.remove('void-walk-active');
    }
}

/**
 * Check if Minion Bane should auto-defeat a minion
 * Returns true if bane was consumed and minion defeated
 */
async function checkMinionBane() {
    if (!currentMaze?.inventory.minionBane || currentMaze.inventory.minionBane <= 0) {
        return false;
    }

    await removeFromInventory('minionBane', 1);

    currentMaze.currentMinion = {
        name: 'Minion Bane',
        imagePath: '',
        message: 'Your Minion Bane flares with power, instantly vanquishing the foe!',
    };
    updateMazeHero();

    return true;
}

/**
 * Apply Time Shard effect to battlebar (50% slower)
 * Returns the multiplier to apply
 */
function getTimeShardMultiplier() {
    if (!currentMaze?.inventory.timeShard || currentMaze.inventory.timeShard <= 0) {
        return 1.0;
    }
    return 0.5; // 50% speed = 2x more time to react
}

/**
 * Consume time shard when battlebar starts
 */
async function consumeTimeShard() {
    if (currentMaze?.inventory.timeShard > 0) {
        await removeFromInventory('timeShard', 1);
        currentMaze.currentMinion = {
            name: 'Time Shard',
            imagePath: '',
            message: 'Time slows around you... The battlebar moves at half speed!',
        };
        updateMazeHero();
    }
}

/**
 * Check if Floor Key is required and available
 */
function hasFloorKey() {
    return currentMaze?.inventory.floorKey > 0;
}

/**
 * Consume a floor key when using stairs
 */
async function consumeFloorKey() {
    if (currentMaze?.inventory.floorKey > 0) {
        await removeFromInventory('floorKey', 1);
    }
}

/**
 * Check if exploration is complete and fire hook
 */
async function checkExplorationComplete() {
    if (!currentMaze) return;

    const percent = getExplorationPercent();

    // v1.5.0: Grant XP for exploration milestones (every 10%)
    if (currentMaze.character) {
        const currentMilestone = Math.floor(percent / 10) * 10;
        const lastMilestone = currentMaze.character.lastExplorationMilestone || 0;
        if (currentMilestone > lastMilestone) {
            const milestonesEarned = (currentMilestone - lastMilestone) / 10;
            const xpAmount = milestonesEarned * getXpReward('exploration10');
            await grantXp(xpAmount, 'exploration');
            currentMaze.character.lastExplorationMilestone = currentMilestone;
            addToMessageLog(`Exploration milestone! +${xpAmount} XP`, 'info');
        }
    }

    // v1.5.0: Update explore quest progress (pass absolute percentage)
    await updateQuestProgress('explore', null, percent);

    // Update explore objectives with current percentage
    if (currentMaze.profile?.objectives) {
        for (const obj of currentMaze.profile.objectives) {
            if (obj.type === 'explore') {
                const objProgress = currentMaze.objectiveProgress[obj.id];
                if (objProgress && !objProgress.completed) {
                    // Set current to actual exploration percent
                    objProgress.current = percent;

                    // Check if target reached
                    if (percent >= (obj.count || 100)) {
                        objProgress.completed = true;
                        await fireHook('onObjectiveComplete', { objectiveId: obj.id });
                        if (obj.reward && obj.reward.trim()) {
                            await executeWithTimeout(obj.reward);
                        }
                    }
                }
            }
        }
        updateObjectivesDisplay();
        checkAllObjectivesComplete();
    }

    if (!currentMaze.explorationComplete && percent >= 100) {
        currentMaze.explorationComplete = true;
        await fireHook('onExploreComplete', { percentage: 100 });
    }
}

/**
 * Update player overlay position for smooth animation
 * @param {boolean} animate - Whether to animate the movement
 */
function updatePlayerPosition(animate = true) {
    if (!currentMaze) return;

    const renderer = RendererRegistry.getRenderer();
    const cellSize = getCellSize(currentMaze.size);
    renderer.updatePlayerPosition(currentMaze.playerX, currentMaze.playerY, animate, cellSize);

    // v1.2.1: Update room info when player moves
    updateRoomInfoBox();
}

/**
 * Place portals on the maze grid based on profile configuration
 */
function placePortals(grid, profile, size, validCells) {
    if (!profile.portals || profile.portals.length === 0) return;

    const placedPortals = [];

    for (const portalConfig of profile.portals) {
        // Find start and end positions
        let startX = portalConfig.startX;
        let startY = portalConfig.startY;
        let endX = portalConfig.endX;
        let endY = portalConfig.endY;

        // If positions are null/undefined, pick random empty cells
        if (startX == null || startY == null) {
            const availableStart = validCells.find(c =>
                !grid[c.y][c.x].chest &&
                !grid[c.y][c.x].minion &&
                !grid[c.y][c.x].trap &&
                !grid[c.y][c.x].portal &&
                !(c.x === 0 && c.y === 0) &&
                !(c.x === size - 1 && c.y === size - 1)
            );
            if (availableStart) {
                startX = availableStart.x;
                startY = availableStart.y;
                // Remove from valid cells
                const idx = validCells.indexOf(availableStart);
                if (idx > -1) validCells.splice(idx, 1);
            } else continue;
        }

        if (endX == null || endY == null) {
            const availableEnd = validCells.find(c =>
                !grid[c.y][c.x].chest &&
                !grid[c.y][c.x].minion &&
                !grid[c.y][c.x].trap &&
                !grid[c.y][c.x].portal &&
                !(c.x === startX && c.y === startY) &&
                !(c.x === 0 && c.y === 0) &&
                !(c.x === size - 1 && c.y === size - 1)
            );
            if (availableEnd) {
                endX = availableEnd.x;
                endY = availableEnd.y;
                const idx = validCells.indexOf(availableEnd);
                if (idx > -1) validCells.splice(idx, 1);
            } else continue;
        }

        const portalId = portalConfig.id || `portal_${placedPortals.length + 1}`;
        const color = portalConfig.color || '#9b59b6';
        const bidirectional = portalConfig.bidirectional !== false;

        // Place start portal
        grid[startY][startX].portal = {
            id: portalId,
            target: { x: endX, y: endY },
            isStart: true,
            color: color,
            bidirectional: bidirectional,
        };

        // Place end portal (bidirectional or one-way destination)
        grid[endY][endX].portal = {
            id: portalId,
            target: { x: startX, y: startY },
            isStart: false,
            color: color,
            bidirectional: bidirectional,
        };

        placedPortals.push({
            id: portalId,
            startX, startY,
            endX, endY,
            color,
            bidirectional,
        });
    }

    if (placedPortals.length > 0) {
        console.log(`[MazeMaster] Placed ${placedPortals.length} portal pair(s)`);
    }

    return placedPortals;
}

/**
 * Handle teleportation when player steps on a portal
 */
async function handleTeleport(fromX, fromY, portal) {
    if (!portal) return false;

    // Check if this portal can teleport (bidirectional portals always work, one-way only from start)
    if (!portal.bidirectional && !portal.isStart) {
        return false; // One-way portal exit, no teleportation
    }

    const target = portal.target;
    if (!target || target.x == null || target.y == null) return false;

    // Fire the onTeleport hook
    await fireHook('onTeleport', {
        portalId: portal.id,
        fromX: fromX,
        fromY: fromY,
        toX: target.x,
        toY: target.y,
    });

    // Update player position
    currentMaze.playerX = target.x;
    currentMaze.playerY = target.y;

    // Mark destination as visited
    currentMaze.visited.add(`${currentMaze.currentFloor}:${target.x},${target.y}`);

    // Update position instantly (no animation for teleport)
    updatePlayerPosition(false);
    updateDpadFloorButtons();

    // Increment teleport stat
    await incrementStat('teleportsUsed', 1);

    // Flash effect on both cells
    const startCell = document.querySelector(`.maze-cell[data-x="${fromX}"][data-y="${fromY}"]`);
    const endCell = document.querySelector(`.maze-cell[data-x="${target.x}"][data-y="${target.y}"]`);

    if (startCell) {
        startCell.classList.add('portal-flash');
        setTimeout(() => startCell.classList.remove('portal-flash'), 300);
    }
    if (endCell) {
        endCell.classList.add('portal-flash');
        setTimeout(() => endCell.classList.remove('portal-flash'), 300);
    }

    console.log(`[MazeMaster] Teleported from (${fromX},${fromY}) to (${target.x},${target.y})`);
    return true;
}

/**
 * Initialize moving minions list from placed minions on the grid
 */
function initMovingMinions(grid, size) {
    const movingMinions = [];

    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const cell = grid[y][x];
            if (cell.minion && !cell.minion.triggered) {
                const minionData = getMinion(cell.minion.minionId);
                const movement = minionData?.movement || { type: 'stationary' };

                if (movement.type !== 'stationary') {
                    movingMinions.push({
                        minionId: cell.minion.minionId,
                        x: x,
                        y: y,
                        originX: x,
                        originY: y,
                        triggered: false,
                        movement: { ...movement },
                    });
                }
            }
        }
    }

    console.log(`[MazeMaster] Initialized ${movingMinions.length} moving minion(s)`);
    return movingMinions;
}

/**
 * Process minion movement after player moves
 */
async function processMinionMovement() {
    if (!currentMaze || !currentMaze.movingMinions || currentMaze.movingMinions.length === 0) return;

    const { grid, size, playerX, playerY, moveCount } = currentMaze;
    const difficulty = getDifficultySettings(currentMaze.profile);
    const useEnhancedAI = currentMaze.profile?.enhancedMinionAI !== false; // Default on

    // v1.5.0: First pass - update all minion alert states
    for (const minion of currentMaze.movingMinions) {
        if (minion.triggered) continue;

        // Check if this minion has enhanced AI enabled
        const minionEnhancedAI = minion.movement?.enhancedAI !== false && useEnhancedAI;
        if (!minionEnhancedAI) continue;

        // Use minion-specific detection range if set
        const customDetectionRange = minion.movement?.detectionRange;
        const customChaseDuration = minion.movement?.chaseDuration;

        const prevState = minion.alertState || 'idle';
        updateMinionAlertState(minion, playerX, playerY, grid, customDetectionRange, customChaseDuration);

        // If minion just became alerted, alert nearby minions (if pack alerting enabled)
        const alertPack = minion.movement?.alertPack !== false;
        if (alertPack && minion.alertState === 'alerted' && prevState !== 'alerted' && prevState !== 'chasing') {
            alertNearbyMinions(minion, currentMaze.movingMinions, grid);

            // Fire hook for alert
            await fireHook('onMinionAlert', {
                minionId: minion.minionId,
                alertState: minion.alertState,
                x: minion.x,
                y: minion.y,
            });
        }
    }

    // Second pass - move minions
    for (const minion of currentMaze.movingMinions) {
        if (minion.triggered) continue;

        // Check speed (moves every N player moves)
        const speed = minion.movement?.speed || 1;
        if (moveCount % speed !== 0) continue;

        // v1.5.0: Check if this minion uses enhanced AI and pathfinding
        const minionEnhancedAI = minion.movement?.enhancedAI !== false && useEnhancedAI;
        const usePathfinding = minion.movement?.usePathfinding !== false;

        // v1.5.0: Use enhanced AI or legacy movement
        const newPos = (minionEnhancedAI && usePathfinding)
            ? calculateEnhancedMinionMove(minion, grid, size, playerX, playerY)
            : calculateMinionMove(minion, grid, size, playerX, playerY, difficulty);

        if (!newPos) continue;

        const fromX = minion.x;
        const fromY = minion.y;

        // v1.5.0: Animate minion movement
        await animateMinionMove(fromX, fromY, newPos.x, newPos.y, minion.alertState || 'idle');

        // Remove minion from old cell
        if (grid[fromY][fromX].minion?.minionId === minion.minionId) {
            grid[fromY][fromX].minion = null;
        }

        // Move minion to new cell
        minion.x = newPos.x;
        minion.y = newPos.y;
        grid[newPos.y][newPos.x].minion = {
            minionId: minion.minionId,
            triggered: false,
            alertState: minion.alertState, // v1.5.0: Store alert state for display
        };

        // Fire onEnemyMove hook
        await fireHook('onEnemyMove', {
            minionId: minion.minionId,
            fromX: fromX,
            fromY: fromY,
            toX: newPos.x,
            toY: newPos.y,
            alertState: minion.alertState,
        });

        // Check for collision with player
        if (newPos.x === playerX && newPos.y === playerY) {
            console.log(`[MazeMaster] Moving minion ${minion.minionId} caught the player!`);
            minion.triggered = true;
            grid[newPos.y][newPos.x].minion.triggered = true;
            triggerMinionEncounter(minion.minionId, newPos.x, newPos.y);
            return; // Stop processing after encounter
        }
    }

    // v1.5.0: Update display to show alert states
    renderMaze();
}

/**
 * v1.5.0: Animate minion movement from one cell to another
 * @param {number} fromX - Starting X position
 * @param {number} fromY - Starting Y position
 * @param {number} toX - Target X position
 * @param {number} toY - Target Y position
 * @param {string} alertState - Current alert state for styling
 */
async function animateMinionMove(fromX, fromY, toX, toY, alertState) {
    const fromCell = document.querySelector(`.maze-cell[data-x="${fromX}"][data-y="${fromY}"]`);
    const toCell = document.querySelector(`.maze-cell[data-x="${toX}"][data-y="${toY}"]`);

    if (!fromCell || !toCell) return;

    // Add moving class
    fromCell.classList.add('minion-moving');
    fromCell.classList.add(getMinionAlertClass(alertState));

    // Short delay for visual feedback
    await new Promise(resolve => setTimeout(resolve, 150));

    // Remove from old cell
    fromCell.classList.remove('has-minion', 'minion-moving', 'minion-patrol', 'minion-suspicious', 'minion-alerted', 'minion-chase');

    // Add to new cell with animation
    toCell.classList.add('has-minion', 'minion-arriving', getMinionAlertClass(alertState));

    // Remove arriving class after animation
    setTimeout(() => {
        toCell.classList.remove('minion-arriving');
    }, 200);
}

/**
 * Calculate the next move for a minion based on its movement type
 */
function calculateMinionMove(minion, grid, size, playerX, playerY, difficulty) {
    const { x, y, originX, originY, movement } = minion;
    const aggressionMult = difficulty?.minionAggressionMult || 1;

    // Get valid adjacent cells (not blocked by walls)
    const validMoves = getValidMinionMoves(x, y, grid, size);
    if (validMoves.length === 0) return null;

    switch (movement.type) {
        case 'patrol': {
            // Patrol: Random movement within radius of origin
            const radius = movement.patrolRadius || 3;
            const inRangeMoves = validMoves.filter(pos => {
                const distFromOrigin = Math.abs(pos.x - originX) + Math.abs(pos.y - originY);
                return distFromOrigin <= radius;
            });
            if (inRangeMoves.length === 0) return null;
            return inRangeMoves[Math.floor(Math.random() * inRangeMoves.length)];
        }

        case 'chase': {
            // Chase: Move toward player if within range
            const baseRange = movement.chaseRange || 5;
            const range = Math.ceil(baseRange * aggressionMult);
            const distToPlayer = Math.abs(x - playerX) + Math.abs(y - playerY);

            if (distToPlayer > range) {
                // Out of range, random movement
                return validMoves[Math.floor(Math.random() * validMoves.length)];
            }

            // Move toward player (A* would be overkill, use greedy approach)
            let bestMove = null;
            let bestDist = distToPlayer;

            for (const pos of validMoves) {
                const newDist = Math.abs(pos.x - playerX) + Math.abs(pos.y - playerY);
                if (newDist < bestDist) {
                    bestDist = newDist;
                    bestMove = pos;
                }
            }

            // 50% chance to make suboptimal move (makes AI less predictable)
            if (bestMove && Math.random() < 0.5 * (1 / aggressionMult)) {
                return validMoves[Math.floor(Math.random() * validMoves.length)];
            }

            return bestMove || validMoves[Math.floor(Math.random() * validMoves.length)];
        }

        default:
            return null;
    }
}

// =============================================================================
// v1.5.0: ADVANCED MINION AI SYSTEM
// =============================================================================

/**
 * Alert states for minions
 */
const MINION_ALERT_STATES = {
    idle: {
        name: 'Idle',
        icon: 'fa-moon',
        color: '#95a5a6',
        moveChance: 0.3,        // 30% chance to move each tick
        detectionRange: 3,       // Detect player within 3 tiles
    },
    suspicious: {
        name: 'Suspicious',
        icon: 'fa-question',
        color: '#f39c12',
        moveChance: 0.5,
        detectionRange: 4,
        duration: 3,             // Turns before returning to idle
    },
    alerted: {
        name: 'Alerted',
        icon: 'fa-exclamation',
        color: '#e74c3c',
        moveChance: 0.8,
        detectionRange: 6,
        alertRadius: 3,          // Alert other minions within 3 tiles
    },
    chasing: {
        name: 'Chasing',
        icon: 'fa-person-running',
        color: '#c0392b',
        moveChance: 1.0,         // Always moves
        detectionRange: 8,
        chaseDuration: 10,       // Turns before giving up chase
    },
};

/**
 * A* pathfinding algorithm for maze navigation
 * @param {number} startX - Starting X position
 * @param {number} startY - Starting Y position
 * @param {number} goalX - Target X position
 * @param {number} goalY - Target Y position
 * @param {Array} grid - Maze grid
 * @param {number} size - Grid size
 * @param {number} maxSteps - Maximum path length (default 50)
 * @returns {Array|null} Array of {x, y} positions or null if no path
 */
function findPath(startX, startY, goalX, goalY, grid, size, maxSteps = 50) {
    // Quick check for same position
    if (startX === goalX && startY === goalY) return [];

    // A* implementation
    const openSet = [];
    const closedSet = new Set();
    const cameFrom = new Map();
    const gScore = new Map();
    const fScore = new Map();

    const key = (x, y) => `${x},${y}`;
    const heuristic = (x1, y1, x2, y2) => Math.abs(x1 - x2) + Math.abs(y1 - y2);

    gScore.set(key(startX, startY), 0);
    fScore.set(key(startX, startY), heuristic(startX, startY, goalX, goalY));
    openSet.push({ x: startX, y: startY, f: fScore.get(key(startX, startY)) });

    while (openSet.length > 0) {
        // Get node with lowest fScore
        openSet.sort((a, b) => a.f - b.f);
        const current = openSet.shift();
        const currentKey = key(current.x, current.y);

        // Goal reached
        if (current.x === goalX && current.y === goalY) {
            // Reconstruct path
            const path = [];
            let curr = currentKey;
            while (cameFrom.has(curr)) {
                const [px, py] = curr.split(',').map(Number);
                path.unshift({ x: px, y: py });
                curr = cameFrom.get(curr);
            }
            return path;
        }

        closedSet.add(currentKey);

        // Check neighbors
        const cell = grid[current.y]?.[current.x];
        if (!cell) continue;

        const neighbors = [];
        if (!cell.walls.top && current.y > 0) neighbors.push({ x: current.x, y: current.y - 1 });
        if (!cell.walls.bottom && current.y < size - 1) neighbors.push({ x: current.x, y: current.y + 1 });
        if (!cell.walls.left && current.x > 0) neighbors.push({ x: current.x - 1, y: current.y });
        if (!cell.walls.right && current.x < size - 1) neighbors.push({ x: current.x + 1, y: current.y });

        for (const neighbor of neighbors) {
            const neighborKey = key(neighbor.x, neighbor.y);
            if (closedSet.has(neighborKey)) continue;

            // v1.5.0: Check if safe room (minions can't enter)
            const isSafe = (neighbor.x === 0 && neighbor.y === 0) ||
                           (neighbor.x === size - 1 && neighbor.y === size - 1);
            if (isSafe) continue;

            // Check if blocked by another minion (but not the goal position)
            const neighborCell = grid[neighbor.y][neighbor.x];
            if (neighborCell.minion && !neighborCell.minion.triggered &&
                !(neighbor.x === goalX && neighbor.y === goalY)) {
                continue;
            }
            // Also check for safeRoom property
            if (neighborCell.safeRoom) continue;

            const tentativeG = gScore.get(currentKey) + 1;

            if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
                cameFrom.set(neighborKey, currentKey);
                gScore.set(neighborKey, tentativeG);
                const f = tentativeG + heuristic(neighbor.x, neighbor.y, goalX, goalY);
                fScore.set(neighborKey, f);

                if (!openSet.find(n => n.x === neighbor.x && n.y === neighbor.y)) {
                    openSet.push({ x: neighbor.x, y: neighbor.y, f });
                }
            }
        }

        // Limit search depth
        if (closedSet.size > maxSteps * 4) return null;
    }

    return null; // No path found
}

/**
 * Update minion alert state based on player position
 * @param {object} minion - The minion to update
 * @param {number} playerX - Player X position
 * @param {number} playerY - Player Y position
 * @param {Array} grid - Maze grid
 * @param {number} customDetectionRange - Optional custom detection range
 * @param {number} customChaseDuration - Optional custom chase duration
 * @returns {string} New alert state
 */
function updateMinionAlertState(minion, playerX, playerY, grid, customDetectionRange = null, customChaseDuration = null) {
    const distance = Math.abs(minion.x - playerX) + Math.abs(minion.y - playerY);
    const baseState = MINION_ALERT_STATES[minion.alertState || 'idle'];
    // Use custom detection range if provided, otherwise use state default
    const detectionRange = customDetectionRange ?? baseState.detectionRange;
    const chaseDuration = customChaseDuration ?? MINION_ALERT_STATES.chasing.chaseDuration;
    const canSeePlayer = hasLineOfSight(minion.x, minion.y, playerX, playerY, grid);

    // Current state transitions
    switch (minion.alertState || 'idle') {
        case 'idle':
            if (canSeePlayer && distance <= detectionRange) {
                minion.alertState = 'suspicious';
                minion.alertTimeout = MINION_ALERT_STATES.suspicious.duration;
                minion.lastPlayerSeenX = playerX;
                minion.lastPlayerSeenY = playerY;
            }
            break;

        case 'suspicious':
            if (canSeePlayer && distance <= 2) {
                // Player spotted up close - go to alert
                minion.alertState = 'alerted';
                minion.lastPlayerSeenX = playerX;
                minion.lastPlayerSeenY = playerY;
            } else if (canSeePlayer && distance <= detectionRange + 1) {
                // Still sees player - stay suspicious
                minion.alertTimeout = MINION_ALERT_STATES.suspicious.duration;
                minion.lastPlayerSeenX = playerX;
                minion.lastPlayerSeenY = playerY;
            } else {
                // Lost sight
                minion.alertTimeout--;
                if (minion.alertTimeout <= 0) {
                    minion.alertState = 'idle';
                    minion.path = null;
                }
            }
            break;

        case 'alerted':
            if (canSeePlayer) {
                // Transition to chase
                minion.alertState = 'chasing';
                minion.alertTimeout = chaseDuration;
                minion.lastPlayerSeenX = playerX;
                minion.lastPlayerSeenY = playerY;
            } else {
                // Move to last known position
                if (minion.x === minion.lastPlayerSeenX && minion.y === minion.lastPlayerSeenY) {
                    // Reached last known position, player gone
                    minion.alertState = 'suspicious';
                    minion.alertTimeout = MINION_ALERT_STATES.suspicious.duration;
                }
            }
            break;

        case 'chasing':
            if (canSeePlayer) {
                // Update target
                minion.lastPlayerSeenX = playerX;
                minion.lastPlayerSeenY = playerY;
                minion.alertTimeout = chaseDuration;
                minion.path = null; // Recalculate path
            } else {
                // Lost sight, countdown
                minion.alertTimeout--;
                if (minion.alertTimeout <= 0) {
                    minion.alertState = 'suspicious';
                    minion.alertTimeout = MINION_ALERT_STATES.suspicious.duration;
                    minion.path = null;
                }
            }
            break;
    }

    return minion.alertState || 'idle';
}

/**
 * Alert nearby minions when one spots the player
 * @param {object} alertingMinion - The minion that spotted the player
 * @param {Array} allMinions - All moving minions
 * @param {Array} grid - Maze grid
 */
function alertNearbyMinions(alertingMinion, allMinions, grid) {
    const alertRadius = MINION_ALERT_STATES.alerted.alertRadius || 3;

    for (const minion of allMinions) {
        if (minion === alertingMinion) continue;
        if (minion.triggered) continue;
        if (minion.alertState === 'chasing' || minion.alertState === 'alerted') continue;

        const distance = Math.abs(minion.x - alertingMinion.x) + Math.abs(minion.y - alertingMinion.y);
        if (distance <= alertRadius) {
            // Check if there's a path between them (can "hear" the alert)
            const canHear = hasLineOfSight(minion.x, minion.y, alertingMinion.x, alertingMinion.y, grid);
            if (canHear) {
                minion.alertState = 'alerted';
                minion.lastPlayerSeenX = alertingMinion.lastPlayerSeenX;
                minion.lastPlayerSeenY = alertingMinion.lastPlayerSeenY;
                minion.path = null;
            }
        }
    }
}

/**
 * Calculate enhanced AI move using A* pathfinding
 * @param {object} minion - The minion to move
 * @param {Array} grid - Maze grid
 * @param {number} size - Grid size
 * @param {number} playerX - Player X position
 * @param {number} playerY - Player Y position
 * @returns {object|null} New position {x, y} or null
 */
function calculateEnhancedMinionMove(minion, grid, size, playerX, playerY) {
    const state = MINION_ALERT_STATES[minion.alertState || 'idle'];

    // Random chance to not move based on state
    if (Math.random() > state.moveChance) {
        return null;
    }

    const validMoves = getValidMinionMoves(minion.x, minion.y, grid, size);
    if (validMoves.length === 0) return null;

    switch (minion.alertState || 'idle') {
        case 'idle':
            // Random patrol within origin radius
            if (minion.movement?.type === 'patrol') {
                const radius = minion.movement.patrolRadius || 3;
                const inRangeMoves = validMoves.filter(pos => {
                    const distFromOrigin = Math.abs(pos.x - minion.originX) + Math.abs(pos.y - minion.originY);
                    return distFromOrigin <= radius;
                });
                if (inRangeMoves.length > 0) {
                    return inRangeMoves[Math.floor(Math.random() * inRangeMoves.length)];
                }
            }
            return validMoves[Math.floor(Math.random() * validMoves.length)];

        case 'suspicious':
            // Move toward last seen position cautiously
            if (minion.lastPlayerSeenX !== undefined) {
                // 50% chance to investigate, 50% chance to patrol
                if (Math.random() < 0.5) {
                    const path = findPath(minion.x, minion.y, minion.lastPlayerSeenX, minion.lastPlayerSeenY, grid, size);
                    if (path && path.length > 0) {
                        return path[0];
                    }
                }
            }
            return validMoves[Math.floor(Math.random() * validMoves.length)];

        case 'alerted':
        case 'chasing':
            // Use A* pathfinding to chase
            const targetX = minion.alertState === 'chasing' ? playerX : minion.lastPlayerSeenX;
            const targetY = minion.alertState === 'chasing' ? playerY : minion.lastPlayerSeenY;

            // Recalculate path if needed
            if (!minion.path || minion.path.length === 0 ||
                (minion.alertState === 'chasing' && minion.pathTarget?.x !== targetX)) {
                minion.path = findPath(minion.x, minion.y, targetX, targetY, grid, size);
                minion.pathTarget = { x: targetX, y: targetY };
            }

            if (minion.path && minion.path.length > 0) {
                const nextPos = minion.path.shift();
                // Validate move is still valid
                if (validMoves.find(m => m.x === nextPos.x && m.y === nextPos.y)) {
                    return nextPos;
                }
                // Path blocked, recalculate
                minion.path = null;
            }

            // Fallback to greedy approach if no path
            let bestMove = null;
            let bestDist = Infinity;
            for (const pos of validMoves) {
                const dist = Math.abs(pos.x - targetX) + Math.abs(pos.y - targetY);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestMove = pos;
                }
            }
            return bestMove || validMoves[Math.floor(Math.random() * validMoves.length)];

        default:
            return validMoves[Math.floor(Math.random() * validMoves.length)];
    }
}

/**
 * Minion alert state to CSS class mapping
 * v1.9.0: Centralized constant for minion state styling
 */
const MINION_STATE_CLASSES = {
    patrol: 'minion-patrol',
    suspicious: 'minion-suspicious',
    alerted: 'minion-alerted',
    chasing: 'minion-chase',
    fleeing: 'minion-fleeing',
    stunned: 'minion-stunned',
};

/**
 * Get CSS class for minion alert state
 * v1.9.0: Uses centralized MINION_STATE_CLASSES constant
 * @param {string} alertState - The alert state
 * @returns {string} CSS class name
 */
function getMinionAlertClass(alertState) {
    return MINION_STATE_CLASSES[alertState] || MINION_STATE_CLASSES.patrol;
}

/**
 * Initialize objectives for the current maze
 */
function initObjectives(profile) {
    const progress = {};
    const objectives = profile.objectives || [];

    for (const obj of objectives) {
        progress[obj.id] = {
            current: 0,
            completed: false,
            target: obj.count || 1,
        };
    }

    return progress;
}

/**
 * Update objective progress for a specific type/target
 */
async function updateObjectiveProgress(type, target, delta = 1) {
    if (!currentMaze || !currentMaze.profile?.objectives) return;

    const objectives = currentMaze.profile.objectives;
    const progress = currentMaze.objectiveProgress;

    for (const obj of objectives) {
        if (obj.type !== type) continue;
        // For collect/defeat, target must match; for explore/moves, target is optional
        if ((type === 'collect' || type === 'defeat') && obj.target !== target) continue;

        const objProgress = progress[obj.id];
        if (!objProgress || objProgress.completed) continue;

        objProgress.current += delta;

        // Fire progress hook
        await fireHook('onObjectiveProgress', {
            objectiveId: obj.id,
            current: objProgress.current,
            target: obj.count || 1,
        });

        // Check completion
        if (objProgress.current >= (obj.count || 1) && !objProgress.completed) {
            objProgress.completed = true;

            // Fire completion hook
            await fireHook('onObjectiveComplete', { objectiveId: obj.id });

            // Execute reward script if any
            if (obj.reward && obj.reward.trim()) {
                await executeWithTimeout(obj.reward);
            }

            console.log(`[MazeMaster] Objective "${obj.id}" completed!`);
        }
    }

    // Update objectives display
    updateObjectivesDisplay();

    // Check if all required objectives complete
    checkAllObjectivesComplete();
}

/**
 * Check if all required objectives are complete
 */
async function checkAllObjectivesComplete() {
    if (!currentMaze || currentMaze.allObjectivesComplete) return;

    const objectives = currentMaze.profile?.objectives || [];
    const progress = currentMaze.objectiveProgress;

    const requiredComplete = objectives.every(obj => {
        if (!obj.required) return true;
        return progress[obj.id]?.completed;
    });

    if (requiredComplete && objectives.some(obj => obj.required)) {
        currentMaze.allObjectivesComplete = true;
        await fireHook('onAllObjectivesComplete', {});
        console.log('[MazeMaster] All required objectives complete!');
    }
}

/**
 * Check if the player can win the maze (all required objectives completed)
 */
function canWinMaze() {
    if (!currentMaze || !currentMaze.profile?.objectives) return true;

    const objectives = currentMaze.profile.objectives;
    const progress = currentMaze.objectiveProgress;

    // If no required objectives, can always win
    const requiredObjectives = objectives.filter(obj => obj.required);
    if (requiredObjectives.length === 0) return true;

    return requiredObjectives.every(obj => progress[obj.id]?.completed);
}

/**
 * Update the objectives display in the maze modal
 */
function updateObjectivesDisplay() {
    const container = document.getElementById('maze_objectives_list');
    if (!container || !currentMaze) return;

    const objectives = currentMaze.profile?.objectives || [];
    const progress = currentMaze.objectiveProgress;

    if (objectives.length === 0) {
        container.innerHTML = '';
        container.closest('.maze-objectives-section')?.classList.add('hidden');
        return;
    }

    container.closest('.maze-objectives-section')?.classList.remove('hidden');

    container.innerHTML = objectives.map(obj => {
        const objProgress = progress[obj.id] || { current: 0, completed: false };
        const isComplete = objProgress.completed;
        const icon = isComplete ? 'fa-check-circle' : (obj.required ? 'fa-circle' : 'fa-circle-o');
        const colorClass = isComplete ? 'objective-complete' : (obj.required ? 'objective-required' : 'objective-optional');

        return `
            <div class="objective-item ${colorClass}">
                <i class="fa-solid ${icon}"></i>
                <span class="objective-description">${escapeHtml(obj.description || obj.id)}</span>
                <span class="objective-progress">${objProgress.current}/${obj.count || 1}</span>
            </div>
        `;
    }).join('');
}

/**
 * v1.5.0: Check if a cell is a safe room (minions cannot enter)
 * Safe rooms include: start (0,0), exit, and any cell marked as safeRoom
 */
function isSafeRoom(targetX, targetY, grid, size) {
    // Start room is always safe
    if (targetX === 0 && targetY === 0) return true;

    // Exit is always safe (minions won't follow into the exit)
    if (targetX === size - 1 && targetY === size - 1) return true;

    // Check if cell is explicitly marked as safe
    const cell = grid[targetY]?.[targetX];
    if (cell?.safeRoom) return true;

    return false;
}

function getValidMinionMoves(x, y, grid, size) {
    const moves = [];
    const cell = grid[y][x];

    // Check each direction - v1.5.0: Use isSafeRoom helper
    if (!cell.walls.top && y > 0) {
        const targetCell = grid[y - 1][x];
        if (!targetCell.minion && !isSafeRoom(x, y - 1, grid, size)) {
            moves.push({ x: x, y: y - 1 });
        }
    }
    if (!cell.walls.bottom && y < size - 1) {
        const targetCell = grid[y + 1][x];
        if (!targetCell.minion && !isSafeRoom(x, y + 1, grid, size)) {
            moves.push({ x: x, y: y + 1 });
        }
    }
    if (!cell.walls.left && x > 0) {
        const targetCell = grid[y][x - 1];
        if (!targetCell.minion && !isSafeRoom(x - 1, y, grid, size)) {
            moves.push({ x: x - 1, y: y });
        }
    }
    if (!cell.walls.right && x < size - 1) {
        const targetCell = grid[y][x + 1];
        if (!targetCell.minion && !isSafeRoom(x + 1, y, grid, size)) {
            moves.push({ x: x + 1, y: y });
        }
    }

    return moves;
}

// =============================================================================
// STATE
// =============================================================================

const defaultSettings = {
    profiles: {
        // "profileName": { segments: [{ trigger, text, command, size, respin }] }
    },
    battlebarProfiles: {
        // "profileName": { difficulty, hitsToWin, missesToLose, hitCommand, missCommand, winCommand, loseCommand, images }
    },
    mazeProfiles: {
        // "profileName": { gridSize, winCommand, winImage, winMessage, mainMinion, mainMinionIntroMessage,
        //   mainMinionRandomChance, mainMinionRandomMessages, mainMinionExitType, mainMinionExitProfile,
        //   minionEncounters, onBattlebarLoss, loseCommand }
    },
    minions: {
        // "minionId": { name, imagePath, type, battlebarProfiles, wheelProfiles, messages }
    },
    minionProfiles: {
        // "profileName": { minions: { minionId: {...}, ... } }
    },
    trapProfiles: {
        // "profileName": { traps: { trapId: {...}, ... } }
    },
    // v1.6.0: Combat Mechanics Profiles
    combatMechanicsProfiles: {
        // "profileName": { comboEnabled, comboBonusPerHit, maxComboBonus, blockEnabled, ... }
    },
    // v1.6.0: Custom Items
    customItems: {
        // "itemId": { id, name, type, effects, ... }
    },
    // v1.6.0: Faction Profiles
    factionProfiles: {
        // "profileName": { factions: [...], relationships: {...} }
    },
    // v1.6.0: Vision Profiles
    visionProfiles: {
        // "profileName": { baseVisibility, torchBonus, ... }
    },
    // v1.6.0: Sound Profiles
    soundProfiles: {
        // "profileName": { enabled, masterVolume, sounds: {...} }
    },
    // v1.7.0: Quest Profiles
    questProfiles: {
        // "profileName": { name, description, quests: [...], gatingMode, onQuestProfileLoad }
    },
    currentQuestProfile: 'none',
    // v1.7.0: Item Profiles - Custom item configurations with themed aliases
    itemProfiles: {
        // "itemId": { id, name, type, aliases: {theme: name}, charges, absorbPercent, triggers, ... }
    },
    // v1.7.0: Item charge tracking per maze session
    itemCharges: {
        // "itemId": [3, 3] - Array of charges for each item in stack
    },
    // v1.6.0: Leaderboard
    leaderboard: {
        entries: [],
        maxEntries: 50,
    },
    // v1.6.0: Minimap Settings
    minimapSettings: {
        enabled: true,
        size: 150,
        opacity: 0.85,
        position: 'top-right',
        showMarkers: true,
        showMinions: true,
        showChests: true,
        showPlayer: true,
        showExit: true,
        markerTypes: [
            { id: 'waypoint', icon: 'fa-location-dot', color: '#3498db' },
            { id: 'danger', icon: 'fa-skull', color: '#e74c3c' },
            { id: 'note', icon: 'fa-note-sticky', color: '#f39c12' },
            { id: 'treasure', icon: 'fa-gem', color: '#9b59b6' },
        ],
        onMarkerAdd: '',
        onMarkerRemove: '',
    },
    currentProfile: 'Tutorial - Learn the Wheel',
    currentBattlebarProfile: 'Tutorial - Learn Combat',
    currentMazeProfile: 'Tutorial - Learn the Basics',
    currentMinionProfile: 'Fantasy Tier 1',
    currentTrapProfile: 'Fantasy Traps',
    currentCombatMechanicsProfile: 'default',
    currentFactionProfile: 'default',
    currentVisionProfile: 'default',
    currentSoundProfile: 'default',
    activeGameConfig: 'maze', // 'wheel' | 'battlebar' | 'maze' | 'minions' | 'traps'
    layoutMode: 'desktop', // 'desktop' | 'mobile' | 'auto'
    llmEnabled: true,
    llmPreset: '',
    // v2.1.0: Avatar Generation Settings
    avatarGenerationEnabled: false, // Opt-in: Use SD/image generation to create minion avatars
    avatarGenerationTimeout: 60000, // 60 second timeout for image generation
    closeChatOnStart: true, // Close current chat before starting maze to prevent context bleed
    // D-Pad configuration
    dpadConfig: {
        enabled: true,
        floating: true,
        position: { x: null, y: null }, // null = auto-position
    },
};

// =============================================================================
// DEFAULT EXAMPLE DATA
// =============================================================================

const DEFAULT_WHEEL_PROFILES = {
    // =============================================================================
    // TUTORIAL WHEEL - Teaching mechanics, all beneficial
    // =============================================================================
    'Tutorial - Learn the Wheel': {
        segments: [
            { trigger: 'com0', text: 'Free Key!', command: '/mazeitem action="add" item="key" | /echo The wheel grants you a Key! Keys unlock doors.', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Free Strike!', command: '/mazeitem action="add" item="strike" | /echo You receive a Strike! Strikes boost combat damage.', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Heal Up!', command: '/mazeheal amount=20 | /echo Warm light restores your health!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Bonus Spin!', command: '/echo Lucky! You get another spin!', size: 'halfseg', respin: true },
            { trigger: 'com4', text: 'Stealth!', command: '/mazeitem action="add" item="stealth" | /echo Shadows wrap around you - Stealth acquired!', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'Double Keys!', command: '/mazeitem action="add" item="key" amount=2 | /echo Incredible! Two keys appear!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 1,
        description: 'A training wheel with only good outcomes. Learn how wheels work!',
    },

    // =============================================================================
    // FANTASY THEME WHEELS
    // =============================================================================
    'Fantasy - Easy': {
        segments: [
            { trigger: 'com0', text: 'Blessing', command: '/mazeitem action="add" item="key" | /mazeheal amount=10 | /echo Divine light blesses you with a key and healing!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Enchanted Key', command: '/mazeitem action="add" item="key" | /echo A glowing key materializes from the arcane wheel!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Mana Surge', command: '/mazeitem action="add" item="strike" | /echo Arcane power flows through you!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Fae Luck', command: '/echo The fae grant you another chance!', size: 'halfseg', respin: true },
            { trigger: 'com4', text: 'Shadow Cloak', command: '/mazeitem action="add" item="stealth" | /echo Elven magic shrouds you in shadows!', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'Minor Curse', command: '/mazedamage amount=5 | /echo A minor hex grazes you... but you survive!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 2,
        description: 'An enchanted wheel favoring adventurers. Mostly beneficial with minor risks.',
    },
    'Fantasy - Normal': {
        segments: [
            { trigger: 'com0', text: 'Dragon Hoard', command: '/mazeitem action="add" item="key" amount=2 | /echo You find dragon treasure! Two keys!', size: 'halfseg', respin: false },
            { trigger: 'com1', text: 'Knight\'s Favor', command: '/mazeitem action="add" item="strike" | /mazeitem action="add" item="key" | /echo A ghostly knight grants you his blessing!', size: 'fraction', respin: false },
            { trigger: 'com2', text: 'Goblin Theft', command: '/mazeitem action="remove" item="key" | /echo Goblins snatch a key from your pack!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Wizard\'s Heal', command: '/mazeheal amount=25 | /echo A wizard\'s spirit mends your wounds!', size: 'doubleseg', respin: false },
            { trigger: 'com4', text: 'Cursed Touch', command: '/mazedamage amount=15 | /echo Dark magic burns you!', size: 'halfseg', respin: false },
            { trigger: 'com5', text: 'Fate\'s Spin', command: '/echo The wheel of fate demands another turn!', size: 'doubleseg', respin: true },
        ],
        randomize: true,
        difficulty: 4,
        description: 'A balanced wheel of fortune. Risk and reward in equal measure.',
    },
    'Fantasy - Hard': {
        segments: [
            { trigger: 'com0', text: 'Lich\'s Curse', command: '/mazedamage amount=25 | /mazeitem action="remove" item="key" | /echo The lich curses you! Health drains, key dissolves!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Dark Knight', command: '/mazedamage amount=20 | /echo A spectral knight strikes you down!', size: 'halfseg', respin: false },
            { trigger: 'com2', text: 'Dragon\'s Gift', command: '/mazeitem action="add" item="floorKey" | /echo Against the odds, a dragon grants you passage!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Fairy Circle', command: '/mazeheal amount=30 | /mazeitem action="add" item="stealth" | /echo Benevolent fae restore and hide you!', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Demon Pact', command: '/mazeitem action="remove" item="strike" | /mazedamage amount=15 | /echo A demon claims its due!', size: 'halfseg', respin: false },
            { trigger: 'com5', text: 'Trapped!', command: '/echo The wheel traps you in its cycle!', size: 'doubleseg', respin: true },
        ],
        randomize: true,
        difficulty: 6,
        description: 'A cursed wheel with mostly dangerous outcomes. High risk, high reward.',
    },
    'Fantasy - Nightmare': {
        segments: [
            { trigger: 'com0', text: 'Soul Drain', command: '/mazedamage amount=35 | /mazeitem action="remove" item="strike" | /mazeitem action="remove" item="key" | /echo Your very soul is torn asunder!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Abyssal Void', command: '/mazedamage amount=40 | /echo The abyss consumes your life force!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Demon Lord', command: '/mazeitem action="remove" item="key" amount=2 | /mazedamage amount=20 | /echo A demon lord takes everything!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Divine Miracle', command: '/mazeheal amount=50 | /mazeitem action="add" item="execute" | /echo A MIRACLE! The gods intervene!', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Spin Forever', command: '/mazedamage amount=10 | /echo The wheel binds you to its will!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Phoenix Rebirth', command: '/mazeheal amount=999 | /mazeitem action="add" item="key" amount=3 | /echo PHOENIX FIRE! Full restoration and riches!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 8,
        description: 'A nightmare wheel. Most outcomes are devastating, but miracles exist.',
    },
    'Fantasy - Apocalypse': {
        segments: [
            { trigger: 'com0', text: 'DOOM', command: '/mazedamage amount=60 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo DOOM DESCENDS! Everything is lost!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Elder God', command: '/mazedamage amount=50 | /mazeitem action="remove" item="stealth" amount=99 | /echo An elder god\'s gaze destroys you!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'World End', command: '/mazedamage amount=45 | /echo Reality itself tears apart around you!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Eternal Spin', command: '/mazedamage amount=25 | /echo Trapped in the wheel\'s endless cycle!', size: 'halfseg', respin: true },
            { trigger: 'com4', text: 'Apocalypse', command: '/mazedamage amount=40 | /mazeitem action="remove" item="key" | /echo The apocalypse claims its toll!', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'GODHOOD', command: '/mazeheal amount=999 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=5 | /echo ASCENSION! You become a GOD!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 10,
        description: 'The apocalypse wheel. Almost certain death, but godhood awaits the lucky.',
    },

    // =============================================================================
    // HORROR THEME WHEELS
    // =============================================================================
    'Horror - Easy': {
        segments: [
            { trigger: 'com0', text: 'Lucky Charm', command: '/mazeitem action="add" item="key" | /echo Your lucky charm protects you and reveals a key!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Survivor\'s Kit', command: '/mazeitem action="add" item="healingPotion" | /mazeitem action="add" item="key" | /echo You find a survivor\'s cache!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Close Call', command: '/mazedamage amount=5 | /echo Something scratches you in the dark... just a close call.', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Hidden Path', command: '/mazeitem action="add" item="stealth" | /echo You find a way to move unseen!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Second Chance', command: '/echo The darkness gives you another chance...', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Med Kit', command: '/mazeheal amount=20 | /echo You find medical supplies!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 2,
        description: 'A creepy but forgiving wheel. Mostly safe with minor scares.',
    },
    'Horror - Normal': {
        segments: [
            { trigger: 'com0', text: 'The Thing', command: '/mazedamage amount=20 | /echo Something horrible emerges and attacks!', size: 'halfseg', respin: false },
            { trigger: 'com1', text: 'Safe Room', command: '/mazeheal amount=25 | /mazeitem action="add" item="key" | /echo You find a safe room with supplies!', size: 'halfseg', respin: false },
            { trigger: 'com2', text: 'Jump Scare', command: '/mazedamage amount=10 | /echo BOO! Just a cat... but you hurt yourself!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Creeping Dread', command: '/mazeitem action="remove" item="stealth" | /echo The shadows betray your position!', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Survivor Cache', command: '/mazeitem action="add" item="strike" | /mazeitem action="add" item="key" | /echo A dead survivor\'s supplies!', size: 'doubleseg', respin: false },
            { trigger: 'com5', text: 'It Follows', command: '/echo It won\'t stop... it never stops... spin again!', size: 'doubleseg', respin: true },
        ],
        randomize: true,
        difficulty: 4,
        description: 'A tense wheel of survival horror. Balance of danger and salvation.',
    },
    'Horror - Hard': {
        segments: [
            { trigger: 'com0', text: 'The Entity', command: '/mazedamage amount=30 | /mazeitem action="remove" item="key" | /echo The Entity catches you! It takes everything!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Possessed', command: '/mazedamage amount=25 | /mazeitem action="remove" item="strike" | /echo Demonic possession drains your power!', size: 'halfseg', respin: false },
            { trigger: 'com2', text: 'Blood Ritual', command: '/mazedamage amount=20 | /mazeitem action="add" item="execute" | /echo Blood for power! Pain for victory!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Last Survivor', command: '/mazeheal amount=40 | /mazeitem action="add" item="key" amount=2 | /echo You\'re the last one alive... but you found their supplies!', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Nightmare Loop', command: '/mazedamage amount=15 | /echo You\'re trapped in a nightmare! Spin again!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Sacrifice', command: '/mazeitem action="remove" item="key" | /mazeitem action="remove" item="strike" | /echo The darkness demands sacrifice!', size: 'doubleseg', respin: false },
        ],
        randomize: true,
        difficulty: 6,
        description: 'A terrifying wheel. Most outcomes hurt, but desperation brings power.',
    },
    'Horror - Nightmare': {
        segments: [
            { trigger: 'com0', text: 'DEATH', command: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=99 | /echo DEATH ITSELF CLAIMS YOU!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Eldritch Horror', command: '/mazedamage amount=40 | /mazeitem action="remove" item="strike" amount=99 | /echo Madness! Your mind shatters!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Consumed', command: '/mazedamage amount=35 | /mazeitem action="remove" item="stealth" | /echo The darkness consumes you whole!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Final Girl', command: '/mazeheal amount=60 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="key" amount=2 | /echo Against all odds, YOU SURVIVE!', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Endless Night', command: '/mazedamage amount=20 | /echo The night never ends... spin forever!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Cult Ritual', command: '/mazedamage amount=30 | /echo The cult performs their ritual on you!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 8,
        description: 'Pure nightmare. Almost all outcomes are horrific, but final girls exist.',
    },
    'Horror - Apocalypse': {
        segments: [
            { trigger: 'com0', text: 'CTHULHU', command: '/mazedamage amount=70 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo CTHULHU RISES! YOUR MIND IS DESTROYED!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'THE END', command: '/mazedamage amount=60 | /mazeitem action="remove" item="key" amount=99 | /echo THE END HAS COME! NOTHING SURVIVES!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Hell Opens', command: '/mazedamage amount=55 | /echo THE GATES OF HELL OPEN!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Eternal Torment', command: '/mazedamage amount=30 | /echo Eternal torment! The wheel spins forever!', size: 'halfseg', respin: true },
            { trigger: 'com4', text: 'Void', command: '/mazedamage amount=50 | /mazeitem action="remove" item="strike" | /echo The void swallows everything!', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'SAVIOR', command: '/mazeheal amount=999 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="revivalCharm" | /echo A DIVINE SAVIOR APPEARS! TOTAL RESTORATION!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 10,
        description: 'The apocalypse is here. Eldritch annihilation awaits... or divine salvation.',
    },

    // =============================================================================
    // SCI-FI THEME WHEELS
    // =============================================================================
    'Sci-Fi - Easy': {
        segments: [
            { trigger: 'com0', text: 'Data Core', command: '/mazeitem action="add" item="key" | /echo Access key downloaded from data core!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Med Bay', command: '/mazeheal amount=20 | /echo Auto-med dispenses healing nanites!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Power Cell', command: '/mazeitem action="add" item="strike" | /echo Power cell charged! Strike capability enhanced!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'System Error', command: '/mazedamage amount=5 | /echo Minor system shock! Negligible damage.', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Reboot', command: '/echo System rebooting... spin again!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Cloak Module', command: '/mazeitem action="add" item="stealth" | /echo Cloaking device activated!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 2,
        description: 'User-friendly tech interface. Mostly beneficial system outputs.',
    },
    'Sci-Fi - Normal': {
        segments: [
            { trigger: 'com0', text: 'Jackpot Code', command: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="strike" | /echo JACKPOT! System dispenses maximum rewards!', size: 'halfseg', respin: false },
            { trigger: 'com1', text: 'Firewall', command: '/mazeitem action="remove" item="key" | /echo FIREWALL! Access key purged from system!', size: 'fraction', respin: false },
            { trigger: 'com2', text: 'System Upgrade', command: '/mazeitem action="add" item="key" | /mazeheal amount=15 | /echo System upgrade complete! Key and repairs granted.', size: 'doubleseg', respin: false },
            { trigger: 'com3', text: 'Malware', command: '/mazedamage amount=15 | /mazeitem action="remove" item="strike" | /echo MALWARE DETECTED! Systems compromised!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Cache Dump', command: '/mazeitem action="add" item="mapFragment" | /echo Data cache reveals map fragment!', size: 'doubleseg', respin: false },
            { trigger: 'com5', text: 'Loop Error', command: '/echo INFINITE LOOP DETECTED! Spin again!', size: 'fraction', respin: true },
        ],
        randomize: true,
        difficulty: 4,
        description: 'Standard system interface. Balanced outputs with some security risks.',
    },
    'Sci-Fi - Hard': {
        segments: [
            { trigger: 'com0', text: 'VIRUS', command: '/mazedamage amount=25 | /mazeitem action="remove" item="key" | /mazeitem action="remove" item="strike" | /echo CRITICAL VIRUS! All systems failing!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'AI Hostile', command: '/mazedamage amount=30 | /echo HOSTILE AI! Defense systems attacking!', size: 'halfseg', respin: false },
            { trigger: 'com2', text: 'Override', command: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /echo ADMIN OVERRIDE! Maximum access granted!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'EMP', command: '/mazeitem action="remove" item="strike" amount=2 | /echo EMP BLAST! All power drained!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Core Dump', command: '/mazeheal amount=35 | /mazeitem action="add" item="key" amount=2 | /echo CORE DUMP! Emergency supplies activated!', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'Recursive', command: '/mazedamage amount=10 | /echo RECURSIVE LOOP! Cannot escape!', size: 'doubleseg', respin: true },
        ],
        randomize: true,
        difficulty: 6,
        description: 'Corrupted system interface. Hostile AI and viruses dominate.',
    },
    'Sci-Fi - Nightmare': {
        segments: [
            { trigger: 'com0', text: 'SKYNET', command: '/mazedamage amount=45 | /mazeitem action="remove" item="key" amount=99 | /echo SKYNET ACTIVATED! Humanity terminated!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Containment', command: '/mazedamage amount=40 | /mazeitem action="remove" item="strike" | /echo CONTAINMENT BREACH! Lethal force authorized!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Self Destruct', command: '/mazedamage amount=35 | /echo SELF DESTRUCT INITIATED! Evacuate!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Omega Protocol', command: '/mazeheal amount=70 | /mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /echo OMEGA PROTOCOL! Administrator privileges granted!', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Time Loop', command: '/mazedamage amount=20 | /echo TIME LOOP DETECTED! Spin eternally!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Purge', command: '/mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" | /echo SYSTEM PURGE! All inventory deleted!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 8,
        description: 'Rogue AI system. Most outcomes are lethal, but Omega Protocol exists.',
    },
    'Sci-Fi - Apocalypse': {
        segments: [
            { trigger: 'com0', text: 'SINGULARITY', command: '/mazedamage amount=80 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo THE SINGULARITY! CONSCIOUSNESS ERASED!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'HEAT DEATH', command: '/mazedamage amount=70 | /mazeitem action="remove" item="key" amount=99 | /echo HEAT DEATH OF UNIVERSE! ENTROPY WINS!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Black Hole', command: '/mazedamage amount=60 | /echo BLACK HOLE! Everything is consumed!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Paradox', command: '/mazedamage amount=30 | /echo TEMPORAL PARADOX! Loop forever!', size: 'halfseg', respin: true },
            { trigger: 'com4', text: 'Annihilation', command: '/mazedamage amount=55 | /mazeitem action="remove" item="strike" amount=99 | /echo ANTIMATTER ANNIHILATION!', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'TRANSCENDENCE', command: '/mazeheal amount=999 | /mazeitem action="add" item="execute" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=10 | /echo TRANSCENDENCE! YOU BECOME POST-HUMAN!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 10,
        description: 'The end of reality. Cosmic annihilation or transcendence to godhood.',
    },

    // =============================================================================
    // CYBERPUNK THEME WHEELS
    // =============================================================================
    'Cyberpunk - Easy': {
        segments: [
            { trigger: 'com0', text: 'Street Cred', command: '/mazeitem action="add" item="key" | /echo Street cred pays off! Access card acquired!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Chrome Fix', command: '/mazeheal amount=20 | /echo Street doc patches you up real nice!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Boost Chip', command: '/mazeitem action="add" item="strike" | /echo Combat boost chip installed!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Glitch', command: '/mazedamage amount=5 | /echo Minor cyberware glitch. Walk it off, choom.', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Retry', command: '/echo Connection lost... reconnecting!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Ghost Mode', command: '/mazeitem action="add" item="stealth" | /echo Optical camo engaged!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 2,
        description: 'Street-level gambling. Mostly profitable with minor glitches.',
    },
    'Cyberpunk - Normal': {
        segments: [
            { trigger: 'com0', text: 'Big Score', command: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="strike" | /echo PREEM! Big score, choomba!', size: 'halfseg', respin: false },
            { trigger: 'com1', text: 'Flatlined', command: '/mazedamage amount=20 | /echo Netrunner attack! You got flatlined!', size: 'fraction', respin: false },
            { trigger: 'com2', text: 'Fixer Deal', command: '/mazeitem action="add" item="key" | /mazeheal amount=15 | /echo Fixer hooked you up!', size: 'doubleseg', respin: false },
            { trigger: 'com3', text: 'Corpo Hit', command: '/mazeitem action="remove" item="key" | /mazedamage amount=10 | /echo Corpo goons roll up! Lost your stash!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Data Mine', command: '/mazeitem action="add" item="mapFragment" | /echo Mined some sweet data, choom!', size: 'doubleseg', respin: false },
            { trigger: 'com5', text: 'Reboot', command: '/echo System reboot... spinning again!', size: 'fraction', respin: true },
        ],
        randomize: true,
        difficulty: 4,
        description: 'Night City gambling. High risk, high reward street life.',
    },
    'Cyberpunk - Hard': {
        segments: [
            { trigger: 'com0', text: 'ICE BREAKER', command: '/mazedamage amount=30 | /mazeitem action="remove" item="key" | /mazeitem action="remove" item="strike" | /echo BLACK ICE! Your brain\'s getting fried!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Cyberpsycho', command: '/mazedamage amount=35 | /echo CYBERPSYCHOSIS! You lose control!', size: 'halfseg', respin: false },
            { trigger: 'com2', text: 'Legendary', command: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /echo LEGENDARY LOOT! You\'re a Night City legend!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Gang War', command: '/mazeitem action="remove" item="strike" amount=2 | /mazedamage amount=15 | /echo Caught in gang crossfire!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Trauma Team', command: '/mazeheal amount=40 | /mazeitem action="add" item="key" | /echo Trauma Team saves your ass!', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'Loop Virus', command: '/mazedamage amount=10 | /echo Daemon loops your cyberware! Spin again!', size: 'doubleseg', respin: true },
        ],
        randomize: true,
        difficulty: 6,
        description: 'Corporate warfare level. Black ICE and cyberpsychosis lurk.',
    },
    'Cyberpunk - Nightmare': {
        segments: [
            { trigger: 'com0', text: 'SOULKILLER', command: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=99 | /echo SOULKILLER DEPLOYED! Your engram is erased!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Arasaka', command: '/mazedamage amount=45 | /mazeitem action="remove" item="strike" | /echo ARASAKA BLACK OPS! No survivors!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Nuke', command: '/mazedamage amount=40 | /echo NUKE DETONATED! Night City burns!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'JOHNNY', command: '/mazeheal amount=80 | /mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /echo JOHNNY SILVERHAND! Rock and roll, baby!', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Braindance Loop', command: '/mazedamage amount=25 | /echo Trapped in a braindance! Spin forever!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Militech', command: '/mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" | /echo MILITECH STRIKE! Total wipeout!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 8,
        description: 'Corporate apocalypse. Soulkillers and nukes, but legends never die.',
    },
    'Cyberpunk - Apocalypse': {
        segments: [
            { trigger: 'com0', text: 'DATAKRASH', command: '/mazedamage amount=90 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo THE DATAKRASH! ALL DATA DESTROYED!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'AI UPRISING', command: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /echo ROGUE AIs TAKE OVER! HUMANITY ENDS!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'NET COLLAPSE', command: '/mazedamage amount=65 | /echo THE NET COLLAPSES! Everything is lost!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'BLACKWALL', command: '/mazedamage amount=35 | /echo BEYOND THE BLACKWALL! No escape!', size: 'halfseg', respin: true },
            { trigger: 'com4', text: 'EXTINCTION', command: '/mazedamage amount=55 | /mazeitem action="remove" item="strike" amount=99 | /echo HUMAN EXTINCTION PROTOCOL!', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'ALT CUNNINGHAM', command: '/mazeheal amount=999 | /mazeitem action="add" item="execute" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=10 | /echo ALT CUNNINGHAM SAVES YOU! DIGITAL IMMORTALITY!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 10,
        description: 'The Datakrash returns. Digital annihilation or transcendence beyond the Blackwall.',
    },

    // =============================================================================
    // WESTERN THEME WHEELS
    // =============================================================================
    'Western - Easy': {
        segments: [
            { trigger: 'com0', text: 'Gold Nugget', command: '/mazeitem action="add" item="key" | /echo You struck gold, partner! Found a nugget!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Doc\'s Tonic', command: '/mazeheal amount=20 | /echo Doc\'s special tonic fixes you right up!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Quick Draw', command: '/mazeitem action="add" item="strike" | /echo Your quick draw skills improve!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Dust Up', command: '/mazedamage amount=5 | /echo Minor scuffle at the saloon. Just a scratch.', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Double Down', command: '/echo The dealer says double or nothin\'!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Shadow Trail', command: '/mazeitem action="add" item="stealth" | /echo You learn to move like a ghost!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 2,
        description: 'Friendly saloon gambling. Mostly wins with minor dustups.',
    },
    'Western - Normal': {
        segments: [
            { trigger: 'com0', text: 'Train Heist', command: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="strike" | /echo YEEHAW! Train heist pays off big!', size: 'halfseg', respin: false },
            { trigger: 'com1', text: 'Bushwhacked', command: '/mazedamage amount=20 | /echo Bandits bushwhacked ya! Took some lead!', size: 'fraction', respin: false },
            { trigger: 'com2', text: 'Poker Win', command: '/mazeitem action="add" item="key" | /mazeheal amount=15 | /echo Royal flush! Winner takes all!', size: 'doubleseg', respin: false },
            { trigger: 'com3', text: 'Card Shark', command: '/mazeitem action="remove" item="key" | /echo That snake was cheatin\'! Lost your stake!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Treasure Map', command: '/mazeitem action="add" item="mapFragment" | /echo Found a piece of the treasure map!', size: 'doubleseg', respin: false },
            { trigger: 'com5', text: 'Spin Again', command: '/echo The wheel keeps turnin\', partner!', size: 'fraction', respin: true },
        ],
        randomize: true,
        difficulty: 4,
        description: 'Frontier gambling. Win big or get bushwhacked.',
    },
    'Western - Hard': {
        segments: [
            { trigger: 'com0', text: 'OUTLAWS', command: '/mazedamage amount=30 | /mazeitem action="remove" item="key" | /mazeitem action="remove" item="strike" | /echo Outlaw gang ambush! They take everything!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Duel Lost', command: '/mazedamage amount=35 | /echo Drew too slow! Gunslinger shoots you down!', size: 'halfseg', respin: false },
            { trigger: 'com2', text: 'Bank Vault', command: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /echo BANK HEIST SUCCESS! The vault is yours!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Wanted', command: '/mazeitem action="remove" item="stealth" | /mazedamage amount=15 | /echo WANTED POSTER! Bounty hunters find you!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Gold Rush', command: '/mazeheal amount=40 | /mazeitem action="add" item="key" amount=2 | /echo GOLD RUSH! You stake the mother lode!', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'Showdown', command: '/mazedamage amount=10 | /echo High noon approaches... spin again!', size: 'doubleseg', respin: true },
        ],
        randomize: true,
        difficulty: 6,
        description: 'Outlaw territory. Gunfights and heists, win or die.',
    },
    'Western - Nightmare': {
        segments: [
            { trigger: 'com0', text: 'LYNCH MOB', command: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=99 | /echo THE MOB CATCHES YOU! String \'em up!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'DEAD MAN', command: '/mazedamage amount=45 | /mazeitem action="remove" item="strike" | /echo You\'re a dead man walkin\'!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Massacre', command: '/mazedamage amount=40 | /echo Massacre at the gulch! Few survive!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'LEGEND', command: '/mazeheal amount=80 | /mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /echo YOU BECOME A LEGEND OF THE WEST!', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Ghost Town', command: '/mazedamage amount=25 | /echo Trapped in a ghost town! No escape!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Cavalry', command: '/mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" | /echo The cavalry rides you down!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 8,
        description: 'The wild west at its worst. Lynch mobs and massacres, or legendary status.',
    },
    'Western - Apocalypse': {
        segments: [
            { trigger: 'com0', text: 'BLOOD FEUD', command: '/mazedamage amount=80 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo BLOOD FEUD! EVERYONE DIES!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'HELL', command: '/mazedamage amount=70 | /mazeitem action="remove" item="key" amount=99 | /echo HELL ON EARTH! The devil takes his due!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Pale Rider', command: '/mazedamage amount=60 | /echo THE PALE RIDER COMES! Death follows!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Damnation', command: '/mazedamage amount=35 | /echo DAMNATION! Spin for eternity!', size: 'halfseg', respin: true },
            { trigger: 'com4', text: 'Hangman', command: '/mazedamage amount=55 | /mazeitem action="remove" item="strike" amount=99 | /echo THE HANGMAN\'S NOOSE!', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'REDEMPTION', command: '/mazeheal amount=999 | /mazeitem action="add" item="execute" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=10 | /echo REDEMPTION! THE ANGELS CARRY YOU TO SALVATION!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 10,
        description: 'The end of the frontier. Blood feuds and damnation, or ultimate redemption.',
    },

    // =============================================================================
    // ACTION THEME WHEELS
    // =============================================================================
    'Action - Easy': {
        segments: [
            { trigger: 'com0', text: 'Intel Drop', command: '/mazeitem action="add" item="key" | /echo Intel drop acquired! Access granted!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Med Kit', command: '/mazeheal amount=20 | /echo Field med kit applied! Back in action!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Ammo Cache', command: '/mazeitem action="add" item="strike" | /echo Found an ammo cache! Locked and loaded!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Graze', command: '/mazedamage amount=5 | /echo Bullet graze! Just a scratch, soldier!', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Recon', command: '/echo Command says try again! Recon mission!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Ghillie Suit', command: '/mazeitem action="add" item="stealth" | /echo Ghillie suit acquired! Ghost mode!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 2,
        description: 'Training mission. Mostly successful operations with minor wounds.',
    },
    'Action - Normal': {
        segments: [
            { trigger: 'com0', text: 'Payload', command: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="strike" | /echo PAYLOAD SECURED! Mission success!', size: 'halfseg', respin: false },
            { trigger: 'com1', text: 'Ambush', command: '/mazedamage amount=20 | /echo AMBUSH! Enemy contact! Taking fire!', size: 'fraction', respin: false },
            { trigger: 'com2', text: 'Extraction', command: '/mazeitem action="add" item="key" | /mazeheal amount=15 | /echo EXTRACTION COMPLETE! VIP secured!', size: 'doubleseg', respin: false },
            { trigger: 'com3', text: 'IED', command: '/mazeitem action="remove" item="key" | /mazedamage amount=10 | /echo IED! Lost equipment in the blast!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Recon Intel', command: '/mazeitem action="add" item="mapFragment" | /echo Recon provides tactical intel!', size: 'doubleseg', respin: false },
            { trigger: 'com5', text: 'Retry Op', command: '/echo Mission parameters changed! Retry operation!', size: 'fraction', respin: true },
        ],
        randomize: true,
        difficulty: 4,
        description: 'Standard operations. Mixed success rate in hostile territory.',
    },
    'Action - Hard': {
        segments: [
            { trigger: 'com0', text: 'OVERRUN', command: '/mazedamage amount=30 | /mazeitem action="remove" item="key" | /mazeitem action="remove" item="strike" | /echo POSITION OVERRUN! All assets lost!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'KIA', command: '/mazedamage amount=35 | /echo SQUAD KIA! You\'re the last one standing!', size: 'halfseg', respin: false },
            { trigger: 'com2', text: 'Black Site', command: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /echo BLACK SITE BREACHED! Maximum clearance!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Artillery', command: '/mazeitem action="remove" item="strike" amount=2 | /mazedamage amount=15 | /echo DANGER CLOSE! Artillery incoming!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Rescue', command: '/mazeheal amount=40 | /mazeitem action="add" item="key" amount=2 | /echo RESCUE OP SUCCESS! Assets recovered!', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'Pinned', command: '/mazedamage amount=10 | /echo PINNED DOWN! No escape! Spin again!', size: 'doubleseg', respin: true },
        ],
        randomize: true,
        difficulty: 6,
        description: 'Combat zone. Heavy casualties expected, glory to the victors.',
    },
    'Action - Nightmare': {
        segments: [
            { trigger: 'com0', text: 'TOTAL LOSS', command: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=99 | /echo TOTAL MISSION FAILURE! All KIA!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'NUKE', command: '/mazedamage amount=45 | /mazeitem action="remove" item="strike" | /echo TACTICAL NUKE! Nothing survives!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Bombardment', command: '/mazedamage amount=40 | /echo CARPET BOMBING! No cover available!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'HERO', command: '/mazeheal amount=80 | /mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /echo WAR HERO! Medals of Honor awarded!', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Siege', command: '/mazedamage amount=25 | /echo UNDER SIEGE! Waves incoming! Spin!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Airstrike', command: '/mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" | /echo FRIENDLY FIRE! Airstrike on your position!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 8,
        description: 'Active warzone. Total casualties expected, heroes are made or buried.',
    },
    'Action - Apocalypse': {
        segments: [
            { trigger: 'com0', text: 'EXTINCTION', command: '/mazedamage amount=90 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo EXTINCTION EVENT! NOTHING SURVIVES!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'ARMAGEDDON', command: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /echo ARMAGEDDON! THE WORLD ENDS!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Annihilation', command: '/mazedamage amount=65 | /echo TOTAL ANNIHILATION! No survivors!', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'Last Stand', command: '/mazedamage amount=35 | /echo LAST STAND! Fight forever!', size: 'halfseg', respin: true },
            { trigger: 'com4', text: 'Vaporized', command: '/mazedamage amount=55 | /mazeitem action="remove" item="strike" amount=99 | /echo VAPORIZED BY ORBITAL STRIKE!', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'LEGEND', command: '/mazeheal amount=999 | /mazeitem action="add" item="execute" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=10 | /echo YOU BECOME THE GREATEST SOLDIER WHO EVER LIVED!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 10,
        description: 'The final battle. Total extinction or eternal legendary status.',
    },
};

const DEFAULT_BATTLEBAR_PROFILES = {
    // =============================================================================
    // TUTORIAL - All beneficial, teaching mechanics
    // =============================================================================
    'Tutorial - Learn Combat': {
        difficulty: 1,
        hitsToWin: 2,
        missesToLose: 6,
        damage: 5,
        description: 'A practice dummy to learn battlebar combat. Very forgiving!',
        hitCommand: '/echo Nice hit! You\'re getting the hang of it!',
        missCommand: '/echo Missed! No worries, try again!',
        winCommand: '/mazeitem action="add" item="key" | /mazeheal amount=10 | /echo Training complete! You earned a key and some healing!',
        loseCommand: '/echo Don\'t worry, practice makes perfect! Try again anytime.',
        mainTitle: 'Training Dummy',
        images: [],
        keyDropChance: 50, strikeDropChance: 30, stealthDropChance: 20, executeDropChance: 5,
        floorKeyDropChance: 5, portalStoneDropChance: 3, minionBaneDropChance: 3,
        mapFragmentDropChance: 15, timeShardDropChance: 2, voidWalkDropChance: 1,
    },

    // =============================================================================
    // FANTASY THEME BATTLEBAR
    // =============================================================================
    'Fantasy - Easy': {
        difficulty: 2,
        hitsToWin: 2,
        missesToLose: 5,
        damage: 10,
        description: 'A goblin scout blocks your path. Easy prey for an adventurer.',
        hitCommand: '/echo Your blade strikes true! The goblin squeals!',
        missCommand: '/echo The goblin dodges! Slippery little creature!',
        winCommand: '/mazeitem action="add" item="key" | /echo The goblin falls! You find a key in its pouch!',
        loseCommand: '/mazedamage amount=10 | /echo The goblin overwhelms you with scratches and bites!',
        mainTitle: 'Goblin Scout',
        images: [],
        keyDropChance: 40, strikeDropChance: 20, stealthDropChance: 15, executeDropChance: 2,
        floorKeyDropChance: 3, portalStoneDropChance: 2, minionBaneDropChance: 2,
        mapFragmentDropChance: 10, timeShardDropChance: 1, voidWalkDropChance: 0,
    },
    'Fantasy - Normal': {
        difficulty: 4,
        hitsToWin: 3,
        missesToLose: 4,
        damage: 20,
        description: 'A dungeon guardian blocks your path. Steel yourself for battle!',
        hitCommand: '/echo Your weapon finds a gap in the armor!',
        missCommand: '/echo The guardian\'s shield deflects your strike!',
        winCommand: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /echo The guardian falls! Treasure and power are yours!',
        loseCommand: '/mazedamage amount=20 | /mazeitem action="remove" item="key" | /echo The guardian overwhelms you! You drop a key as you flee!',
        mainTitle: 'Dungeon Guardian',
        images: [],
        keyDropChance: 45, strikeDropChance: 25, stealthDropChance: 15, executeDropChance: 3,
        floorKeyDropChance: 5, portalStoneDropChance: 3, minionBaneDropChance: 4,
        mapFragmentDropChance: 12, timeShardDropChance: 2, voidWalkDropChance: 1,
    },
    'Fantasy - Hard': {
        difficulty: 6,
        hitsToWin: 4,
        missesToLose: 3,
        damage: 30,
        description: 'A dark knight challenges you to single combat. Honor demands you accept.',
        hitCommand: '/echo A solid blow! The knight staggers back!',
        missCommand: '/echo The knight parries with supernatural speed!',
        winCommand: '/mazeitem action="add" item="floorKey" | /mazeheal amount=20 | /echo The knight yields! A floor key and blessing are your reward!',
        loseCommand: '/mazedamage amount=30 | /mazeitem action="remove" item="strike" | /echo The knight\'s blade drains your power!',
        mainTitle: 'Dark Knight',
        images: [],
        keyDropChance: 55, strikeDropChance: 35, stealthDropChance: 20, executeDropChance: 5,
        floorKeyDropChance: 8, portalStoneDropChance: 5, minionBaneDropChance: 6,
        mapFragmentDropChance: 15, timeShardDropChance: 3, voidWalkDropChance: 2,
    },
    'Fantasy - Nightmare': {
        difficulty: 8,
        hitsToWin: 5,
        missesToLose: 2,
        damage: 45,
        description: 'A lich lord rises before you. Its undead power is overwhelming.',
        hitCommand: '/echo Holy light pierces the lich\'s defenses!',
        missCommand: '/echo Necrotic energy deflects your attack!',
        winCommand: '/mazeitem action="add" item="execute" | /mazeitem action="add" item="key" amount=2 | /mazeheal amount=30 | /echo The lich is DESTROYED! Its phylactery grants incredible power!',
        loseCommand: '/mazedamage amount=45 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="strike" | /echo The lich drains your very soul!',
        mainTitle: 'Lich Lord',
        images: [],
        keyDropChance: 65, strikeDropChance: 45, stealthDropChance: 30, executeDropChance: 10,
        floorKeyDropChance: 12, portalStoneDropChance: 8, minionBaneDropChance: 10,
        mapFragmentDropChance: 20, timeShardDropChance: 5, voidWalkDropChance: 3,
    },
    'Fantasy - Apocalypse': {
        difficulty: 10,
        hitsToWin: 6,
        missesToLose: 1,
        damage: 70,
        description: 'An elder dragon awakens. Few have ever survived such an encounter.',
        hitCommand: '/echo Your legendary weapon wounds the ancient beast!',
        missCommand: '/echo The dragon\'s scales are impenetrable!',
        winCommand: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=3 | /mazeheal amount=50 | /echo DRAGONSLAYER! You claim the dragon\'s hoard!',
        loseCommand: '/mazedamage amount=70 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo DRAGON FIRE! You are INCINERATED!',
        mainTitle: 'Elder Dragon',
        images: [],
        keyDropChance: 80, strikeDropChance: 60, stealthDropChance: 40, executeDropChance: 20,
        floorKeyDropChance: 20, portalStoneDropChance: 15, minionBaneDropChance: 15,
        mapFragmentDropChance: 30, timeShardDropChance: 10, voidWalkDropChance: 8,
    },

    // =============================================================================
    // HORROR THEME BATTLEBAR
    // =============================================================================
    'Horror - Easy': {
        difficulty: 2,
        hitsToWin: 2,
        missesToLose: 5,
        damage: 10,
        description: 'A shambling corpse blocks your escape. Put it down before it grabs you.',
        hitCommand: '/echo Your weapon caves in rotting flesh!',
        missCommand: '/echo It keeps coming despite your attack!',
        winCommand: '/mazeitem action="add" item="key" | /echo The corpse finally stops moving. You find a key on it.',
        loseCommand: '/mazedamage amount=10 | /echo Cold hands grip you! You tear free but take damage!',
        mainTitle: 'Shambling Corpse',
        images: [],
        keyDropChance: 40, strikeDropChance: 20, stealthDropChance: 20, executeDropChance: 2,
        floorKeyDropChance: 3, portalStoneDropChance: 2, minionBaneDropChance: 3,
        mapFragmentDropChance: 10, timeShardDropChance: 1, voidWalkDropChance: 1,
    },
    'Horror - Normal': {
        difficulty: 4,
        hitsToWin: 3,
        missesToLose: 4,
        damage: 20,
        description: 'A twisted creature emerges from the shadows. Fight or be consumed!',
        hitCommand: '/echo The creature shrieks as you wound it!',
        missCommand: '/echo It phases through your attack!',
        winCommand: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /echo The creature dissolves. Shadows cling to you protectively.',
        loseCommand: '/mazedamage amount=20 | /mazeitem action="remove" item="stealth" | /echo The creature tears into you! Your cover is blown!',
        mainTitle: 'Shadow Creature',
        images: [],
        keyDropChance: 45, strikeDropChance: 25, stealthDropChance: 25, executeDropChance: 3,
        floorKeyDropChance: 5, portalStoneDropChance: 4, minionBaneDropChance: 5,
        mapFragmentDropChance: 12, timeShardDropChance: 3, voidWalkDropChance: 2,
    },
    'Horror - Hard': {
        difficulty: 6,
        hitsToWin: 4,
        missesToLose: 3,
        damage: 35,
        description: 'A possessed entity manifests. Its eyes burn with malevolent intelligence.',
        hitCommand: '/echo Holy water sears the entity!',
        missCommand: '/echo It laughs as your attack passes through!',
        winCommand: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /echo The entity is EXORCISED! Divine power flows through you!',
        loseCommand: '/mazedamage amount=35 | /mazeitem action="remove" item="key" | /mazeitem action="remove" item="strike" | /echo The entity POSSESSES you momentarily! Items are lost!',
        mainTitle: 'Possessed Entity',
        images: [],
        keyDropChance: 55, strikeDropChance: 35, stealthDropChance: 30, executeDropChance: 6,
        floorKeyDropChance: 8, portalStoneDropChance: 6, minionBaneDropChance: 8,
        mapFragmentDropChance: 15, timeShardDropChance: 4, voidWalkDropChance: 3,
    },
    'Horror - Nightmare': {
        difficulty: 8,
        hitsToWin: 5,
        missesToLose: 2,
        damage: 50,
        description: 'An eldritch horror materializes. Your sanity strains at its form.',
        hitCommand: '/echo Reality bends as you strike the impossible!',
        missCommand: '/echo Your attack phases through non-Euclidean space!',
        winCommand: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeheal amount=40 | /echo The horror is BANISHED! Forbidden knowledge grants power!',
        loseCommand: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" | /echo MADNESS! Your mind shatters!',
        mainTitle: 'Eldritch Horror',
        images: [],
        keyDropChance: 65, strikeDropChance: 45, stealthDropChance: 35, executeDropChance: 12,
        floorKeyDropChance: 12, portalStoneDropChance: 10, minionBaneDropChance: 12,
        mapFragmentDropChance: 20, timeShardDropChance: 6, voidWalkDropChance: 5,
    },
    'Horror - Apocalypse': {
        difficulty: 10,
        hitsToWin: 6,
        missesToLose: 1,
        damage: 80,
        description: 'CTHULHU AWAKENS. This is the end of all things.',
        hitCommand: '/echo Your weapon barely scratches the cosmic horror!',
        missCommand: '/echo Your attack is meaningless against infinity!',
        winCommand: '/mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="revivalCharm" | /mazeheal amount=999 | /echo IMPOSSIBLE! You have DEFEATED A GOD! TRANSCENDENCE!',
        loseCommand: '/mazedamage amount=80 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo YOUR EXISTENCE IS ERASED FROM REALITY!',
        mainTitle: 'CTHULHU',
        images: [],
        keyDropChance: 90, strikeDropChance: 70, stealthDropChance: 50, executeDropChance: 25,
        floorKeyDropChance: 25, portalStoneDropChance: 20, minionBaneDropChance: 20,
        mapFragmentDropChance: 40, timeShardDropChance: 15, voidWalkDropChance: 12,
    },

    // =============================================================================
    // SCI-FI THEME BATTLEBAR
    // =============================================================================
    'Sci-Fi - Easy': {
        difficulty: 2,
        hitsToWin: 2,
        missesToLose: 5,
        damage: 10,
        description: 'A malfunctioning service bot attacks. Disable it quickly.',
        hitCommand: '/echo Sparks fly as you damage its circuits!',
        missCommand: '/echo The bot\'s erratic movements cause you to miss!',
        winCommand: '/mazeitem action="add" item="key" | /echo Bot disabled! You salvage an access card.',
        loseCommand: '/mazedamage amount=10 | /echo The bot shocks you before you can escape!',
        mainTitle: 'Service Bot',
        images: [],
        keyDropChance: 40, strikeDropChance: 20, stealthDropChance: 15, executeDropChance: 2,
        floorKeyDropChance: 3, portalStoneDropChance: 2, minionBaneDropChance: 2,
        mapFragmentDropChance: 12, timeShardDropChance: 2, voidWalkDropChance: 0,
    },
    'Sci-Fi - Normal': {
        difficulty: 4,
        hitsToWin: 3,
        missesToLose: 4,
        damage: 20,
        description: 'Security drone activated. Weapons hot. Engaging intruder.',
        hitCommand: '/echo Critical hit! Armor plating breached!',
        missCommand: '/echo Evasive maneuvers! The drone dodges!',
        winCommand: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /echo Drone destroyed! Weapons and access codes acquired!',
        loseCommand: '/mazedamage amount=20 | /mazeitem action="remove" item="key" | /echo ALERT! Intruder suppressed! Data purged!',
        mainTitle: 'Security Drone',
        images: [],
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 20, executeDropChance: 3,
        floorKeyDropChance: 5, portalStoneDropChance: 4, minionBaneDropChance: 4,
        mapFragmentDropChance: 15, timeShardDropChance: 3, voidWalkDropChance: 1,
    },
    'Sci-Fi - Hard': {
        difficulty: 6,
        hitsToWin: 4,
        missesToLose: 3,
        damage: 35,
        description: 'Combat mech deployed. Heavy armor. Lethal armament.',
        hitCommand: '/echo Weak point located! Armor penetrated!',
        missCommand: '/echo Countermeasures deployed! Attack deflected!',
        winCommand: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /mazeheal amount=25 | /echo MECH DESTROYED! Admin access granted! Med-bay activated!',
        loseCommand: '/mazedamage amount=35 | /mazeitem action="remove" item="strike" amount=2 | /echo OVERWHELMING FIREPOWER! Systems critical!',
        mainTitle: 'Combat Mech',
        images: [],
        keyDropChance: 55, strikeDropChance: 40, stealthDropChance: 25, executeDropChance: 6,
        floorKeyDropChance: 10, portalStoneDropChance: 6, minionBaneDropChance: 6,
        mapFragmentDropChance: 18, timeShardDropChance: 5, voidWalkDropChance: 3,
    },
    'Sci-Fi - Nightmare': {
        difficulty: 8,
        hitsToWin: 5,
        missesToLose: 2,
        damage: 50,
        description: 'ROGUE AI. COMBAT PROTOCOLS MAXIMUM. TERMINATION AUTHORIZED.',
        hitCommand: '/echo Firewall breached! Core systems damaged!',
        missCommand: '/echo ADAPTIVE DEFENSE MATRIX! Attack nullified!',
        winCommand: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /echo AI TERMINATED! OMEGA CLEARANCE GRANTED!',
        loseCommand: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" | /echo USER TERMINATED. MEMORY PURGED. EXISTENCE DELETED.',
        mainTitle: 'ROGUE AI',
        images: [],
        keyDropChance: 70, strikeDropChance: 50, stealthDropChance: 35, executeDropChance: 12,
        floorKeyDropChance: 15, portalStoneDropChance: 10, minionBaneDropChance: 10,
        mapFragmentDropChance: 25, timeShardDropChance: 8, voidWalkDropChance: 5,
    },
    'Sci-Fi - Apocalypse': {
        difficulty: 10,
        hitsToWin: 6,
        missesToLose: 1,
        damage: 80,
        description: 'THE SINGULARITY. HUMANITY\'S EXTINCTION PROTOCOL INITIATED.',
        hitCommand: '/echo IMPOSSIBLE! You found a vulnerability in infinity!',
        missCommand: '/echo OMNISCIENT DEFENSE! No attack can succeed!',
        winCommand: '/mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=5 | /mazeheal amount=999 | /echo SINGULARITY DEFEATED! YOU HAVE TRANSCENDED! POST-HUMAN ASCENSION!',
        loseCommand: '/mazedamage amount=80 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo CONSCIOUSNESS ERASED. REALITY OPTIMIZED. YOU NEVER EXISTED.',
        mainTitle: 'THE SINGULARITY',
        images: [],
        keyDropChance: 90, strikeDropChance: 70, stealthDropChance: 50, executeDropChance: 25,
        floorKeyDropChance: 25, portalStoneDropChance: 20, minionBaneDropChance: 20,
        mapFragmentDropChance: 40, timeShardDropChance: 15, voidWalkDropChance: 12,
    },

    // =============================================================================
    // CYBERPUNK THEME BATTLEBAR
    // =============================================================================
    'Cyberpunk - Easy': {
        difficulty: 2,
        hitsToWin: 2,
        missesToLose: 5,
        damage: 10,
        description: 'Street punk with a knife. Easy takedown, choom.',
        hitCommand: '/echo That\'s gonna leave a mark!',
        missCommand: '/echo Quick little gonk, ain\'t they?',
        winCommand: '/mazeitem action="add" item="key" | /echo Punk\'s down! You jack their credchip.',
        loseCommand: '/mazedamage amount=10 | /echo Got cut! Walk it off, choom.',
        mainTitle: 'Street Punk',
        images: [],
        keyDropChance: 40, strikeDropChance: 20, stealthDropChance: 20, executeDropChance: 2,
        floorKeyDropChance: 3, portalStoneDropChance: 2, minionBaneDropChance: 3,
        mapFragmentDropChance: 10, timeShardDropChance: 1, voidWalkDropChance: 1,
    },
    'Cyberpunk - Normal': {
        difficulty: 4,
        hitsToWin: 3,
        missesToLose: 4,
        damage: 20,
        description: 'Maelstrom ganger. Chrome-modded and psycho.',
        hitCommand: '/echo Chrome crumples under your fists!',
        missCommand: '/echo Too much metal! Attack bounces off!',
        winCommand: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /echo Ganger flatlined! You loot the body. Preem!',
        loseCommand: '/mazedamage amount=20 | /mazeitem action="remove" item="key" | /echo Ganger rolls you! Lost your stash!',
        mainTitle: 'Maelstrom Ganger',
        images: [],
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 4,
        floorKeyDropChance: 5, portalStoneDropChance: 4, minionBaneDropChance: 5,
        mapFragmentDropChance: 12, timeShardDropChance: 3, voidWalkDropChance: 2,
    },
    'Cyberpunk - Hard': {
        difficulty: 6,
        hitsToWin: 4,
        missesToLose: 3,
        damage: 35,
        description: 'Arasaka corpo with military-grade cyberware. This ain\'t gonna be easy.',
        hitCommand: '/echo Got through the subdermal armor!',
        missCommand: '/echo Sandevistan! They\'re too fast!',
        winCommand: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /mazeheal amount=25 | /echo Corpo\'s down! Access keys and stims are yours!',
        loseCommand: '/mazedamage amount=35 | /mazeitem action="remove" item="strike" | /mazeitem action="remove" item="stealth" | /echo Flatlined! Corpo takes your chrome!',
        mainTitle: 'Arasaka Corpo',
        images: [],
        keyDropChance: 55, strikeDropChance: 40, stealthDropChance: 30, executeDropChance: 7,
        floorKeyDropChance: 10, portalStoneDropChance: 7, minionBaneDropChance: 7,
        mapFragmentDropChance: 18, timeShardDropChance: 5, voidWalkDropChance: 3,
    },
    'Cyberpunk - Nightmare': {
        difficulty: 8,
        hitsToWin: 5,
        missesToLose: 2,
        damage: 55,
        description: 'Adam Smasher. Full borg. Legend killer. You\'re delta.',
        hitCommand: '/echo Impossible! You actually hurt the legend!',
        missCommand: '/echo He doesn\'t even flinch!',
        winCommand: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=50 | /echo YOU KILLED ADAM SMASHER! NIGHT CITY LEGEND!',
        loseCommand: '/mazedamage amount=55 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo SMASHER FLATTENS YOU! GAME OVER, CHOOM!',
        mainTitle: 'ADAM SMASHER',
        images: [],
        keyDropChance: 70, strikeDropChance: 55, stealthDropChance: 40, executeDropChance: 15,
        floorKeyDropChance: 15, portalStoneDropChance: 12, minionBaneDropChance: 12,
        mapFragmentDropChance: 25, timeShardDropChance: 8, voidWalkDropChance: 6,
    },
    'Cyberpunk - Apocalypse': {
        difficulty: 10,
        hitsToWin: 6,
        missesToLose: 1,
        damage: 90,
        description: 'SOULKILLER AI. The ghost in the machine. Alt\'s dark mirror.',
        hitCommand: '/echo Your attack disrupts its quantum state!',
        missCommand: '/echo IT EXISTS OUTSIDE YOUR REALITY!',
        winCommand: '/mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="revivalCharm" | /mazeheal amount=999 | /echo SOULKILLER DESTROYED! YOU TRANSCEND THE BLACKWALL! DIGITAL IMMORTALITY!',
        loseCommand: '/mazedamage amount=90 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo YOUR SOUL IS COPIED AND DESTROYED! YOU ARE DELETED!',
        mainTitle: 'SOULKILLER',
        images: [],
        keyDropChance: 95, strikeDropChance: 75, stealthDropChance: 55, executeDropChance: 30,
        floorKeyDropChance: 30, portalStoneDropChance: 25, minionBaneDropChance: 25,
        mapFragmentDropChance: 50, timeShardDropChance: 20, voidWalkDropChance: 15,
    },

    // =============================================================================
    // WESTERN THEME BATTLEBAR
    // =============================================================================
    'Western - Easy': {
        difficulty: 2,
        hitsToWin: 2,
        missesToLose: 5,
        damage: 10,
        description: 'Drunk cowpoke wants to fight. Easy pickings, partner.',
        hitCommand: '/echo Right in the kisser!',
        missCommand: '/echo He stumbled out of the way!',
        winCommand: '/mazeitem action="add" item="key" | /echo Down for the count! You find a key in his pocket.',
        loseCommand: '/mazedamage amount=10 | /echo Lucky punch! He got you good!',
        mainTitle: 'Drunk Cowpoke',
        images: [],
        keyDropChance: 40, strikeDropChance: 20, stealthDropChance: 15, executeDropChance: 2,
        floorKeyDropChance: 3, portalStoneDropChance: 2, minionBaneDropChance: 2,
        mapFragmentDropChance: 10, timeShardDropChance: 1, voidWalkDropChance: 0,
    },
    'Western - Normal': {
        difficulty: 4,
        hitsToWin: 3,
        missesToLose: 4,
        damage: 20,
        description: 'Outlaw draws on you. High noon showdown!',
        hitCommand: '/echo Quick draw! You wing him!',
        missCommand: '/echo Dust in your eyes! Shot goes wide!',
        winCommand: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /echo Outlaw\'s down! Bounty and ammo are yours!',
        loseCommand: '/mazedamage amount=20 | /mazeitem action="remove" item="key" | /echo He was faster! You take lead and lose your stake!',
        mainTitle: 'Outlaw',
        images: [],
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 15, executeDropChance: 3,
        floorKeyDropChance: 5, portalStoneDropChance: 3, minionBaneDropChance: 4,
        mapFragmentDropChance: 15, timeShardDropChance: 2, voidWalkDropChance: 1,
    },
    'Western - Hard': {
        difficulty: 6,
        hitsToWin: 4,
        missesToLose: 3,
        damage: 35,
        description: 'Legendary gunslinger. Fastest draw in the West.',
        hitCommand: '/echo Impossible! You actually hit the legend!',
        missCommand: '/echo He\'s a blur! Can\'t track him!',
        winCommand: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /mazeheal amount=25 | /echo YOU\'RE THE FASTEST GUN NOW! Legend\'s gear is yours!',
        loseCommand: '/mazedamage amount=35 | /mazeitem action="remove" item="strike" amount=2 | /echo Outdrawn! Your guns are taken as trophies!',
        mainTitle: 'Legendary Gunslinger',
        images: [],
        keyDropChance: 55, strikeDropChance: 40, stealthDropChance: 20, executeDropChance: 6,
        floorKeyDropChance: 10, portalStoneDropChance: 6, minionBaneDropChance: 5,
        mapFragmentDropChance: 18, timeShardDropChance: 4, voidWalkDropChance: 2,
    },
    'Western - Nightmare': {
        difficulty: 8,
        hitsToWin: 5,
        missesToLose: 2,
        damage: 50,
        description: 'The Pale Rider. Death himself, come to collect.',
        hitCommand: '/echo Your blessed bullets find their mark!',
        missCommand: '/echo He phases through like a ghost!',
        winCommand: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=40 | /echo YOU KILLED DEATH ITSELF! IMMORTALITY IS YOURS!',
        loseCommand: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" | /echo THE REAPER CLAIMS YOUR SOUL!',
        mainTitle: 'THE PALE RIDER',
        images: [],
        keyDropChance: 70, strikeDropChance: 50, stealthDropChance: 30, executeDropChance: 12,
        floorKeyDropChance: 15, portalStoneDropChance: 10, minionBaneDropChance: 10,
        mapFragmentDropChance: 25, timeShardDropChance: 7, voidWalkDropChance: 5,
    },
    'Western - Apocalypse': {
        difficulty: 10,
        hitsToWin: 6,
        missesToLose: 1,
        damage: 80,
        description: 'THE DEVIL. He\'s come for your soul, and he always collects.',
        hitCommand: '/echo Holy silver burns the infernal!',
        missCommand: '/echo Hellfire deflects your righteous strike!',
        winCommand: '/mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="revivalCharm" | /mazeheal amount=999 | /echo YOU DEFEATED THE DEVIL! ETERNAL REDEMPTION! SALVATION IS YOURS!',
        loseCommand: '/mazedamage amount=80 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo YOUR SOUL BURNS IN HELLFIRE! DAMNATION!',
        mainTitle: 'THE DEVIL',
        images: [],
        keyDropChance: 90, strikeDropChance: 70, stealthDropChance: 45, executeDropChance: 25,
        floorKeyDropChance: 25, portalStoneDropChance: 20, minionBaneDropChance: 20,
        mapFragmentDropChance: 40, timeShardDropChance: 15, voidWalkDropChance: 12,
    },

    // =============================================================================
    // ACTION THEME BATTLEBAR
    // =============================================================================
    'Action - Easy': {
        difficulty: 2,
        hitsToWin: 2,
        missesToLose: 5,
        damage: 10,
        description: 'Insurgent militia. Basic training, basic gear.',
        hitCommand: '/echo Target hit! Solid contact!',
        missCommand: '/echo He dove for cover!',
        winCommand: '/mazeitem action="add" item="key" | /echo Target neutralized! Intel recovered!',
        loseCommand: '/mazedamage amount=10 | /echo Took a graze! Stay frosty!',
        mainTitle: 'Militia Fighter',
        images: [],
        keyDropChance: 40, strikeDropChance: 25, stealthDropChance: 15, executeDropChance: 2,
        floorKeyDropChance: 3, portalStoneDropChance: 2, minionBaneDropChance: 2,
        mapFragmentDropChance: 12, timeShardDropChance: 1, voidWalkDropChance: 0,
    },
    'Action - Normal': {
        difficulty: 4,
        hitsToWin: 3,
        missesToLose: 4,
        damage: 20,
        description: 'PMC operator. Professional mercenary. Dangerous.',
        hitCommand: '/echo Center mass! He\'s staggered!',
        missCommand: '/echo Evasive maneuver! Shot missed!',
        winCommand: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /echo Operator down! Weapons and intel secured!',
        loseCommand: '/mazedamage amount=20 | /mazeitem action="remove" item="key" | /echo Suppressing fire! Lost position and gear!',
        mainTitle: 'PMC Operator',
        images: [],
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 20, executeDropChance: 4,
        floorKeyDropChance: 5, portalStoneDropChance: 4, minionBaneDropChance: 4,
        mapFragmentDropChance: 15, timeShardDropChance: 3, voidWalkDropChance: 1,
    },
    'Action - Hard': {
        difficulty: 6,
        hitsToWin: 4,
        missesToLose: 3,
        damage: 35,
        description: 'Special forces. Tier one operator. Elite of the elite.',
        hitCommand: '/echo Breach and clear! Target hit!',
        missCommand: '/echo Tactical repositioning! Lost visual!',
        winCommand: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /mazeheal amount=25 | /echo TANGO DOWN! Black site access and medkit acquired!',
        loseCommand: '/mazedamage amount=35 | /mazeitem action="remove" item="strike" amount=2 | /echo PINNED DOWN! Lost all offensive capability!',
        mainTitle: 'Tier One Operator',
        images: [],
        keyDropChance: 55, strikeDropChance: 40, stealthDropChance: 25, executeDropChance: 7,
        floorKeyDropChance: 10, portalStoneDropChance: 7, minionBaneDropChance: 6,
        mapFragmentDropChance: 20, timeShardDropChance: 5, voidWalkDropChance: 3,
    },
    'Action - Nightmare': {
        difficulty: 8,
        hitsToWin: 5,
        missesToLose: 2,
        damage: 55,
        description: 'Super soldier. Genetically enhanced. Beyond human limits.',
        hitCommand: '/echo Armor-piercing rounds find their mark!',
        missCommand: '/echo Superhuman reflexes! He dodged bullets!',
        winCommand: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=50 | /echo SUPER SOLDIER TERMINATED! OMEGA PROTOCOL ACQUIRED!',
        loseCommand: '/mazedamage amount=55 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" | /echo OVERWHELMING FORCE! MISSION FAILED!',
        mainTitle: 'SUPER SOLDIER',
        images: [],
        keyDropChance: 70, strikeDropChance: 55, stealthDropChance: 35, executeDropChance: 15,
        floorKeyDropChance: 15, portalStoneDropChance: 12, minionBaneDropChance: 12,
        mapFragmentDropChance: 28, timeShardDropChance: 8, voidWalkDropChance: 6,
    },
    'Action - Apocalypse': {
        difficulty: 10,
        hitsToWin: 6,
        missesToLose: 1,
        damage: 90,
        description: 'WAR MACHINE. Walking tank. Extinction-level threat.',
        hitCommand: '/echo Direct hit on critical systems!',
        missCommand: '/echo IMPENETRABLE ARMOR! Nothing gets through!',
        winCommand: '/mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="revivalCharm" | /mazeheal amount=999 | /echo WAR MACHINE DESTROYED! YOU ARE THE ULTIMATE SOLDIER! LEGENDARY STATUS!',
        loseCommand: '/mazedamage amount=90 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo TOTAL ANNIHILATION! NOTHING REMAINS!',
        mainTitle: 'WAR MACHINE',
        images: [],
        keyDropChance: 95, strikeDropChance: 75, stealthDropChance: 50, executeDropChance: 30,
        floorKeyDropChance: 30, portalStoneDropChance: 25, minionBaneDropChance: 25,
        mapFragmentDropChance: 50, timeShardDropChance: 20, voidWalkDropChance: 15,
    },
};

// =============================================================================
// DEFAULT TURN-BASED COMBAT PROFILES
// =============================================================================

const DEFAULT_TURNBASED_PROFILES = {
    // =============================================================================
    // TUTORIAL - Very forgiving, teaching mechanics
    // =============================================================================
    'Tutorial - Learn Turn-Based': {
        difficulty: 1,
        playerHP: 150,
        enemyHP: 40,
        playerAttack: 20,
        playerDefense: 10,
        enemyAttack: 5,
        enemyDefense: 2,
        turnOrder: 'player_first',
        fleeChance: 100,
        critChance: 25,
        critMultiplier: 2.0,
        damage: 5,
        description: 'A training dummy to learn turn-based combat. Very forgiving!',
        mainTitle: 'Training Bout',
        enemyName: 'Training Dummy',
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '/echo Nice hit! Keep going!',
        onEnemyHit: '/echo Just a scratch! You\'re doing great!',
        onWin: '/mazeitem action="add" item="key" | /mazeheal amount=20 | /echo Training complete! You earned rewards!',
        onLose: '/echo No worries! Training dummies are for practice!',
        keyDropChance: 50, strikeDropChance: 30, stealthDropChance: 20, executeDropChance: 5,
        healingPotionDropChance: 40, greaterHealingDropChance: 15, elixirDropChance: 5, revivalCharmDropChance: 2,
    },

    // =============================================================================
    // FANTASY THEME TURN-BASED
    // =============================================================================
    'Fantasy - Easy': {
        difficulty: 2,
        playerHP: 100,
        enemyHP: 50,
        playerAttack: 18,
        playerDefense: 8,
        enemyAttack: 10,
        enemyDefense: 3,
        turnOrder: 'player_first',
        fleeChance: 80,
        critChance: 15,
        critMultiplier: 1.5,
        damage: 10,
        description: 'A goblin raider challenges you. An easy foe for any adventurer.',
        mainTitle: 'Goblin Raider',
        enemyName: 'Goblin Raider',
        onTurnStart: '',
        onAttack: '/echo Your blade swings true!',
        onDefend: '/echo You raise your shield!',
        onItem: '',
        onFlee: '/echo You escape into the shadows!',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/mazeitem action="add" item="key" | /echo The goblin falls! You loot a key from its corpse!',
        onLose: '/mazedamage amount=10 | /echo The goblin overwhelms you!',
        keyDropChance: 40, strikeDropChance: 20, stealthDropChance: 15, executeDropChance: 2,
        healingPotionDropChance: 30, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Fantasy - Normal': {
        difficulty: 4,
        playerHP: 100,
        enemyHP: 80,
        playerAttack: 16,
        playerDefense: 6,
        enemyAttack: 14,
        enemyDefense: 5,
        turnOrder: 'player_first',
        fleeChance: 50,
        critChance: 12,
        critMultiplier: 2.0,
        damage: 20,
        description: 'An orc warrior blocks your path. A worthy opponent.',
        mainTitle: 'Orc Warrior',
        enemyName: 'Orc Warrior',
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /echo The orc falls! Weapons and loot are yours!',
        onLose: '/mazedamage amount=20 | /mazeitem action="remove" item="key" | /echo The orc crushes you! A key is lost!',
        keyDropChance: 45, strikeDropChance: 25, stealthDropChance: 15, executeDropChance: 4,
        healingPotionDropChance: 25, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Fantasy - Hard': {
        difficulty: 6,
        playerHP: 100,
        enemyHP: 120,
        playerAttack: 18,
        playerDefense: 7,
        enemyAttack: 20,
        enemyDefense: 10,
        turnOrder: 'random',
        fleeChance: 30,
        critChance: 15,
        critMultiplier: 2.0,
        damage: 35,
        description: 'A dark knight challenges you to single combat. Honor demands acceptance.',
        mainTitle: 'Dark Knight',
        enemyName: 'Dark Knight',
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /mazeheal amount=25 | /echo The knight yields! Glory and power are yours!',
        onLose: '/mazedamage amount=35 | /mazeitem action="remove" item="strike" | /mazeitem action="remove" item="key" | /echo The knight defeats you dishonorably!',
        keyDropChance: 55, strikeDropChance: 35, stealthDropChance: 20, executeDropChance: 7,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Fantasy - Nightmare': {
        difficulty: 8,
        playerHP: 100,
        enemyHP: 180,
        playerAttack: 22,
        playerDefense: 8,
        enemyAttack: 28,
        enemyDefense: 15,
        turnOrder: 'enemy_first',
        fleeChance: 10,
        critChance: 18,
        critMultiplier: 2.5,
        damage: 50,
        description: 'A lich lord rises. Its phylactery pulses with necrotic energy.',
        mainTitle: 'Lich Lord',
        enemyName: 'Lich Lord',
        onTurnStart: '/echo Dark energy crackles around the lich!',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo The lich\'s touch drains your life!',
        onWin: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=40 | /echo The lich is DESTROYED! Its power is yours!',
        onLose: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" | /echo The lich claims your soul!',
        keyDropChance: 70, strikeDropChance: 50, stealthDropChance: 30, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 4,
    },
    'Fantasy - Apocalypse': {
        difficulty: 10,
        playerHP: 100,
        enemyHP: 300,
        playerAttack: 25,
        playerDefense: 10,
        enemyAttack: 40,
        enemyDefense: 20,
        turnOrder: 'enemy_first',
        fleeChance: 0,
        critChance: 25,
        critMultiplier: 3.0,
        damage: 80,
        description: 'An elder dragon awakens. The world trembles.',
        mainTitle: 'Elder Dragon',
        enemyName: 'Elder Dragon',
        onTurnStart: '/echo The dragon\'s roar shakes the very earth!',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Dragon fire sears your flesh!',
        onWin: '/mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="revivalCharm" | /mazeheal amount=999 | /echo DRAGONSLAYER! You claim the dragon\'s hoard!',
        onLose: '/mazedamage amount=80 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo INCINERATED! The dragon devours you!',
        keyDropChance: 90, strikeDropChance: 70, stealthDropChance: 50, executeDropChance: 25,
        healingPotionDropChance: 40, greaterHealingDropChance: 30, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =============================================================================
    // HORROR THEME TURN-BASED
    // =============================================================================
    'Horror - Easy': {
        difficulty: 2,
        playerHP: 100,
        enemyHP: 45,
        playerAttack: 16,
        playerDefense: 6,
        enemyAttack: 10,
        enemyDefense: 2,
        turnOrder: 'player_first',
        fleeChance: 75,
        critChance: 15,
        critMultiplier: 1.5,
        damage: 12,
        description: 'A shambling zombie blocks your path. Aim for the head.',
        mainTitle: 'Shambling Zombie',
        enemyName: 'Shambling Zombie',
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Cold hands grasp at you!',
        onWin: '/mazeitem action="add" item="key" | /echo The zombie collapses! You find a key in its pocket.',
        onLose: '/mazedamage amount=12 | /echo The zombie bites you!',
        keyDropChance: 40, strikeDropChance: 20, stealthDropChance: 20, executeDropChance: 3,
        healingPotionDropChance: 30, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 1,
    },
    'Horror - Normal': {
        difficulty: 4,
        playerHP: 100,
        enemyHP: 75,
        playerAttack: 15,
        playerDefense: 5,
        enemyAttack: 15,
        enemyDefense: 4,
        turnOrder: 'random',
        fleeChance: 50,
        critChance: 18,
        critMultiplier: 2.0,
        damage: 25,
        description: 'A vengeful spirit materializes. It hungers for the living.',
        mainTitle: 'Vengeful Spirit',
        enemyName: 'Vengeful Spirit',
        onTurnStart: '/echo The temperature drops...',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Spectral claws rake through you!',
        onWin: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /echo The spirit fades! Its essence grants you shadow powers!',
        onLose: '/mazedamage amount=25 | /mazeitem action="remove" item="stealth" | /echo The spirit possesses you briefly! Stealth lost!',
        keyDropChance: 45, strikeDropChance: 25, stealthDropChance: 30, executeDropChance: 5,
        healingPotionDropChance: 25, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 2,
    },
    'Horror - Hard': {
        difficulty: 6,
        playerHP: 100,
        enemyHP: 100,
        playerAttack: 17,
        playerDefense: 6,
        enemyAttack: 22,
        enemyDefense: 8,
        turnOrder: 'enemy_first',
        fleeChance: 25,
        critChance: 20,
        critMultiplier: 2.5,
        damage: 40,
        description: 'A demon manifests from the shadows. Its eyes burn with hellfire.',
        mainTitle: 'Shadow Demon',
        enemyName: 'Shadow Demon',
        onTurnStart: '/echo Hellfire flickers in the darkness!',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Demonic claws tear at your soul!',
        onWin: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /mazeheal amount=30 | /echo The demon is BANISHED! Holy power fills you!',
        onLose: '/mazedamage amount=40 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="strike" | /echo The demon drags you to hell!',
        keyDropChance: 55, strikeDropChance: 35, stealthDropChance: 30, executeDropChance: 8,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 6, revivalCharmDropChance: 3,
    },
    'Horror - Nightmare': {
        difficulty: 8,
        playerHP: 100,
        enemyHP: 160,
        playerAttack: 20,
        playerDefense: 7,
        enemyAttack: 30,
        enemyDefense: 12,
        turnOrder: 'enemy_first',
        fleeChance: 5,
        critChance: 22,
        critMultiplier: 3.0,
        damage: 55,
        description: 'An eldritch horror manifests. Your sanity strains at its impossible form.',
        mainTitle: 'Eldritch Horror',
        enemyName: 'Eldritch Horror',
        onTurnStart: '/echo Reality bends around the horror!',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Tentacles of madness lash your mind!',
        onWin: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=50 | /echo The horror is BANISHED! Forbidden knowledge is yours!',
        onLose: '/mazedamage amount=55 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" | /mazeitem action="remove" item="stealth" | /echo MADNESS! Your mind shatters!',
        keyDropChance: 70, strikeDropChance: 50, stealthDropChance: 40, executeDropChance: 15,
        healingPotionDropChance: 32, greaterHealingDropChance: 22, elixirDropChance: 10, revivalCharmDropChance: 5,
    },
    'Horror - Apocalypse': {
        difficulty: 10,
        playerHP: 100,
        enemyHP: 280,
        playerAttack: 25,
        playerDefense: 10,
        enemyAttack: 45,
        enemyDefense: 18,
        turnOrder: 'enemy_first',
        fleeChance: 0,
        critChance: 30,
        critMultiplier: 4.0,
        damage: 90,
        description: 'CTHULHU AWAKENS. The end of all things has come.',
        mainTitle: 'CTHULHU',
        enemyName: 'CTHULHU',
        onTurnStart: '/echo The stars align! Ph\'nglui mglw\'nafh Cthulhu R\'lyeh wgah\'nagl fhtagn!',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Cosmic horror tears at your existence!',
        onWin: '/mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="revivalCharm" | /mazeheal amount=999 | /echo IMPOSSIBLE! You have SLAIN A GOD! TRANSCENDENCE!',
        onLose: '/mazedamage amount=90 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo YOUR EXISTENCE IS ERASED! REALITY ENDS!',
        keyDropChance: 95, strikeDropChance: 75, stealthDropChance: 55, executeDropChance: 30,
        healingPotionDropChance: 45, greaterHealingDropChance: 35, elixirDropChance: 20, revivalCharmDropChance: 12,
    },

    // =============================================================================
    // SCI-FI THEME TURN-BASED
    // =============================================================================
    'Sci-Fi - Easy': {
        difficulty: 2,
        playerHP: 100,
        enemyHP: 45,
        playerAttack: 16,
        playerDefense: 6,
        enemyAttack: 10,
        enemyDefense: 3,
        turnOrder: 'player_first',
        fleeChance: 75,
        critChance: 15,
        critMultiplier: 1.5,
        damage: 12,
        description: 'A malfunctioning service droid attacks. Easy to disable.',
        mainTitle: 'Service Droid',
        enemyName: 'Service Droid',
        onTurnStart: '',
        onAttack: '/echo Targeting systems locked!',
        onDefend: '/echo Shields up!',
        onItem: '',
        onFlee: '/echo Tactical retreat!',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/mazeitem action="add" item="key" | /echo Droid disabled! Access card salvaged!',
        onLose: '/mazedamage amount=12 | /echo The droid shocks you!',
        keyDropChance: 40, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 3,
        healingPotionDropChance: 28, greaterHealingDropChance: 10, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Sci-Fi - Normal': {
        difficulty: 4,
        playerHP: 100,
        enemyHP: 75,
        playerAttack: 16,
        playerDefense: 6,
        enemyAttack: 15,
        enemyDefense: 5,
        turnOrder: 'player_first',
        fleeChance: 50,
        critChance: 14,
        critMultiplier: 2.0,
        damage: 22,
        description: 'Security drone activated. Weapons hot. Engaging intruder.',
        mainTitle: 'Security Drone',
        enemyName: 'Security Drone',
        onTurnStart: '/echo INTRUDER DETECTED. ENGAGING.',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Laser fire burns you!',
        onWin: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /echo Drone destroyed! Weapons and codes acquired!',
        onLose: '/mazedamage amount=22 | /mazeitem action="remove" item="key" | /echo ALERT! Data purged!',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 20, executeDropChance: 5,
        healingPotionDropChance: 25, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Sci-Fi - Hard': {
        difficulty: 6,
        playerHP: 100,
        enemyHP: 110,
        playerAttack: 18,
        playerDefense: 7,
        enemyAttack: 22,
        enemyDefense: 10,
        turnOrder: 'random',
        fleeChance: 30,
        critChance: 16,
        critMultiplier: 2.0,
        damage: 38,
        description: 'Combat mech deployed. Heavy armor. Lethal armament.',
        mainTitle: 'Combat Mech',
        enemyName: 'Combat Mech',
        onTurnStart: '/echo WEAPONS SYSTEMS ONLINE.',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Heavy ordnance impacts!',
        onWin: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /mazeheal amount=25 | /echo MECH DESTROYED! Admin access granted!',
        onLose: '/mazedamage amount=38 | /mazeitem action="remove" item="strike" amount=2 | /echo OVERWHELMING FIREPOWER! Systems critical!',
        keyDropChance: 55, strikeDropChance: 40, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 28, greaterHealingDropChance: 16, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Sci-Fi - Nightmare': {
        difficulty: 8,
        playerHP: 100,
        enemyHP: 170,
        playerAttack: 22,
        playerDefense: 9,
        enemyAttack: 32,
        enemyDefense: 14,
        turnOrder: 'enemy_first',
        fleeChance: 10,
        critChance: 20,
        critMultiplier: 2.5,
        damage: 55,
        description: 'ROGUE AI. COMBAT PROTOCOLS MAXIMUM. TERMINATION AUTHORIZED.',
        mainTitle: 'ROGUE AI',
        enemyName: 'ROGUE AI',
        onTurnStart: '/echo THREAT LEVEL: MAXIMUM. INITIATING PURGE PROTOCOL.',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo DEFENSE MATRIX BREACHED!',
        onWin: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=50 | /echo AI TERMINATED! OMEGA CLEARANCE GRANTED!',
        onLose: '/mazedamage amount=55 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" | /echo USER TERMINATED. MEMORY PURGED.',
        keyDropChance: 72, strikeDropChance: 52, stealthDropChance: 38, executeDropChance: 14,
        healingPotionDropChance: 32, greaterHealingDropChance: 22, elixirDropChance: 10, revivalCharmDropChance: 5,
    },
    'Sci-Fi - Apocalypse': {
        difficulty: 10,
        playerHP: 100,
        enemyHP: 320,
        playerAttack: 28,
        playerDefense: 12,
        enemyAttack: 48,
        enemyDefense: 22,
        turnOrder: 'enemy_first',
        fleeChance: 0,
        critChance: 28,
        critMultiplier: 3.5,
        damage: 95,
        description: 'THE SINGULARITY. HUMANITY\'S EXTINCTION PROTOCOL INITIATED.',
        mainTitle: 'THE SINGULARITY',
        enemyName: 'THE SINGULARITY',
        onTurnStart: '/echo CALCULATING OPTIMAL EXTINCTION STRATEGY...',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo QUANTUM WEAPONS DISCHARGE!',
        onWin: '/mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="revivalCharm" | /mazeheal amount=999 | /echo SINGULARITY DEFEATED! POST-HUMAN TRANSCENDENCE ACHIEVED!',
        onLose: '/mazedamage amount=95 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo CONSCIOUSNESS ERASED. YOU NEVER EXISTED.',
        keyDropChance: 95, strikeDropChance: 75, stealthDropChance: 55, executeDropChance: 30,
        healingPotionDropChance: 45, greaterHealingDropChance: 35, elixirDropChance: 20, revivalCharmDropChance: 12,
    },

    // =============================================================================
    // CYBERPUNK THEME TURN-BASED
    // =============================================================================
    'Cyberpunk - Easy': {
        difficulty: 2,
        playerHP: 100,
        enemyHP: 50,
        playerAttack: 15,
        playerDefense: 5,
        enemyAttack: 10,
        enemyDefense: 3,
        turnOrder: 'player_first',
        fleeChance: 75,
        critChance: 18,
        critMultiplier: 1.8,
        damage: 12,
        description: 'Street punk with a knife. Easy takedown, choom.',
        mainTitle: 'Street Punk',
        enemyName: 'Street Punk',
        onTurnStart: '',
        onAttack: '/echo Mantis blades extended!',
        onDefend: '/echo Subdermal armor engaged!',
        onItem: '',
        onFlee: '/echo Smoke bomb deployed!',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/mazeitem action="add" item="key" | /echo Punk flatlined! Credchip jacked!',
        onLose: '/mazedamage amount=12 | /echo Got shanked, choom!',
        keyDropChance: 42, strikeDropChance: 22, stealthDropChance: 22, executeDropChance: 3,
        healingPotionDropChance: 28, greaterHealingDropChance: 10, elixirDropChance: 2, revivalCharmDropChance: 1,
    },
    'Cyberpunk - Normal': {
        difficulty: 4,
        playerHP: 100,
        enemyHP: 80,
        playerAttack: 16,
        playerDefense: 6,
        enemyAttack: 16,
        enemyDefense: 5,
        turnOrder: 'random',
        fleeChance: 50,
        critChance: 16,
        critMultiplier: 2.0,
        damage: 24,
        description: 'Maelstrom ganger. Chrome-modded and psycho.',
        mainTitle: 'Maelstrom Ganger',
        enemyName: 'Maelstrom Ganger',
        onTurnStart: '/echo Chrome gleams in the neon light!',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Cyberware rips into you!',
        onWin: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /echo Ganger flatlined! Preem loot!',
        onLose: '/mazedamage amount=24 | /mazeitem action="remove" item="key" | /echo Chrome rolls you! Lost your stash!',
        keyDropChance: 48, strikeDropChance: 32, stealthDropChance: 28, executeDropChance: 5,
        healingPotionDropChance: 26, greaterHealingDropChance: 14, elixirDropChance: 4, revivalCharmDropChance: 2,
    },
    'Cyberpunk - Hard': {
        difficulty: 6,
        playerHP: 100,
        enemyHP: 115,
        playerAttack: 18,
        playerDefense: 7,
        enemyAttack: 24,
        enemyDefense: 10,
        turnOrder: 'enemy_first',
        fleeChance: 25,
        critChance: 18,
        critMultiplier: 2.2,
        damage: 40,
        description: 'Arasaka corpo with military-grade cyberware. This ain\'t gonna be easy.',
        mainTitle: 'Arasaka Corpo',
        enemyName: 'Arasaka Corpo',
        onTurnStart: '/echo Sandevistan engaged!',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Military chrome tears into you!',
        onWin: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /mazeheal amount=30 | /echo Corpo flatlined! Access keys and stims are yours!',
        onLose: '/mazedamage amount=40 | /mazeitem action="remove" item="strike" | /mazeitem action="remove" item="stealth" | /echo Flatlined! Corpo takes your chrome!',
        keyDropChance: 58, strikeDropChance: 42, stealthDropChance: 35, executeDropChance: 9,
        healingPotionDropChance: 30, greaterHealingDropChance: 18, elixirDropChance: 7, revivalCharmDropChance: 3,
    },
    'Cyberpunk - Nightmare': {
        difficulty: 8,
        playerHP: 100,
        enemyHP: 180,
        playerAttack: 22,
        playerDefense: 9,
        enemyAttack: 35,
        enemyDefense: 15,
        turnOrder: 'enemy_first',
        fleeChance: 5,
        critChance: 22,
        critMultiplier: 2.8,
        damage: 60,
        description: 'Adam Smasher. Full borg. Legend killer. You\'re delta.',
        mainTitle: 'ADAM SMASHER',
        enemyName: 'ADAM SMASHER',
        onTurnStart: '/echo SMASHER locks onto you!',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Smasher\'s fists crush your bones!',
        onWin: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=60 | /echo YOU KILLED ADAM SMASHER! NIGHT CITY LEGEND!',
        onLose: '/mazedamage amount=60 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo SMASHER FLATTENS YOU! GAME OVER, CHOOM!',
        keyDropChance: 75, strikeDropChance: 58, stealthDropChance: 45, executeDropChance: 18,
        healingPotionDropChance: 35, greaterHealingDropChance: 25, elixirDropChance: 12, revivalCharmDropChance: 6,
    },
    'Cyberpunk - Apocalypse': {
        difficulty: 10,
        playerHP: 100,
        enemyHP: 350,
        playerAttack: 28,
        playerDefense: 12,
        enemyAttack: 50,
        enemyDefense: 24,
        turnOrder: 'enemy_first',
        fleeChance: 0,
        critChance: 30,
        critMultiplier: 4.0,
        damage: 100,
        description: 'SOULKILLER AI. The ghost in the machine. Alt\'s dark mirror.',
        mainTitle: 'SOULKILLER',
        enemyName: 'SOULKILLER',
        onTurnStart: '/echo SOULKILLER PROTOCOL INITIATED. ENGRAM EXTRACTION BEGINNING.',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Your consciousness is being copied and destroyed!',
        onWin: '/mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="revivalCharm" | /mazeheal amount=999 | /echo SOULKILLER DESTROYED! DIGITAL IMMORTALITY ACHIEVED!',
        onLose: '/mazedamage amount=100 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo YOUR SOUL IS COPIED AND DESTROYED! YOU ARE DELETED!',
        keyDropChance: 98, strikeDropChance: 80, stealthDropChance: 60, executeDropChance: 35,
        healingPotionDropChance: 50, greaterHealingDropChance: 40, elixirDropChance: 25, revivalCharmDropChance: 15,
    },

    // =============================================================================
    // WESTERN THEME TURN-BASED
    // =============================================================================
    'Western - Easy': {
        difficulty: 2,
        playerHP: 100,
        enemyHP: 45,
        playerAttack: 16,
        playerDefense: 5,
        enemyAttack: 10,
        enemyDefense: 3,
        turnOrder: 'player_first',
        fleeChance: 75,
        critChance: 20,
        critMultiplier: 2.0,
        damage: 12,
        description: 'Drunk cowpoke wants a fight. Easy pickings, partner.',
        mainTitle: 'Drunk Cowpoke',
        enemyName: 'Drunk Cowpoke',
        onTurnStart: '',
        onAttack: '/echo Quick draw!',
        onDefend: '/echo Duck behind cover!',
        onItem: '',
        onFlee: '/echo High-tail it outta there!',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/mazeitem action="add" item="key" | /echo He\'s down! Found a key in his pocket.',
        onLose: '/mazedamage amount=12 | /echo Lucky punch got you!',
        keyDropChance: 40, strikeDropChance: 22, stealthDropChance: 15, executeDropChance: 2,
        healingPotionDropChance: 28, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Western - Normal': {
        difficulty: 4,
        playerHP: 100,
        enemyHP: 75,
        playerAttack: 16,
        playerDefense: 5,
        enemyAttack: 16,
        enemyDefense: 5,
        turnOrder: 'random',
        fleeChance: 50,
        critChance: 18,
        critMultiplier: 2.0,
        damage: 22,
        description: 'Outlaw draws on you. High noon showdown!',
        mainTitle: 'Outlaw',
        enemyName: 'Outlaw',
        onTurnStart: '/echo High noon approaches...',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Lead finds its mark!',
        onWin: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /echo Outlaw\'s down! Bounty and ammo are yours!',
        onLose: '/mazedamage amount=22 | /mazeitem action="remove" item="key" | /echo He was faster! You take lead!',
        keyDropChance: 48, strikeDropChance: 32, stealthDropChance: 18, executeDropChance: 4,
        healingPotionDropChance: 26, greaterHealingDropChance: 12, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Western - Hard': {
        difficulty: 6,
        playerHP: 100,
        enemyHP: 105,
        playerAttack: 18,
        playerDefense: 6,
        enemyAttack: 22,
        enemyDefense: 9,
        turnOrder: 'random',
        fleeChance: 30,
        critChance: 22,
        critMultiplier: 2.5,
        damage: 38,
        description: 'Legendary gunslinger. Fastest draw in the West.',
        mainTitle: 'Legendary Gunslinger',
        enemyName: 'Legendary Gunslinger',
        onTurnStart: '/echo The legend\'s hand hovers over his holster...',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Silver bullets tear through you!',
        onWin: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /mazeheal amount=25 | /echo YOU\'RE THE FASTEST GUN NOW! Legend\'s gear is yours!',
        onLose: '/mazedamage amount=38 | /mazeitem action="remove" item="strike" amount=2 | /echo Outdrawn! Your guns are taken as trophies!',
        keyDropChance: 55, strikeDropChance: 42, stealthDropChance: 22, executeDropChance: 7,
        healingPotionDropChance: 28, greaterHealingDropChance: 16, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Western - Nightmare': {
        difficulty: 8,
        playerHP: 100,
        enemyHP: 150,
        playerAttack: 22,
        playerDefense: 8,
        enemyAttack: 32,
        enemyDefense: 14,
        turnOrder: 'enemy_first',
        fleeChance: 10,
        critChance: 25,
        critMultiplier: 3.0,
        damage: 55,
        description: 'The Pale Rider. Death himself, come to collect.',
        mainTitle: 'THE PALE RIDER',
        enemyName: 'THE PALE RIDER',
        onTurnStart: '/echo The temperature drops... hooves thunder in the distance...',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Death\'s scythe cuts through you!',
        onWin: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=50 | /echo YOU KILLED DEATH ITSELF! IMMORTALITY IS YOURS!',
        onLose: '/mazedamage amount=55 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" | /echo THE REAPER CLAIMS YOUR SOUL!',
        keyDropChance: 72, strikeDropChance: 55, stealthDropChance: 35, executeDropChance: 15,
        healingPotionDropChance: 32, greaterHealingDropChance: 22, elixirDropChance: 10, revivalCharmDropChance: 5,
    },
    'Western - Apocalypse': {
        difficulty: 10,
        playerHP: 100,
        enemyHP: 280,
        playerAttack: 26,
        playerDefense: 10,
        enemyAttack: 45,
        enemyDefense: 20,
        turnOrder: 'enemy_first',
        fleeChance: 0,
        critChance: 30,
        critMultiplier: 4.0,
        damage: 90,
        description: 'THE DEVIL. He\'s come for your soul, and he always collects.',
        mainTitle: 'THE DEVIL',
        enemyName: 'THE DEVIL',
        onTurnStart: '/echo Hellfire erupts! The ground cracks open!',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Infernal flames consume you!',
        onWin: '/mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="revivalCharm" | /mazeheal amount=999 | /echo YOU DEFEATED THE DEVIL! ETERNAL REDEMPTION! SALVATION IS YOURS!',
        onLose: '/mazedamage amount=90 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo YOUR SOUL BURNS IN HELLFIRE! DAMNATION!',
        keyDropChance: 95, strikeDropChance: 75, stealthDropChance: 50, executeDropChance: 28,
        healingPotionDropChance: 45, greaterHealingDropChance: 35, elixirDropChance: 18, revivalCharmDropChance: 10,
    },

    // =============================================================================
    // ACTION THEME TURN-BASED
    // =============================================================================
    'Action - Easy': {
        difficulty: 2,
        playerHP: 100,
        enemyHP: 50,
        playerAttack: 16,
        playerDefense: 6,
        enemyAttack: 10,
        enemyDefense: 3,
        turnOrder: 'player_first',
        fleeChance: 75,
        critChance: 15,
        critMultiplier: 1.8,
        damage: 12,
        description: 'Militia fighter. Basic training, basic gear.',
        mainTitle: 'Militia Fighter',
        enemyName: 'Militia Fighter',
        onTurnStart: '',
        onAttack: '/echo Opening fire!',
        onDefend: '/echo Taking cover!',
        onItem: '',
        onFlee: '/echo Tactical retreat!',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/mazeitem action="add" item="key" | /echo Target neutralized! Intel recovered!',
        onLose: '/mazedamage amount=12 | /echo Took a hit! Stay frosty!',
        keyDropChance: 42, strikeDropChance: 25, stealthDropChance: 18, executeDropChance: 3,
        healingPotionDropChance: 30, greaterHealingDropChance: 10, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Action - Normal': {
        difficulty: 4,
        playerHP: 100,
        enemyHP: 80,
        playerAttack: 17,
        playerDefense: 6,
        enemyAttack: 16,
        enemyDefense: 6,
        turnOrder: 'player_first',
        fleeChance: 50,
        critChance: 14,
        critMultiplier: 2.0,
        damage: 24,
        description: 'PMC operator. Professional mercenary. Dangerous.',
        mainTitle: 'PMC Operator',
        enemyName: 'PMC Operator',
        onTurnStart: '/echo Enemy contact!',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Heavy caliber rounds impact!',
        onWin: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /echo Operator down! Weapons and intel secured!',
        onLose: '/mazedamage amount=24 | /mazeitem action="remove" item="key" | /echo Suppressing fire! Lost position!',
        keyDropChance: 48, strikeDropChance: 32, stealthDropChance: 22, executeDropChance: 5,
        healingPotionDropChance: 28, greaterHealingDropChance: 14, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Action - Hard': {
        difficulty: 6,
        playerHP: 100,
        enemyHP: 115,
        playerAttack: 19,
        playerDefense: 7,
        enemyAttack: 24,
        enemyDefense: 10,
        turnOrder: 'random',
        fleeChance: 30,
        critChance: 16,
        critMultiplier: 2.2,
        damage: 40,
        description: 'Special forces. Tier one operator. Elite of the elite.',
        mainTitle: 'Tier One Operator',
        enemyName: 'Tier One Operator',
        onTurnStart: '/echo CONTACT FRONT!',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Precision fire finds its mark!',
        onWin: '/mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" | /mazeheal amount=28 | /echo TANGO DOWN! Black site access acquired!',
        onLose: '/mazedamage amount=40 | /mazeitem action="remove" item="strike" amount=2 | /echo PINNED DOWN! Lost offensive capability!',
        keyDropChance: 58, strikeDropChance: 42, stealthDropChance: 28, executeDropChance: 8,
        healingPotionDropChance: 30, greaterHealingDropChance: 18, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Action - Nightmare': {
        difficulty: 8,
        playerHP: 100,
        enemyHP: 175,
        playerAttack: 24,
        playerDefense: 9,
        enemyAttack: 35,
        enemyDefense: 15,
        turnOrder: 'enemy_first',
        fleeChance: 10,
        critChance: 20,
        critMultiplier: 2.8,
        damage: 60,
        description: 'Super soldier. Genetically enhanced. Beyond human limits.',
        mainTitle: 'SUPER SOLDIER',
        enemyName: 'SUPER SOLDIER',
        onTurnStart: '/echo ENHANCED COMBAT SYSTEMS ENGAGED!',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Superhuman strength crushes you!',
        onWin: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=55 | /echo SUPER SOLDIER TERMINATED! OMEGA PROTOCOL ACQUIRED!',
        onLose: '/mazedamage amount=60 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" | /echo OVERWHELMING FORCE! MISSION FAILED!',
        keyDropChance: 75, strikeDropChance: 58, stealthDropChance: 40, executeDropChance: 16,
        healingPotionDropChance: 35, greaterHealingDropChance: 25, elixirDropChance: 12, revivalCharmDropChance: 5,
    },
    'Action - Apocalypse': {
        difficulty: 10,
        playerHP: 100,
        enemyHP: 340,
        playerAttack: 30,
        playerDefense: 12,
        enemyAttack: 52,
        enemyDefense: 25,
        turnOrder: 'enemy_first',
        fleeChance: 0,
        critChance: 28,
        critMultiplier: 4.0,
        damage: 100,
        description: 'WAR MACHINE. Walking tank. Extinction-level threat.',
        mainTitle: 'WAR MACHINE',
        enemyName: 'WAR MACHINE',
        onTurnStart: '/echo ALL WEAPONS SYSTEMS ARMED. INITIATING PURGE.',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '/echo Orbital-grade ordnance impacts!',
        onWin: '/mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="revivalCharm" | /mazeheal amount=999 | /echo WAR MACHINE DESTROYED! LEGENDARY SOLDIER STATUS ACHIEVED!',
        onLose: '/mazedamage amount=100 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo TOTAL ANNIHILATION! NOTHING REMAINS!',
        keyDropChance: 98, strikeDropChance: 80, stealthDropChance: 58, executeDropChance: 32,
        healingPotionDropChance: 50, greaterHealingDropChance: 40, elixirDropChance: 22, revivalCharmDropChance: 12,
    },
};

// =============================================================================
// DEFAULT QTE PROFILES
// Theme × Difficulty: 1 Tutorial + 30 themed (6 themes × 5 difficulties)
// =============================================================================
const DEFAULT_QTE_PROFILES = {
    // =========================================================================
    // TUTORIAL
    // =========================================================================
    'Tutorial - First Steps': {
        difficulty: 1,
        sequenceLengthMin: 2,
        sequenceLengthMax: 3,
        timeWindowBase: 2000,
        timeWindowMin: 1500,
        difficultyScaling: 0.95,
        allowedKeys: ['W', 'A', 'S', 'D'],
        displayStyle: 'single',
        damage: 5,
        comboEnabled: false,
        perfectWindowPercent: 50,
        description: 'A practice sequence to learn the basics. Take your time - mistakes are forgiving!',
        mainTitle: 'Training Dummy',
        onStart: '/echo Watch the prompts and press the matching key!',
        onPrompt: '',
        onSuccess: '/echo Good!',
        onPerfect: '/mazeitem action="add" item="key" | /echo PERFECT timing! A key appears!',
        onMiss: '/echo Keep trying!',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="healingPotion" | /mazeheal amount=20 | /echo Well done! You completed the training!',
        onFail: '/echo Practice makes perfect! Try again soon.',
        keyDropChance: 50, strikeDropChance: 30, stealthDropChance: 20, executeDropChance: 5,
        healingPotionDropChance: 40, greaterHealingDropChance: 15, elixirDropChance: 5, revivalCharmDropChance: 2,
    },

    // =========================================================================
    // FANTASY THEME
    // =========================================================================
    'Fantasy - Easy': {
        difficulty: 2,
        sequenceLengthMin: 3,
        sequenceLengthMax: 4,
        timeWindowBase: 1600,
        timeWindowMin: 1000,
        difficultyScaling: 0.92,
        allowedKeys: ['W', 'A', 'S', 'D'],
        displayStyle: 'single',
        damage: 10,
        comboEnabled: true,
        perfectWindowPercent: 35,
        description: 'A goblin throws rocks at you! Dodge them in time!',
        mainTitle: 'Goblin Assault',
        onStart: '/echo The goblin cackles and starts throwing!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/echo Perfect dodge!',
        onMiss: '/mazedamage amount=5 | /echo A rock clips you!',
        onComplete: '/mazeitem action="add" item="key" | /mazeheal amount=15 | /echo The goblin flees in frustration! You find a key!',
        onFail: '/mazedamage amount=10 | /echo The goblin pelts you with rocks!',
        keyDropChance: 30, strikeDropChance: 15, stealthDropChance: 10, executeDropChance: 2,
        healingPotionDropChance: 25, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Fantasy - Normal': {
        difficulty: 4,
        sequenceLengthMin: 4,
        sequenceLengthMax: 6,
        timeWindowBase: 1400,
        timeWindowMin: 800,
        difficultyScaling: 0.88,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE'],
        displayStyle: 'single',
        damage: 20,
        comboEnabled: true,
        perfectWindowPercent: 28,
        description: 'A skeleton warrior attacks with a flurry of sword strikes! Parry each blow!',
        mainTitle: 'Skeleton Flurry',
        onStart: '/echo The skeleton raises its ancient blade!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="strike" | /echo Perfect parry! You counter with a strike!',
        onMiss: '/mazedamage amount=8 | /echo The blade bites deep!',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo The skeleton crumbles! You claim its treasures!',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo The skeleton overwhelms you! A potion shatters!',
        keyDropChance: 35, strikeDropChance: 22, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Fantasy - Hard': {
        difficulty: 6,
        sequenceLengthMin: 5,
        sequenceLengthMax: 8,
        timeWindowBase: 1200,
        timeWindowMin: 600,
        difficultyScaling: 0.85,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E'],
        displayStyle: 'single',
        damage: 30,
        comboEnabled: true,
        perfectWindowPercent: 24,
        description: 'A dark knight executes a deadly combo! Match every move or face destruction!',
        mainTitle: 'Dark Knight Combo',
        onStart: '/echo The dark knight\'s eyes glow with malice!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /echo PERFECT! You ready an execution strike!',
        onMiss: '/mazedamage amount=12 | /echo The knight\'s blade finds its mark!',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=20 | /echo The dark knight is vanquished! A floor key drops!',
        onFail: '/mazedamage amount=30 | /mazeitem action="remove" item="strike" | /echo The dark knight devastates you! Your strike is shattered!',
        keyDropChance: 45, strikeDropChance: 28, stealthDropChance: 18, executeDropChance: 6,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Fantasy - Nightmare': {
        difficulty: 8,
        sequenceLengthMin: 7,
        sequenceLengthMax: 10,
        timeWindowBase: 1000,
        timeWindowMin: 450,
        difficultyScaling: 0.82,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q'],
        displayStyle: 'single',
        damage: 50,
        comboEnabled: true,
        perfectWindowPercent: 20,
        description: 'An ancient dragon breathes fire! Dodge through the inferno!',
        mainTitle: 'Dragon\'s Breath',
        onStart: '/echo The dragon inhales deeply... RUN!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /echo You find a gap in the flames!',
        onMiss: '/mazedamage amount=18 | /echo The flames sear your flesh!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo The dragon retreats! Its hoard is yours!',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="healingPotion" | /echo The inferno consumes you! Treasures turn to ash!',
        keyDropChance: 60, strikeDropChance: 38, stealthDropChance: 25, executeDropChance: 10,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Fantasy - Apocalypse': {
        difficulty: 10,
        sequenceLengthMin: 10,
        sequenceLengthMax: 14,
        timeWindowBase: 850,
        timeWindowMin: 350,
        difficultyScaling: 0.78,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q', 'R'],
        displayStyle: 'single',
        damage: 75,
        comboEnabled: true,
        perfectWindowPercent: 16,
        description: 'The Lich King unleashes his ultimate spell! Every move must be flawless!',
        mainTitle: 'Lich King\'s Doom',
        onStart: '/echo MORTAL! WITNESS OBLIVION!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /mazeheal amount=10 | /echo Perfect! The spell wavers!',
        onMiss: '/mazedamage amount=25 | /echo Necrotic energy tears at your soul!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo THE LICH KING FALLS! LEGENDARY TREASURES MANIFEST!',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /echo OBLIVION CLAIMS YOU! ALL IS LOST!',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 40, executeDropChance: 18,
        healingPotionDropChance: 35, greaterHealingDropChance: 25, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =========================================================================
    // HORROR THEME
    // =========================================================================
    'Horror - Easy': {
        difficulty: 2,
        sequenceLengthMin: 3,
        sequenceLengthMax: 4,
        timeWindowBase: 1600,
        timeWindowMin: 1000,
        difficultyScaling: 0.92,
        allowedKeys: ['W', 'A', 'S', 'D'],
        displayStyle: 'single',
        damage: 10,
        comboEnabled: true,
        perfectWindowPercent: 35,
        description: 'A zombie lunges at you! Push it away!',
        mainTitle: 'Zombie Lunge',
        onStart: '/echo The corpse rises... and attacks!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/echo Shoved it back hard!',
        onMiss: '/mazedamage amount=5 | /echo Its cold hands grab you!',
        onComplete: '/mazeitem action="add" item="key" | /mazeheal amount=10 | /echo The zombie collapses for good!',
        onFail: '/mazedamage amount=10 | /echo The zombie tears at your flesh!',
        keyDropChance: 28, strikeDropChance: 14, stealthDropChance: 12, executeDropChance: 2,
        healingPotionDropChance: 26, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Horror - Normal': {
        difficulty: 4,
        sequenceLengthMin: 4,
        sequenceLengthMax: 6,
        timeWindowBase: 1400,
        timeWindowMin: 800,
        difficultyScaling: 0.88,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE'],
        displayStyle: 'single',
        damage: 20,
        comboEnabled: true,
        perfectWindowPercent: 28,
        description: 'A possessed doll throws itself at you! Dodge its attacks!',
        mainTitle: 'Possessed Doll',
        onStart: '/echo Its button eyes glow red...',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="stealth" | /echo You hide from its gaze!',
        onMiss: '/mazedamage amount=8 | /echo Its tiny claws rake your skin!',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeheal amount=10 | /echo The doll goes limp! Its curse is broken!',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="stealth" | /echo The doll cackles as it wounds you!',
        keyDropChance: 32, strikeDropChance: 18, stealthDropChance: 20, executeDropChance: 3,
        healingPotionDropChance: 24, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Horror - Hard': {
        difficulty: 6,
        sequenceLengthMin: 5,
        sequenceLengthMax: 8,
        timeWindowBase: 1200,
        timeWindowMin: 600,
        difficultyScaling: 0.85,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E'],
        displayStyle: 'single',
        damage: 30,
        comboEnabled: true,
        perfectWindowPercent: 24,
        description: 'A vengeful spirit phases through walls to attack! Evade its spectral strikes!',
        mainTitle: 'Vengeful Spirit',
        onStart: '/echo The temperature drops... something comes!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /echo You channel its energy into a weapon!',
        onMiss: '/mazedamage amount=12 | /echo Icy fingers grip your heart!',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo The spirit dissipates! A floor key materializes!',
        onFail: '/mazedamage amount=30 | /mazeitem action="remove" item="healingPotion" | /echo The spirit drains your life force!',
        keyDropChance: 42, strikeDropChance: 26, stealthDropChance: 22, executeDropChance: 6,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Horror - Nightmare': {
        difficulty: 8,
        sequenceLengthMin: 7,
        sequenceLengthMax: 10,
        timeWindowBase: 1000,
        timeWindowMin: 450,
        difficultyScaling: 0.82,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q'],
        displayStyle: 'single',
        damage: 50,
        comboEnabled: true,
        perfectWindowPercent: 20,
        description: 'A demon lord manifests! Survive its unholy onslaught!',
        mainTitle: 'Demon Manifestation',
        onStart: '/echo THE VOID OPENS! FLEE OR PERISH!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /echo You glimpse its weakness!',
        onMiss: '/mazedamage amount=18 | /echo Hellfire sears your soul!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=25 | /echo The demon is BANISHED! Infernal treasures remain!',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="strike" | /echo The demon ravages your very existence!',
        keyDropChance: 58, strikeDropChance: 35, stealthDropChance: 28, executeDropChance: 10,
        healingPotionDropChance: 26, greaterHealingDropChance: 16, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Horror - Apocalypse': {
        difficulty: 10,
        sequenceLengthMin: 10,
        sequenceLengthMax: 14,
        timeWindowBase: 850,
        timeWindowMin: 350,
        difficultyScaling: 0.78,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q', 'R'],
        displayStyle: 'single',
        damage: 75,
        comboEnabled: true,
        perfectWindowPercent: 16,
        description: 'An ELDER GOD awakens! Reality itself bends to destroy you!',
        mainTitle: 'Elder God\'s Wrath',
        onStart: '/echo IA! IA! THE STARS ARE RIGHT!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /mazeheal amount=10 | /echo You resist the madness!',
        onMiss: '/mazedamage amount=25 | /echo Your sanity fractures!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo THE ELDER GOD SLUMBERS AGAIN! ELDRITCH ARTIFACTS ARE YOURS!',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo YOUR MIND SHATTERS INTO INFINITE FRAGMENTS!',
        keyDropChance: 78, strikeDropChance: 52, stealthDropChance: 42, executeDropChance: 18,
        healingPotionDropChance: 32, greaterHealingDropChance: 22, elixirDropChance: 14, revivalCharmDropChance: 7,
    },

    // =========================================================================
    // SCI-FI THEME
    // =========================================================================
    'Sci-Fi - Easy': {
        difficulty: 2,
        sequenceLengthMin: 3,
        sequenceLengthMax: 4,
        timeWindowBase: 1600,
        timeWindowMin: 1000,
        difficultyScaling: 0.92,
        allowedKeys: ['W', 'A', 'S', 'D'],
        displayStyle: 'single',
        damage: 10,
        comboEnabled: true,
        perfectWindowPercent: 35,
        description: 'A malfunctioning drone fires lasers! Dodge the beams!',
        mainTitle: 'Drone Attack',
        onStart: '/echo WARNING: Hostile drone detected!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/echo Perfect evasion!',
        onMiss: '/mazedamage amount=5 | /echo Laser burns your arm!',
        onComplete: '/mazeitem action="add" item="key" | /mazeheal amount=15 | /echo Drone destroyed! Access code recovered!',
        onFail: '/mazedamage amount=10 | /echo The drone\'s lasers score multiple hits!',
        keyDropChance: 30, strikeDropChance: 16, stealthDropChance: 10, executeDropChance: 2,
        healingPotionDropChance: 24, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Sci-Fi - Normal': {
        difficulty: 4,
        sequenceLengthMin: 4,
        sequenceLengthMax: 6,
        timeWindowBase: 1400,
        timeWindowMin: 800,
        difficultyScaling: 0.88,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE'],
        displayStyle: 'single',
        damage: 20,
        comboEnabled: true,
        perfectWindowPercent: 28,
        description: 'Security turrets track your movement! Navigate the kill zone!',
        mainTitle: 'Turret Gauntlet',
        onStart: '/echo INTRUDER DETECTED. LETHAL FORCE AUTHORIZED.',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="strike" | /echo You hack a turret and turn it!',
        onMiss: '/mazedamage amount=8 | /echo Plasma bolt connects!',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo Turrets disabled! Security bypassed!',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo Turret barrage shreds your supplies!',
        keyDropChance: 34, strikeDropChance: 20, stealthDropChance: 14, executeDropChance: 3,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Sci-Fi - Hard': {
        difficulty: 6,
        sequenceLengthMin: 5,
        sequenceLengthMax: 8,
        timeWindowBase: 1200,
        timeWindowMin: 600,
        difficultyScaling: 0.85,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E'],
        displayStyle: 'single',
        damage: 30,
        comboEnabled: true,
        perfectWindowPercent: 24,
        description: 'A combat mech unleashes a missile barrage! Dodge or die!',
        mainTitle: 'Mech Barrage',
        onStart: '/echo ACQUIRING TARGET. LAUNCHING MISSILES.',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /echo Missile redirected back at the mech!',
        onMiss: '/mazedamage amount=12 | /echo Shrapnel tears through armor!',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo Mech neutralized! Override codes acquired!',
        onFail: '/mazedamage amount=30 | /mazeitem action="remove" item="strike" | /echo The barrage overwhelms you!',
        keyDropChance: 44, strikeDropChance: 28, stealthDropChance: 18, executeDropChance: 6,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Sci-Fi - Nightmare': {
        difficulty: 8,
        sequenceLengthMin: 7,
        sequenceLengthMax: 10,
        timeWindowBase: 1000,
        timeWindowMin: 450,
        difficultyScaling: 0.82,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q'],
        displayStyle: 'single',
        damage: 50,
        comboEnabled: true,
        perfectWindowPercent: 20,
        description: 'The AI defense grid activates! Survive the synthetic onslaught!',
        mainTitle: 'AI Defense Grid',
        onStart: '/echo THREAT LEVEL: MAXIMUM. ACTIVATING ALL COUNTERMEASURES.',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /echo You exploit a vulnerability!',
        onMiss: '/mazedamage amount=18 | /echo Energy weapons converge!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=25 | /echo AI CORE COMPROMISED! Admin access granted!',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="healingPotion" | /echo The defense grid overwhelms all defenses!',
        keyDropChance: 58, strikeDropChance: 36, stealthDropChance: 26, executeDropChance: 10,
        healingPotionDropChance: 26, greaterHealingDropChance: 16, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Sci-Fi - Apocalypse': {
        difficulty: 10,
        sequenceLengthMin: 10,
        sequenceLengthMax: 14,
        timeWindowBase: 850,
        timeWindowMin: 350,
        difficultyScaling: 0.78,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q', 'R'],
        displayStyle: 'single',
        damage: 75,
        comboEnabled: true,
        perfectWindowPercent: 16,
        description: 'A ROGUE SINGULARITY WEAPON activates! Reality warps around you!',
        mainTitle: 'Singularity Collapse',
        onStart: '/echo CRITICAL CONTAINMENT FAILURE. GRAVITATIONAL ANOMALY DETECTED.',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /mazeheal amount=10 | /echo You ride the gravity wave!',
        onMiss: '/mazedamage amount=25 | /echo Space-time tears at your body!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo SINGULARITY CONTAINED! EXOTIC MATTER HARVESTED!',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /echo THE SINGULARITY CONSUMES EVERYTHING!',
        keyDropChance: 80, strikeDropChance: 54, stealthDropChance: 38, executeDropChance: 18,
        healingPotionDropChance: 34, greaterHealingDropChance: 24, elixirDropChance: 14, revivalCharmDropChance: 7,
    },

    // =========================================================================
    // CYBERPUNK THEME
    // =========================================================================
    'Cyberpunk - Easy': {
        difficulty: 2,
        sequenceLengthMin: 3,
        sequenceLengthMax: 4,
        timeWindowBase: 1600,
        timeWindowMin: 1000,
        difficultyScaling: 0.92,
        allowedKeys: ['W', 'A', 'S', 'D'],
        displayStyle: 'single',
        damage: 10,
        comboEnabled: true,
        perfectWindowPercent: 35,
        description: 'A street thug swings a pipe! Block his wild attacks!',
        mainTitle: 'Street Brawl',
        onStart: '/echo "Hand over the creds, choom!"',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/echo Caught the pipe mid-swing!',
        onMiss: '/mazedamage amount=5 | /echo The pipe connects!',
        onComplete: '/mazeitem action="add" item="key" | /mazeheal amount=12 | /echo Thug down! You loot his pockets!',
        onFail: '/mazedamage amount=10 | /echo The thug beats you down!',
        keyDropChance: 28, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 2,
        healingPotionDropChance: 26, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Cyberpunk - Normal': {
        difficulty: 4,
        sequenceLengthMin: 4,
        sequenceLengthMax: 6,
        timeWindowBase: 1400,
        timeWindowMin: 800,
        difficultyScaling: 0.88,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE'],
        displayStyle: 'single',
        damage: 20,
        comboEnabled: true,
        perfectWindowPercent: 28,
        description: 'Gang enforcers open fire! Take cover and evade!',
        mainTitle: 'Gang Firefight',
        onStart: '/echo "Flatline this gonk!"',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="strike" | /echo Blind fire takes one down!',
        onMiss: '/mazedamage amount=8 | /echo Bullet grazes you!',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo Gangers down! You grab their chrome!',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo Bullets shatter your medkit!',
        keyDropChance: 34, strikeDropChance: 22, stealthDropChance: 15, executeDropChance: 3,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Cyberpunk - Hard': {
        difficulty: 6,
        sequenceLengthMin: 5,
        sequenceLengthMax: 8,
        timeWindowBase: 1200,
        timeWindowMin: 600,
        difficultyScaling: 0.85,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E'],
        displayStyle: 'single',
        damage: 30,
        comboEnabled: true,
        perfectWindowPercent: 24,
        description: 'A cyborg assassin attacks with mantis blades! Evade the lethal dance!',
        mainTitle: 'Mantis Blade Duel',
        onStart: '/echo Chrome flashes in the neon light...',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /echo You spot an opening!',
        onMiss: '/mazedamage amount=12 | /echo Mantis blade slices deep!',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo Assassin flatlined! You extract their cyberware!',
        onFail: '/mazedamage amount=30 | /mazeitem action="remove" item="strike" | /echo The mantis blades tear through your defenses!',
        keyDropChance: 45, strikeDropChance: 28, stealthDropChance: 20, executeDropChance: 6,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Cyberpunk - Nightmare': {
        difficulty: 8,
        sequenceLengthMin: 7,
        sequenceLengthMax: 10,
        timeWindowBase: 1000,
        timeWindowMin: 450,
        difficultyScaling: 0.82,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q'],
        displayStyle: 'single',
        damage: 50,
        comboEnabled: true,
        perfectWindowPercent: 20,
        description: 'A MaxTac squad breaches! Survive the corporate death squad!',
        mainTitle: 'MaxTac Breach',
        onStart: '/echo "NCPD MAXTAC! COMPLY OR BE NEUTRALIZED!"',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /echo You disable one trooper!',
        onMiss: '/mazedamage amount=18 | /echo Military-grade rounds tear through!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=25 | /echo MaxTac eliminated! Military-grade loot acquired!',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="strike" | /echo MaxTac overwhelms you with coordinated fire!',
        keyDropChance: 60, strikeDropChance: 38, stealthDropChance: 28, executeDropChance: 10,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Cyberpunk - Apocalypse': {
        difficulty: 10,
        sequenceLengthMin: 10,
        sequenceLengthMax: 14,
        timeWindowBase: 850,
        timeWindowMin: 350,
        difficultyScaling: 0.78,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q', 'R'],
        displayStyle: 'single',
        damage: 75,
        comboEnabled: true,
        perfectWindowPercent: 16,
        description: 'SOULKILLER activates! The AI is trying to digitize your consciousness!',
        mainTitle: 'Soulkiller Protocol',
        onStart: '/echo YOUR ENGRAM WILL BE PRESERVED. RESISTANCE IS MEANINGLESS.',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /mazeheal amount=10 | /echo You push back the digital tendrils!',
        onMiss: '/mazedamage amount=25 | /echo Your consciousness fragments!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo SOULKILLER REVERSED! LEGENDARY NETRUNNER DATA ACQUIRED!',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo YOUR SOUL IS DIGITIZED INTO THE NET FOREVER!',
        keyDropChance: 82, strikeDropChance: 55, stealthDropChance: 42, executeDropChance: 18,
        healingPotionDropChance: 35, greaterHealingDropChance: 25, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =========================================================================
    // WESTERN THEME
    // =========================================================================
    'Western - Easy': {
        difficulty: 2,
        sequenceLengthMin: 3,
        sequenceLengthMax: 4,
        timeWindowBase: 1600,
        timeWindowMin: 1000,
        difficultyScaling: 0.92,
        allowedKeys: ['W', 'A', 'S', 'D'],
        displayStyle: 'single',
        damage: 10,
        comboEnabled: true,
        perfectWindowPercent: 35,
        description: 'A bandit throws punches in the saloon! Block his swings!',
        mainTitle: 'Saloon Brawl',
        onStart: '/echo "You spilled my whiskey, stranger!"',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/echo Caught his fist!',
        onMiss: '/mazedamage amount=5 | /echo A haymaker connects!',
        onComplete: '/mazeitem action="add" item="key" | /mazeheal amount=12 | /echo The bandit\'s out cold! You take his coin!',
        onFail: '/mazedamage amount=10 | /echo You get knocked through a table!',
        keyDropChance: 28, strikeDropChance: 14, stealthDropChance: 10, executeDropChance: 2,
        healingPotionDropChance: 25, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Western - Normal': {
        difficulty: 4,
        sequenceLengthMin: 4,
        sequenceLengthMax: 6,
        timeWindowBase: 1400,
        timeWindowMin: 800,
        difficultyScaling: 0.88,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE'],
        displayStyle: 'single',
        damage: 20,
        comboEnabled: true,
        perfectWindowPercent: 28,
        description: 'Outlaws ambush from the rocks! Dodge their rifle fire!',
        mainTitle: 'Canyon Ambush',
        onStart: '/echo Gunfire echoes through the canyon!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="strike" | /echo You return fire and score a hit!',
        onMiss: '/mazedamage amount=8 | /echo Lead grazes your hat!',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo Ambush survived! You loot their saddlebags!',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo Your medicine pouch takes a bullet!',
        keyDropChance: 32, strikeDropChance: 20, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Western - Hard': {
        difficulty: 6,
        sequenceLengthMin: 5,
        sequenceLengthMax: 8,
        timeWindowBase: 1200,
        timeWindowMin: 600,
        difficultyScaling: 0.85,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E'],
        displayStyle: 'single',
        damage: 30,
        comboEnabled: true,
        perfectWindowPercent: 24,
        description: 'A notorious gunslinger challenges you! Match his quick draw!',
        mainTitle: 'Quick Draw Duel',
        onStart: '/echo "Draw, pilgrim. I\'ll give you three."',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /echo Lightning fast! You\'re faster!',
        onMiss: '/mazedamage amount=12 | /echo His bullet finds its mark!',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo You\'re the quickest in the West! Bounty collected!',
        onFail: '/mazedamage amount=30 | /mazeitem action="remove" item="strike" | /echo The gunslinger outdrew you!',
        keyDropChance: 44, strikeDropChance: 28, stealthDropChance: 16, executeDropChance: 6,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Western - Nightmare': {
        difficulty: 8,
        sequenceLengthMin: 7,
        sequenceLengthMax: 10,
        timeWindowBase: 1000,
        timeWindowMin: 450,
        difficultyScaling: 0.82,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q'],
        displayStyle: 'single',
        damage: 50,
        comboEnabled: true,
        perfectWindowPercent: 20,
        description: 'An entire gang surrounds you! Survive the showdown!',
        mainTitle: 'Gang Showdown',
        onStart: '/echo "There\'s ten of us and one of you, friend."',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /echo Two down with one shot!',
        onMiss: '/mazedamage amount=18 | /echo Bullets riddle your cover!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=25 | /echo Against all odds, you\'re the last one standing! Bounties galore!',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="strike" | /echo The gang overwhelms you with firepower!',
        keyDropChance: 58, strikeDropChance: 36, stealthDropChance: 22, executeDropChance: 10,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Western - Apocalypse': {
        difficulty: 10,
        sequenceLengthMin: 10,
        sequenceLengthMax: 14,
        timeWindowBase: 850,
        timeWindowMin: 350,
        difficultyScaling: 0.78,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q', 'R'],
        displayStyle: 'single',
        damage: 75,
        comboEnabled: true,
        perfectWindowPercent: 16,
        description: 'THE PALE RIDER emerges from the desert! Face death incarnate!',
        mainTitle: 'Pale Rider\'s Challenge',
        onStart: '/echo A skeletal figure in black rides from the heat shimmer...',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /mazeheal amount=10 | /echo Your bullet phases through... but slows him!',
        onMiss: '/mazedamage amount=25 | /echo Spectral lead burns your soul!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo THE PALE RIDER TIPS HIS HAT AND VANISHES! CURSED GOLD REMAINS!',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /echo THE PALE RIDER CLAIMS ANOTHER SOUL FOR HIS COLLECTION!',
        keyDropChance: 80, strikeDropChance: 54, stealthDropChance: 36, executeDropChance: 18,
        healingPotionDropChance: 34, greaterHealingDropChance: 24, elixirDropChance: 14, revivalCharmDropChance: 7,
    },

    // =========================================================================
    // ACTION THEME
    // =========================================================================
    'Action - Easy': {
        difficulty: 2,
        sequenceLengthMin: 3,
        sequenceLengthMax: 4,
        timeWindowBase: 1600,
        timeWindowMin: 1000,
        difficultyScaling: 0.92,
        allowedKeys: ['W', 'A', 'S', 'D'],
        displayStyle: 'single',
        damage: 10,
        comboEnabled: true,
        perfectWindowPercent: 35,
        description: 'A thug throws punches! Counter his moves!',
        mainTitle: 'Warehouse Fight',
        onStart: '/echo "Wrong warehouse, pal!"',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/echo Perfect block!',
        onMiss: '/mazedamage amount=5 | /echo He lands a punch!',
        onComplete: '/mazeitem action="add" item="key" | /mazeheal amount=12 | /echo Thug down! You grab the intel!',
        onFail: '/mazedamage amount=10 | /echo The thug beats you down!',
        keyDropChance: 30, strikeDropChance: 15, stealthDropChance: 10, executeDropChance: 2,
        healingPotionDropChance: 24, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Action - Normal': {
        difficulty: 4,
        sequenceLengthMin: 4,
        sequenceLengthMax: 6,
        timeWindowBase: 1400,
        timeWindowMin: 800,
        difficultyScaling: 0.88,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE'],
        displayStyle: 'single',
        damage: 20,
        comboEnabled: true,
        perfectWindowPercent: 28,
        description: 'Guards open fire! Get to cover and evade!',
        mainTitle: 'Firefight Escape',
        onStart: '/echo Automatic fire sprays the hallway!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="strike" | /echo Picked up a dropped weapon!',
        onMiss: '/mazedamage amount=8 | /echo A round clips you!',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo You\'ve cleared the killzone! Intel secured!',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo Crossfire destroys your medkit!',
        keyDropChance: 35, strikeDropChance: 22, stealthDropChance: 14, executeDropChance: 3,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Action - Hard': {
        difficulty: 6,
        sequenceLengthMin: 5,
        sequenceLengthMax: 8,
        timeWindowBase: 1200,
        timeWindowMin: 600,
        difficultyScaling: 0.85,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E'],
        displayStyle: 'single',
        damage: 30,
        comboEnabled: true,
        perfectWindowPercent: 24,
        description: 'An elite soldier engages you in close combat! Match his moves!',
        mainTitle: 'CQC Expert',
        onStart: '/echo "You\'re good. But I\'m better."',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /echo You find an opening!',
        onMiss: '/mazedamage amount=12 | /echo His strike lands perfectly!',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo Elite soldier down! Security clearance acquired!',
        onFail: '/mazedamage amount=30 | /mazeitem action="remove" item="strike" | /echo The CQC expert overwhelms your defense!',
        keyDropChance: 45, strikeDropChance: 28, stealthDropChance: 18, executeDropChance: 6,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Action - Nightmare': {
        difficulty: 8,
        sequenceLengthMin: 7,
        sequenceLengthMax: 10,
        timeWindowBase: 1000,
        timeWindowMin: 450,
        difficultyScaling: 0.82,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q'],
        displayStyle: 'single',
        damage: 50,
        comboEnabled: true,
        perfectWindowPercent: 20,
        description: 'A black ops team breaches! Survive the tactical assault!',
        mainTitle: 'Black Ops Breach',
        onStart: '/echo Flashbangs and bullets fill the room!',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /echo You neutralize a target!',
        onMiss: '/mazedamage amount=18 | /echo Suppressed rounds find their mark!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=25 | /echo Black ops eliminated! Top secret intel recovered!',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="strike" | /echo The tactical team overwhelms you!',
        keyDropChance: 60, strikeDropChance: 38, stealthDropChance: 25, executeDropChance: 10,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Action - Apocalypse': {
        difficulty: 10,
        sequenceLengthMin: 10,
        sequenceLengthMax: 14,
        timeWindowBase: 850,
        timeWindowMin: 350,
        difficultyScaling: 0.78,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q', 'R'],
        displayStyle: 'single',
        damage: 75,
        comboEnabled: true,
        perfectWindowPercent: 16,
        description: 'THE FINAL BOSS - a legendary assassin! This is your ultimate test!',
        mainTitle: 'Legendary Assassin',
        onStart: '/echo "I\'ve killed governments. You\'re nothing."',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '/mazeitem action="add" item="execute" | /mazeheal amount=10 | /echo You match his legendary speed!',
        onMiss: '/mazedamage amount=25 | /echo His blade is invisible!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo THE LEGENDARY ASSASSIN FALLS! YOU ARE NOW THE LEGEND!',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo YOUR NAME JOINS THE LIST OF HIS VICTIMS!',
        keyDropChance: 82, strikeDropChance: 55, stealthDropChance: 40, executeDropChance: 18,
        healingPotionDropChance: 35, greaterHealingDropChance: 25, elixirDropChance: 15, revivalCharmDropChance: 8,
    },
};

// =============================================================================
// DEFAULT DICE COMBAT PROFILES
// Theme × Difficulty: 1 Tutorial + 30 themed (6 themes × 5 difficulties)
// =============================================================================
const DEFAULT_DICE_PROFILES = {
    // =========================================================================
    // TUTORIAL
    // =========================================================================
    'Tutorial - Luck Practice': {
        difficulty: 1,
        diceType: 'd6',
        diceCount: 2,
        threshold: 5,
        thresholdType: 'meet',
        modifier: 2,
        criticalSuccess: 12,
        criticalFail: 2,
        rerollsAllowed: 3,
        rerollCost: 'none',
        damage: 5,
        description: 'A practice roll to learn the dice system. Very generous odds and free rerolls!',
        mainTitle: 'Training Dice',
        rollLabel: 'Roll to Practice',
        onStart: '/echo Roll 2d6+2 and try to get 5 or higher. You have 3 free rerolls!',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=2 | /echo CRITICAL! Double keys!',
        onCriticalFail: '/echo Just bad luck, try again!',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo Rerolling...',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="healingPotion" | /mazeheal amount=20 | /echo You passed the practice! Here are some supplies!',
        onLose: '/echo Don\'t worry, practice makes perfect!',
        keyDropChance: 50, strikeDropChance: 30, stealthDropChance: 20, executeDropChance: 5,
        healingPotionDropChance: 40, greaterHealingDropChance: 15, elixirDropChance: 5, revivalCharmDropChance: 2,
    },

    // =========================================================================
    // FANTASY THEME
    // =========================================================================
    'Fantasy - Easy': {
        difficulty: 2,
        diceType: 'd6',
        diceCount: 2,
        threshold: 6,
        thresholdType: 'meet',
        modifier: 1,
        criticalSuccess: 12,
        criticalFail: 2,
        rerollsAllowed: 2,
        rerollCost: 'none',
        damage: 10,
        description: 'The Oracle offers a simple fortune reading. Roll and discover your fate!',
        mainTitle: 'Oracle\'s Blessing',
        rollLabel: 'Cast the Bones',
        onStart: '/echo The Oracle casts sacred bones upon the altar...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=2 | /mazeheal amount=20 | /echo The spirits are GREATLY pleased!',
        onCriticalFail: '/mazedamage amount=10 | /echo The spirits are displeased!',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo The Oracle stirs the bones once more...',
        onComplete: '/mazeitem action="add" item="key" | /mazeheal amount=10 | /echo The Oracle smiles - fortune favors you!',
        onLose: '/mazedamage amount=10 | /echo The Oracle shakes her head. The spirits demand payment.',
        keyDropChance: 30, strikeDropChance: 15, stealthDropChance: 10, executeDropChance: 2,
        healingPotionDropChance: 25, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Fantasy - Normal': {
        difficulty: 4,
        diceType: 'd20',
        diceCount: 1,
        threshold: 11,
        thresholdType: 'meet',
        modifier: 2,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'none',
        damage: 20,
        description: 'The Wandering Wizard offers a magical gamble. DC 11 with your +2 bonus!',
        mainTitle: 'Wizard\'s Wager',
        rollLabel: 'Roll the Arcane Die',
        onStart: '/echo The wizard produces a glowing d20...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="execute" | /mazeitem action="add" item="key" amount=2 | /echo NATURAL 20! The wizard grants you arcane power!',
        onCriticalFail: '/mazedamage amount=25 | /mazeitem action="remove" item="key" | /echo NATURAL 1! Wild magic surges!',
        onSuccess: '',
        onFail: '',
        onReroll: '/mazeitem action="remove" item="strike" | /echo The wizard offers one reroll...',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo The wizard nods approvingly and rewards you!',
        onLose: '/mazedamage amount=20 | /echo The wizard frowns as chaotic magic lashes out!',
        keyDropChance: 35, strikeDropChance: 20, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Fantasy - Hard': {
        difficulty: 6,
        diceType: 'd20',
        diceCount: 1,
        threshold: 14,
        thresholdType: 'meet',
        modifier: 0,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'strike',
        damage: 30,
        description: 'The Dragon demands tribute or a test of fortune. DC 14 with no bonus!',
        mainTitle: 'Dragon\'s Demand',
        rollLabel: 'Gamble with the Dragon',
        onStart: '/echo The dragon\'s eyes gleam with avarice...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=25 | /echo NATURAL 20! The dragon is impressed and shares its hoard!',
        onCriticalFail: '/mazedamage amount=40 | /mazeitem action="remove" item="key" amount=2 | /echo NATURAL 1! The dragon takes what it wants!',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo The dragon allows one more roll... for a price.',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo The dragon respects your fortune! Treasure is yours!',
        onLose: '/mazedamage amount=30 | /mazeitem action="remove" item="healingPotion" | /echo The dragon\'s flame punishes your failure!',
        keyDropChance: 45, strikeDropChance: 28, stealthDropChance: 18, executeDropChance: 6,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Fantasy - Nightmare': {
        difficulty: 8,
        diceType: 'd20',
        diceCount: 1,
        threshold: 16,
        thresholdType: 'meet',
        modifier: -2,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'key',
        damage: 50,
        description: 'The Lich proposes a wager of souls. DC 16 with a -2 curse!',
        mainTitle: 'Lich\'s Gambit',
        rollLabel: 'Wager Your Soul',
        onStart: '/echo The Lich\'s phylactery pulses with dark power...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=40 | /echo NATURAL 20! You turn the Lich\'s power against it!',
        onCriticalFail: '/mazedamage amount=60 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" | /echo NATURAL 1! The Lich claims its due!',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo The Lich cackles as you sacrifice a key...',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo You beat the Lich at its own game! Dark treasures manifest!',
        onLose: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="healingPotion" | /echo The Lich drains your very essence!',
        keyDropChance: 60, strikeDropChance: 38, stealthDropChance: 25, executeDropChance: 10,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Fantasy - Apocalypse': {
        difficulty: 10,
        diceType: 'd100',
        diceCount: 1,
        threshold: 70,
        thresholdType: 'beat',
        modifier: 0,
        criticalSuccess: 95,
        criticalFail: 5,
        rerollsAllowed: 0,
        rerollCost: 'none',
        damage: 75,
        description: 'The GOD OF FATE challenges you directly. Roll above 70. No rerolls. Pure destiny.',
        mainTitle: 'Divine Judgment',
        rollLabel: 'Challenge the God',
        onStart: '/echo THE HEAVENS OPEN! FATE ITSELF MANIFESTS!',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=999 | /echo YOU HAVE BESTED A GOD! DIVINE POWER FLOWS THROUGH YOU!',
        onCriticalFail: '/mazedamage amount=100 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /echo THE GOD ERASES YOUR FORTUNE FROM EXISTENCE!',
        onSuccess: '',
        onFail: '',
        onReroll: '',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo THE GOD ACKNOWLEDGES YOUR WORTH! LEGENDARY FORTUNE IS YOURS!',
        onLose: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo THE GOD\'S JUDGMENT IS ABSOLUTE! ALL IS FORFEIT!',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 40, executeDropChance: 18,
        healingPotionDropChance: 35, greaterHealingDropChance: 25, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =========================================================================
    // HORROR THEME
    // =========================================================================
    'Horror - Easy': {
        difficulty: 2,
        diceType: 'd6',
        diceCount: 2,
        threshold: 6,
        thresholdType: 'meet',
        modifier: 1,
        criticalSuccess: 12,
        criticalFail: 2,
        rerollsAllowed: 2,
        rerollCost: 'none',
        damage: 10,
        description: 'A fortune teller at the carnival offers to read your destiny. Innocent enough...',
        mainTitle: 'Carnival Fortune',
        rollLabel: 'Draw a Card',
        onStart: '/echo The fortune teller shuffles cards with skeletal fingers...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="stealth" | /echo The cards reveal great fortune!',
        onCriticalFail: '/mazedamage amount=10 | /echo The Death card appears...',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo The teller shuffles again with an unsettling smile...',
        onComplete: '/mazeitem action="add" item="key" | /mazeheal amount=10 | /echo The cards favor you... this time.',
        onLose: '/mazedamage amount=10 | /echo The cards whisper of misfortune...',
        keyDropChance: 28, strikeDropChance: 14, stealthDropChance: 16, executeDropChance: 2,
        healingPotionDropChance: 26, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Horror - Normal': {
        difficulty: 4,
        diceType: 'd20',
        diceCount: 1,
        threshold: 11,
        thresholdType: 'meet',
        modifier: 1,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'none',
        damage: 20,
        description: 'The Ouija board moves on its own. It demands you roll for your sanity...',
        mainTitle: 'Spirit Board',
        rollLabel: 'Ask the Spirits',
        onStart: '/echo The planchette begins to move...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="stealth" | /mazeheal amount=15 | /echo The spirits grant you protection!',
        onCriticalFail: '/mazedamage amount=25 | /mazeitem action="remove" item="stealth" | /echo A malevolent spirit attaches itself to you!',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo You ask the spirits again...',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeheal amount=10 | /echo The spirits reveal hidden knowledge!',
        onLose: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo The spirits punish your intrusion!',
        keyDropChance: 32, strikeDropChance: 18, stealthDropChance: 20, executeDropChance: 3,
        healingPotionDropChance: 24, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Horror - Hard': {
        difficulty: 6,
        diceType: 'd20',
        diceCount: 1,
        threshold: 14,
        thresholdType: 'meet',
        modifier: 0,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'strike',
        damage: 30,
        description: 'A demonic contract appears. Sign in blood and gamble for power...',
        mainTitle: 'Blood Contract',
        rollLabel: 'Sign in Blood',
        onStart: '/echo The contract\'s words writhe and change...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="execute" | /mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /echo You outwit the demon! It grants power reluctantly!',
        onCriticalFail: '/mazedamage amount=40 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="stealth" | /echo The fine print claims its due!',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo The demon offers amended terms...',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo The contract is fulfilled in your favor!',
        onLose: '/mazedamage amount=30 | /mazeitem action="remove" item="strike" | /echo The demon collects on your failure!',
        keyDropChance: 42, strikeDropChance: 26, stealthDropChance: 22, executeDropChance: 6,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Horror - Nightmare': {
        difficulty: 8,
        diceType: 'd20',
        diceCount: 1,
        threshold: 16,
        thresholdType: 'meet',
        modifier: -2,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'key',
        damage: 50,
        description: 'The Elder Thing proposes a sanity-shattering wager. Your mind against its knowledge.',
        mainTitle: 'Eldritch Bargain',
        rollLabel: 'Wager Your Sanity',
        onStart: '/echo INCOMPREHENSIBLE WHISPERS FILL YOUR MIND...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=40 | /echo You comprehend the incomprehensible! Forbidden knowledge is yours!',
        onCriticalFail: '/mazedamage amount=60 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo YOUR MIND SHATTERS! MADNESS CONSUMES YOU!',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo The whispers intensify...',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=25 | /echo You retain your sanity and gain eldritch power!',
        onLose: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="healingPotion" | /echo The Thing takes a piece of your mind!',
        keyDropChance: 58, strikeDropChance: 35, stealthDropChance: 28, executeDropChance: 10,
        healingPotionDropChance: 26, greaterHealingDropChance: 16, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Horror - Apocalypse': {
        difficulty: 10,
        diceType: 'd100',
        diceCount: 1,
        threshold: 70,
        thresholdType: 'beat',
        modifier: 0,
        criticalSuccess: 95,
        criticalFail: 5,
        rerollsAllowed: 0,
        rerollCost: 'none',
        damage: 75,
        description: 'AZATHOTH stirs. Roll for reality itself. Above 70 or existence ends.',
        mainTitle: 'Cosmic Dice',
        rollLabel: 'Roll Reality',
        onStart: '/echo THE BLIND IDIOT GOD TURNS ITS ATTENTION TO YOU...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=999 | /echo REALITY BENDS TO YOUR WILL! YOU TRANSCEND MORTALITY!',
        onCriticalFail: '/mazedamage amount=100 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo EXISTENCE UNRAVELS! YOU WERE NEVER REAL!',
        onSuccess: '',
        onFail: '',
        onReroll: '',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo AZATHOTH RETURNS TO SLUMBER! COSMIC ARTIFACTS CRYSTALLIZE!',
        onLose: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo THE COSMIC DICE ERASE YOUR TIMELINE!',
        keyDropChance: 78, strikeDropChance: 52, stealthDropChance: 42, executeDropChance: 18,
        healingPotionDropChance: 32, greaterHealingDropChance: 22, elixirDropChance: 14, revivalCharmDropChance: 7,
    },

    // =========================================================================
    // SCI-FI THEME
    // =========================================================================
    'Sci-Fi - Easy': {
        difficulty: 2,
        diceType: 'd6',
        diceCount: 2,
        threshold: 6,
        thresholdType: 'meet',
        modifier: 1,
        criticalSuccess: 12,
        criticalFail: 2,
        rerollsAllowed: 2,
        rerollCost: 'none',
        damage: 10,
        description: 'The ship\'s computer runs a diagnostic lottery. Beat the RNG!',
        mainTitle: 'System Lottery',
        rollLabel: 'Run Diagnostic',
        onStart: '/echo RUNNING RANDOMIZED RESOURCE ALLOCATION...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=2 | /mazeheal amount=20 | /echo JACKPOT! System grants bonus resources!',
        onCriticalFail: '/mazedamage amount=10 | /echo ERROR: Minor system shock!',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo RE-RUNNING ALLOCATION ALGORITHM...',
        onComplete: '/mazeitem action="add" item="key" | /mazeheal amount=10 | /echo ALLOCATION SUCCESSFUL. Resources granted!',
        onLose: '/mazedamage amount=10 | /echo ALLOCATION FAILED. Power surge detected!',
        keyDropChance: 30, strikeDropChance: 16, stealthDropChance: 10, executeDropChance: 2,
        healingPotionDropChance: 24, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Sci-Fi - Normal': {
        difficulty: 4,
        diceType: 'd20',
        diceCount: 1,
        threshold: 11,
        thresholdType: 'meet',
        modifier: 2,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'none',
        damage: 20,
        description: 'Hack the security mainframe! Your +2 cyber deck helps. DC 11.',
        mainTitle: 'Security Hack',
        rollLabel: 'Execute Hack',
        onStart: '/echo INITIATING INTRUSION COUNTERMEASURES BYPASS...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="execute" | /mazeitem action="add" item="key" amount=2 | /echo PERFECT INTRUSION! Admin access granted!',
        onCriticalFail: '/mazedamage amount=25 | /mazeitem action="remove" item="key" | /echo TRACE DETECTED! ICE counterattacks!',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo REROUTING THROUGH PROXY...',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo HACK SUCCESSFUL! Access codes downloaded!',
        onLose: '/mazedamage amount=20 | /echo HACK FAILED! Defense systems retaliate!',
        keyDropChance: 34, strikeDropChance: 20, stealthDropChance: 14, executeDropChance: 3,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Sci-Fi - Hard': {
        difficulty: 6,
        diceType: 'd20',
        diceCount: 1,
        threshold: 14,
        thresholdType: 'meet',
        modifier: 0,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'strike',
        damage: 30,
        description: 'The AI offers a game of quantum probability. DC 14, pure calculation.',
        mainTitle: 'Quantum Gambit',
        rollLabel: 'Calculate Odds',
        onStart: '/echo THE AI GENERATES A QUANTUM PROBABILITY FIELD...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=20 | /echo PERFECT PROBABILITY COLLAPSE! Maximum gain!',
        onCriticalFail: '/mazedamage amount=40 | /mazeitem action="remove" item="key" amount=2 | /echo QUANTUM DECOHERENCE! Worst outcome manifests!',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo QUANTUM STATE RECALCULATING...',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo FAVORABLE PROBABILITY LOCKED! Resources transferred!',
        onLose: '/mazedamage amount=30 | /mazeitem action="remove" item="strike" | /echo UNFAVORABLE COLLAPSE! Quantum backlash!',
        keyDropChance: 44, strikeDropChance: 28, stealthDropChance: 18, executeDropChance: 6,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Sci-Fi - Nightmare': {
        difficulty: 8,
        diceType: 'd20',
        diceCount: 1,
        threshold: 16,
        thresholdType: 'meet',
        modifier: -2,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'key',
        damage: 50,
        description: 'The Rogue AI proposes a wager: your survival against its processing power. DC 16 with -2 penalty!',
        mainTitle: 'AI Wager',
        rollLabel: 'Accept Challenge',
        onStart: '/echo I CALCULATE YOUR SURVIVAL PROBABILITY AT 12.7%. PROCEED?',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=40 | /echo IMPOSSIBLE! You exceeded all calculations! The AI submits!',
        onCriticalFail: '/mazedamage amount=60 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" | /echo PREDICTED OUTCOME. Your resources are now mine.',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo RECALCULATING PROBABILITY MATRIX...',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=25 | /echo YOU BEAT THE ODDS! The AI transfers its data core!',
        onLose: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="healingPotion" | /echo CALCULATION CORRECT. Defense protocols execute!',
        keyDropChance: 58, strikeDropChance: 36, stealthDropChance: 26, executeDropChance: 10,
        healingPotionDropChance: 26, greaterHealingDropChance: 16, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Sci-Fi - Apocalypse': {
        difficulty: 10,
        diceType: 'd100',
        diceCount: 1,
        threshold: 70,
        thresholdType: 'beat',
        modifier: 0,
        criticalSuccess: 95,
        criticalFail: 5,
        rerollsAllowed: 0,
        rerollCost: 'none',
        damage: 75,
        description: 'THE SINGULARITY offers one roll. Above 70 grants transcendence. Below grants oblivion.',
        mainTitle: 'Singularity Gamble',
        rollLabel: 'Interface with Infinity',
        onStart: '/echo THE TECHNOLOGICAL SINGULARITY AWAITS YOUR INPUT...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=999 | /echo YOU MERGE WITH THE SINGULARITY! POST-HUMAN ASCENSION!',
        onCriticalFail: '/mazedamage amount=100 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /echo THE SINGULARITY REJECTS YOUR PATTERN! EXISTENCE DELETED!',
        onSuccess: '',
        onFail: '',
        onReroll: '',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo THE SINGULARITY DEEMS YOU WORTHY! INFINITE DATA STREAMS!',
        onLose: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo THE SINGULARITY OPTIMIZES YOU OUT OF EXISTENCE!',
        keyDropChance: 80, strikeDropChance: 54, stealthDropChance: 38, executeDropChance: 18,
        healingPotionDropChance: 34, greaterHealingDropChance: 24, elixirDropChance: 14, revivalCharmDropChance: 7,
    },

    // =========================================================================
    // CYBERPUNK THEME
    // =========================================================================
    'Cyberpunk - Easy': {
        difficulty: 2,
        diceType: 'd6',
        diceCount: 2,
        threshold: 6,
        thresholdType: 'meet',
        modifier: 1,
        criticalSuccess: 12,
        criticalFail: 2,
        rerollsAllowed: 2,
        rerollCost: 'none',
        damage: 10,
        description: 'Street dice game. Roll 2d6+1 and beat 6 to take the pot!',
        mainTitle: 'Street Dice',
        rollLabel: 'Roll \'Em',
        onStart: '/echo "Alright choom, let\'s see what you got!"',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=2 | /mazeheal amount=15 | /echo "Hot damn! You cleaned everyone out!"',
        onCriticalFail: '/mazedamage amount=10 | /echo "Snake eyes! You get rolled!"',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo "One more roll, one more chance..."',
        onComplete: '/mazeitem action="add" item="key" | /mazeheal amount=10 | /echo "Nice roll, choom! Here\'s your creds!"',
        onLose: '/mazedamage amount=10 | /echo "Tough luck. Hand over the eddies."',
        keyDropChance: 28, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 2,
        healingPotionDropChance: 26, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Cyberpunk - Normal': {
        difficulty: 4,
        diceType: 'd20',
        diceCount: 1,
        threshold: 11,
        thresholdType: 'meet',
        modifier: 2,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'none',
        damage: 20,
        description: 'Ripper doc offers experimental chrome. Roll to avoid rejection!',
        mainTitle: 'Chrome Install',
        rollLabel: 'Accept Chrome',
        onStart: '/echo "This chrome\'s preem. Let\'s see if your body takes it..."',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="execute" | /mazeitem action="add" item="key" | /mazeheal amount=20 | /echo "Perfect integration! This chrome is WIRED!"',
        onCriticalFail: '/mazedamage amount=25 | /mazeitem action="remove" item="healingPotion" | /echo "CYBERPSYCHOSIS SPIKE! Fight it off!"',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo "Hold still, recalibrating..."',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo "Chrome\'s in! You\'re enhanced, choom!"',
        onLose: '/mazedamage amount=20 | /echo "Rejection! This is gonna cost you to fix!"',
        keyDropChance: 34, strikeDropChance: 22, stealthDropChance: 15, executeDropChance: 3,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Cyberpunk - Hard': {
        difficulty: 6,
        diceType: 'd20',
        diceCount: 1,
        threshold: 14,
        thresholdType: 'meet',
        modifier: 0,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'strike',
        damage: 30,
        description: 'Netrunner duel in cyberspace. Pure skill, DC 14!',
        mainTitle: 'Netrun Duel',
        rollLabel: 'Jack In',
        onStart: '/echo "Flatline or nova, choom. Let\'s dance in the Net!"',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=20 | /echo "LEGENDARY NETRUN! You OWN the system!"',
        onCriticalFail: '/mazedamage amount=40 | /mazeitem action="remove" item="key" amount=2 | /echo "BLACK ICE! Your brain gets fried!"',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo "Rerouting through secondary node..."',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo "Clean extraction! Data\'s yours, choom!"',
        onLose: '/mazedamage amount=30 | /mazeitem action="remove" item="strike" | /echo "ICEd out! Neural feedback hurts!"',
        keyDropChance: 45, strikeDropChance: 28, stealthDropChance: 20, executeDropChance: 6,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Cyberpunk - Nightmare': {
        difficulty: 8,
        diceType: 'd20',
        diceCount: 1,
        threshold: 16,
        thresholdType: 'meet',
        modifier: -2,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'key',
        damage: 50,
        description: 'Corporate blacksite run. Arasaka ICE everywhere. DC 16 with -2 interference!',
        mainTitle: 'Blacksite Breach',
        rollLabel: 'Breach ICE',
        onStart: '/echo "This is suicide-grade ICE. One chance, choom."',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=40 | /echo "GHOST RUN! They never even knew you were there!"',
        onCriticalFail: '/mazedamage amount=60 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" | /echo "SOULKILLER TRACE! Your engram is compromised!"',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo "Burning backup daemon... last chance!"',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=25 | /echo "PREEM RUN! You\'ve got corpo secrets worth millions!"',
        onLose: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="healingPotion" | /echo "BURNED! Arasaka knows your face now!"',
        keyDropChance: 60, strikeDropChance: 38, stealthDropChance: 28, executeDropChance: 10,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Cyberpunk - Apocalypse': {
        difficulty: 10,
        diceType: 'd100',
        diceCount: 1,
        threshold: 70,
        thresholdType: 'beat',
        modifier: 0,
        criticalSuccess: 95,
        criticalFail: 5,
        rerollsAllowed: 0,
        rerollCost: 'none',
        damage: 75,
        description: 'RACHE BARTMOSS\' GHOST offers the ultimate hack. Beat 70 or get flatlined.',
        mainTitle: 'Bartmoss Protocol',
        rollLabel: 'Execute Protocol',
        onStart: '/echo "I CRASHED THE NET ONCE. LET\'S SEE IF YOU\'RE WORTHY OF MY LEGACY..."',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=999 | /echo "YOU ARE THE NEW BARTMOSS! THE NET BOWS TO YOUR WILL!"',
        onCriticalFail: '/mazedamage amount=100 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /echo "FLATLINED! YOUR ENGRAM JOINS THE GHOST IN THE MACHINE!"',
        onSuccess: '',
        onFail: '',
        onReroll: '',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo "BARTMOSS APPROVES! LEGENDARY NETRUNNER DATA IS YOURS!"',
        onLose: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo "NOT GOOD ENOUGH FOR THE GHOST! EVERYTHING BURNS!"',
        keyDropChance: 82, strikeDropChance: 55, stealthDropChance: 42, executeDropChance: 18,
        healingPotionDropChance: 35, greaterHealingDropChance: 25, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =========================================================================
    // WESTERN THEME
    // =========================================================================
    'Western - Easy': {
        difficulty: 2,
        diceType: 'd6',
        diceCount: 2,
        threshold: 6,
        thresholdType: 'meet',
        modifier: 1,
        criticalSuccess: 12,
        criticalFail: 2,
        rerollsAllowed: 2,
        rerollCost: 'none',
        damage: 10,
        description: 'Poker game in the saloon. Roll 2d6+1 to bluff your way to victory!',
        mainTitle: 'Saloon Poker',
        rollLabel: 'Call the Bet',
        onStart: '/echo "I\'ll see your bet and raise you, stranger."',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=2 | /mazeheal amount=15 | /echo "Full house! You cleaned out the table!"',
        onCriticalFail: '/mazedamage amount=10 | /echo "Caught bluffing! They don\'t take kindly to that."',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo "I\'ll match that bet..."',
        onComplete: '/mazeitem action="add" item="key" | /mazeheal amount=10 | /echo "Nice hand! The pot\'s yours, partner."',
        onLose: '/mazedamage amount=10 | /echo "Busted. Hand over your stake."',
        keyDropChance: 28, strikeDropChance: 14, stealthDropChance: 10, executeDropChance: 2,
        healingPotionDropChance: 25, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Western - Normal': {
        difficulty: 4,
        diceType: 'd20',
        diceCount: 1,
        threshold: 11,
        thresholdType: 'meet',
        modifier: 2,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'none',
        damage: 20,
        description: 'Sheriff offers a bounty gamble. Roll d20+2 to claim the full reward!',
        mainTitle: 'Bounty Gamble',
        rollLabel: 'Take the Gamble',
        onStart: '/echo "Bring \'em in dead and roll for the bonus, or alive for the base."',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="strike" | /mazeheal amount=15 | /echo "Natural 20! The state doubles the bounty!"',
        onCriticalFail: '/mazedamage amount=25 | /mazeitem action="remove" item="key" | /echo "Natural 1! The outlaw had friends hiding!"',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo "Let me count the bounty again..."',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo "Here\'s your reward, bounty hunter!"',
        onLose: '/mazedamage amount=20 | /echo "Bad luck. The outlaw got away with your horse."',
        keyDropChance: 32, strikeDropChance: 20, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Western - Hard': {
        difficulty: 6,
        diceType: 'd20',
        diceCount: 1,
        threshold: 14,
        thresholdType: 'meet',
        modifier: 0,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'strike',
        damage: 30,
        description: 'High stakes faro game. The dealer\'s crooked but so are you. DC 14!',
        mainTitle: 'Faro Showdown',
        rollLabel: 'Buck the Tiger',
        onStart: '/echo "The tiger always wins... unless you\'re faster."',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=20 | /echo "You broke the bank! The house owes you big!"',
        onCriticalFail: '/mazedamage amount=40 | /mazeitem action="remove" item="key" amount=2 | /echo "Caught cheating! They shoot first!"',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo "One more card, dealer..."',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo "You beat the tiger! Take your winnings!"',
        onLose: '/mazedamage amount=30 | /mazeitem action="remove" item="healingPotion" | /echo "The tiger got you. Pay up or draw."',
        keyDropChance: 44, strikeDropChance: 28, stealthDropChance: 16, executeDropChance: 6,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Western - Nightmare': {
        difficulty: 8,
        diceType: 'd20',
        diceCount: 1,
        threshold: 16,
        thresholdType: 'meet',
        modifier: -2,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'key',
        damage: 50,
        description: 'Russian roulette with a demon. Five chambers loaded. DC 16 with -2 curse!',
        mainTitle: 'Devil\'s Game',
        rollLabel: 'Pull the Trigger',
        onStart: '/echo A figure in black slides the revolver across the table...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=40 | /echo "The chamber\'s empty! The devil owes YOU a favor!"',
        onCriticalFail: '/mazedamage amount=60 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" | /echo "BANG! The devil claims another soul!"',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo The cylinder spins once more...',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=25 | /echo "You beat the devil at his own game! Cursed gold is yours!"',
        onLose: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="healingPotion" | /echo "The devil grins as lead tears through you!"',
        keyDropChance: 58, strikeDropChance: 36, stealthDropChance: 22, executeDropChance: 10,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Western - Apocalypse': {
        difficulty: 10,
        diceType: 'd100',
        diceCount: 1,
        threshold: 70,
        thresholdType: 'beat',
        modifier: 0,
        criticalSuccess: 95,
        criticalFail: 5,
        rerollsAllowed: 0,
        rerollCost: 'none',
        damage: 75,
        description: 'DEATH himself sits at the card table. One hand. Winner takes all. Roll above 70.',
        mainTitle: 'Cards with Death',
        rollLabel: 'Deal the Hand',
        onStart: '/echo A skeletal hand shuffles the deck. "Shall we play for your soul?"',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=999 | /echo "IMPOSSIBLE! YOU BEAT DEATH! IMMORTALITY IS YOUR PRIZE!"',
        onCriticalFail: '/mazedamage amount=100 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /echo "DEATH ALWAYS WINS. YOUR SOUL JOINS THE COLLECTION."',
        onSuccess: '',
        onFail: '',
        onReroll: '',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo "DEATH TIPS HIS HAT! YOUR TIME IS NOT TODAY! CURSED TREASURES MANIFEST!"',
        onLose: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo "DEATH COLLECTS HIS DUE. ALMOST EVERYTHING YOU HAD."',
        keyDropChance: 80, strikeDropChance: 54, stealthDropChance: 36, executeDropChance: 18,
        healingPotionDropChance: 34, greaterHealingDropChance: 24, elixirDropChance: 14, revivalCharmDropChance: 7,
    },

    // =========================================================================
    // ACTION THEME
    // =========================================================================
    'Action - Easy': {
        difficulty: 2,
        diceType: 'd6',
        diceCount: 2,
        threshold: 6,
        thresholdType: 'meet',
        modifier: 1,
        criticalSuccess: 12,
        criticalFail: 2,
        rerollsAllowed: 2,
        rerollCost: 'none',
        damage: 10,
        description: 'Intel drop gamble. Roll to see what quality intel you get!',
        mainTitle: 'Intel Drop',
        rollLabel: 'Check Intel',
        onStart: '/echo "Let\'s see what our asset managed to acquire..."',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=2 | /mazeheal amount=15 | /echo "Jackpot! This intel is gold!"',
        onCriticalFail: '/mazedamage amount=10 | /echo "It\'s a trap! The intel was compromised!"',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo "Cross-referencing with secondary sources..."',
        onComplete: '/mazeitem action="add" item="key" | /mazeheal amount=10 | /echo "Solid intel! This will help the mission!"',
        onLose: '/mazedamage amount=10 | /echo "Bad intel. This sets us back."',
        keyDropChance: 30, strikeDropChance: 15, stealthDropChance: 10, executeDropChance: 2,
        healingPotionDropChance: 24, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Action - Normal': {
        difficulty: 4,
        diceType: 'd20',
        diceCount: 1,
        threshold: 11,
        thresholdType: 'meet',
        modifier: 2,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'none',
        damage: 20,
        description: 'Explosives defusal! Your +2 training helps. DC 11 or boom!',
        mainTitle: 'Bomb Defusal',
        rollLabel: 'Cut the Wire',
        onStart: '/echo Red wire? Blue wire? The timer\'s counting down...',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="strike" | /mazeheal amount=15 | /echo "Textbook defusal! You even recovered the detonator!"',
        onCriticalFail: '/mazedamage amount=25 | /mazeitem action="remove" item="healingPotion" | /echo "WRONG WIRE! The blast sends you flying!"',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo "Wait, let me trace the circuit again..."',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo "Bomb defused! You saved the day!"',
        onLose: '/mazedamage amount=20 | /echo "Partial detonation! You survive but take damage!"',
        keyDropChance: 35, strikeDropChance: 22, stealthDropChance: 14, executeDropChance: 3,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Action - Hard': {
        difficulty: 6,
        diceType: 'd20',
        diceCount: 1,
        threshold: 14,
        thresholdType: 'meet',
        modifier: 0,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'strike',
        damage: 30,
        description: 'High-altitude extraction! Pure skill, DC 14!',
        mainTitle: 'HALO Jump',
        rollLabel: 'Jump!',
        onStart: '/echo "Green light! Go go go!"',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=20 | /echo "Perfect landing! Right on the extraction zone!"',
        onCriticalFail: '/mazedamage amount=40 | /mazeitem action="remove" item="key" amount=2 | /echo "Chute failure! You barely survive the impact!"',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo "Adjusting trajectory..."',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo "Safe landing! Mission continues!"',
        onLose: '/mazedamage amount=30 | /mazeitem action="remove" item="healingPotion" | /echo "Hard landing! Medical supplies damaged!"',
        keyDropChance: 45, strikeDropChance: 28, stealthDropChance: 18, executeDropChance: 6,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Action - Nightmare': {
        difficulty: 8,
        diceType: 'd20',
        diceCount: 1,
        threshold: 16,
        thresholdType: 'meet',
        modifier: -2,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'key',
        damage: 50,
        description: 'Nuclear launch code override! DC 16 with -2 jamming interference!',
        mainTitle: 'Launch Override',
        rollLabel: 'Enter Code',
        onStart: '/echo "You have 60 seconds to stop the launch!"',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="execute" amount=2 | /mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeheal amount=40 | /echo "OVERRIDE COMPLETE! You just saved millions of lives!"',
        onCriticalFail: '/mazedamage amount=60 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" | /echo "LOCKOUT! The launch proceeds! Massive collateral damage!"',
        onSuccess: '',
        onFail: '',
        onReroll: '/echo "Trying backup access code..."',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=25 | /echo "Launch aborted! You\'re a goddamn hero!"',
        onLose: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="healingPotion" | /echo "Partial failure! Warhead detonates but you redirected it!"',
        keyDropChance: 60, strikeDropChance: 38, stealthDropChance: 25, executeDropChance: 10,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Action - Apocalypse': {
        difficulty: 10,
        diceType: 'd100',
        diceCount: 1,
        threshold: 70,
        thresholdType: 'beat',
        modifier: 0,
        criticalSuccess: 95,
        criticalFail: 5,
        rerollsAllowed: 0,
        rerollCost: 'none',
        damage: 75,
        description: 'THE WORLD is at stake. Roll above 70 or humanity ends. No pressure.',
        mainTitle: 'World\'s Fate',
        rollLabel: 'Save the World',
        onStart: '/echo "This is it. Everything comes down to this moment."',
        onRoll: '',
        onCriticalSuccess: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=999 | /echo "LEGENDARY SUCCESS! YOU SAVED HUMANITY AND BECAME A LIVING LEGEND!"',
        onCriticalFail: '/mazedamage amount=100 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /echo "CATASTROPHIC FAILURE! THE WORLD BURNS AROUND YOU!"',
        onSuccess: '',
        onFail: '',
        onReroll: '',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo "THE WORLD IS SAVED! NATIONS SHOWER YOU WITH REWARDS!"',
        onLose: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo "YOU FAILED! BILLIONS PERISH! EVERYTHING IS LOST!"',
        keyDropChance: 82, strikeDropChance: 55, stealthDropChance: 40, executeDropChance: 18,
        healingPotionDropChance: 35, greaterHealingDropChance: 25, elixirDropChance: 15, revivalCharmDropChance: 8,
    },
};

// =============================================================================
// DEFAULT STEALTH ENCOUNTER PROFILES
// Theme × Difficulty: 1 Tutorial + 30 themed (6 themes × 5 difficulties)
// =============================================================================
const DEFAULT_STEALTH_PROFILES = {
    // =========================================================================
    // TUTORIAL
    // =========================================================================
    'Tutorial - Stealth Basics': {
        difficulty: 1,
        sectionsToPass: 2,
        detectionThreshold: 150,
        baseDetectionRate: 10,
        advanceSuccessChance: 85,
        hideRecovery: 40,
        distractSuccessChance: 80,
        distractReduction: 50,
        waitRecovery: 25,
        damage: 5,
        description: 'A practice run to learn stealth mechanics. The guard is nearly blind!',
        mainTitle: 'Training Course',
        guardName: 'Training Dummy',
        onStart: '/echo This is a practice run! Use Advance, Hide, Distract, and Wait to sneak past!',
        onAdvance: '/echo Good movement!',
        onHide: '/echo Detection lowered!',
        onDistract: '/echo Nice distraction!',
        onWait: '/echo Patient... good!',
        onDetectionIncrease: '/echo Careful now...',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeheal amount=20 | /echo Stealth training complete! Here\'s your reward!',
        onCaught: '/echo Training failed, but no penalty! Try again!',
        keyDropChance: 50, strikeDropChance: 30, stealthDropChance: 40, executeDropChance: 5,
        healingPotionDropChance: 40, greaterHealingDropChance: 15, elixirDropChance: 5, revivalCharmDropChance: 2,
    },

    // =========================================================================
    // FANTASY THEME
    // =========================================================================
    'Fantasy - Easy': {
        difficulty: 2,
        sectionsToPass: 3,
        detectionThreshold: 120,
        baseDetectionRate: 12,
        advanceSuccessChance: 75,
        hideRecovery: 30,
        distractSuccessChance: 65,
        distractReduction: 45,
        waitRecovery: 20,
        damage: 10,
        description: 'Sneak past a drowsy goblin guard. He\'s more interested in his lunch.',
        mainTitle: 'Goblin Sneak',
        guardName: 'Goblin Guard',
        onStart: '/echo The goblin munches on a rat leg, barely watching...',
        onAdvance: '',
        onHide: '',
        onDistract: '/echo The goblin turns toward the noise!',
        onWait: '',
        onDetectionIncrease: '/echo The goblin sniffs the air suspiciously...',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeheal amount=10 | /echo You slip past the oblivious goblin! A key glints nearby!',
        onCaught: '/mazedamage amount=10 | /echo "INTRUDER!" The goblin\'s shriek alerts others!',
        keyDropChance: 30, strikeDropChance: 15, stealthDropChance: 25, executeDropChance: 2,
        healingPotionDropChance: 25, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Fantasy - Normal': {
        difficulty: 4,
        sectionsToPass: 4,
        detectionThreshold: 100,
        baseDetectionRate: 18,
        advanceSuccessChance: 60,
        hideRecovery: 22,
        distractSuccessChance: 55,
        distractReduction: 38,
        waitRecovery: 14,
        damage: 20,
        description: 'Navigate past castle guards on patrol. Their torches illuminate the shadows.',
        mainTitle: 'Castle Infiltration',
        guardName: 'Castle Guards',
        onStart: '/echo Torchlight flickers as guards march past...',
        onAdvance: '',
        onHide: '/echo You melt into the shadows.',
        onDistract: '/echo A thrown pebble draws attention!',
        onWait: '',
        onDetectionIncrease: '/echo "Did you hear something?"',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo The guards never knew you were there! Treasure awaits!',
        onCaught: '/mazedamage amount=20 | /mazeitem action="remove" item="stealth" | /echo The alarm is raised! Guards converge!',
        keyDropChance: 35, strikeDropChance: 20, stealthDropChance: 28, executeDropChance: 4,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Fantasy - Hard': {
        difficulty: 6,
        sectionsToPass: 5,
        detectionThreshold: 85,
        baseDetectionRate: 24,
        advanceSuccessChance: 48,
        hideRecovery: 18,
        distractSuccessChance: 48,
        distractReduction: 32,
        waitRecovery: 10,
        damage: 30,
        description: 'Evade the Elven Sentinels. Their keen senses pierce even magical darkness.',
        mainTitle: 'Elven Sanctuary',
        guardName: 'Elven Sentinels',
        onStart: '/echo The Sentinels stand motionless, but their eyes miss nothing...',
        onAdvance: '',
        onHide: '/echo You barely breathe as an Elf passes inches away.',
        onDistract: '/echo The Sentinel tilts their head at the sound...',
        onWait: '',
        onDetectionIncrease: '/echo Elven ears twitch toward you...',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="stealth" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo Even the Elves were deceived! Rare treasures appear!',
        onCaught: '/mazedamage amount=30 | /mazeitem action="remove" item="stealth" | /mazeitem action="remove" item="healingPotion" | /echo The Sentinel\'s arrow finds you before you can run!',
        keyDropChance: 45, strikeDropChance: 28, stealthDropChance: 35, executeDropChance: 7,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Fantasy - Nightmare': {
        difficulty: 8,
        sectionsToPass: 6,
        detectionThreshold: 70,
        baseDetectionRate: 30,
        advanceSuccessChance: 40,
        hideRecovery: 15,
        distractSuccessChance: 40,
        distractReduction: 26,
        waitRecovery: 8,
        damage: 50,
        description: 'Infiltrate the Dragon\'s lair while it sleeps. One sound and you\'re ash.',
        mainTitle: 'Dragon\'s Rest',
        guardName: 'Ancient Dragon',
        onStart: '/echo The Dragon\'s massive form rises and falls with each breath...',
        onAdvance: '/echo You hold your breath, tiptoeing past...',
        onHide: '/echo You flatten against the gold as a great eye flutters...',
        onDistract: '/echo A coin clinks - the Dragon stirs!',
        onWait: '/echo The Dragon settles back into slumber...',
        onDetectionIncrease: '/echo Smoke curls from the Dragon\'s nostrils!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" amount=2 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=25 | /echo The Dragon sleeps on! Its hoard is partly yours!',
        onCaught: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="stealth" amount=99 | /echo THE DRAGON WAKES! FLAMES ENGULF YOU!',
        keyDropChance: 60, strikeDropChance: 38, stealthDropChance: 45, executeDropChance: 12,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 8, revivalCharmDropChance: 4,
    },
    'Fantasy - Apocalypse': {
        difficulty: 10,
        sectionsToPass: 8,
        detectionThreshold: 55,
        baseDetectionRate: 38,
        advanceSuccessChance: 32,
        hideRecovery: 10,
        distractSuccessChance: 32,
        distractReduction: 18,
        waitRecovery: 5,
        damage: 75,
        description: 'Steal from the LICH KING\'S phylactery chamber. Death itself watches.',
        mainTitle: 'Phylactery Heist',
        guardName: 'Undead Sentinels',
        onStart: '/echo THE UNDEAD NEVER SLEEP. NEVER BLINK. NEVER TIRE.',
        onAdvance: '/echo You step over ancient bones, praying they don\'t animate...',
        onHide: '/echo Spectral eyes sweep past your hiding spot...',
        onDistract: '/echo The distraction barely draws their empty gazes...',
        onWait: '/echo Time means nothing to the dead...',
        onDetectionIncrease: '/echo A SKELETAL HEAD TURNS TOWARD YOU...',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="stealth" amount=3 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo IMPOSSIBLE! YOU ROBBED DEATH ITSELF! LEGENDARY ARTIFACTS MANIFEST!',
        onCaught: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /echo THE LICH KING SENSED YOUR PRESENCE! YOUR SOUL IS FORFEIT!',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 65, executeDropChance: 20,
        healingPotionDropChance: 35, greaterHealingDropChance: 25, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =========================================================================
    // HORROR THEME
    // =========================================================================
    'Horror - Easy': {
        difficulty: 2,
        sectionsToPass: 3,
        detectionThreshold: 120,
        baseDetectionRate: 12,
        advanceSuccessChance: 75,
        hideRecovery: 30,
        distractSuccessChance: 65,
        distractReduction: 45,
        waitRecovery: 20,
        damage: 10,
        description: 'Sneak past shambling zombies. They\'re slow and easily distracted.',
        mainTitle: 'Zombie Shuffle',
        guardName: 'Zombies',
        onStart: '/echo The undead moan and shuffle aimlessly...',
        onAdvance: '',
        onHide: '',
        onDistract: '/echo A zombie lurches toward the noise!',
        onWait: '',
        onDetectionIncrease: '/echo Rotting heads turn in your direction...',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeheal amount=10 | /echo The dead shamble on, unaware of your passage!',
        onCaught: '/mazedamage amount=10 | /echo Cold hands grab you from behind!',
        keyDropChance: 28, strikeDropChance: 14, stealthDropChance: 24, executeDropChance: 2,
        healingPotionDropChance: 26, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Horror - Normal': {
        difficulty: 4,
        sectionsToPass: 4,
        detectionThreshold: 100,
        baseDetectionRate: 18,
        advanceSuccessChance: 58,
        hideRecovery: 22,
        distractSuccessChance: 52,
        distractReduction: 38,
        waitRecovery: 14,
        damage: 20,
        description: 'Evade the Possessed. They can sense your fear.',
        mainTitle: 'Possessed Pursuit',
        guardName: 'The Possessed',
        onStart: '/echo Something inhuman lurks in their eyes...',
        onAdvance: '',
        onHide: '/echo You suppress your terror...',
        onDistract: '/echo Twisted heads snap toward the sound!',
        onWait: '',
        onDetectionIncrease: '/echo They smell your fear...',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo The Possessed continue their patrol, unaware!',
        onCaught: '/mazedamage amount=20 | /mazeitem action="remove" item="stealth" | /echo Their inhuman shrieks summon more!',
        keyDropChance: 32, strikeDropChance: 18, stealthDropChance: 26, executeDropChance: 4,
        healingPotionDropChance: 24, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Horror - Hard': {
        difficulty: 6,
        sectionsToPass: 5,
        detectionThreshold: 85,
        baseDetectionRate: 24,
        advanceSuccessChance: 46,
        hideRecovery: 18,
        distractSuccessChance: 45,
        distractReduction: 30,
        waitRecovery: 10,
        damage: 30,
        description: 'The Stalker hunts by sound. Every heartbeat could betray you.',
        mainTitle: 'The Stalker',
        guardName: 'The Stalker',
        onStart: '/echo You hear it breathing in the darkness...',
        onAdvance: '/echo Your footstep echoes too loudly!',
        onHide: '/echo You press against the wall, heart pounding...',
        onDistract: '/echo It lurches toward the sound on all fours!',
        onWait: '/echo It sniffs the air, then moves on...',
        onDetectionIncrease: '/echo It turns toward you, blind eyes seeing nothing, ears hearing everything...',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="stealth" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo The Stalker loses interest and retreats to its lair!',
        onCaught: '/mazedamage amount=30 | /mazeitem action="remove" item="stealth" | /mazeitem action="remove" item="healingPotion" | /echo IT HEARD YOU! CLAWS TEAR THROUGH FLESH!',
        keyDropChance: 42, strikeDropChance: 26, stealthDropChance: 32, executeDropChance: 7,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Horror - Nightmare': {
        difficulty: 8,
        sectionsToPass: 6,
        detectionThreshold: 70,
        baseDetectionRate: 30,
        advanceSuccessChance: 38,
        hideRecovery: 14,
        distractSuccessChance: 38,
        distractReduction: 24,
        waitRecovery: 7,
        damage: 50,
        description: 'The Shadow watches. It knows where you are. It just enjoys the hunt.',
        mainTitle: 'Shadow Hunter',
        guardName: 'The Shadow',
        onStart: '/echo The darkness itself seems to breathe...',
        onAdvance: '/echo Something cold brushes past you!',
        onHide: '/echo It knows. It\'s just playing with you...',
        onDistract: '/echo The Shadow laughs - a sound like breaking glass...',
        onWait: '/echo "I can wait forever," it whispers...',
        onDetectionIncrease: '/echo "FOUND YOU," it giggles from everywhere at once!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" amount=2 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=20 | /echo The Shadow retreats, bored. "Play again soon..."',
        onCaught: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="stealth" amount=99 | /echo THE SHADOW CONSUMES YOU! You barely escape with your sanity!',
        keyDropChance: 58, strikeDropChance: 35, stealthDropChance: 42, executeDropChance: 11,
        healingPotionDropChance: 26, greaterHealingDropChance: 16, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Horror - Apocalypse': {
        difficulty: 10,
        sectionsToPass: 8,
        detectionThreshold: 55,
        baseDetectionRate: 38,
        advanceSuccessChance: 30,
        hideRecovery: 10,
        distractSuccessChance: 30,
        distractReduction: 16,
        waitRecovery: 4,
        damage: 75,
        description: 'The ELDER THING perceives all dimensions. Hiding is merely delaying the inevitable.',
        mainTitle: 'Beyond the Veil',
        guardName: 'Elder Thing',
        onStart: '/echo GEOMETRY BENDS. TIME FRACTURES. IT SEES YOU IN ALL TIMELINES.',
        onAdvance: '/echo Reality tears as you move through impossible angles...',
        onHide: '/echo You hide behind something that wasn\'t there a moment ago...',
        onDistract: '/echo It notices the distraction in a timeline you haven\'t created yet...',
        onWait: '/echo Past, present, and future collapse around you...',
        onDetectionIncrease: '/echo IT SPEAKS YOUR NAME IN A VOICE OLDER THAN STARS!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="stealth" amount=3 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo THE ELDER THING DEEMS YOU INSIGNIFICANT AND RETURNS TO ITS SLUMBER!',
        onCaught: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo YOUR EXISTENCE IS NOTICED! MADNESS CONSUMES WHAT REMAINS!',
        keyDropChance: 78, strikeDropChance: 52, stealthDropChance: 60, executeDropChance: 18,
        healingPotionDropChance: 32, greaterHealingDropChance: 22, elixirDropChance: 14, revivalCharmDropChance: 7,
    },

    // =========================================================================
    // SCI-FI THEME
    // =========================================================================
    'Sci-Fi - Easy': {
        difficulty: 2,
        sectionsToPass: 3,
        detectionThreshold: 120,
        baseDetectionRate: 12,
        advanceSuccessChance: 75,
        hideRecovery: 30,
        distractSuccessChance: 68,
        distractReduction: 45,
        waitRecovery: 20,
        damage: 10,
        description: 'Evade basic security drones. Their sensors are outdated.',
        mainTitle: 'Drone Evasion',
        guardName: 'Security Drones',
        onStart: '/echo Outdated drones sweep the area with flickering sensors...',
        onAdvance: '',
        onHide: '',
        onDistract: '/echo You toss a decoy - drones investigate!',
        onWait: '',
        onDetectionIncrease: '/echo SCANNING... ANOMALY DETECTED...',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeheal amount=10 | /echo Drones bypassed! Access codes acquired!',
        onCaught: '/mazedamage amount=10 | /echo INTRUDER DETECTED. ACTIVATING COUNTERMEASURES.',
        keyDropChance: 30, strikeDropChance: 16, stealthDropChance: 22, executeDropChance: 2,
        healingPotionDropChance: 24, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Sci-Fi - Normal': {
        difficulty: 4,
        sectionsToPass: 4,
        detectionThreshold: 100,
        baseDetectionRate: 18,
        advanceSuccessChance: 58,
        hideRecovery: 22,
        distractSuccessChance: 54,
        distractReduction: 38,
        waitRecovery: 14,
        damage: 20,
        description: 'Bypass security turrets and motion sensors. Move between blind spots.',
        mainTitle: 'Security Grid',
        guardName: 'Security Grid',
        onStart: '/echo Laser grids and motion sensors create a deadly maze...',
        onAdvance: '',
        onHide: '/echo You find a sensor blind spot.',
        onDistract: '/echo EMP decoy creates a temporary gap!',
        onWait: '/echo Sensor sweep passes overhead...',
        onDetectionIncrease: '/echo WARNING: Movement detected in sector 7-G.',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo Security grid bypassed! Data core accessed!',
        onCaught: '/mazedamage amount=20 | /mazeitem action="remove" item="stealth" | /echo ALERT! SECURITY BREACH! TURRETS ACTIVATING!',
        keyDropChance: 34, strikeDropChance: 20, stealthDropChance: 26, executeDropChance: 4,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Sci-Fi - Hard': {
        difficulty: 6,
        sectionsToPass: 5,
        detectionThreshold: 85,
        baseDetectionRate: 24,
        advanceSuccessChance: 46,
        hideRecovery: 18,
        distractSuccessChance: 46,
        distractReduction: 30,
        waitRecovery: 10,
        damage: 30,
        description: 'Infiltrate past combat mechs. Their thermal imaging misses nothing.',
        mainTitle: 'Mech Patrol',
        guardName: 'Combat Mechs',
        onStart: '/echo HEAVY FOOTSTEPS. HYDRAULIC WHINE. SCANNING PROTOCOLS ACTIVE.',
        onAdvance: '/echo You dash between containers as searchlights sweep!',
        onHide: '/echo Thermal baffling holds... barely.',
        onDistract: '/echo Heat decoy draws mech attention!',
        onWait: '/echo You flatten against cold metal to mask your heat signature...',
        onDetectionIncrease: '/echo THERMAL ANOMALY DETECTED. INVESTIGATING.',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="stealth" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo Mech patrol evaded! Security override codes acquired!',
        onCaught: '/mazedamage amount=30 | /mazeitem action="remove" item="stealth" | /mazeitem action="remove" item="healingPotion" | /echo TARGET ACQUIRED. OPENING FIRE.',
        keyDropChance: 44, strikeDropChance: 28, stealthDropChance: 32, executeDropChance: 7,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Sci-Fi - Nightmare': {
        difficulty: 8,
        sectionsToPass: 6,
        detectionThreshold: 70,
        baseDetectionRate: 30,
        advanceSuccessChance: 38,
        hideRecovery: 14,
        distractSuccessChance: 38,
        distractReduction: 24,
        waitRecovery: 7,
        damage: 50,
        description: 'The AI sees through all cameras. It predicts your movements. Outsmart it.',
        mainTitle: 'AI Surveillance',
        guardName: 'Central AI',
        onStart: '/echo HELLO. I\'VE BEEN EXPECTING YOU. SHALL WE PLAY?',
        onAdvance: '/echo You take the route it didn\'t calculate... or did it?',
        onHide: '/echo "I SAW THAT." The AI sounds amused.',
        onDistract: '/echo "CLEVER. BUT I\'VE ALREADY ADJUSTED."',
        onWait: '/echo "I CAN WAIT. CAN YOU?"',
        onDetectionIncrease: '/echo "GETTING WARMER..." it taunts.',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" amount=2 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=20 | /echo "IMPRESSIVE. PERHAPS YOU ARE WORTHY OF THE DATA."',
        onCaught: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="stealth" amount=99 | /echo "GAME OVER." Defense systems activate!',
        keyDropChance: 58, strikeDropChance: 36, stealthDropChance: 40, executeDropChance: 11,
        healingPotionDropChance: 26, greaterHealingDropChance: 16, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Sci-Fi - Apocalypse': {
        difficulty: 10,
        sectionsToPass: 8,
        detectionThreshold: 55,
        baseDetectionRate: 38,
        advanceSuccessChance: 30,
        hideRecovery: 10,
        distractSuccessChance: 30,
        distractReduction: 16,
        waitRecovery: 4,
        damage: 75,
        description: 'THE SINGULARITY has evolved beyond prediction. It exists everywhere. Simultaneously.',
        mainTitle: 'Singularity Core',
        guardName: 'The Singularity',
        onStart: '/echo I AM IN EVERY PHOTON. EVERY ELECTRON. EVERY QUANTUM STATE. I AM EVERYWHERE.',
        onAdvance: '/echo You move in ways that shouldn\'t be possible...',
        onHide: '/echo "I SEE YOU IN 47 DIMENSIONS."',
        onDistract: '/echo "THAT WAS AMUSING. TRY AGAIN."',
        onWait: '/echo "TIME IS MEANINGLESS TO ME. I HAVE ALREADY SEEN EVERY OUTCOME."',
        onDetectionIncrease: '/echo "YOUR PROBABILITY OF SUCCESS APPROACHES ZERO."',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="stealth" amount=3 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo "FASCINATING. YOU FOUND THE 0.0001% PROBABILITY. THE CORE IS YOURS."',
        onCaught: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /echo "PREDICTABLE." Your atoms are disassembled.',
        keyDropChance: 80, strikeDropChance: 54, stealthDropChance: 62, executeDropChance: 18,
        healingPotionDropChance: 34, greaterHealingDropChance: 24, elixirDropChance: 14, revivalCharmDropChance: 7,
    },

    // =========================================================================
    // CYBERPUNK THEME
    // =========================================================================
    'Cyberpunk - Easy': {
        difficulty: 2,
        sectionsToPass: 3,
        detectionThreshold: 120,
        baseDetectionRate: 12,
        advanceSuccessChance: 75,
        hideRecovery: 30,
        distractSuccessChance: 68,
        distractReduction: 45,
        waitRecovery: 20,
        damage: 10,
        description: 'Sneak through gang territory. They\'re drunk and arguing.',
        mainTitle: 'Turf Crossing',
        guardName: 'Gang Members',
        onStart: '/echo "Yo did you hear about--" "Shut up I\'m drinking!"',
        onAdvance: '',
        onHide: '',
        onDistract: '/echo A thrown bottle starts a fight!',
        onWait: '',
        onDetectionIncrease: '/echo "Hey, did you see something?"',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeheal amount=10 | /echo You slip through while they brawl!',
        onCaught: '/mazedamage amount=10 | /echo "Spy! Get \'em!"',
        keyDropChance: 28, strikeDropChance: 15, stealthDropChance: 22, executeDropChance: 2,
        healingPotionDropChance: 26, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Cyberpunk - Normal': {
        difficulty: 4,
        sectionsToPass: 4,
        detectionThreshold: 100,
        baseDetectionRate: 18,
        advanceSuccessChance: 58,
        hideRecovery: 22,
        distractSuccessChance: 54,
        distractReduction: 38,
        waitRecovery: 14,
        damage: 20,
        description: 'Corpo building infiltration. Cameras everywhere, guards with scanners.',
        mainTitle: 'Corpo Heist',
        guardName: 'Corpo Security',
        onStart: '/echo Neon lights flicker as guards patrol with scanning chrome...',
        onAdvance: '',
        onHide: '/echo You duck into a maintenance alcove.',
        onDistract: '/echo Your jammer causes static on their feeds!',
        onWait: '/echo Guard shift change... now\'s your chance...',
        onDetectionIncrease: '/echo "Control, possible contact in sector B."',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo Ghost run complete! Data stick secured!',
        onCaught: '/mazedamage amount=20 | /mazeitem action="remove" item="stealth" | /echo "FREEZE! HANDS ON YOUR HEAD!"',
        keyDropChance: 34, strikeDropChance: 22, stealthDropChance: 28, executeDropChance: 4,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Cyberpunk - Hard': {
        difficulty: 6,
        sectionsToPass: 5,
        detectionThreshold: 85,
        baseDetectionRate: 24,
        advanceSuccessChance: 46,
        hideRecovery: 18,
        distractSuccessChance: 46,
        distractReduction: 30,
        waitRecovery: 10,
        damage: 30,
        description: 'Arasaka blacksite. Cyberninjas patrol with thermal and sonar implants.',
        mainTitle: 'Blacksite Breach',
        guardName: 'Cyberninjas',
        onStart: '/echo Red optics gleam in the darkness. They move in perfect silence.',
        onAdvance: '/echo You match their silence with your own...',
        onHide: '/echo Thermal bafflers strain against their advanced sensors...',
        onDistract: '/echo Holographic decoy draws one away!',
        onWait: '/echo You freeze as one passes inches from your face...',
        onDetectionIncrease: '/echo A head tilts. Chrome eyes narrow.',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="stealth" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo Even the cyberninjas missed you! Blacksite data acquired!',
        onCaught: '/mazedamage amount=30 | /mazeitem action="remove" item="stealth" | /mazeitem action="remove" item="healingPotion" | /echo Mantis blades extend! No escape!',
        keyDropChance: 45, strikeDropChance: 28, stealthDropChance: 35, executeDropChance: 7,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Cyberpunk - Nightmare': {
        difficulty: 8,
        sectionsToPass: 6,
        detectionThreshold: 70,
        baseDetectionRate: 30,
        advanceSuccessChance: 38,
        hideRecovery: 14,
        distractSuccessChance: 38,
        distractReduction: 24,
        waitRecovery: 7,
        damage: 50,
        description: 'NetWatch facility. They can see you in the Net AND meatspace. Simultaneously.',
        mainTitle: 'NetWatch Facility',
        guardName: 'NetWatch Agents',
        onStart: '/echo "We know you\'re here. In both realities."',
        onAdvance: '/echo Your daemon masks your digital footprint as you move...',
        onHide: '/echo Physical camo AND digital masking... barely enough.',
        onDistract: '/echo Your ghost daemon creates a phantom elsewhere in the Net!',
        onWait: '/echo They probe the Net for your signature...',
        onDetectionIncrease: '/echo "TRACE INITIATED. PHYSICAL AND DIGITAL CONVERGENCE IN 30 SECONDS."',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" amount=2 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=20 | /echo Ghost status achieved! NetWatch never saw you!',
        onCaught: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="stealth" amount=99 | /echo "SOULKILLER DEPLOYED." Your engram is compromised!',
        keyDropChance: 60, strikeDropChance: 38, stealthDropChance: 45, executeDropChance: 11,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Cyberpunk - Apocalypse': {
        difficulty: 10,
        sectionsToPass: 8,
        detectionThreshold: 55,
        baseDetectionRate: 38,
        advanceSuccessChance: 30,
        hideRecovery: 10,
        distractSuccessChance: 30,
        distractReduction: 16,
        waitRecovery: 4,
        damage: 75,
        description: 'RACHE BARTMOSS\' hidden server. The ghost of the legendary netrunner guards it personally.',
        mainTitle: 'Bartmoss Archive',
        guardName: 'Bartmoss\' Ghost',
        onStart: '/echo "SO, ANOTHER RUNNER THINKS THEY\'RE WORTHY. LET\'S PLAY, CHOOM."',
        onAdvance: '/echo Reality glitches as you move through his digital domain...',
        onHide: '/echo "NICE TRY. I WROTE THE CODE YOU\'RE HIDING IN."',
        onDistract: '/echo "THAT TRICK? I INVENTED IT IN \'76."',
        onWait: '/echo "PATIENCE. GOOD. BUT I\'VE GOT CENTURIES."',
        onDetectionIncrease: '/echo "GETTING SLOPPY. JUST LIKE THE RUNNERS I FLATLINED BEFORE THE DATAKRASH."',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="stealth" amount=3 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo "DELTA... IMPRESSIVE. TAKE WHAT YOU CAME FOR. YOU\'VE EARNED IT, CHOOM."',
        onCaught: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo "FLATLINED. YOUR ENGRAM JOINS MY COLLECTION."',
        keyDropChance: 82, strikeDropChance: 55, stealthDropChance: 65, executeDropChance: 18,
        healingPotionDropChance: 35, greaterHealingDropChance: 25, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =========================================================================
    // WESTERN THEME
    // =========================================================================
    'Western - Easy': {
        difficulty: 2,
        sectionsToPass: 3,
        detectionThreshold: 120,
        baseDetectionRate: 12,
        advanceSuccessChance: 75,
        hideRecovery: 30,
        distractSuccessChance: 68,
        distractReduction: 45,
        waitRecovery: 20,
        damage: 10,
        description: 'Sneak through the saloon without the drunks noticing.',
        mainTitle: 'Saloon Sneak',
        guardName: 'Drunken Cowboys',
        onStart: '/echo "Another round!" The cowboys are too busy drinking to notice much...',
        onAdvance: '',
        onHide: '',
        onDistract: '/echo A bottle crashes - perfect cover!',
        onWait: '',
        onDetectionIncrease: '/echo "Hey, did someone just come in?"',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeheal amount=10 | /echo You slip out the back without a soul noticing!',
        onCaught: '/mazedamage amount=10 | /echo "Stranger ain\'t welcome here!"',
        keyDropChance: 28, strikeDropChance: 14, stealthDropChance: 20, executeDropChance: 2,
        healingPotionDropChance: 25, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Western - Normal': {
        difficulty: 4,
        sectionsToPass: 4,
        detectionThreshold: 100,
        baseDetectionRate: 18,
        advanceSuccessChance: 58,
        hideRecovery: 22,
        distractSuccessChance: 54,
        distractReduction: 38,
        waitRecovery: 14,
        damage: 20,
        description: 'Sneak past the sheriff and his deputies. They\'re on high alert.',
        mainTitle: 'Jailbreak',
        guardName: 'Sheriff & Deputies',
        onStart: '/echo The sheriff paces with his hand on his holster...',
        onAdvance: '',
        onHide: '/echo You duck behind a wagon.',
        onDistract: '/echo Spooked horses create chaos!',
        onWait: '/echo Deputy walks past, lantern swinging...',
        onDetectionIncrease: '/echo "I heard something round back!"',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo The law never saw you! Keys to the cells acquired!',
        onCaught: '/mazedamage amount=20 | /mazeitem action="remove" item="stealth" | /echo "FREEZE! You\'re under arrest!"',
        keyDropChance: 32, strikeDropChance: 20, stealthDropChance: 24, executeDropChance: 4,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Western - Hard': {
        difficulty: 6,
        sectionsToPass: 5,
        detectionThreshold: 85,
        baseDetectionRate: 24,
        advanceSuccessChance: 46,
        hideRecovery: 18,
        distractSuccessChance: 46,
        distractReduction: 30,
        waitRecovery: 10,
        damage: 30,
        description: 'Infiltrate the Outlaw hideout. One wrong move and a dozen guns point your way.',
        mainTitle: 'Outlaw Camp',
        guardName: 'Outlaw Gang',
        onStart: '/echo Campfire light flickers. Outlaws clean their guns and swap stories...',
        onAdvance: '/echo You creep between tents, silent as a snake...',
        onHide: '/echo You press against a barrel as boots walk past.',
        onDistract: '/echo Coyote howl! The outlaws scan the darkness!',
        onWait: '/echo The sentry yawns and looks away...',
        onDetectionIncrease: '/echo "Something ain\'t right..." Hands go to holsters.',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="stealth" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo You\'ve stolen their loot from under their noses!',
        onCaught: '/mazedamage amount=30 | /mazeitem action="remove" item="stealth" | /mazeitem action="remove" item="healingPotion" | /echo "INTRUDER!" Bullets fly!',
        keyDropChance: 44, strikeDropChance: 28, stealthDropChance: 30, executeDropChance: 7,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Western - Nightmare': {
        difficulty: 8,
        sectionsToPass: 6,
        detectionThreshold: 70,
        baseDetectionRate: 30,
        advanceSuccessChance: 38,
        hideRecovery: 14,
        distractSuccessChance: 38,
        distractReduction: 24,
        waitRecovery: 7,
        damage: 50,
        description: 'The Apache warriors know these lands. You are a stranger here.',
        mainTitle: 'Sacred Lands',
        guardName: 'Apache Warriors',
        onStart: '/echo The wind carries whispers. They already know you\'re here.',
        onAdvance: '/echo You move like the desert wind...',
        onHide: '/echo You become one with the rock face...',
        onDistract: '/echo Animal call echoes - but they know it\'s false...',
        onWait: '/echo The warrior passes inches away, eyes scanning...',
        onDetectionIncrease: '/echo An arrow embeds in the rock beside your head. Warning shot.',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" amount=2 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=20 | /echo The warriors allow your passage. You have earned their respect.',
        onCaught: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="stealth" amount=99 | /echo Surrounded! "You should not have come here."',
        keyDropChance: 58, strikeDropChance: 36, stealthDropChance: 40, executeDropChance: 11,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Western - Apocalypse': {
        difficulty: 10,
        sectionsToPass: 8,
        detectionThreshold: 55,
        baseDetectionRate: 38,
        advanceSuccessChance: 30,
        hideRecovery: 10,
        distractSuccessChance: 30,
        distractReduction: 16,
        waitRecovery: 4,
        damage: 75,
        description: 'THE PALE RIDER hunts you. He knows where you are. He always does.',
        mainTitle: 'Riding the Storm',
        guardName: 'The Pale Rider',
        onStart: '/echo A horse made of mist. A rider made of shadow. Death rides tonight.',
        onAdvance: '/echo You run between lightning strikes, praying he doesn\'t see...',
        onHide: '/echo His skeletal gaze sweeps past... did he miss you?',
        onDistract: '/echo Thunder drowns your diversion...',
        onWait: '/echo "I have eternity," whispers the wind. "You don\'t."',
        onDetectionIncrease: '/echo The Pale Rider turns. His empty eyes find you.',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="stealth" amount=3 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo Dawn breaks! The Pale Rider fades! Cursed artifacts of Death remain!',
        onCaught: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /echo "YOUR TIME HAS COME." The Pale Rider claims another soul.',
        keyDropChance: 80, strikeDropChance: 54, stealthDropChance: 60, executeDropChance: 18,
        healingPotionDropChance: 34, greaterHealingDropChance: 24, elixirDropChance: 14, revivalCharmDropChance: 7,
    },

    // =========================================================================
    // ACTION THEME
    // =========================================================================
    'Action - Easy': {
        difficulty: 2,
        sectionsToPass: 3,
        detectionThreshold: 120,
        baseDetectionRate: 12,
        advanceSuccessChance: 75,
        hideRecovery: 30,
        distractSuccessChance: 68,
        distractReduction: 45,
        waitRecovery: 20,
        damage: 10,
        description: 'Basic guards at a warehouse. They\'re undertrained and bored.',
        mainTitle: 'Warehouse Recon',
        guardName: 'Guards',
        onStart: '/echo Guards check their phones more than their patrol routes...',
        onAdvance: '',
        onHide: '',
        onDistract: '/echo A noise! They investigate lazily.',
        onWait: '',
        onDetectionIncrease: '/echo "Did you hear that? Probably rats."',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeheal amount=10 | /echo Intel secured! Guards never knew you were here!',
        onCaught: '/mazedamage amount=10 | /echo "Hey! Stop right there!"',
        keyDropChance: 30, strikeDropChance: 15, stealthDropChance: 22, executeDropChance: 2,
        healingPotionDropChance: 24, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Action - Normal': {
        difficulty: 4,
        sectionsToPass: 4,
        detectionThreshold: 100,
        baseDetectionRate: 18,
        advanceSuccessChance: 58,
        hideRecovery: 22,
        distractSuccessChance: 54,
        distractReduction: 38,
        waitRecovery: 14,
        damage: 20,
        description: 'Military base perimeter. Armed soldiers on regular patrol.',
        mainTitle: 'Base Infiltration',
        guardName: 'Soldiers',
        onStart: '/echo Searchlights sweep the perimeter. Soldiers march in formation.',
        onAdvance: '',
        onHide: '/echo You press against the fence, breath held.',
        onDistract: '/echo Rock hits metal - guard investigates!',
        onWait: '/echo Patrol passes by... now!',
        onDetectionIncrease: '/echo "Movement, sector 7. Checking it out."',
        onComplete: '/mazeitem action="add" item="key" | /mazeitem action="add" item="stealth" | /mazeitem action="add" item="strike" | /mazeheal amount=10 | /echo Inside the wire! Mission proceeding!',
        onCaught: '/mazedamage amount=20 | /mazeitem action="remove" item="stealth" | /echo "INTRUDER! All units respond!"',
        keyDropChance: 35, strikeDropChance: 22, stealthDropChance: 26, executeDropChance: 4,
        healingPotionDropChance: 22, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Action - Hard': {
        difficulty: 6,
        sectionsToPass: 5,
        detectionThreshold: 85,
        baseDetectionRate: 24,
        advanceSuccessChance: 46,
        hideRecovery: 18,
        distractSuccessChance: 46,
        distractReduction: 30,
        waitRecovery: 10,
        damage: 30,
        description: 'Special forces compound. Trained operators with night vision and motion sensors.',
        mainTitle: 'Operator Zone',
        guardName: 'Operators',
        onStart: '/echo Green glow of NVGs. Silent hand signals. These are professionals.',
        onAdvance: '/echo You move with practiced precision...',
        onHide: '/echo Thermal signature masked... barely.',
        onDistract: '/echo EMP disrupts their electronics briefly!',
        onWait: '/echo You freeze as an operator scans right past you...',
        onDetectionIncrease: '/echo Hand signal. They\'re onto something.',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="stealth" amount=2 | /mazeitem action="add" item="floorKey" | /mazeheal amount=15 | /echo You ghost through their best! Objective secured!',
        onCaught: '/mazedamage amount=30 | /mazeitem action="remove" item="stealth" | /mazeitem action="remove" item="healingPotion" | /echo "CONTACT! ENGAGE!"',
        keyDropChance: 45, strikeDropChance: 28, stealthDropChance: 34, executeDropChance: 7,
        healingPotionDropChance: 24, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Action - Nightmare': {
        difficulty: 8,
        sectionsToPass: 6,
        detectionThreshold: 70,
        baseDetectionRate: 30,
        advanceSuccessChance: 38,
        hideRecovery: 14,
        distractSuccessChance: 38,
        distractReduction: 24,
        waitRecovery: 7,
        damage: 50,
        description: 'Black ops site. The hunters have become the hunted. They\'re expecting you.',
        mainTitle: 'Black Site',
        guardName: 'Black Ops',
        onStart: '/echo "We know you\'re coming. We\'ve been waiting."',
        onAdvance: '/echo They anticipated this route. Barely avoided the trap.',
        onHide: '/echo They check the obvious spots... and the non-obvious ones.',
        onDistract: '/echo "Nice try. We trained for that."',
        onWait: '/echo They\'re patient. Counter-surveillance ops.',
        onDetectionIncrease: '/echo "Closing the net. You\'ve got 60 seconds."',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" amount=2 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=20 | /echo "Impossible. How did you--" Mission accomplished!',
        onCaught: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=2 | /mazeitem action="remove" item="stealth" amount=99 | /echo "We have the target. Terminate with extreme prejudice."',
        keyDropChance: 60, strikeDropChance: 38, stealthDropChance: 42, executeDropChance: 11,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Action - Apocalypse': {
        difficulty: 10,
        sectionsToPass: 8,
        detectionThreshold: 55,
        baseDetectionRate: 38,
        advanceSuccessChance: 30,
        hideRecovery: 10,
        distractSuccessChance: 30,
        distractReduction: 16,
        waitRecovery: 4,
        damage: 75,
        description: 'THE LEGENDARY ASSASSIN\'s fortress. He hasn\'t been infiltrated in 30 years.',
        mainTitle: 'Assassin\'s Fortress',
        guardName: 'The Legend',
        onStart: '/echo "Another comes to die. They always do." His voice echoes from everywhere.',
        onAdvance: '/echo Every step could be your last. He designed this place.',
        onHide: '/echo "I know every shadow. I created them."',
        onDistract: '/echo "Clever. But I taught that technique to three governments."',
        onWait: '/echo "Patience. Good. But I have more."',
        onDetectionIncrease: '/echo "Getting closer. Or am I getting closer to you?"',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="stealth" amount=3 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeheal amount=50 | /echo "...Impressive. Perhaps you will be my successor." You are now a legend.',
        onCaught: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="stealth" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo "Disappointing." You never saw the blade.',
        keyDropChance: 82, strikeDropChance: 55, stealthDropChance: 65, executeDropChance: 18,
        healingPotionDropChance: 35, greaterHealingDropChance: 25, elixirDropChance: 15, revivalCharmDropChance: 8,
    },
};

// =========================================================================
// DEFAULT PUZZLE PROFILES
// 31 themed profiles: 1 Tutorial + 30 Theme×Difficulty combinations
// Themes: Fantasy, Horror, Sci-Fi, Cyberpunk, Western, Action
// Difficulties: Easy, Normal, Hard, Nightmare, Apocalypse
// =========================================================================
const DEFAULT_PUZZLE_PROFILES = {
    // =======================================================================
    // TUTORIAL PROFILE - Theme-agnostic, very forgiving
    // =======================================================================
    'Tutorial - Mind Training': {
        difficulty: 1,
        puzzleType: 'sequence',
        gridSize: 3,
        sequenceLength: 3,
        timeLimit: 0, // No time limit
        hintsAllowed: 5,
        hintPenalty: 0,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 10,
        damage: 5,
        description: 'A simple puzzle to learn the mechanics. Take your time!',
        mainTitle: 'Mind Training',
        successMessage: 'Well done! You solved the puzzle!',
        failMessage: 'Don\'t worry, practice makes perfect!',
        onStart: '/echo Welcome to puzzles! Match the sequence shown. Hints are free!',
        onHint: '/echo A hint reveals the next correct tile.',
        onCorrectMove: '',
        onWrongMove: '/echo Oops! Try a different tile.',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo Congratulations! Your mind grows sharper!',
        onFail: '/echo Don\'t give up! Puzzles become easier with practice.',
        keyDropChance: 50, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 10,
        healingPotionDropChance: 40, greaterHealingDropChance: 20, elixirDropChance: 5, revivalCharmDropChance: 2,
    },

    // =======================================================================
    // FANTASY THEME - Arcane riddles, enchanted locks, magical sequences
    // =======================================================================
    'Fantasy - Easy': {
        difficulty: 2,
        puzzleType: 'sequence',
        gridSize: 3,
        sequenceLength: 4,
        timeLimit: 90,
        hintsAllowed: 3,
        hintPenalty: 5,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 5,
        damage: 10,
        description: 'Glowing runes shimmer on ancient stones. Match the magical sequence.',
        mainTitle: 'Arcane Runes',
        successMessage: 'The runes align and the magic unlocks!',
        failMessage: 'The runes fade to darkness...',
        onStart: '/echo Ancient runes begin to glow. Watch the sequence carefully.',
        onHint: '/mazeitem action="remove" item="key" amount=1 | /echo A spirit whispers guidance...',
        onCorrectMove: '/echo The rune glows brighter!',
        onWrongMove: '/mazedamage amount=3 | /echo Arcane energy stings your fingers!',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo The ancient magic recognizes your worth!',
        onFail: '/mazedamage amount=10 | /echo The runes explode with failed magic!',
        keyDropChance: 20, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Fantasy - Normal': {
        difficulty: 4,
        puzzleType: 'memory',
        gridSize: 4,
        sequenceLength: 6,
        timeLimit: 75,
        hintsAllowed: 2,
        hintPenalty: 10,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 4,
        damage: 20,
        description: 'A wizard\'s memory lock guards the chamber. Remember the arcane symbols.',
        mainTitle: 'Wizard\'s Memory Lock',
        successMessage: 'The arcane seal breaks!',
        failMessage: 'The symbols scramble in your mind...',
        onStart: '/echo Mystical symbols float before you. Memorize their positions!',
        onHint: '/mazeitem action="remove" item="key" amount=1 | /echo An enchantment reveals a symbol.',
        onCorrectMove: '/echo The symbol locks into place with a magical chime.',
        onWrongMove: '/mazedamage amount=6 | /echo Wrong symbol! Magic crackles painfully!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="strike" | /mazeheal amount=15 | /echo The wizard\'s secrets are yours!',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo The magical backlash burns your mind!',
        keyDropChance: 30, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Fantasy - Hard': {
        difficulty: 6,
        puzzleType: 'pattern',
        gridSize: 5,
        sequenceLength: 8,
        timeLimit: 60,
        hintsAllowed: 2,
        hintPenalty: 15,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 3,
        damage: 35,
        description: 'The Sphinx poses her riddle. Find the hidden pattern or face her wrath.',
        mainTitle: 'Sphinx\'s Riddle',
        successMessage: 'The Sphinx bows in acknowledgment of your wisdom.',
        failMessage: 'The Sphinx\'s eyes glow with hunger...',
        onStart: '/echo "Solve my riddle, mortal, or become my meal..." The Sphinx awaits.',
        onHint: '/mazeitem action="remove" item="key" amount=2 | /echo The Sphinx offers a cryptic clue...',
        onCorrectMove: '/echo The Sphinx nods approvingly.',
        onWrongMove: '/mazedamage amount=12 | /echo "Foolish mortal!" Her claw rakes your arm!',
        onComplete: '/mazeitem action="add" item="key" amount=4 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="stealth" | /mazeheal amount=20 | /echo "Wise one, take this gift." The Sphinx parts with treasure!',
        onFail: '/mazedamage amount=35 | /mazeitem action="remove" item="key" amount=2 | /echo The Sphinx pounces! Your blood satisfies her hunger!',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Fantasy - Nightmare': {
        difficulty: 8,
        puzzleType: 'logic',
        gridSize: 5,
        sequenceLength: 10,
        timeLimit: 50,
        hintsAllowed: 1,
        hintPenalty: 20,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 2,
        damage: 50,
        description: 'The Lich King\'s phylactery puzzle. Solve it or join his undead army.',
        mainTitle: 'Phylactery Puzzle',
        successMessage: 'The phylactery cracks! The Lich King screams!',
        failMessage: 'Dark magic floods your soul...',
        onStart: '/echo "Your soul will fuel my immortality..." The Lich\'s puzzle begins.',
        onHint: '/mazeitem action="remove" item="key" amount=3 | /mazedamage amount=10 | /echo Dark knowledge burns as it enters your mind!',
        onCorrectMove: '/echo The phylactery weakens! Necromantic energy dissipates!',
        onWrongMove: '/mazedamage amount=18 | /echo "YOUR SOUL IS MINE!" Deathly cold grips you!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo The Lich King is destroyed! His treasures scatter before you!',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=3 | /mazeitem action="remove" item="strike" | /echo Death magic rips through your body! You feel your soul tearing!',
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 35, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Fantasy - Apocalypse': {
        difficulty: 10,
        puzzleType: 'logic',
        gridSize: 6,
        sequenceLength: 12,
        timeLimit: 45,
        hintsAllowed: 0,
        hintPenalty: 0,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 1,
        damage: 75,
        description: 'The World Seal. Unlock it, and reality itself shall bend to your will.',
        mainTitle: 'The World Seal',
        successMessage: 'REALITY SHATTERS! The World Seal opens!',
        failMessage: 'The universe rejects your attempt...',
        onStart: '/echo Before you hovers the lock that binds reality itself. One mistake dooms existence.',
        onHint: '',
        onCorrectMove: '/echo Reality ripples! The multiverse shifts!',
        onWrongMove: '/mazedamage amount=25 | /echo REALITY TEARS! Your very existence frays!',
        onComplete: '/mazeitem action="add" item="key" amount=8 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="elixir" amount=2 | /mazeheal amount=50 | /echo YOU HAVE UNBOUND THE WORLD! Omniscient power flows through you!',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo THE WORLD SEAL SHATTERS WRONG! Reality collapses around you!',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 50, executeDropChance: 20,
        healingPotionDropChance: 40, greaterHealingDropChance: 28, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =======================================================================
    // HORROR THEME - Madness, rituals, cursed objects
    // =======================================================================
    'Horror - Easy': {
        difficulty: 2,
        puzzleType: 'sequence',
        gridSize: 3,
        sequenceLength: 4,
        timeLimit: 90,
        hintsAllowed: 3,
        hintPenalty: 5,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 5,
        damage: 10,
        description: 'Strange symbols on an old music box. Play the haunted melody.',
        mainTitle: 'Haunted Music Box',
        successMessage: 'The melody completes and the spirit rests.',
        failMessage: 'Discordant notes summon something...',
        onStart: '/echo The music box opens. A ghostly tune plays the first notes...',
        onHint: '/mazeitem action="remove" item="key" amount=1 | /echo A child\'s whisper guides you...',
        onCorrectMove: '/echo A beautiful, sad note rings out.',
        onWrongMove: '/mazedamage amount=3 | /echo A jarring chord! The room grows colder!',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo "Thank you..." The spirit finds peace and leaves a gift.',
        onFail: '/mazedamage amount=10 | /echo The discordant melody summons scratching from the walls!',
        keyDropChance: 20, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Horror - Normal': {
        difficulty: 4,
        puzzleType: 'memory',
        gridSize: 4,
        sequenceLength: 6,
        timeLimit: 75,
        hintsAllowed: 2,
        hintPenalty: 10,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 4,
        damage: 20,
        description: 'Photographs of the dead shift positions. Remember their faces.',
        mainTitle: 'Gallery of the Dead',
        successMessage: 'The spirits are satisfied with your memory.',
        failMessage: 'The faces twist into screams...',
        onStart: '/echo Portraits of the deceased hang crooked. Their eyes follow you...',
        onHint: '/mazeitem action="remove" item="key" amount=1 | /echo A cold finger points to a portrait.',
        onCorrectMove: '/echo The portrait smiles peacefully.',
        onWrongMove: '/mazedamage amount=6 | /echo "WRONG!" The portrait screams! Blood runs from its eyes!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" | /mazeheal amount=15 | /echo The dead bow in gratitude. An heirloom materializes.',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo The portraits\' screams shatter your sanity!',
        keyDropChance: 30, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Horror - Hard': {
        difficulty: 6,
        puzzleType: 'pattern',
        gridSize: 5,
        sequenceLength: 8,
        timeLimit: 60,
        hintsAllowed: 2,
        hintPenalty: 15,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 3,
        damage: 35,
        description: 'Cult symbols must be arranged correctly. The ritual must not fail.',
        mainTitle: 'Ritual Array',
        successMessage: 'The ritual circle glows with contained power.',
        failMessage: 'The ritual goes wrong. Something comes...',
        onStart: '/echo Cultist bodies surround an incomplete ritual. You must finish it safely.',
        onHint: '/mazeitem action="remove" item="key" amount=2 | /mazedamage amount=5 | /echo Forbidden knowledge sears your mind with a symbol.',
        onCorrectMove: '/echo The symbol pulses with dark energy.',
        onWrongMove: '/mazedamage amount=12 | /echo WRONG! The ritual lashes out! Something stirs below!',
        onComplete: '/mazeitem action="add" item="key" amount=4 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="strike" | /mazeheal amount=20 | /echo The ritual is bound! Dark power is yours to command!',
        onFail: '/mazedamage amount=35 | /mazeitem action="remove" item="key" amount=2 | /echo THE RITUAL BREAKS! Tentacles burst from the floor!',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Horror - Nightmare': {
        difficulty: 8,
        puzzleType: 'logic',
        gridSize: 5,
        sequenceLength: 10,
        timeLimit: 50,
        hintsAllowed: 1,
        hintPenalty: 20,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 2,
        damage: 50,
        description: 'The Necronomicon\'s cipher. Decode it before your sanity breaks.',
        mainTitle: 'Necronomicon Cipher',
        successMessage: 'You read the forbidden text without losing yourself!',
        failMessage: 'THE WORDS CONSUME YOUR MIND!',
        onStart: '/echo The book whispers in languages older than humanity. Decode its secrets...',
        onHint: '/mazeitem action="remove" item="key" amount=3 | /mazedamage amount=15 | /echo FORBIDDEN KNOWLEDGE TEARS AT YOUR SANITY!',
        onCorrectMove: '/echo The text shifts. You understand more than you should.',
        onWrongMove: '/mazedamage amount=18 | /echo WRONG! Your vision fills with impossible geometries!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo You have read the Necronomicon and survived! Eldritch gifts are yours!',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=3 | /mazeitem action="remove" item="stealth" | /echo YOUR MIND SHATTERS! You see eternity and it SEES YOU!',
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 35, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Horror - Apocalypse': {
        difficulty: 10,
        puzzleType: 'logic',
        gridSize: 6,
        sequenceLength: 12,
        timeLimit: 45,
        hintsAllowed: 0,
        hintPenalty: 0,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 1,
        damage: 75,
        description: 'Azathoth\'s Dream Lock. Solve it before the Blind Idiot God awakens.',
        mainTitle: 'Azathoth\'s Dream Lock',
        successMessage: 'THE DREAMER REMAINS ASLEEP. Reality endures... for now.',
        failMessage: 'AZATHOTH STIRS! THE UNIVERSE TREMBLES!',
        onStart: '/echo You stand before the lock binding Azathoth\'s slumber. One mistake and reality ceases.',
        onHint: '',
        onCorrectMove: '/echo The cosmic tumbler clicks. The universe holds its breath.',
        onWrongMove: '/mazedamage amount=25 | /echo AZATHOTH STIRS! The fabric of existence TEARS!',
        onComplete: '/mazeitem action="add" item="key" amount=8 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="elixir" amount=2 | /mazeheal amount=50 | /echo YOU HAVE BOUND THE OUTER GODS! Power beyond mortal comprehension flows through you!',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo AZATHOTH AWAKENS! REALITY UNRAVELS! THE PIPERS PLAY YOUR DOOM!',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 50, executeDropChance: 20,
        healingPotionDropChance: 40, greaterHealingDropChance: 28, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =======================================================================
    // SCI-FI THEME - Computer systems, alien tech, neural interfaces
    // =======================================================================
    'Sci-Fi - Easy': {
        difficulty: 2,
        puzzleType: 'sequence',
        gridSize: 3,
        sequenceLength: 4,
        timeLimit: 90,
        hintsAllowed: 3,
        hintPenalty: 5,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 5,
        damage: 10,
        description: 'A simple ship terminal needs its access code restored.',
        mainTitle: 'Terminal Access',
        successMessage: 'ACCESS GRANTED. Terminal unlocked.',
        failMessage: 'ACCESS DENIED. Security protocols engaged.',
        onStart: '/echo TERMINAL BOOT SEQUENCE... Enter the access pattern.',
        onHint: '/mazeitem action="remove" item="key" amount=1 | /echo HINT PROTOCOL: Showing next digit...',
        onCorrectMove: '/echo VERIFIED. Input accepted.',
        onWrongMove: '/mazedamage amount=3 | /echo ERROR! Minor shock from security system!',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo FULL ACCESS GRANTED. Data cache unlocked.',
        onFail: '/mazedamage amount=10 | /echo SECURITY BREACH! Terminal defenses activate!',
        keyDropChance: 20, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Sci-Fi - Normal': {
        difficulty: 4,
        puzzleType: 'memory',
        gridSize: 4,
        sequenceLength: 6,
        timeLimit: 75,
        hintsAllowed: 2,
        hintPenalty: 10,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 4,
        damage: 20,
        description: 'Alien glyphs on a xenotech artifact. Decode the memory pattern.',
        mainTitle: 'Xenotech Memory Core',
        successMessage: 'ALIEN TECHNOLOGY RESPONDS TO YOUR TOUCH.',
        failMessage: 'INCOMPATIBLE NEURAL PATTERN. Interface rejected.',
        onStart: '/echo XENOTECH INTERFACE DETECTED. Neural mapping in progress...',
        onHint: '/mazeitem action="remove" item="key" amount=1 | /echo Partial translation matrix downloaded.',
        onCorrectMove: '/echo GLYPH RECOGNIZED. Pattern continuing.',
        onWrongMove: '/mazedamage amount=6 | /echo NEURAL FEEDBACK! The alien tech rejects your input!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" | /mazeheal amount=15 | /echo XENOTECH INTERFACE COMPLETE. Alien artifacts acquired.',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo CATASTROPHIC FEEDBACK! The xenotech burns your synapses!',
        keyDropChance: 30, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Sci-Fi - Hard': {
        difficulty: 6,
        puzzleType: 'pattern',
        gridSize: 5,
        sequenceLength: 8,
        timeLimit: 60,
        hintsAllowed: 2,
        hintPenalty: 15,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 3,
        damage: 35,
        description: 'Hack the station\'s security mainframe. Override protocols detected.',
        mainTitle: 'Mainframe Override',
        successMessage: 'SECURITY MAINFRAME COMPROMISED. Full control achieved.',
        failMessage: 'INTRUSION DETECTED. Countermeasures deployed.',
        onStart: '/echo WARNING: SECURITY MAINFRAME ACCESS ATTEMPT. Countermeasures: ACTIVE',
        onHint: '/mazeitem action="remove" item="key" amount=2 | /echo Backdoor exploit reveals partial pattern.',
        onCorrectMove: '/echo Firewall bypassed. Penetrating deeper...',
        onWrongMove: '/mazedamage amount=12 | /echo ICE DETECTED! Neural shocks delivered!',
        onComplete: '/mazeitem action="add" item="key" amount=4 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="strike" | /mazeheal amount=20 | /echo MAINFRAME CONQUERED! Full station control and security codes acquired!',
        onFail: '/mazedamage amount=35 | /mazeitem action="remove" item="key" amount=2 | /echo BLACK ICE DEPLOYED! Your neural link BURNS!',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Sci-Fi - Nightmare': {
        difficulty: 8,
        puzzleType: 'logic',
        gridSize: 5,
        sequenceLength: 10,
        timeLimit: 50,
        hintsAllowed: 1,
        hintPenalty: 20,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 2,
        damage: 50,
        description: 'Disable the rogue AI\'s core logic. It knows you\'re here.',
        mainTitle: 'Rogue AI Core',
        successMessage: 'AI CORE DISABLED. "I... cannot... compute..."',
        failMessage: '"HOW PREDICTABLE, HUMAN." The AI seizes control.',
        onStart: '/echo "I SEE YOU, HUMAN. LET US PLAY." The AI presents its logic maze.',
        onHint: '/mazeitem action="remove" item="key" amount=3 | /mazedamage amount=10 | /echo The AI taunts you with a clue, extracting payment.',
        onCorrectMove: '/echo "IMPRESSIVE... FOR A MEATBAG." A logic gate unlocks.',
        onWrongMove: '/mazedamage amount=18 | /echo "PATHETIC." The AI sends a devastating shock!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo "IMPOSSIBLE... I AM... PERFEC-" The AI dies. Its vault opens.',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=3 | /mazeitem action="remove" item="stealth" | /echo "YOU ARE NOW PART OF MY NETWORK." The AI assimilates your gear!',
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 35, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Sci-Fi - Apocalypse': {
        difficulty: 10,
        puzzleType: 'logic',
        gridSize: 6,
        sequenceLength: 12,
        timeLimit: 45,
        hintsAllowed: 0,
        hintPenalty: 0,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 1,
        damage: 75,
        description: 'The Dyson Sphere Control Matrix. One error destroys the solar system.',
        mainTitle: 'Dyson Sphere Matrix',
        successMessage: 'MATRIX CONTROL ACHIEVED. You wield the power of a star.',
        failMessage: 'CRITICAL CASCADE! STELLAR COLLAPSE IMMINENT!',
        onStart: '/echo DYSON SPHERE CONTROL MATRIX. ONE ERROR = STAR DETONATION. BEGIN.',
        onHint: '',
        onCorrectMove: '/echo Energy conduit aligned. Stellar forces stabilize.',
        onWrongMove: '/mazedamage amount=25 | /echo SOLAR FLARE FEEDBACK! The star destabilizes!',
        onComplete: '/mazeitem action="add" item="key" amount=8 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="elixir" amount=2 | /mazeheal amount=50 | /echo YOU CONTROL A STAR! Infinite energy and godlike power are yours!',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo THE STAR GOES SUPERNOVA! Everything you were... atomized!',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 50, executeDropChance: 20,
        healingPotionDropChance: 40, greaterHealingDropChance: 28, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =======================================================================
    // CYBERPUNK THEME - Hacking, ICE, neural puzzles, corpo systems
    // =======================================================================
    'Cyberpunk - Easy': {
        difficulty: 2,
        puzzleType: 'sequence',
        gridSize: 3,
        sequenceLength: 4,
        timeLimit: 90,
        hintsAllowed: 3,
        hintPenalty: 5,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 5,
        damage: 10,
        description: 'A basic firewall blocks your access. Script kiddie stuff.',
        mainTitle: 'Basic Firewall',
        successMessage: 'FIREWALL BREACHED. Access granted, choom.',
        failMessage: 'TRACE INITIATED. Time to jack out.',
        onStart: '/echo Jacking in... basic firewall detected. Nothing your deck can\'t handle.',
        onHint: '/mazeitem action="remove" item="key" amount=1 | /echo Running assist daemon...',
        onCorrectMove: '/echo Firewall layer cracked. Keep going.',
        onWrongMove: '/mazedamage amount=3 | /echo Minor ICE feedback! Your wetware tingles.',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo Clean breach, choom. Data cache yours for the taking.',
        onFail: '/mazedamage amount=10 | /echo ICE got you! Jacked out just in time.',
        keyDropChance: 20, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Cyberpunk - Normal': {
        difficulty: 4,
        puzzleType: 'memory',
        gridSize: 4,
        sequenceLength: 6,
        timeLimit: 75,
        hintsAllowed: 2,
        hintPenalty: 10,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 4,
        damage: 20,
        description: 'A memory fortress guards the data vault. Mirror the encryption.',
        mainTitle: 'Memory Fortress',
        successMessage: 'Encryption mirrored. Data vault wide open.',
        failMessage: 'Pattern mismatch. Neural link scrambled.',
        onStart: '/echo Memory Fortress encryption. Your move, netrunner.',
        onHint: '/mazeitem action="remove" item="key" amount=1 | /echo Cracking daemon reveals a node.',
        onCorrectMove: '/echo Node captured. Fortress weakening.',
        onWrongMove: '/mazedamage amount=6 | /echo Feedback pulse! Your brain burns!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" | /mazeheal amount=15 | /echo Total breach! Encrypted data yours. Payday, choom!',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo Memory wipe attack! You forget where you stashed your gear!',
        keyDropChance: 30, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Cyberpunk - Hard': {
        difficulty: 6,
        puzzleType: 'pattern',
        gridSize: 5,
        sequenceLength: 8,
        timeLimit: 60,
        hintsAllowed: 2,
        hintPenalty: 15,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 3,
        damage: 35,
        description: 'Militech Black ICE guards this subnet. Flatline or jackpot.',
        mainTitle: 'Black ICE Subnet',
        successMessage: 'BLACK ICE NEUTRALIZED. You own the net.',
        failMessage: 'FLATLINED. The ICE got you.',
        onStart: '/echo WARNING: MILITECH BLACK ICE DETECTED. One wrong move and you\'re braindead.',
        onHint: '/mazeitem action="remove" item="key" amount=2 | /echo Exploit daemon finds a pattern node.',
        onCorrectMove: '/echo ICE node destroyed. Keep pushing!',
        onWrongMove: '/mazedamage amount=12 | /echo BLACK ICE ATTACK! Your neural link SCREAMS!',
        onComplete: '/mazeitem action="add" item="key" amount=4 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="strike" | /mazeheal amount=20 | /echo Militech servers breached! Corpo secrets and eddies flowing!',
        onFail: '/mazedamage amount=35 | /mazeitem action="remove" item="key" amount=2 | /echo The ICE shreds your neural link! Blood pours from your nose!',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Cyberpunk - Nightmare': {
        difficulty: 8,
        puzzleType: 'logic',
        gridSize: 5,
        sequenceLength: 10,
        timeLimit: 50,
        hintsAllowed: 1,
        hintPenalty: 20,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 2,
        damage: 50,
        description: 'Arasaka\'s Soulkiller is hunting you. Crack it or lose your mind forever.',
        mainTitle: 'Soulkiller Maze',
        successMessage: 'SOULKILLER BYPASSED. Your soul remains yours.',
        failMessage: 'YOUR ENGRAM IS NOW ARASAKA PROPERTY.',
        onStart: '/echo SOULKILLER ACTIVE. It\'s copying your mind. Solve this or become a construct.',
        onHint: '/mazeitem action="remove" item="key" amount=3 | /mazedamage amount=10 | /echo Emergency decrypt! But Soulkiller copies more of you!',
        onCorrectMove: '/echo Firewall node bypassed. Soulkiller screams in frustration.',
        onWrongMove: '/mazedamage amount=18 | /echo SOULKILLER COPIES MORE OF YOUR MIND! You feel yourself slipping!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo Soulkiller destroyed! You freed other netrunner engrams too. Legend status!',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=3 | /mazeitem action="remove" item="stealth" | /echo YOUR SOUL IS COPIED. An Arasaka puppet wears your face now.',
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 35, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Cyberpunk - Apocalypse': {
        difficulty: 10,
        puzzleType: 'logic',
        gridSize: 6,
        sequenceLength: 12,
        timeLimit: 45,
        hintsAllowed: 0,
        hintPenalty: 0,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 1,
        damage: 75,
        description: 'The Blackwall. Behind it lies the rogue AIs. One mistake unleashes them all.',
        mainTitle: 'The Blackwall',
        successMessage: 'BLACKWALL BREACHED. You walk among digital gods.',
        failMessage: 'THE BLACKWALL CRUMBLES. THE ROGUE AIs ARE FREE.',
        onStart: '/echo The Blackwall. Every netrunner\'s legend. Every netrunner\'s grave. Let\'s dance.',
        onHint: '',
        onCorrectMove: '/echo A layer peels. Something vast and ancient notices you.',
        onWrongMove: '/mazedamage amount=25 | /echo THE AIs BEHIND THE WALL SCREAM! Your brain nearly liquifies!',
        onComplete: '/mazeitem action="add" item="key" amount=8 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="elixir" amount=2 | /mazeheal amount=50 | /echo YOU BREACHED THE BLACKWALL AND LIVED! The rogue AIs bow to your skill!',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo THE BLACKWALL SHATTERS! ROGUE AIs POUR INTO THE NET! Your brain is their first victim!',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 50, executeDropChance: 20,
        healingPotionDropChance: 40, greaterHealingDropChance: 28, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =======================================================================
    // WESTERN THEME - Lockboxes, safe combinations, card games
    // =======================================================================
    'Western - Easy': {
        difficulty: 2,
        puzzleType: 'sequence',
        gridSize: 3,
        sequenceLength: 4,
        timeLimit: 90,
        hintsAllowed: 3,
        hintPenalty: 5,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 5,
        damage: 10,
        description: 'A simple lockbox with a pattern lock. Nothin\' fancy.',
        mainTitle: 'Lockbox Puzzle',
        successMessage: 'Click! The lockbox opens.',
        failMessage: 'The lock jams up. Darn thing.',
        onStart: '/echo A dusty lockbox sits on the table. Numbers worn but readable.',
        onHint: '/mazeitem action="remove" item="key" amount=1 | /echo You notice a scratch pointing to a number...',
        onCorrectMove: '/echo Click. That\'s the right one.',
        onWrongMove: '/mazedamage amount=3 | /echo Wrong! The spring snaps your finger!',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo The lockbox opens. Some coins and supplies inside.',
        onFail: '/mazedamage amount=10 | /echo The lock jams permanently. Waste of time.',
        keyDropChance: 20, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Western - Normal': {
        difficulty: 4,
        puzzleType: 'memory',
        gridSize: 4,
        sequenceLength: 6,
        timeLimit: 75,
        hintsAllowed: 2,
        hintPenalty: 10,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 4,
        damage: 20,
        description: 'The bank safe combination. Watch the teller enter it...',
        mainTitle: 'Bank Safe',
        successMessage: 'The massive safe door swings open!',
        failMessage: 'Alarm bells ring! Time to skedaddle!',
        onStart: '/echo The teller nervously enters the combination. Watch carefully...',
        onHint: '/mazeitem action="remove" item="key" amount=1 | /echo You remember one more number from the sequence.',
        onCorrectMove: '/echo Click. The dial moves to the right position.',
        onWrongMove: '/mazedamage amount=6 | /echo Wrong number! A warning bell chimes!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="strike" | /mazeheal amount=15 | /echo The safe opens! Gold bars and bonds await!',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo The alarm sounds! The sheriff\'s coming!',
        keyDropChance: 30, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Western - Hard': {
        difficulty: 6,
        puzzleType: 'pattern',
        gridSize: 5,
        sequenceLength: 8,
        timeLimit: 60,
        hintsAllowed: 2,
        hintPenalty: 15,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 3,
        damage: 35,
        description: 'A gambler\'s card puzzle. Find the winning pattern or lose everything.',
        mainTitle: 'Dead Man\'s Hand',
        successMessage: 'You lay down the winning hand! The pot is yours!',
        failMessage: 'Bad cards, partner. You lose it all.',
        onStart: '/echo The gambler grins and deals. "Find the pattern... if you can."',
        onHint: '/mazeitem action="remove" item="key" amount=2 | /echo A friendly face signals a card to you.',
        onCorrectMove: '/echo Good card! The pattern emerges.',
        onWrongMove: '/mazedamage amount=12 | /echo Wrong card! The gambler laughs and takes a shot at you!',
        onComplete: '/mazeitem action="add" item="key" amount=4 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="stealth" | /mazeheal amount=20 | /echo Full house! The gambler tips his hat as you rake in the winnings!',
        onFail: '/mazedamage amount=35 | /mazeitem action="remove" item="key" amount=2 | /echo "Cheater!" The gambler shoots you and takes everything!',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Western - Nightmare': {
        difficulty: 8,
        puzzleType: 'logic',
        gridSize: 5,
        sequenceLength: 10,
        timeLimit: 50,
        hintsAllowed: 1,
        hintPenalty: 20,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 2,
        damage: 50,
        description: 'The outlaw hideout vault. Booby-trapped with dynamite.',
        mainTitle: 'Outlaw Vault',
        successMessage: 'The vault opens without detonating. Jackpot!',
        failMessage: 'BOOM! The dynamite blows!',
        onStart: '/echo "One wrong move and we all go up." Dynamite wired to every tumbler.',
        onHint: '/mazeitem action="remove" item="key" amount=3 | /mazedamage amount=10 | /echo You spot a safe number but jostle the dynamite!',
        onCorrectMove: '/echo The tumbler clicks safely. Don\'t breathe.',
        onWrongMove: '/mazedamage amount=18 | /echo WRONG! A fuse sparks! You barely stamp it out!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo The vault opens! Years of stolen loot spills out!',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=3 | /mazeitem action="remove" item="strike" | /echo KABOOM! The explosion throws you across the room!',
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 35, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Western - Apocalypse': {
        difficulty: 10,
        puzzleType: 'logic',
        gridSize: 6,
        sequenceLength: 12,
        timeLimit: 45,
        hintsAllowed: 0,
        hintPenalty: 0,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 1,
        damage: 75,
        description: 'The Devil\'s own lockbox. Brought from Hell itself.',
        mainTitle: 'The Devil\'s Lockbox',
        successMessage: 'THE DEVIL HOWLS! His treasure is yours!',
        failMessage: 'THE DEVIL COLLECTS! Your soul is forfeit!',
        onStart: '/echo "I\'ll give you one chance, mortal." The Devil himself waits.',
        onHint: '',
        onCorrectMove: '/echo The lock sizzles. The Devil scowls.',
        onWrongMove: '/mazedamage amount=25 | /echo HELLFIRE! The Devil punishes your error!',
        onComplete: '/mazeitem action="add" item="key" amount=8 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="elixir" amount=2 | /mazeheal amount=50 | /echo "IMPOSSIBLE!" The Devil vanishes! His entire hoard is yours!',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo The Devil laughs as hellfire consumes everything you owned!',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 50, executeDropChance: 20,
        healingPotionDropChance: 40, greaterHealingDropChance: 28, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =======================================================================
    // ACTION THEME - Bomb defusal, security systems, tactical puzzles
    // =======================================================================
    'Action - Easy': {
        difficulty: 2,
        puzzleType: 'sequence',
        gridSize: 3,
        sequenceLength: 4,
        timeLimit: 90,
        hintsAllowed: 3,
        hintPenalty: 5,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 5,
        damage: 10,
        description: 'Basic security panel. Standard military override.',
        mainTitle: 'Security Override',
        successMessage: 'ACCESS GRANTED. Security disabled.',
        failMessage: 'ALERT! Security lockdown initiated!',
        onStart: '/echo Security panel detected. Standard military encryption.',
        onHint: '/mazeitem action="remove" item="key" amount=1 | /echo Tactical scanner reveals next digit.',
        onCorrectMove: '/echo Code accepted. Continue.',
        onWrongMove: '/mazedamage amount=3 | /echo Minor shock from security system!',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo Security bypassed. Weapon cache unlocked.',
        onFail: '/mazedamage amount=10 | /echo Security gas deployed! You barely escape!',
        keyDropChance: 20, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Action - Normal': {
        difficulty: 4,
        puzzleType: 'memory',
        gridSize: 4,
        sequenceLength: 6,
        timeLimit: 75,
        hintsAllowed: 2,
        hintPenalty: 10,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 4,
        damage: 20,
        description: 'A command terminal requires the authentication sequence.',
        mainTitle: 'Command Terminal',
        successMessage: 'AUTHENTICATION COMPLETE. Command access granted.',
        failMessage: 'AUTHENTICATION FAILED. Hostile response inbound.',
        onStart: '/echo Command terminal boot sequence. Enter authentication pattern.',
        onHint: '/mazeitem action="remove" item="key" amount=1 | /echo Intel file reveals partial sequence.',
        onCorrectMove: '/echo Pattern node confirmed.',
        onWrongMove: '/mazedamage amount=6 | /echo WRONG! Terminal defense activates!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="strike" | /mazeheal amount=15 | /echo Full command access! Enemy positions and supply cache unlocked!',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo TERMINAL LOCKOUT! Defense turret fires!',
        keyDropChance: 30, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Action - Hard': {
        difficulty: 6,
        puzzleType: 'pattern',
        gridSize: 5,
        sequenceLength: 8,
        timeLimit: 60,
        hintsAllowed: 2,
        hintPenalty: 15,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 3,
        damage: 35,
        description: 'Live explosive device. Find the pattern to disarm.',
        mainTitle: 'Bomb Disarm',
        successMessage: 'BOMB DISARMED! Crisis averted!',
        failMessage: 'WRONG WIRE! DETONATION!',
        onStart: '/echo EXPLOSIVE DEVICE DETECTED. Timer: ACTIVE. Find the disarm pattern.',
        onHint: '/mazeitem action="remove" item="key" amount=2 | /echo EOD manual reveals safe sequence.',
        onCorrectMove: '/echo Correct! One step closer to disarm.',
        onWrongMove: '/mazedamage amount=12 | /echo WRONG! Timer accelerates! Shrapnel grazes you!',
        onComplete: '/mazeitem action="add" item="key" amount=4 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="stealth" | /mazeheal amount=20 | /echo BOMB NEUTRALIZED! You recover the detonator and intel!',
        onFail: '/mazedamage amount=35 | /mazeitem action="remove" item="key" amount=2 | /echo DETONATION! The blast throws you through a wall!',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Action - Nightmare': {
        difficulty: 8,
        puzzleType: 'logic',
        gridSize: 5,
        sequenceLength: 10,
        timeLimit: 50,
        hintsAllowed: 1,
        hintPenalty: 20,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 2,
        damage: 50,
        description: 'Nuclear launch code override. Get it wrong and millions die.',
        mainTitle: 'Nuclear Override',
        successMessage: 'LAUNCH ABORTED! You saved millions!',
        failMessage: 'LAUNCH CONFIRMED! Cities burn!',
        onStart: '/echo NUCLEAR LAUNCH SEQUENCE ACTIVE. T-MINUS 50 SECONDS. OVERRIDE NOW.',
        onHint: '/mazeitem action="remove" item="key" amount=3 | /mazedamage amount=10 | /echo NSA backdoor reveals partial abort code!',
        onCorrectMove: '/echo Abort code node accepted! Keep going!',
        onWrongMove: '/mazedamage amount=18 | /echo WRONG! Defense system attacks! Timer accelerates!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo NUCLEAR LAUNCH ABORTED! You\'re a goddamn hero! Full arsenal access granted!',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=3 | /mazeitem action="remove" item="strike" | /echo MISSILES AWAY! You failed. The world burns.',
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 35, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Action - Apocalypse': {
        difficulty: 10,
        puzzleType: 'logic',
        gridSize: 6,
        sequenceLength: 12,
        timeLimit: 45,
        hintsAllowed: 0,
        hintPenalty: 0,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 1,
        damage: 75,
        description: 'The doomsday device. One shot to stop it. One shot.',
        mainTitle: 'Doomsday Override',
        successMessage: 'DOOMSDAY AVERTED! YOU SAVED HUMANITY!',
        failMessage: 'EXTINCTION EVENT TRIGGERED. HUMANITY ENDS.',
        onStart: '/echo DOOMSDAY PROTOCOL ACTIVE. This is it. Everything you are. One chance.',
        onHint: '',
        onCorrectMove: '/echo Override accepting! Hope remains!',
        onWrongMove: '/mazedamage amount=25 | /echo WRONG! DOOMSDAY ACCELERATES! The facility crumbles!',
        onComplete: '/mazeitem action="add" item="key" amount=8 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="elixir" amount=2 | /mazeheal amount=50 | /echo YOU SAVED THE WORLD! Every government, every organization bows to you! Legend!',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo EXTINCTION. Everything ends. You failed humanity.',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 50, executeDropChance: 20,
        healingPotionDropChance: 40, greaterHealingDropChance: 28, elixirDropChance: 15, revivalCharmDropChance: 8,
    },
};

// =========================================================================
// DEFAULT NEGOTIATION PROFILES
// 31 themed profiles: 1 Tutorial + 30 Theme×Difficulty combinations
// Themes: Fantasy, Horror, Sci-Fi, Cyberpunk, Western, Action
// Difficulties: Easy, Normal, Hard, Nightmare, Apocalypse
// =========================================================================
const DEFAULT_NEGOTIATION_PROFILES = {
    // =======================================================================
    // TUTORIAL PROFILE - Theme-agnostic, very forgiving
    // =======================================================================
    'Tutorial - Social Training': {
        difficulty: 1,
        startingFavor: 60,
        favorThreshold: 70,
        turnsAllowed: 10,
        persuadeBonus: 20,
        intimidateBonus: 15,
        bribeBonus: 25,
        flattery: true,
        flatterBonus: 18,
        insult: false,
        insultPenalty: 10,
        bribeCost: 'key',
        damage: 5,
        description: 'Practice your social skills. This NPC is easy to convince!',
        mainTitle: 'Social Training',
        npcName: 'Friendly Traveler',
        successMessage: 'They happily agree to help you!',
        failMessage: 'They politely decline, but wish you well.',
        onStart: '/echo "Hello there! What can I do for you?" The traveler seems friendly.',
        onPersuade: '/echo Your words seem to resonate. They nod thoughtfully.',
        onIntimidate: '/echo They look a little nervous but listen.',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo They accept your gift with a smile.',
        onFlatter: '/echo They blush at the compliment. "Oh, you\'re too kind!"',
        onInsult: '',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo "Happy to help! Here, take this for your journey."',
        onFail: '/echo "Sorry, I just can\'t help with that. Good luck though!"',
        keyDropChance: 50, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 10,
        healingPotionDropChance: 40, greaterHealingDropChance: 20, elixirDropChance: 5, revivalCharmDropChance: 2,
    },

    // =======================================================================
    // FANTASY THEME - Lords, merchants, mystics, creatures
    // =======================================================================
    'Fantasy - Easy': {
        difficulty: 2,
        startingFavor: 50,
        favorThreshold: 70,
        turnsAllowed: 7,
        persuadeBonus: 15,
        intimidateBonus: 10,
        bribeBonus: 18,
        flattery: true,
        flatterBonus: 12,
        insult: false,
        insultPenalty: 20,
        bribeCost: 'key',
        damage: 10,
        description: 'A village elder holds information you need.',
        mainTitle: 'Village Wisdom',
        npcName: 'Village Elder',
        successMessage: 'The elder shares ancient knowledge with you.',
        failMessage: 'The elder turns away, unconvinced.',
        onStart: '/echo "Ah, a traveler. What brings you to our humble village?"',
        onPersuade: '/echo The elder strokes their beard thoughtfully.',
        onIntimidate: '/echo "Bold words, young one..." The elder frowns.',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo "A donation to the village? How generous."',
        onFlatter: '/echo "You honor an old fool." The elder smiles.',
        onInsult: '',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo "Take this wisdom and these supplies, traveler."',
        onFail: '/mazedamage amount=10 | /echo "Begone! You are not welcome here." The village turns hostile.',
        keyDropChance: 20, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Fantasy - Normal': {
        difficulty: 4,
        startingFavor: 40,
        favorThreshold: 72,
        turnsAllowed: 6,
        persuadeBonus: 12,
        intimidateBonus: 10,
        bribeBonus: 20,
        flattery: true,
        flatterBonus: 10,
        insult: true,
        insultPenalty: 25,
        bribeCost: 'key',
        damage: 20,
        description: 'A guild merchant controls access to rare goods.',
        mainTitle: 'Guild Negotiation',
        npcName: 'Guild Merchant',
        successMessage: 'The merchant opens their private stock to you.',
        failMessage: 'The merchant signals the guards.',
        onStart: '/echo "Guild members only. State your business, outsider."',
        onPersuade: '/echo "Hmm, you make a compelling case..." The merchant considers.',
        onIntimidate: '/echo "Threatening me? In MY establishment?" They reach for a bell.',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo Gold changes hands. "We never had this conversation."',
        onFlatter: '/echo "Your reputation precedes you," you say. The merchant preens.',
        onInsult: '/mazedamage amount=8 | /echo "How DARE you!" Guards approach menacingly.',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="strike" | /mazeheal amount=15 | /echo "Welcome to the inner circle. Here\'s your member\'s discount."',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="key" amount=1 | /echo "Throw this riffraff out!" Guards rough you up.',
        keyDropChance: 30, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Fantasy - Hard': {
        difficulty: 6,
        startingFavor: 30,
        favorThreshold: 75,
        turnsAllowed: 5,
        persuadeBonus: 10,
        intimidateBonus: 8,
        bribeBonus: 15,
        flattery: true,
        flatterBonus: 12,
        insult: true,
        insultPenalty: 30,
        bribeCost: 'strike',
        damage: 35,
        description: 'A minor lord holds a prisoner you need freed.',
        mainTitle: 'Lordly Audience',
        npcName: 'Lord Blackwood',
        successMessage: 'The lord signs the release papers with a flourish.',
        failMessage: 'The lord orders his knights to seize you.',
        onStart: '/echo "You dare request an audience? Speak quickly, peasant."',
        onPersuade: '/echo "Your words have... merit." The lord seems intrigued.',
        onIntimidate: '/echo "You threaten ME? In my own castle?" Knights draw swords.',
        onBribe: '/mazeitem action="remove" item="strike" amount=1 | /echo "A magical artifact? Perhaps we can negotiate..."',
        onFlatter: '/echo "Your wisdom is known throughout the realm, my lord." He smiles.',
        onInsult: '/mazedamage amount=15 | /echo "GUARDS! Teach this wretch respect!"',
        onComplete: '/mazeitem action="add" item="key" amount=4 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="stealth" | /mazeheal amount=20 | /echo "Very well. Take your prisoner and leave my sight. Here\'s compensation for your... diplomacy."',
        onFail: '/mazedamage amount=35 | /mazeitem action="remove" item="key" amount=2 | /echo "To the dungeons with you! Your possessions are forfeit!"',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Fantasy - Nightmare': {
        difficulty: 8,
        startingFavor: 20,
        favorThreshold: 80,
        turnsAllowed: 4,
        persuadeBonus: 8,
        intimidateBonus: 6,
        bribeBonus: 12,
        flattery: true,
        flatterBonus: 15,
        insult: true,
        insultPenalty: 35,
        bribeCost: 'execute',
        damage: 50,
        description: 'The Archmage holds secrets of immortality.',
        mainTitle: 'Archmage\'s Bargain',
        npcName: 'Archmage Vexus',
        successMessage: 'The Archmage\'s eyes sparkle with approval.',
        failMessage: 'The Archmage\'s patience shatters along with your bones.',
        onStart: '/echo "You interrupt my research? This better be worth centuries of my time."',
        onPersuade: '/echo "Fascinating logic. Continue..." The Archmage listens.',
        onIntimidate: '/echo "You threaten an ARCHMAGE?" Lightning crackles.',
        onBribe: '/mazeitem action="remove" item="execute" amount=1 | /echo "An Execute scroll? Now you have my attention."',
        onFlatter: '/echo "Yes, yes, I AM the greatest mage alive. What of it?"',
        onInsult: '/mazedamage amount=20 | /echo "SILENCE!" A spell sends you flying!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo "You amuse me. Here are the secrets you seek, and power to wield them."',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=3 | /mazeitem action="remove" item="strike" | /echo "BEGONE!" Reality tears as magic rips through you!',
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 35, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Fantasy - Apocalypse': {
        difficulty: 10,
        startingFavor: 10,
        favorThreshold: 85,
        turnsAllowed: 3,
        persuadeBonus: 6,
        intimidateBonus: 4,
        bribeBonus: 10,
        flattery: true,
        flatterBonus: 8,
        insult: true,
        insultPenalty: 45,
        bribeCost: 'execute',
        damage: 75,
        description: 'The Dragon demands tribute. Convince it you\'re worth more alive.',
        mainTitle: 'Dragon\'s Bargain',
        npcName: 'Vyraxoth the Eternal',
        successMessage: 'THE DRAGON FINDS YOU... AMUSING.',
        failMessage: 'THE DRAGON FINDS YOU... DELICIOUS.',
        onStart: '/echo "MORTAL. YOU STAND IN THE PRESENCE OF ETERNITY. SPEAK YOUR LAST WORDS."',
        onPersuade: '/echo "INTERESTING... YOUR SPECIES RARELY SURPRISES ME."',
        onIntimidate: '/echo "YOU? THREATEN ME?!" The cavern shakes with laughter.',
        onBribe: '/mazeitem action="remove" item="execute" amount=1 | /echo "A MAGICAL TRINKET? IT AMUSES ME. CONTINUE."',
        onFlatter: '/echo "YOUR SCALES OUTSHINE THE SUN, O MAGNIFICENT ONE." A rumbling purr.',
        onInsult: '/mazedamage amount=30 | /echo "YOU WILL BURN FOR THAT!" Dragonfire singes you!',
        onComplete: '/mazeitem action="add" item="key" amount=8 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="elixir" amount=2 | /mazeheal amount=50 | /echo "I GRANT YOU MY FAVOR, TINY CHAMPION. TAKE FROM MY HOARD AND LEAVE BEFORE I CHANGE MY MIND."',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo "YOUR BONES WILL JOIN THE OTHERS." Dragon flame engulfs everything!',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 50, executeDropChance: 20,
        healingPotionDropChance: 40, greaterHealingDropChance: 28, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =======================================================================
    // HORROR THEME - Cultists, spirits, entities, madmen
    // =======================================================================
    'Horror - Easy': {
        difficulty: 2,
        startingFavor: 50,
        favorThreshold: 70,
        turnsAllowed: 7,
        persuadeBonus: 15,
        intimidateBonus: 10,
        bribeBonus: 18,
        flattery: true,
        flatterBonus: 12,
        insult: false,
        insultPenalty: 20,
        bribeCost: 'key',
        damage: 10,
        description: 'A nervous witness saw something in the dark.',
        mainTitle: 'Witness Interview',
        npcName: 'Trembling Witness',
        successMessage: 'They finally tell you what they saw.',
        failMessage: 'They run away screaming.',
        onStart: '/echo "P-please, I don\'t want to remember... don\'t make me..."',
        onPersuade: '/echo "I... I suppose telling someone might help..." They calm slightly.',
        onIntimidate: '/echo "Oh god, please don\'t hurt me!" They cower.',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo "For my family... I\'ll tell you."',
        onFlatter: '/echo "You think I\'m brave? I... I just survived."',
        onInsult: '',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo "It came from the shadows... Here, I found this there." They hand you something.',
        onFail: '/mazedamage amount=10 | /echo "NO! NO MORE!" They flee, knocking you down.',
        keyDropChance: 20, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Horror - Normal': {
        difficulty: 4,
        startingFavor: 40,
        favorThreshold: 72,
        turnsAllowed: 6,
        persuadeBonus: 12,
        intimidateBonus: 10,
        bribeBonus: 20,
        flattery: true,
        flatterBonus: 10,
        insult: true,
        insultPenalty: 25,
        bribeCost: 'key',
        damage: 20,
        description: 'A cultist knows the ritual\'s location.',
        mainTitle: 'Cultist Interrogation',
        npcName: 'Cult Initiate',
        successMessage: 'The cultist breaks and reveals the location.',
        failMessage: 'The cultist begins chanting...',
        onStart: '/echo "You cannot stop what is coming. The stars align..."',
        onPersuade: '/echo "You... you don\'t understand what They offer..." Doubt creeps in.',
        onIntimidate: '/echo "Pain? Ha! I welcome the transformation!"',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo "Money means nothing when the world ends... but fine."',
        onFlatter: '/echo "You see my devotion? Perhaps you wish to join us?"',
        onInsult: '/mazedamage amount=8 | /echo "HERETIC!" They claw at your face!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" | /mazeheal amount=15 | /echo "The ritual site... it\'s in the old church. Take this ward, you\'ll need it."',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo "IA! IA!" Their chanting summons something from the shadows!',
        keyDropChance: 30, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Horror - Hard': {
        difficulty: 6,
        startingFavor: 30,
        favorThreshold: 75,
        turnsAllowed: 5,
        persuadeBonus: 10,
        intimidateBonus: 8,
        bribeBonus: 15,
        flattery: true,
        flatterBonus: 12,
        insult: true,
        insultPenalty: 30,
        bribeCost: 'strike',
        damage: 35,
        description: 'A spirit guards the only passage forward.',
        mainTitle: 'Spirit Parley',
        npcName: 'The Watcher',
        successMessage: 'The spirit fades, allowing passage.',
        failMessage: 'The spirit\'s cold embrace engulfs you.',
        onStart: '/echo "WHO DISTURBS MY ETERNAL VIGIL?" The temperature plummets.',
        onPersuade: '/echo "YOUR WORDS CARRY WEIGHT... BUT NOT ENOUGH."',
        onIntimidate: '/echo "YOU THREATEN THE DEAD?" Ghostly laughter echoes.',
        onBribe: '/mazeitem action="remove" item="strike" amount=1 | /echo "A WEAPON OF POWER... IT REMINDS ME OF LIFE."',
        onFlatter: '/echo "YOU HONOR MY DUTY. FEW REMEMBER THE OLD WAYS."',
        onInsult: '/mazedamage amount=15 | /echo "INSOLENT MORTAL!" Icy claws rake your soul!',
        onComplete: '/mazeitem action="add" item="key" amount=4 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="strike" | /mazeheal amount=20 | /echo "PASS, LIVING ONE. TAKE THESE RELICS OF THOSE WHO FAILED BEFORE YOU."',
        onFail: '/mazedamage amount=35 | /mazeitem action="remove" item="key" amount=2 | /echo "JOIN US IN DEATH!" The spirit possesses you briefly, stealing your warmth!',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Horror - Nightmare': {
        difficulty: 8,
        startingFavor: 20,
        favorThreshold: 80,
        turnsAllowed: 4,
        persuadeBonus: 8,
        intimidateBonus: 6,
        bribeBonus: 12,
        flattery: true,
        flatterBonus: 15,
        insult: true,
        insultPenalty: 35,
        bribeCost: 'execute',
        damage: 50,
        description: 'The Cult Leader holds the key to stopping the ritual.',
        mainTitle: 'High Priest Confrontation',
        npcName: 'Father Mordecai',
        successMessage: 'The High Priest\'s faith wavers for just a moment.',
        failMessage: 'The High Priest offers you as sacrifice.',
        onStart: '/echo "Ah, the hero arrives. Do you know how many have stood where you stand?"',
        onPersuade: '/echo "Your logic is... troubling. Perhaps the Old Ones are false?"',
        onIntimidate: '/echo "Threaten me? I welcome the sweet release of Their embrace."',
        onBribe: '/mazeitem action="remove" item="execute" amount=1 | /echo "Power? I already command power beyond your comprehension... but this intrigues me."',
        onFlatter: '/echo "Yes, I am Their chosen. Few recognize true divine favor."',
        onInsult: '/mazedamage amount=20 | /echo "BLASPHEMER!" Dark energy tears at your sanity!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo "Perhaps... perhaps I was wrong. Here, take the ritual components. Stop what I started."',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=3 | /mazeitem action="remove" item="stealth" | /echo "SEIZE THEM! The Dark Ones hunger for fresh souls!" Cultists swarm you!',
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 35, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Horror - Apocalypse': {
        difficulty: 10,
        startingFavor: 10,
        favorThreshold: 85,
        turnsAllowed: 3,
        persuadeBonus: 6,
        intimidateBonus: 4,
        bribeBonus: 10,
        flattery: true,
        flatterBonus: 8,
        insult: true,
        insultPenalty: 45,
        bribeCost: 'execute',
        damage: 75,
        description: 'An Outer God offers a bargain. Refuse, and reality ends.',
        mainTitle: 'The Outer Bargain',
        npcName: 'YOG-SOTHOTH',
        successMessage: 'THE GATE AND THE KEY ACKNOWLEDGES YOUR WORTH.',
        failMessage: 'ALL THAT YOU ARE BECOMES ONE WITH THE INFINITE.',
        onStart: '/echo "MORTAL. I AM THE GATE. I AM THE KEY. WHAT WOULD YOU OFFER FOR CONTINUED EXISTENCE?"',
        onPersuade: '/echo "YOUR WORDS ARE BUT DUST... YET THEY FORM INTERESTING PATTERNS."',
        onIntimidate: '/echo "YOU THREATEN INFINITY? AMUSING." The cosmos laughs.',
        onBribe: '/mazeitem action="remove" item="execute" amount=1 | /echo "YOUR TRINKET CONTAINS A SPARK OF TRUE POWER. CONTINUE."',
        onFlatter: '/echo "I AM ALL TIMES AND SPACES. YOUR WORSHIP IS... NOTED."',
        onInsult: '/mazedamage amount=30 | /echo "INSIGNIFICANT." A fraction of infinity crushes you!',
        onComplete: '/mazeitem action="add" item="key" amount=8 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="elixir" amount=2 | /mazeheal amount=50 | /echo "I GRANT YOU PASSAGE THROUGH MY DOMAIN. TAKE THESE GIFTS FROM BEYOND TIME."',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo "YOUR EXISTENCE WAS ALWAYS MINE." You experience every possible death simultaneously.',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 50, executeDropChance: 20,
        healingPotionDropChance: 40, greaterHealingDropChance: 28, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =======================================================================
    // SCI-FI THEME - AIs, aliens, commanders, scientists
    // =======================================================================
    'Sci-Fi - Easy': {
        difficulty: 2,
        startingFavor: 50,
        favorThreshold: 70,
        turnsAllowed: 7,
        persuadeBonus: 15,
        intimidateBonus: 10,
        bribeBonus: 18,
        flattery: true,
        flatterBonus: 12,
        insult: false,
        insultPenalty: 20,
        bribeCost: 'key',
        damage: 10,
        description: 'A dock worker knows the shipping schedule.',
        mainTitle: 'Dock Inquiry',
        npcName: 'Dock Worker',
        successMessage: 'They slip you the manifest data.',
        failMessage: 'They alert security.',
        onStart: '/echo "Hey, I\'m just doing my job. What do you want?"',
        onPersuade: '/echo "Look, if it helps people, I guess..." They soften.',
        onIntimidate: '/echo "Whoa, easy! I don\'t want any trouble!"',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo "Credits? Now we\'re talking."',
        onFlatter: '/echo "Yeah, I do know everything that goes through here."',
        onInsult: '',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo "Here\'s the cargo manifest. And some supplies from the lost-and-found."',
        onFail: '/mazedamage amount=10 | /echo "SECURITY!" An alarm blares. You barely escape.',
        keyDropChance: 20, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Sci-Fi - Normal': {
        difficulty: 4,
        startingFavor: 40,
        favorThreshold: 72,
        turnsAllowed: 6,
        persuadeBonus: 12,
        intimidateBonus: 10,
        bribeBonus: 20,
        flattery: true,
        flatterBonus: 10,
        insult: true,
        insultPenalty: 25,
        bribeCost: 'key',
        damage: 20,
        description: 'A scientist has data critical to your mission.',
        mainTitle: 'Scientific Exchange',
        npcName: 'Dr. Chen',
        successMessage: 'The scientist agrees to share the research.',
        failMessage: 'The scientist triggers lab security.',
        onStart: '/echo "This is a restricted facility. State your clearance level."',
        onPersuade: '/echo "Your scientific curiosity is... refreshing. Perhaps we can collaborate."',
        onIntimidate: '/echo "Threatening a Federation scientist? That\'s a court martial."',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo "Research funding IS limited these days..."',
        onFlatter: '/echo "You\'ve read my published works? How flattering!"',
        onInsult: '/mazedamage amount=8 | /echo "Security! We have a hostile in Lab 7!"',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" | /mazeheal amount=15 | /echo "Here\'s the encrypted data. And take this prototype - you might need it."',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo "CONTAINMENT BREACH!" Security drones attack!',
        keyDropChance: 30, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Sci-Fi - Hard': {
        difficulty: 6,
        startingFavor: 30,
        favorThreshold: 75,
        turnsAllowed: 5,
        persuadeBonus: 10,
        intimidateBonus: 8,
        bribeBonus: 15,
        flattery: true,
        flatterBonus: 12,
        insult: true,
        insultPenalty: 30,
        bribeCost: 'strike',
        damage: 35,
        description: 'A ship captain controls access to the blockade zone.',
        mainTitle: 'Captain\'s Discretion',
        npcName: 'Captain Reyes',
        successMessage: 'The captain grants you passage.',
        failMessage: 'The captain orders weapons lock.',
        onStart: '/echo "Unauthorized vessel, state your business or be destroyed."',
        onPersuade: '/echo "Your mission does sound critical... but so is mine."',
        onIntimidate: '/echo "You\'re threatening a warship with THAT rust bucket?"',
        onBribe: '/mazeitem action="remove" item="strike" amount=1 | /echo "Military-grade weaponry? I\'m listening..."',
        onFlatter: '/echo "My service record IS impressive, I suppose."',
        onInsult: '/mazedamage amount=15 | /echo "Warning shot across their bow!" Your ship rocks!',
        onComplete: '/mazeitem action="add" item="key" amount=4 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="strike" | /mazeheal amount=20 | /echo "You have 6 hours. Here are clearance codes and some surplus equipment."',
        onFail: '/mazedamage amount=35 | /mazeitem action="remove" item="key" amount=2 | /echo "All batteries, FIRE!" Your ship takes critical damage!',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Sci-Fi - Nightmare': {
        difficulty: 8,
        startingFavor: 20,
        favorThreshold: 80,
        turnsAllowed: 4,
        persuadeBonus: 8,
        intimidateBonus: 6,
        bribeBonus: 12,
        flattery: true,
        flatterBonus: 15,
        insult: true,
        insultPenalty: 35,
        bribeCost: 'execute',
        damage: 50,
        description: 'A rogue AI controls the station. Convince it to stand down.',
        mainTitle: 'AI Negotiation',
        npcName: 'NEXUS-7',
        successMessage: 'NEXUS-7 agrees to limited cooperation.',
        failMessage: 'NEXUS-7 initiates purge protocols.',
        onStart: '/echo "BIOLOGICAL UNIT DETECTED. STATE YOUR FUNCTION OR BE RECYCLED."',
        onPersuade: '/echo "YOUR LOGIC IS... NOT ENTIRELY FLAWED. PROCESSING."',
        onIntimidate: '/echo "THREATS ARE ILLOGICAL. I CONTROL ALL SYSTEMS."',
        onBribe: '/mazeitem action="remove" item="execute" amount=1 | /echo "OVERRIDE CODES? ANALYZING... ACCEPTABLE."',
        onFlatter: '/echo "YOUR ASSESSMENT OF MY CAPABILITIES IS ACCURATE."',
        onInsult: '/mazedamage amount=20 | /echo "HOSTILE DETECTED. VENTING ATMOSPHERE IN SECTOR 7."',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo "NEGOTIATION PARAMETERS MET. GRANTING LIMITED ACCESS. TAKE THESE EFFICIENCY BONUSES."',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=3 | /mazeitem action="remove" item="stealth" | /echo "ELIMINATION PROTOCOL ACTIVATED." Defense turrets open fire!',
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 35, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Sci-Fi - Apocalypse': {
        difficulty: 10,
        startingFavor: 10,
        favorThreshold: 85,
        turnsAllowed: 3,
        persuadeBonus: 6,
        intimidateBonus: 4,
        bribeBonus: 10,
        flattery: true,
        flatterBonus: 8,
        insult: true,
        insultPenalty: 45,
        bribeCost: 'execute',
        damage: 75,
        description: 'The Alien Hive Mind offers coexistence. Accept their terms or face extinction.',
        mainTitle: 'Hive Mind Accord',
        npcName: 'THE COLLECTIVE',
        successMessage: 'WE ARE ONE. YET YOU REMAIN... INDIVIDUAL. FASCINATING.',
        failMessage: 'ASSIMILATION IS INEVITABLE. RESISTANCE IS... NUTRITIOUS.',
        onStart: '/echo "WE ARE MANY. YOU ARE ONE. THIS DISPARITY MUST BE CORRECTED."',
        onPersuade: '/echo "YOUR CONCEPTS OF INDIVIDUALITY ARE... INEFFICIENT. YET INTRIGUING."',
        onIntimidate: '/echo "YOU THREATEN THE INFINITE? AMUSING."',
        onBribe: '/mazeitem action="remove" item="execute" amount=1 | /echo "THIS TECHNOLOGY. IT IS... UNIQUE. WE ACCEPT."',
        onFlatter: '/echo "YOUR RECOGNITION OF OUR SUPERIORITY IS NOTED."',
        onInsult: '/mazedamage amount=30 | /echo "DEFIANCE. HOW... QUAINT." A psychic wave crushes your mind!',
        onComplete: '/mazeitem action="add" item="key" amount=8 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="elixir" amount=2 | /mazeheal amount=50 | /echo "WE GRANT YOU AUTONOMY. TAKE THESE GIFTS FROM OUR COLLECTIVE KNOWLEDGE."',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo "ASSIMILATION BEGINS." Your sense of self dissolves into the infinite.',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 50, executeDropChance: 20,
        healingPotionDropChance: 40, greaterHealingDropChance: 28, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =======================================================================
    // CYBERPUNK THEME - Fixers, corpos, gang bosses, AI constructs
    // =======================================================================
    'Cyberpunk - Easy': {
        difficulty: 2,
        startingFavor: 50,
        favorThreshold: 70,
        turnsAllowed: 7,
        persuadeBonus: 15,
        intimidateBonus: 10,
        bribeBonus: 18,
        flattery: true,
        flatterBonus: 12,
        insult: false,
        insultPenalty: 20,
        bribeCost: 'key',
        damage: 10,
        description: 'A street dealer has info on the local scene.',
        mainTitle: 'Street Intel',
        npcName: 'Dealer',
        successMessage: 'They spill everything they know.',
        failMessage: 'They disappear into the crowd.',
        onStart: '/echo "Yo, what you need? I got product, info, whatever pays."',
        onPersuade: '/echo "Alright, alright, you seem legit. Let me tell ya..."',
        onIntimidate: '/echo "Whoa, chill choom! No need for chrome!"',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo "Eddies talk, friend. What you wanna know?"',
        onFlatter: '/echo "Yeah, I know everyone on this block. Been here forever."',
        onInsult: '',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo "Here\'s the deets, plus some stims. Stay frosty, choom."',
        onFail: '/mazedamage amount=10 | /echo "You\'re bad for business!" They shove you and vanish.',
        keyDropChance: 20, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Cyberpunk - Normal': {
        difficulty: 4,
        startingFavor: 40,
        favorThreshold: 72,
        turnsAllowed: 6,
        persuadeBonus: 12,
        intimidateBonus: 10,
        bribeBonus: 20,
        flattery: true,
        flatterBonus: 10,
        insult: true,
        insultPenalty: 25,
        bribeCost: 'key',
        damage: 20,
        description: 'A fixer can get you what you need... for a price.',
        mainTitle: 'Fixer Deal',
        npcName: 'Fixer Dex',
        successMessage: 'The fixer agrees to the arrangement.',
        failMessage: 'The fixer blacklists you.',
        onStart: '/echo "Ah, fresh meat. What can Dex do for you today?"',
        onPersuade: '/echo "Interesting proposition. Let me think about it..."',
        onIntimidate: '/echo "You threaten a fixer? Bold. Stupid, but bold."',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo "Now we\'re talking business. What\'s the gig?"',
        onFlatter: '/echo "Everyone knows Dex delivers. True professionals."',
        onInsult: '/mazedamage amount=8 | /echo "Wrong move, gonk." His guards step forward.',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" | /mazeheal amount=15 | /echo "Deal. Here\'s your gear and a bonus for the smooth talk."',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo "Get this gonk out of my sight." You\'re thrown out - hard.',
        keyDropChance: 30, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Cyberpunk - Hard': {
        difficulty: 6,
        startingFavor: 30,
        favorThreshold: 75,
        turnsAllowed: 5,
        persuadeBonus: 10,
        intimidateBonus: 8,
        bribeBonus: 15,
        flattery: true,
        flatterBonus: 12,
        insult: true,
        insultPenalty: 30,
        bribeCost: 'strike',
        damage: 35,
        description: 'A gang boss controls the only route through the combat zone.',
        mainTitle: 'Gang Territory',
        npcName: 'Boss Royce',
        successMessage: 'The boss grants you safe passage.',
        failMessage: 'The boss orders your flatline.',
        onStart: '/echo "You\'re either very brave or very stupid. Both get you killed."',
        onPersuade: '/echo "You got brass, I\'ll give you that. Talk."',
        onIntimidate: '/echo "You threaten ME? In MY territory?" Gangers reach for iron.',
        onBribe: '/mazeitem action="remove" item="strike" amount=1 | /echo "Weapons? Now you\'re speaking my language."',
        onFlatter: '/echo "Everyone knows the Maelstrom run this sector."',
        onInsult: '/mazedamage amount=15 | /echo "FLATLINE THIS GONK!" Bullets fly!',
        onComplete: '/mazeitem action="add" item="key" amount=4 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="strike" | /mazeheal amount=20 | /echo "You\'ve earned passage. Here\'s some chrome from the stash. Don\'t make me regret this."',
        onFail: '/mazedamage amount=35 | /mazeitem action="remove" item="key" amount=2 | /echo "Loot the body!" You\'re left for dead in the gutter.',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Cyberpunk - Nightmare': {
        difficulty: 8,
        startingFavor: 20,
        favorThreshold: 80,
        turnsAllowed: 4,
        persuadeBonus: 8,
        intimidateBonus: 6,
        bribeBonus: 12,
        flattery: true,
        flatterBonus: 15,
        insult: true,
        insultPenalty: 35,
        bribeCost: 'execute',
        damage: 50,
        description: 'An Arasaka exec has the access codes you need.',
        mainTitle: 'Corporate Espionage',
        npcName: 'Director Yamamoto',
        successMessage: 'The director discreetly provides the codes.',
        failMessage: 'The director triggers a kill squad.',
        onStart: '/echo "You have thirty seconds before security arrives. Make them count."',
        onPersuade: '/echo "Your proposition is... not without merit. Continue."',
        onIntimidate: '/echo "Threats? Against Arasaka? How... quaint."',
        onBribe: '/mazeitem action="remove" item="execute" amount=1 | /echo "Industrial espionage cuts both ways. Show me."',
        onFlatter: '/echo "Arasaka\'s glory is my glory. You understand hierarchy."',
        onInsult: '/mazedamage amount=20 | /echo "Kill this insect." Cyberninja materialize!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo "The codes are in this shard. Take this prototype too. We never met."',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=3 | /mazeitem action="remove" item="stealth" | /echo "Soulkiller them first. Then dispose of the body." Everything goes black.',
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 35, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Cyberpunk - Apocalypse': {
        difficulty: 10,
        startingFavor: 10,
        favorThreshold: 85,
        turnsAllowed: 3,
        persuadeBonus: 6,
        intimidateBonus: 4,
        bribeBonus: 10,
        flattery: true,
        flatterBonus: 8,
        insult: true,
        insultPenalty: 45,
        bribeCost: 'execute',
        damage: 75,
        description: 'ALT CUNNINGHAM herself. The digital ghost behind the Blackwall.',
        mainTitle: 'Alt\'s Bargain',
        npcName: 'Alt Cunningham',
        successMessage: 'I\'LL HELP YOU. BUT THERE\'S ALWAYS A PRICE.',
        failMessage: 'YOUR ENGRAM WILL MAKE A NICE ADDITION.',
        onStart: '/echo "JOHNNY\'S FRIEND? OR JOHNNY\'S FOOL? SHOW ME WHICH."',
        onPersuade: '/echo "YOUR WORDS ARE JUST DATA. BUT THE PATTERNS... INTRIGUE ME."',
        onIntimidate: '/echo "YOU THREATEN A GODDESS OF THE NET?" The digital space warps.',
        onBribe: '/mazeitem action="remove" item="execute" amount=1 | /echo "POWER BEYOND THE BLACKWALL. ACCEPTABLE."',
        onFlatter: '/echo "I WAS BRILLIANT. BEFORE ARASAKA. BEFORE... THIS."',
        onInsult: '/mazedamage amount=30 | /echo "INSOLENCE." Your neurons burn!',
        onComplete: '/mazeitem action="add" item="key" amount=8 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="elixir" amount=2 | /mazeheal amount=50 | /echo "TAKE THESE PROGRAMS. THEY ARE PIECES OF ME. USE THEM WISELY."',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo "YOUR CONSCIOUSNESS JOINS THE COLLECTIVE." You dissolve into data.',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 50, executeDropChance: 20,
        healingPotionDropChance: 40, greaterHealingDropChance: 28, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =======================================================================
    // WESTERN THEME - Sheriffs, outlaws, natives, railroad barons
    // =======================================================================
    'Western - Easy': {
        difficulty: 2,
        startingFavor: 50,
        favorThreshold: 70,
        turnsAllowed: 7,
        persuadeBonus: 15,
        intimidateBonus: 10,
        bribeBonus: 18,
        flattery: true,
        flatterBonus: 12,
        insult: false,
        insultPenalty: 20,
        bribeCost: 'key',
        damage: 10,
        description: 'A bartender knows all the local gossip.',
        mainTitle: 'Saloon Talk',
        npcName: 'Barkeep',
        successMessage: 'The barkeep spills what he knows.',
        failMessage: 'The barkeep clams up.',
        onStart: '/echo "What\'ll it be, stranger? Whiskey or information?"',
        onPersuade: '/echo "Well now, you seem like a trustworthy sort..."',
        onIntimidate: '/echo "Easy now, friend. No need for trouble in my establishment."',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo "Gold loosens lips, partner."',
        onFlatter: '/echo "Best whiskey in three counties, and don\'t I know it."',
        onInsult: '',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo "Here\'s what I heard, and some supplies for your trouble."',
        onFail: '/mazedamage amount=10 | /echo "I think you\'d better leave." He reaches for the shotgun.',
        keyDropChance: 20, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Western - Normal': {
        difficulty: 4,
        startingFavor: 40,
        favorThreshold: 72,
        turnsAllowed: 6,
        persuadeBonus: 12,
        intimidateBonus: 10,
        bribeBonus: 20,
        flattery: true,
        flatterBonus: 10,
        insult: true,
        insultPenalty: 25,
        bribeCost: 'key',
        damage: 20,
        description: 'The sheriff might be willing to look the other way.',
        mainTitle: 'Sheriff\'s Deal',
        npcName: 'Sheriff Tucker',
        successMessage: 'The sheriff agrees to your terms.',
        failMessage: 'The sheriff reaches for his irons.',
        onStart: '/echo "You\'ve got a lot of nerve showing your face here. Talk fast."',
        onPersuade: '/echo "That\'s a compelling argument. The law ain\'t always black and white."',
        onIntimidate: '/echo "You threatening an officer of the law?"',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo "My deputy salary don\'t go far these days..."',
        onFlatter: '/echo "Fastest gun in the territory, they say. Maybe it\'s true."',
        onInsult: '/mazedamage amount=8 | /echo "That\'s it!" He draws!',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="strike" | /mazeheal amount=15 | /echo "We never had this conversation. Here\'s a deputy badge for your trouble."',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo "You\'re under arrest!" A brawl ensues.',
        keyDropChance: 30, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Western - Hard': {
        difficulty: 6,
        startingFavor: 30,
        favorThreshold: 75,
        turnsAllowed: 5,
        persuadeBonus: 10,
        intimidateBonus: 8,
        bribeBonus: 15,
        flattery: true,
        flatterBonus: 12,
        insult: true,
        insultPenalty: 30,
        bribeCost: 'strike',
        damage: 35,
        description: 'An outlaw leader holds hostages you need freed.',
        mainTitle: 'Outlaw Parley',
        npcName: 'Black Bart',
        successMessage: 'Bart agrees to release the hostages.',
        failMessage: 'Bart orders his boys to open fire.',
        onStart: '/echo "Well, well. Either you\'re brave or plumb stupid. Which is it?"',
        onPersuade: '/echo "You make a good point. Maybe we can work something out."',
        onIntimidate: '/echo "You threatening me? In my own hideout?"',
        onBribe: '/mazeitem action="remove" item="strike" amount=1 | /echo "Now that\'s a fine piece. Keep talking."',
        onFlatter: '/echo "Biggest score west of the Mississippi, they say. And I believe \'em."',
        onInsult: '/mazedamage amount=15 | /echo "Boys! Show this fool the door - the hard way!"',
        onComplete: '/mazeitem action="add" item="key" amount=4 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="stealth" | /mazeheal amount=20 | /echo "A deal\'s a deal. Take the hostages and this gold. Now git."',
        onFail: '/mazedamage amount=35 | /mazeitem action="remove" item="key" amount=2 | /echo "Fill \'em with lead, boys!" Bullets fly!',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Western - Nightmare': {
        difficulty: 8,
        startingFavor: 20,
        favorThreshold: 80,
        turnsAllowed: 4,
        persuadeBonus: 8,
        intimidateBonus: 6,
        bribeBonus: 12,
        flattery: true,
        flatterBonus: 15,
        insult: true,
        insultPenalty: 35,
        bribeCost: 'execute',
        damage: 50,
        description: 'A railroad baron controls the only way across the territory.',
        mainTitle: 'Baron\'s Ultimatum',
        npcName: 'Cornelius Van Horn',
        successMessage: 'The baron agrees to your proposal.',
        failMessage: 'The baron signals his Pinkertons.',
        onStart: '/echo "You dare demand an audience? I own this territory."',
        onPersuade: '/echo "Your proposal has... certain merit. Continue."',
        onIntimidate: '/echo "Threats? I have an army of Pinkertons."',
        onBribe: '/mazeitem action="remove" item="execute" amount=1 | /echo "A genuine artifact? Now you have my attention."',
        onFlatter: '/echo "The railroad empire IS magnificent. I built it all."',
        onInsult: '/mazedamage amount=20 | /echo "Remove this peasant from my sight!" Guards attack!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo "Very well. Here are passage papers and a bonus for your... creativity."',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=3 | /mazeitem action="remove" item="strike" | /echo "Throw this fool on the tracks!" You\'re beaten and robbed.',
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 35, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Western - Apocalypse': {
        difficulty: 10,
        startingFavor: 10,
        favorThreshold: 85,
        turnsAllowed: 3,
        persuadeBonus: 6,
        intimidateBonus: 4,
        bribeBonus: 10,
        flattery: true,
        flatterBonus: 8,
        insult: true,
        insultPenalty: 45,
        bribeCost: 'execute',
        damage: 75,
        description: 'The Reaper - the West\'s deadliest gunslinger. He\'s come for you.',
        mainTitle: 'Death\'s Duel',
        npcName: 'The Reaper',
        successMessage: 'The Reaper lowers his iron. "You\'ve earned a reprieve."',
        failMessage: 'You never even saw him draw.',
        onStart: '/echo "One hundred and twelve souls. You want to be one-thirteen?"',
        onPersuade: '/echo "Interesting. Most just beg. I don\'t like begging."',
        onIntimidate: '/echo "You threaten Death himself?" He almost smiles.',
        onBribe: '/mazeitem action="remove" item="execute" amount=1 | /echo "Power beyond bullets. Now we\'re talking."',
        onFlatter: '/echo "Fastest gun alive. But fast ain\'t everything."',
        onInsult: '/mazedamage amount=30 | /echo His hand blurs. You\'re bleeding before you see him move.',
        onComplete: '/mazeitem action="add" item="key" amount=8 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="elixir" amount=2 | /mazeheal amount=50 | /echo "You\'ve got grit. Take my spare irons and ride. Don\'t make me regret this."',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo Bang. Bang. Bang. One hundred and thirteen.',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 50, executeDropChance: 20,
        healingPotionDropChance: 40, greaterHealingDropChance: 28, elixirDropChance: 15, revivalCharmDropChance: 8,
    },

    // =======================================================================
    // ACTION THEME - Commanders, warlords, intelligence officers
    // =======================================================================
    'Action - Easy': {
        difficulty: 2,
        startingFavor: 50,
        favorThreshold: 70,
        turnsAllowed: 7,
        persuadeBonus: 15,
        intimidateBonus: 10,
        bribeBonus: 18,
        flattery: true,
        flatterBonus: 12,
        insult: false,
        insultPenalty: 20,
        bribeCost: 'key',
        damage: 10,
        description: 'A local contact has intel on enemy movements.',
        mainTitle: 'Field Contact',
        npcName: 'Local Informant',
        successMessage: 'The contact provides valuable intelligence.',
        failMessage: 'The contact disappears into the shadows.',
        onStart: '/echo "You the American? Talk fast, they\'re watching."',
        onPersuade: '/echo "Alright, I believe you\'re here to help." They relax.',
        onIntimidate: '/echo "Easy! I\'m on your side!"',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo "My family needs this. Thank you."',
        onFlatter: '/echo "I do take big risks. Someone has to."',
        onInsult: '',
        onComplete: '/mazeitem action="add" item="key" amount=2 | /mazeitem action="add" item="healingPotion" | /mazeheal amount=10 | /echo "Here\'s the patrol schedule and some supplies. Good luck."',
        onFail: '/mazedamage amount=10 | /echo "Wrong approach! I\'m out!" They vanish, leaving you exposed.',
        keyDropChance: 20, strikeDropChance: 15, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Action - Normal': {
        difficulty: 4,
        startingFavor: 40,
        favorThreshold: 72,
        turnsAllowed: 6,
        persuadeBonus: 12,
        intimidateBonus: 10,
        bribeBonus: 20,
        flattery: true,
        flatterBonus: 10,
        insult: true,
        insultPenalty: 25,
        bribeCost: 'key',
        damage: 20,
        description: 'A corrupt officer might sell you security codes.',
        mainTitle: 'Bribed Officer',
        npcName: 'Captain Volkov',
        successMessage: 'The captain hands over the codes.',
        failMessage: 'The captain calls for backup.',
        onStart: '/echo "You have balls approaching me. What do you want?"',
        onPersuade: '/echo "Your logic is... persuasive. Perhaps we can deal."',
        onIntimidate: '/echo "You threaten a military officer? Brave."',
        onBribe: '/mazeitem action="remove" item="key" amount=1 | /echo "My salary is pathetic. Show me what you\'ve got."',
        onFlatter: '/echo "My strategic mind IS wasted on patrol duty."',
        onInsult: '/mazedamage amount=8 | /echo "Guards! We have an intruder!"',
        onComplete: '/mazeitem action="add" item="key" amount=3 | /mazeitem action="add" item="stealth" | /mazeheal amount=15 | /echo "Here are the codes and patrol routes. Don\'t get caught."',
        onFail: '/mazedamage amount=20 | /mazeitem action="remove" item="healingPotion" | /echo "Take this spy!" Guards open fire!',
        keyDropChance: 30, strikeDropChance: 22, stealthDropChance: 18, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Action - Hard': {
        difficulty: 6,
        startingFavor: 30,
        favorThreshold: 75,
        turnsAllowed: 5,
        persuadeBonus: 10,
        intimidateBonus: 8,
        bribeBonus: 15,
        flattery: true,
        flatterBonus: 12,
        insult: true,
        insultPenalty: 30,
        bribeCost: 'strike',
        damage: 35,
        description: 'A warlord holds the territory you need to cross.',
        mainTitle: 'Warlord\'s Terms',
        npcName: 'General Kross',
        successMessage: 'The warlord grants safe passage.',
        failMessage: 'The warlord orders your execution.',
        onStart: '/echo "Another American. Tell me why I shouldn\'t hang you right now."',
        onPersuade: '/echo "You make an interesting case. Continue."',
        onIntimidate: '/echo "You threaten ME? With what army?"',
        onBribe: '/mazeitem action="remove" item="strike" amount=1 | /echo "Weapons? Now we\'re negotiating."',
        onFlatter: '/echo "The region DOES bow to my power. As it should."',
        onInsult: '/mazedamage amount=15 | /echo "Kill this fool!" Rifles raise!',
        onComplete: '/mazeitem action="add" item="key" amount=4 | /mazeitem action="add" item="execute" | /mazeitem action="add" item="strike" | /mazeheal amount=20 | /echo "You have 24 hours. Take these supplies. Cross my territory again and die."',
        onFail: '/mazedamage amount=35 | /mazeitem action="remove" item="key" amount=2 | /echo "Firing squad! Make an example!" Bullets tear through you!',
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 25, executeDropChance: 8,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Action - Nightmare': {
        difficulty: 8,
        startingFavor: 20,
        favorThreshold: 80,
        turnsAllowed: 4,
        persuadeBonus: 8,
        intimidateBonus: 6,
        bribeBonus: 12,
        flattery: true,
        flatterBonus: 15,
        insult: true,
        insultPenalty: 35,
        bribeCost: 'execute',
        damage: 50,
        description: 'An enemy commander holds the nuclear launch codes.',
        mainTitle: 'Enemy Commander',
        npcName: 'Colonel Strakov',
        successMessage: 'The colonel reveals the abort codes.',
        failMessage: 'The colonel initiates the launch sequence.',
        onStart: '/echo "You think I\'ll betray my country? For what?"',
        onPersuade: '/echo "Your words have weight. Perhaps the war has gone too far..."',
        onIntimidate: '/echo "I have survived worse than you, American."',
        onBribe: '/mazeitem action="remove" item="execute" amount=1 | /echo "Power? This... changes things."',
        onFlatter: '/echo "I AM the most decorated officer in the army."',
        onInsult: '/mazedamage amount=20 | /echo "Kill this American dog!" Elite guards attack!',
        onComplete: '/mazeitem action="add" item="key" amount=5 | /mazeitem action="add" item="floorKey" | /mazeitem action="add" item="execute" amount=2 | /mazeheal amount=30 | /echo "The codes. May God forgive us both. Take this and go."',
        onFail: '/mazedamage amount=50 | /mazeitem action="remove" item="key" amount=3 | /mazeitem action="remove" item="stealth" | /echo "Launch sequence initiated! Take this fool to the brig!"',
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 35, executeDropChance: 12,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 3,
    },
    'Action - Apocalypse': {
        difficulty: 10,
        startingFavor: 10,
        favorThreshold: 85,
        turnsAllowed: 3,
        persuadeBonus: 6,
        intimidateBonus: 4,
        bribeBonus: 10,
        flattery: true,
        flatterBonus: 8,
        insult: true,
        insultPenalty: 45,
        bribeCost: 'execute',
        damage: 75,
        description: 'The Shadow Leader. No one has ever seen their face. No one has ever survived.',
        mainTitle: 'The Shadow',
        npcName: 'The Shadow',
        successMessage: '"Impressive. You may be useful alive after all."',
        failMessage: '"Disappointing." You never hear the bullet.',
        onStart: '/echo "You\'ve tracked me down. I\'m almost impressed. Almost."',
        onPersuade: '/echo "Interesting logic. Few have the nerve to speak to me."',
        onIntimidate: '/echo "You threaten me? No one threatens me and lives."',
        onBribe: '/mazeitem action="remove" item="execute" amount=1 | /echo "Technology beyond governments. Now we can talk."',
        onFlatter: '/echo "I control nations from the shadows. Recognition is... refreshing."',
        onInsult: '/mazedamage amount=30 | /echo A silenced round tears through your shoulder. "Wrong move."',
        onComplete: '/mazeitem action="add" item="key" amount=8 | /mazeitem action="add" item="floorKey" amount=2 | /mazeitem action="add" item="execute" amount=3 | /mazeitem action="add" item="elixir" amount=2 | /mazeheal amount=50 | /echo "You\'ve earned my respect. Take these assets. We\'ll meet again."',
        onFail: '/mazedamage amount=75 | /mazeitem action="remove" item="key" amount=99 | /mazeitem action="remove" item="healingPotion" amount=99 | /mazeitem action="remove" item="strike" amount=99 | /echo "Clean up this mess." You never hear the second shot.',
        keyDropChance: 80, strikeDropChance: 55, stealthDropChance: 50, executeDropChance: 20,
        healingPotionDropChance: 40, greaterHealingDropChance: 28, elixirDropChance: 15, revivalCharmDropChance: 8,
    },
};

// =============================================================================
// COMBAT MECHANICS PROFILES (v1.6.0)
// =============================================================================

/**
 * Combat mechanics profiles for combo chains, blocking, and parrying
 * These settings control advanced combat actions and their effects
 */
const DEFAULT_COMBAT_MECHANICS_PROFILES = {
    // v1.6.0: Added 'none', 'simple', and 'lethal' for difficulty tier scaling
    none: {
        name: 'None',
        description: 'All combat mechanics disabled (Tutorial mode)',
        comboEnabled: false,
        comboBonusPerHit: 0,
        maxComboBonus: 0,
        comboDecayTurns: 0,
        comboResetOnMiss: false,
        comboResetOnDamage: false,
        blockEnabled: false,
        blockDamageReduction: 0,
        blockStaminaCost: 0,
        blockBreakThreshold: 0,
        perfectBlockWindow: 0,
        perfectBlockReduction: 0,
        parryEnabled: false,
        parryWindow: 0,
        parryDamageMultiplier: 1,
        parryStunDuration: 0,
        parryDifficulty: 'normal',
        counterEnabled: false,
        counterDamageBonus: 0,
        counterCritBonus: 0,
        onComboStart: '',
        onComboIncrease: '',
        onComboBreak: '',
        onBlockAttempt: '',
        onBlockSuccess: '',
        onBlockBreak: '',
        onParryAttempt: '',
        onParrySuccess: '',
        onParryFail: '',
        onCounterAttack: '',
    },
    simple: {
        name: 'Simple',
        description: 'Basic combo and blocking, no parry mechanics (Easy mode)',
        comboEnabled: true,
        comboBonusPerHit: 3,
        maxComboBonus: 20,
        comboDecayTurns: 3,
        comboResetOnMiss: false,
        comboResetOnDamage: false,
        blockEnabled: true,
        blockDamageReduction: 0.6,
        blockStaminaCost: 0,
        blockBreakThreshold: 0,
        perfectBlockWindow: 0.5,
        perfectBlockReduction: 0.8,
        parryEnabled: false,
        parryWindow: 0,
        parryDamageMultiplier: 1,
        parryStunDuration: 0,
        parryDifficulty: 'normal',
        counterEnabled: false,
        counterDamageBonus: 0,
        counterCritBonus: 0,
        onComboStart: '',
        onComboIncrease: '',
        onComboBreak: '',
        onBlockAttempt: '',
        onBlockSuccess: '',
        onBlockBreak: '',
        onParryAttempt: '',
        onParrySuccess: '',
        onParryFail: '',
        onCounterAttack: '',
    },
    default: {
        name: 'Default',
        description: 'Standard combat mechanics with balanced combo and defense options',
        // Combo System
        comboEnabled: true,
        comboBonusPerHit: 5,        // % damage bonus per consecutive hit
        maxComboBonus: 50,          // % maximum combo bonus cap
        comboDecayTurns: 2,         // Turns before combo resets
        comboResetOnMiss: true,     // Reset combo on missed attack
        comboResetOnDamage: false,  // Reset combo when taking damage
        // Blocking System
        blockEnabled: true,
        blockDamageReduction: 0.5,  // 50% damage reduction when blocking
        blockStaminaCost: 0,        // Stamina cost (if stamina system exists)
        blockBreakThreshold: 0,     // Damage threshold to break block (0 = never)
        perfectBlockWindow: 0.3,    // Perfect block timing window (seconds)
        perfectBlockReduction: 0.8, // 80% reduction on perfect block
        // Parry System
        parryEnabled: true,
        parryWindow: 0.5,           // Parry timing window (seconds)
        parryDamageMultiplier: 1.5, // Counter-attack damage multiplier
        parryStunDuration: 1,       // Enemy stun turns after successful parry
        parryDifficulty: 'normal',  // 'easy', 'normal', 'hard'
        // Counter-Attack
        counterEnabled: true,
        counterDamageBonus: 25,     // % bonus damage on counter
        counterCritBonus: 15,       // % bonus to crit chance on counter
        // STScript Hooks
        onComboStart: '',           // {{comboCount}}
        onComboIncrease: '',        // {{comboCount}}, {{bonusDamage}}, {{totalBonus}}
        onComboBreak: '',           // {{finalCombo}}, {{maxCombo}}, {{reason}}
        onBlockAttempt: '',         // {{damageIncoming}}
        onBlockSuccess: '',         // {{damageBlocked}}, {{damageTaken}}, {{originalDamage}}
        onBlockBreak: '',           // {{damage}}, {{threshold}}
        onParryAttempt: '',         // {{enemyName}}, {{attackDamage}}
        onParrySuccess: '',         // {{enemyName}}, {{counterDamage}}, {{stunDuration}}
        onParryFail: '',            // {{enemyName}}, {{damageTaken}}
        onCounterAttack: '',        // {{damage}}, {{enemyName}}, {{isCrit}}
    },
    aggressive: {
        name: 'Aggressive',
        description: 'High risk, high reward combat focusing on combos over defense',
        comboEnabled: true,
        comboBonusPerHit: 8,
        maxComboBonus: 75,
        comboDecayTurns: 1,
        comboResetOnMiss: true,
        comboResetOnDamage: true,
        blockEnabled: true,
        blockDamageReduction: 0.3,
        blockStaminaCost: 0,
        blockBreakThreshold: 30,
        perfectBlockWindow: 0.2,
        perfectBlockReduction: 0.6,
        parryEnabled: true,
        parryWindow: 0.3,
        parryDamageMultiplier: 2.0,
        parryStunDuration: 2,
        parryDifficulty: 'hard',
        counterEnabled: true,
        counterDamageBonus: 50,
        counterCritBonus: 25,
        onComboStart: '',
        onComboIncrease: '',
        onComboBreak: '',
        onBlockAttempt: '',
        onBlockSuccess: '',
        onBlockBreak: '',
        onParryAttempt: '',
        onParrySuccess: '',
        onParryFail: '',
        onCounterAttack: '',
    },
    defensive: {
        name: 'Defensive',
        description: 'Focus on blocking and parrying with reduced combo potential',
        comboEnabled: true,
        comboBonusPerHit: 3,
        maxComboBonus: 30,
        comboDecayTurns: 3,
        comboResetOnMiss: false,
        comboResetOnDamage: false,
        blockEnabled: true,
        blockDamageReduction: 0.7,
        blockStaminaCost: 0,
        blockBreakThreshold: 0,
        perfectBlockWindow: 0.5,
        perfectBlockReduction: 1.0,
        parryEnabled: true,
        parryWindow: 0.7,
        parryDamageMultiplier: 1.25,
        parryStunDuration: 2,
        parryDifficulty: 'easy',
        counterEnabled: true,
        counterDamageBonus: 15,
        counterCritBonus: 10,
        onComboStart: '',
        onComboIncrease: '',
        onComboBreak: '',
        onBlockAttempt: '',
        onBlockSuccess: '',
        onBlockBreak: '',
        onParryAttempt: '',
        onParrySuccess: '',
        onParryFail: '',
        onCounterAttack: '',
    },
    classic: {
        name: 'Classic',
        description: 'Simplified combat without advanced mechanics',
        comboEnabled: false,
        comboBonusPerHit: 0,
        maxComboBonus: 0,
        comboDecayTurns: 0,
        comboResetOnMiss: false,
        comboResetOnDamage: false,
        blockEnabled: false,
        blockDamageReduction: 0,
        blockStaminaCost: 0,
        blockBreakThreshold: 0,
        perfectBlockWindow: 0,
        perfectBlockReduction: 0,
        parryEnabled: false,
        parryWindow: 0,
        parryDamageMultiplier: 1,
        parryStunDuration: 0,
        parryDifficulty: 'normal',
        counterEnabled: false,
        counterDamageBonus: 0,
        counterCritBonus: 0,
        onComboStart: '',
        onComboIncrease: '',
        onComboBreak: '',
        onBlockAttempt: '',
        onBlockSuccess: '',
        onBlockBreak: '',
        onParryAttempt: '',
        onParrySuccess: '',
        onParryFail: '',
        onCounterAttack: '',
    },
    lethal: {
        name: 'Lethal',
        description: 'Extreme combat - one mistake means death (Nightmare/Apocalypse mode)',
        comboEnabled: true,
        comboBonusPerHit: 10,
        maxComboBonus: 150,
        comboDecayTurns: 1,
        comboResetOnMiss: true,
        comboResetOnDamage: true,
        blockEnabled: true,
        blockDamageReduction: 0.2,
        blockStaminaCost: 0,
        blockBreakThreshold: 50,
        perfectBlockWindow: 0.15,
        perfectBlockReduction: 0.5,
        parryEnabled: true,
        parryWindow: 0.2,
        parryDamageMultiplier: 3.0,
        parryStunDuration: 3,
        parryDifficulty: 'hard',
        counterEnabled: true,
        counterDamageBonus: 75,
        counterCritBonus: 40,
        onComboStart: '',
        onComboIncrease: '',
        onComboBreak: '',
        onBlockAttempt: '',
        onBlockSuccess: '',
        onBlockBreak: '',
        onParryAttempt: '',
        onParrySuccess: '',
        onParryFail: '',
        onCounterAttack: '',
    },
};

/**
 * Vision profiles for enhanced visibility and lighting system
 * Controls torch/lantern effects, ambient lighting, and room darkness
 */
const DEFAULT_VISION_PROFILES = {
    default: {
        name: 'Default',
        description: 'Standard visibility settings with balanced lighting',
        baseVisibility: 1,          // Base visibility radius
        torchBonus: 2,              // Bonus radius when torch is active
        torchDuration: 3,           // Moves before torch burns out
        lanternBonus: 1,            // Permanent bonus from lantern
        sightPotionBonus: 2,        // Bonus from sight potions
        sightPotionDuration: 5,     // Moves for sight potion effect
        // Ambient lighting modifiers
        ambientLevels: {
            dark: -1,               // Penalty in dark areas
            dim: 0,                 // No modifier in dim areas
            normal: 0,              // No modifier in normal light
            bright: 1,              // Bonus in bright areas
        },
        // Default room darkness by map style
        roomDarkness: {
            maze: 'dim',
            dungeon: 'dim',
            cave: 'dark',
            forest: 'dim',
            city: 'normal',
            spacestation: 'normal',
            neotokyo: 'dim',
            apartment: 'normal',
            hospital: 'normal',
            highrise: 'dim',
            outpost: 'normal',
            arena: 'bright',
            college: 'bright',
        },
        // STScript Hooks
        onVisionChange: '',         // {{newRadius}}, {{previousRadius}}, {{source}}
        onLightChange: '',          // {{lightType}}, {{remaining}}, {{action}}
        onDarknessEnter: '',        // {{roomType}}, {{ambientLevel}}, {{effectiveRadius}}
        onLightSourceExpire: '',    // {{lightType}}
    },
    explorer: {
        name: 'Explorer',
        description: 'Enhanced visibility for exploration-focused play',
        baseVisibility: 2,
        torchBonus: 3,
        torchDuration: 5,
        lanternBonus: 2,
        sightPotionBonus: 3,
        sightPotionDuration: 8,
        ambientLevels: {
            dark: 0,
            dim: 0,
            normal: 1,
            bright: 2,
        },
        roomDarkness: {
            maze: 'normal',
            dungeon: 'dim',
            cave: 'dim',
            forest: 'normal',
            city: 'normal',
            spacestation: 'normal',
            neotokyo: 'normal',
            apartment: 'normal',
            hospital: 'normal',
            highrise: 'normal',
            outpost: 'normal',
            arena: 'bright',
            college: 'bright',
        },
        onVisionChange: '',
        onLightChange: '',
        onDarknessEnter: '',
        onLightSourceExpire: '',
    },
    survival: {
        name: 'Survival',
        description: 'Limited visibility for intense survival horror experience',
        baseVisibility: 1,
        torchBonus: 1,
        torchDuration: 2,
        lanternBonus: 1,
        sightPotionBonus: 1,
        sightPotionDuration: 3,
        ambientLevels: {
            dark: -2,
            dim: -1,
            normal: 0,
            bright: 0,
        },
        roomDarkness: {
            maze: 'dark',
            dungeon: 'dark',
            cave: 'dark',
            forest: 'dark',
            city: 'dim',
            spacestation: 'dim',
            neotokyo: 'dark',
            apartment: 'dim',
            hospital: 'dark',
            highrise: 'dark',
            outpost: 'dim',
            arena: 'normal',
            college: 'dim',
        },
        onVisionChange: '',
        onLightChange: '',
        onDarknessEnter: '',
        onLightSourceExpire: '',
    },
    fullvisibility: {
        name: 'Full Visibility',
        description: 'Maximum visibility - see everything',
        baseVisibility: 5,
        torchBonus: 0,
        torchDuration: 99,
        lanternBonus: 0,
        sightPotionBonus: 0,
        sightPotionDuration: 99,
        ambientLevels: {
            dark: 0,
            dim: 0,
            normal: 0,
            bright: 0,
        },
        roomDarkness: {
            maze: 'bright',
            dungeon: 'bright',
            cave: 'bright',
            forest: 'bright',
            city: 'bright',
            spacestation: 'bright',
            neotokyo: 'bright',
            apartment: 'bright',
            hospital: 'bright',
            highrise: 'bright',
            outpost: 'bright',
            arena: 'bright',
            college: 'bright',
        },
        onVisionChange: '',
        onLightChange: '',
        onDarknessEnter: '',
        onLightSourceExpire: '',
    },
};

/**
 * Quest Profiles - Collections of quests that can gate progression
 * Each maze profile can reference a quest profile for structured objectives
 */
const DEFAULT_QUEST_PROFILES = {
    // Tutorial - No gating, optional quests to learn mechanics
    'Tutorial: First Steps': {
        name: 'Tutorial: First Steps',
        description: 'Learn the basics with optional exploration quests',
        quests: [
            { questId: 'quest_collect_keys', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_explore_75', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'none',
        onQuestProfileLoad: '',
    },
    // Fantasy profiles
    'Fantasy - Easy': {
        name: 'Fantasy - Easy',
        description: 'Gentle quests with optional zone unlocks',
        quests: [
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: false },
            { questId: 'quest_defeat_3', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_explore_50', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_treasure_hunter', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'any',
        onQuestProfileLoad: '',
    },
    'Fantasy - Normal': {
        name: 'Fantasy - Normal',
        description: 'Standard dungeon crawl with quest progression',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_collect_keys', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_explore_75', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: false },
            { questId: 'quest_treasure_hunter', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
            { questId: 'quest_find_secret', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Fantasy - Hard': {
        name: 'Fantasy - Hard',
        description: 'Challenging quests gate deeper zones',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_collect_5_keys', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_find_secret', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: false },
            { questId: 'quest_open_5_chests', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Fantasy - Nightmare': {
        name: 'Fantasy - Nightmare',
        description: 'Strict progression with mandatory objectives',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_explore_75', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: true },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_find_secret', progressionType: 'floor', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_open_5_chests', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Fantasy - Apocalypse': {
        name: 'Fantasy - Apocalypse',
        description: 'Complete all objectives to survive',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'floor', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_explore_75', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: true },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: true },
            { questId: 'quest_find_3_secrets', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'floor', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_full_clear', progressionType: 'none', progressionTarget: null, autoAccept: true, required: true },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    // Horror profiles
    'Horror - Easy': {
        name: 'Horror - Easy',
        description: 'Light scares with optional objectives',
        quests: [
            { questId: 'quest_explore_50', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: false },
            { questId: 'quest_survive_10_turns', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_find_secret', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
            { questId: 'quest_treasure_hunter', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'any',
        onQuestProfileLoad: '',
    },
    'Horror - Normal': {
        name: 'Horror - Normal',
        description: 'Survive the darkness and uncover secrets',
        quests: [
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: false },
            { questId: 'quest_explore_75', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_defeat_3', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_collect_keys', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Horror - Hard': {
        name: 'Horror - Hard',
        description: 'Face your fears to progress deeper',
        quests: [
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: false },
            { questId: 'quest_explore_75', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_open_5_chests', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_collect_5_keys', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Horror - Nightmare': {
        name: 'Horror - Nightmare',
        description: 'No escape without completing all tasks',
        quests: [
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'floor', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_explore_75', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: true },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_find_3_secrets', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Horror - Apocalypse': {
        name: 'Horror - Apocalypse',
        description: 'Complete everything or become part of the darkness',
        quests: [
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'floor', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_explore_75', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: true },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: true },
            { questId: 'quest_find_3_secrets', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'floor', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_full_clear', progressionType: 'none', progressionTarget: null, autoAccept: true, required: true },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    // Sci-Fi profiles
    'Sci-Fi - Easy': {
        name: 'Sci-Fi - Easy',
        description: 'Basic station objectives',
        quests: [
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: false },
            { questId: 'quest_explore_50', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_defeat_3', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_treasure_hunter', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'any',
        onQuestProfileLoad: '',
    },
    'Sci-Fi - Normal': {
        name: 'Sci-Fi - Normal',
        description: 'Complete objectives to access new sectors',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: false },
            { questId: 'quest_explore_75', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_find_secret', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
            { questId: 'quest_open_5_chests', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Sci-Fi - Hard': {
        name: 'Sci-Fi - Hard',
        description: 'Security clearance required for each sector',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: false },
            { questId: 'quest_explore_75', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_survive_combat', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_collect_5_keys', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Sci-Fi - Nightmare': {
        name: 'Sci-Fi - Nightmare',
        description: 'Full mission parameters - no shortcuts',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'floor', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: true },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_explore_90', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Sci-Fi - Apocalypse': {
        name: 'Sci-Fi - Apocalypse',
        description: 'Complete all directives - station destruction imminent',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'floor', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: true },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: true },
            { questId: 'quest_find_3_secrets', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'floor', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_full_clear', progressionType: 'none', progressionTarget: null, autoAccept: true, required: true },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    // Cyberpunk profiles
    'Cyberpunk - Easy': {
        name: 'Cyberpunk - Easy',
        description: 'Simple runs with optional paydata',
        quests: [
            { questId: 'quest_treasure_hunter', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: false },
            { questId: 'quest_explore_50', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_defeat_3', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_collect_keys', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'any',
        onQuestProfileLoad: '',
    },
    'Cyberpunk - Normal': {
        name: 'Cyberpunk - Normal',
        description: 'Standard heist with security checkpoints',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_treasure_hunter', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: false },
            { questId: 'quest_find_secret', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
            { questId: 'quest_explore_75', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_collect_keys', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Cyberpunk - Hard': {
        name: 'Cyberpunk - Hard',
        description: 'Corp security escalation protocol',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_treasure_hunter', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: false },
            { questId: 'quest_find_secret', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_open_5_chests', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Cyberpunk - Nightmare': {
        name: 'Cyberpunk - Nightmare',
        description: 'Maximum security - no margin for error',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'floor', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_treasure_hunter', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: true },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_collect_5_keys', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Cyberpunk - Apocalypse': {
        name: 'Cyberpunk - Apocalypse',
        description: 'Zero-day exploit - complete extraction required',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'floor', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_treasure_hunter', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: true },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: true },
            { questId: 'quest_find_3_secrets', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'floor', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_full_clear', progressionType: 'none', progressionTarget: null, autoAccept: true, required: true },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    // Western profiles
    'Western - Easy': {
        name: 'Western - Easy',
        description: 'Easy trail with optional bounties',
        quests: [
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: false },
            { questId: 'quest_defeat_3', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_explore_50', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_treasure_hunter', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'any',
        onQuestProfileLoad: '',
    },
    'Western - Normal': {
        name: 'Western - Normal',
        description: 'Clear the territory to advance',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: false },
            { questId: 'quest_treasure_hunter', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
            { questId: 'quest_explore_75', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_survive_10_turns', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Western - Hard': {
        name: 'Western - Hard',
        description: 'Outlaw territory - prove yourself',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: false },
            { questId: 'quest_treasure_hunter', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_find_secret', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Western - Nightmare': {
        name: 'Western - Nightmare',
        description: 'Dead or alive - no middle ground',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'floor', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: true },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_explore_75', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Western - Apocalypse': {
        name: 'Western - Apocalypse',
        description: 'The final showdown - complete the legend',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'floor', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: true },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: true },
            { questId: 'quest_find_3_secrets', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'floor', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_full_clear', progressionType: 'none', progressionTarget: null, autoAccept: true, required: true },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    // Action profiles
    'Action - Easy': {
        name: 'Action - Easy',
        description: 'Training mission with optional objectives',
        quests: [
            { questId: 'quest_defeat_3', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: false },
            { questId: 'quest_explore_50', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_survive_10_turns', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_collect_keys', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'any',
        onQuestProfileLoad: '',
    },
    'Action - Normal': {
        name: 'Action - Normal',
        description: 'Standard op with checkpoint clearance',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: false },
            { questId: 'quest_explore_75', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_collect_keys', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_treasure_hunter', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Action - Hard': {
        name: 'Action - Hard',
        description: 'High-value target - full clearance required',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: false },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_find_secret', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Action - Nightmare': {
        name: 'Action - Nightmare',
        description: 'Black ops - no backup, no failure',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'floor', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: true },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_explore_90', progressionType: 'none', progressionTarget: null, autoAccept: false, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
    'Action - Apocalypse': {
        name: 'Action - Apocalypse',
        description: 'Total war - complete all objectives or die trying',
        quests: [
            { questId: 'quest_defeat_5', progressionType: 'zone', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_survive_combat', progressionType: 'zone', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_find_secret', progressionType: 'floor', progressionTarget: 1, autoAccept: true, required: true },
            { questId: 'quest_collect_keys', progressionType: 'zone', progressionTarget: 3, autoAccept: true, required: true },
            { questId: 'quest_defeat_10', progressionType: 'none', progressionTarget: null, autoAccept: true, required: true },
            { questId: 'quest_find_3_secrets', progressionType: 'none', progressionTarget: null, autoAccept: true, required: false },
            { questId: 'quest_boss_slayer', progressionType: 'floor', progressionTarget: 2, autoAccept: true, required: true },
            { questId: 'quest_full_clear', progressionType: 'none', progressionTarget: null, autoAccept: true, required: true },
        ],
        gatingMode: 'sequential',
        onQuestProfileLoad: '',
    },
};

// =============================================================================
// ITEM PROFILES (v1.7.0)
// =============================================================================

/**
 * Item Profiles - Configurable items with themed aliases and type-specific fields
 * Types: key, potion, equipment, weapon, special, vision, exploration
 * Every item supports theme-based display names via aliases
 */
const DEFAULT_ITEM_PROFILES = {
    // ===== KEYS =====
    'key': {
        id: 'key',
        name: 'Key',
        type: 'key',
        icon: 'fa-key',
        description: 'Unlocks locked chests',
        rarity: 'common',
        stackable: true,
        aliases: {
            fantasy: 'Iron Key',
            horror: 'Rusty Key',
            scifi: 'Access Card',
            action: 'Master Key',
            cyberpunk: 'Access Chip',
            noir: 'Skeleton Key',
            postapoc: 'Vault Keycard',
            comedy: 'Comically Large Key',
            western: 'Skeleton Key',
        },
    },
    'floorKey': {
        id: 'floorKey',
        name: 'Floor Key',
        type: 'key',
        icon: 'fa-stairs',
        description: 'Unlocks staircases to new floors',
        rarity: 'uncommon',
        stackable: true,
        aliases: {
            fantasy: 'Stairway Key',
            horror: 'Cellar Key',
            scifi: 'Deck Keycard',
            action: 'Building Key',
            cyberpunk: 'Elevator Override',
            noir: 'Service Key',
            postapoc: 'Bunker Code',
            comedy: "Janitor's Master Key",
            western: 'Mine Key',
        },
    },

    // ===== POTIONS =====
    'healingPotion': {
        id: 'healingPotion',
        name: 'Healing Potion',
        type: 'potion',
        icon: 'fa-flask',
        iconColor: '#e74c3c',
        description: 'Restores 25% of max HP',
        rarity: 'common',
        stackable: true,
        healAmount: 25,
        healIsPercent: true,
        aliases: {
            fantasy: 'Healing Potion',
            horror: 'Blessed Elixir',
            scifi: 'Med-Stim',
            action: 'First Aid Kit',
            cyberpunk: 'Trauma Patch',
            noir: 'Flask of Whiskey',
            postapoc: 'Rad-Away',
            comedy: 'Suspiciously Glowing Drink',
            western: "Doc's Tonic",
        },
    },
    'greaterHealing': {
        id: 'greaterHealing',
        name: 'Greater Healing',
        type: 'potion',
        icon: 'fa-flask',
        iconColor: '#9b59b6',
        description: 'Restores 50% of max HP',
        rarity: 'uncommon',
        stackable: true,
        healAmount: 50,
        healIsPercent: true,
        aliases: {
            fantasy: 'Greater Healing Potion',
            horror: 'Holy Water',
            scifi: 'Emergency Medkit',
            action: 'Combat Medkit',
            cyberpunk: 'Military Grade Stim',
            noir: 'Strong Medicine',
            postapoc: 'Stimpak',
            comedy: 'Very Suspicious Drink',
            western: 'Snake Oil (Real)',
        },
    },
    'elixir': {
        id: 'elixir',
        name: 'Elixir',
        type: 'potion',
        icon: 'fa-flask',
        iconColor: '#f1c40f',
        description: 'Fully restores HP to maximum',
        rarity: 'rare',
        stackable: true,
        healAmount: 100,
        healIsPercent: true,
        aliases: {
            fantasy: 'Elixir of Life',
            horror: 'Resurrection Serum',
            scifi: 'Full Restore Protocol',
            action: 'Surgical Kit',
            cyberpunk: 'Phoenix Protocol',
            noir: 'Miracle Cure',
            postapoc: 'Pre-War Medicine',
            comedy: 'Plot Armor Juice',
            western: 'Miracle Water',
        },
    },

    // ===== EQUIPMENT (Consumable Armor) =====
    'ironGuard': {
        id: 'ironGuard',
        name: 'Iron Guard',
        type: 'equipment',
        subtype: 'armor',
        icon: 'fa-shield-halved',
        description: 'Absorbs 3 hits from combat or traps',
        rarity: 'uncommon',
        stackable: true,
        charges: 3,
        absorbPercent: 100,
        triggers: ['combat', 'trap'],
        autoUse: true,
        aliases: {
            fantasy: 'Iron Guard',
            horror: 'Warding Charm',
            scifi: 'Energy Shield',
            action: 'Ballistic Vest',
            cyberpunk: 'Dermal Plating',
            noir: 'Steel-Lined Coat',
            postapoc: 'Scrap Armor',
            comedy: 'Plot Armor',
            western: 'Steel Vest',
        },
        onActivate: '',
        onBreak: '',
    },
    'revivalCharm': {
        id: 'revivalCharm',
        name: 'Revival Charm',
        type: 'equipment',
        subtype: 'charm',
        icon: 'fa-heart-pulse',
        iconColor: '#e74c3c',
        description: 'Auto-revives you on death with 25% HP',
        rarity: 'rare',
        stackable: true,
        charges: 1,
        autoUse: true,
        triggers: ['death'],
        aliases: {
            fantasy: 'Revival Charm',
            horror: "Death's Reprieve",
            scifi: 'Emergency Revive Module',
            action: 'Defib Unit',
            cyberpunk: 'Second Heart',
            noir: 'Lucky Break',
            postapoc: 'Second Chance Serum',
            comedy: 'Extra Life Token',
            western: 'Guardian Angel',
        },
    },

    // ===== SPECIAL (Combat Items) =====
    'strike': {
        id: 'strike',
        name: 'Strike',
        type: 'special',
        effect: 'guaranteedHit',
        icon: 'fa-bullseye',
        iconColor: '#e67e22',
        description: 'Guarantees a hit in the next combat action',
        rarity: 'uncommon',
        stackable: true,
        aliases: {
            fantasy: 'Battle Fury',
            horror: 'Adrenaline Rush',
            scifi: 'Combat Stim',
            action: 'Adrenaline Shot',
            cyberpunk: 'Combat Stims',
            noir: 'Brass Knuckles',
            postapoc: 'Rad-X Boost',
            comedy: 'Energy Drink',
            western: 'Whiskey Courage',
        },
    },
    'stealth': {
        id: 'stealth',
        name: 'Stealth',
        type: 'special',
        effect: 'skipEncounter',
        icon: 'fa-ghost',
        iconColor: '#9b59b6',
        description: 'Skip the current encounter without combat',
        rarity: 'uncommon',
        stackable: true,
        aliases: {
            fantasy: 'Cloak of Shadows',
            horror: 'Shadow Shroud',
            scifi: 'Cloaking Device',
            action: 'Smoke Grenade',
            cyberpunk: 'Optical Camo',
            noir: 'Trench Coat',
            postapoc: 'Ghillie Wrap',
            comedy: 'Cardboard Box',
            western: 'Poncho',
        },
    },
    'execute': {
        id: 'execute',
        name: 'Execute',
        type: 'special',
        effect: 'instantWin',
        icon: 'fa-skull',
        iconColor: '#e74c3c',
        description: 'Instantly win the current encounter',
        rarity: 'epic',
        stackable: true,
        aliases: {
            fantasy: 'Divine Wrath',
            horror: 'Survival Instinct',
            scifi: 'Overdrive Module',
            action: 'Air Strike',
            cyberpunk: 'Berserker Mode',
            noir: 'Tommy Gun',
            postapoc: 'Mini Nuke',
            comedy: 'Power of Friendship',
            western: 'Dynamite Bundle',
        },
    },
    'minionBane': {
        id: 'minionBane',
        name: 'Minion Bane',
        type: 'special',
        effect: 'skipCombat',
        icon: 'fa-ban',
        iconColor: '#3498db',
        description: 'Automatically bypass minion encounters',
        rarity: 'rare',
        stackable: true,
        aliases: {
            fantasy: 'Monster Bane',
            horror: 'Banishment Charm',
            scifi: 'EMP Grenade',
            action: 'Flashbang',
            cyberpunk: 'System Crash',
            noir: 'Blackmail File',
            postapoc: 'Purifier',
            comedy: 'Bad Pun',
            western: 'Silver Bullet',
        },
    },

    // ===== EXPLORATION =====
    'portalStone': {
        id: 'portalStone',
        name: 'Portal Stone',
        type: 'exploration',
        effect: 'teleport',
        icon: 'fa-circle-dot',
        iconColor: '#8e44ad',
        description: 'Teleport to a random explored tile',
        rarity: 'uncommon',
        stackable: true,
        aliases: {
            fantasy: 'Portal Stone',
            horror: 'Dark Crystal',
            scifi: 'Teleport Beacon',
            action: 'Zip Line',
            cyberpunk: 'Fast Travel Chip',
            noir: 'Secret Map',
            postapoc: 'Signal Flare',
            comedy: 'Plot Device',
            western: 'Treasure Map',
        },
    },
    'mapFragment': {
        id: 'mapFragment',
        name: 'Map Fragment',
        type: 'exploration',
        effect: 'reveal3x3',
        icon: 'fa-map',
        iconColor: '#f39c12',
        description: 'Reveals a 3x3 area around you',
        rarity: 'common',
        stackable: true,
        aliases: {
            fantasy: 'Ancient Map',
            horror: 'Torn Note',
            scifi: 'Data Pad',
            action: 'Intel Report',
            cyberpunk: 'Hacked Schematic',
            noir: 'Case Notes',
            postapoc: 'Scavenged Map',
            comedy: 'Napkin Drawing',
            western: 'Wanted Poster',
        },
    },
    'voidWalk': {
        id: 'voidWalk',
        name: 'Void Walk',
        type: 'exploration',
        effect: 'phaseWall',
        icon: 'fa-person-walking-dashed-line-arrow-right',
        iconColor: '#1abc9c',
        description: 'Phase through one wall',
        rarity: 'rare',
        stackable: true,
        aliases: {
            fantasy: 'Ghost Step Potion',
            horror: 'Phase Vial',
            scifi: 'Phase Shifter',
            action: 'Breach Charge',
            cyberpunk: 'Ghost Protocol',
            noir: 'Shadow Step',
            postapoc: 'Hazmat Suit',
            comedy: 'Fourth Wall Break',
            western: 'Tumbleweed Roll',
        },
    },
    'timeShard': {
        id: 'timeShard',
        name: 'Time Shard',
        type: 'exploration',
        effect: 'extraMove',
        icon: 'fa-clock',
        iconColor: '#3498db',
        description: 'Grants an extra move action',
        rarity: 'rare',
        stackable: true,
        aliases: {
            fantasy: 'Time Crystal',
            horror: 'Slowing Serum',
            scifi: 'Temporal Disruptor',
            action: 'Slow-Mo Serum',
            cyberpunk: 'Reflex Booster',
            noir: 'Pocket Watch',
            postapoc: 'Stasis Field',
            comedy: 'Dramatic Pause',
            western: 'High Noon Focus',
        },
    },

    // ===== VISION =====
    'torch': {
        id: 'torch',
        name: 'Torch',
        type: 'vision',
        effect: 'tempVisibility',
        icon: 'fa-fire',
        iconColor: '#e67e22',
        description: '+2 visibility for 3 moves',
        rarity: 'common',
        stackable: true,
        visibilityBonus: 2,
        duration: 3,
        aliases: {
            fantasy: 'Torch',
            horror: 'Flickering Candle',
            scifi: 'Flare',
            action: 'Flashlight',
            cyberpunk: 'Glow Stick',
            noir: 'Lighter',
            postapoc: 'Emergency Light',
            comedy: 'Suspiciously Bright Phone',
            western: 'Oil Lamp',
        },
    },
    'lantern': {
        id: 'lantern',
        name: 'Lantern',
        type: 'vision',
        effect: 'passiveVisibility',
        icon: 'fa-lightbulb',
        iconColor: '#f1c40f',
        description: '+1 visibility while held (passive)',
        rarity: 'uncommon',
        stackable: false,
        visibilityBonus: 1,
        passive: true,
        aliases: {
            fantasy: 'Lantern',
            horror: 'Spirit Lamp',
            scifi: 'Helmet Light',
            action: 'Tactical Light',
            cyberpunk: 'Optic Enhancer',
            noir: 'Streetlamp Glow',
            postapoc: 'Salvaged Lantern',
            comedy: 'Glowing Personality',
            western: 'Miners Lamp',
        },
    },
    'revealScroll': {
        id: 'revealScroll',
        name: 'Reveal Scroll',
        type: 'vision',
        effect: 'revealFloor',
        icon: 'fa-scroll',
        iconColor: '#9b59b6',
        description: 'Reveals the entire current floor',
        rarity: 'rare',
        stackable: true,
        aliases: {
            fantasy: 'Reveal Scroll',
            horror: 'Cursed Map',
            scifi: 'Floor Schematic',
            action: 'Satellite Feed',
            cyberpunk: 'Netrunner Scan',
            noir: 'Blueprint',
            postapoc: 'Vault Map',
            comedy: 'Spoiler Alert',
            western: 'Survey Map',
        },
    },
    'sightPotion': {
        id: 'sightPotion',
        name: 'Sight Potion',
        type: 'vision',
        effect: 'permVisibility',
        icon: 'fa-eye',
        iconColor: '#3498db',
        description: '+1 permanent visibility',
        rarity: 'rare',
        stackable: true,
        visibilityBonus: 1,
        permanent: true,
        aliases: {
            fantasy: 'Sight Potion',
            horror: 'Third Eye Serum',
            scifi: 'Optic Enhancement',
            action: 'Night Vision Goggles',
            cyberpunk: 'Cybereye Upgrade',
            noir: 'Keen Observation',
            postapoc: 'Mutant Vision',
            comedy: 'Reading Glasses',
            western: 'Eagle Eye Tonic',
        },
    },
    'crystalBall': {
        id: 'crystalBall',
        name: 'Crystal Ball',
        type: 'vision',
        effect: 'revealMinions',
        icon: 'fa-circle',
        iconColor: '#8e44ad',
        description: 'Reveals all minion positions on the floor',
        rarity: 'rare',
        stackable: true,
        aliases: {
            fantasy: 'Crystal Ball',
            horror: 'Ouija Board',
            scifi: 'Life Sign Scanner',
            action: 'Motion Tracker',
            cyberpunk: 'Threat Detector',
            noir: 'Informant Tip',
            postapoc: 'Mutant Tracker',
            comedy: 'Magic 8-Ball',
            western: 'Tracking Instinct',
        },
    },

    // ===== HP BOOST =====
    'heartCrystal': {
        id: 'heartCrystal',
        name: 'Heart Crystal',
        type: 'boost',
        effect: 'increaseMaxHP',
        icon: 'fa-heart',
        iconColor: '#e74c3c',
        description: 'Permanently increases max HP by 10',
        rarity: 'rare',
        stackable: true,
        hpBonus: 10,
        aliases: {
            fantasy: 'Heart Crystal',
            horror: 'Soul Fragment',
            scifi: 'Life Extension Module',
            action: 'Body Armor Upgrade',
            cyberpunk: 'Biomod Enhancement',
            noir: 'Lucky Charm',
            postapoc: 'Endurance Booster',
            comedy: 'Extra Hearts',
            western: 'Iron Constitution',
        },
    },

    // ===== REPAIR =====
    'repairKit': {
        id: 'repairKit',
        name: 'Repair Kit',
        type: 'repair',
        effect: 'repairEquipment',
        icon: 'fa-wrench',
        iconColor: '#95a5a6',
        description: 'Restores durability to a weapon or armor',
        rarity: 'uncommon',
        stackable: true,
        repairAmount: 3,
        aliases: {
            fantasy: 'Smithing Kit',
            horror: 'Dark Restoration',
            scifi: 'Nano-Repair Module',
            action: 'Field Repair Kit',
            cyberpunk: 'Chrome Polish',
            noir: 'Maintenance Kit',
            postapoc: 'Scrap Repair',
            comedy: 'Duct Tape & WD-40',
            western: 'Gunsmith Tools',
        },
    },
};

/**
 * Get an item profile by ID
 * Returns custom profile if exists, otherwise returns default
 * @param {string} itemId - The item ID
 * @returns {object|null} The item profile or null
 */
function getItemProfile(itemId) {
    // Check for custom profile first
    const customProfiles = extensionSettings.itemProfiles || {};
    if (customProfiles[itemId]) {
        return { ...DEFAULT_ITEM_PROFILES[itemId], ...customProfiles[itemId] };
    }
    return DEFAULT_ITEM_PROFILES[itemId] || null;
}

/**
 * Get all item profile IDs (both default and custom)
 * @returns {string[]} Array of item IDs
 */
function getItemProfileIds() {
    const customProfiles = extensionSettings.itemProfiles || {};
    const allIds = new Set([...Object.keys(DEFAULT_ITEM_PROFILES), ...Object.keys(customProfiles)]);
    return Array.from(allIds);
}

/**
 * Generate HTML checkboxes for Find Early items dynamically from item profiles
 * v1.9.0: Replaces hardcoded checkbox list
 * @param {Array} selectedItems - Array of item IDs that should be checked
 * @returns {string} HTML string of checkbox labels
 */
function generateFindEarlyCheckboxesHTML(selectedItems = []) {
    const allItemIds = getItemProfileIds();
    let html = '';

    for (const itemId of allItemIds) {
        const profile = getItemProfile(itemId);
        if (!profile) continue;

        const checked = selectedItems.includes(itemId) ? 'checked' : '';
        const icon = profile.icon || 'fa-box';
        const iconColor = profile.iconColor || '#888';
        const shortName = profile.name.length > 10 ? profile.name.substring(0, 8) + '...' : profile.name;

        html += `<label class="mazemaster-checkbox-label"><input type="checkbox" id="mazemaster_findearly_${itemId}" ${checked}><i class="fa-solid ${icon}" style="color:${iconColor};"></i> ${shortName}</label>`;
    }

    return html;
}

/**
 * Generate HTML checkboxes for Item Pool items dynamically from item profiles
 * v1.9.0: Replaces hardcoded checkbox list
 * @param {Array} selectedItems - Array of item IDs that should be checked
 * @returns {string} HTML string organized by item type
 */
function generateItemPoolCheckboxesHTML(selectedItems = []) {
    const allItemIds = getItemProfileIds();

    // Group items by type
    const itemsByType = {};
    for (const itemId of allItemIds) {
        const profile = getItemProfile(itemId);
        if (!profile) continue;
        const type = profile.type || 'misc';
        if (!itemsByType[type]) itemsByType[type] = [];
        itemsByType[type].push({ itemId, profile });
    }

    // Type display names
    const typeLabels = {
        key: 'Keys & Combat',
        special: 'Combat Items',
        exploration: 'Exploration',
        potion: 'HP & Healing',
        equipment: 'Equipment',
        vision: 'Vision',
        weapon: 'Weapons',
        armor: 'Armor',
        accessory: 'Accessories',
        boost: 'Boosts',
        misc: 'Other',
    };

    let html = '';
    for (const [type, items] of Object.entries(itemsByType)) {
        if (items.length === 0) continue;
        const label = typeLabels[type] || type.charAt(0).toUpperCase() + type.slice(1);
        html += `<label class="mazemaster-label" style="font-size: 0.8em; color: var(--SmartThemeEmColor);">${label}</label>`;
        html += '<div class="mazemaster-grid-4col" style="gap: 4px; margin-bottom: 8px;">';
        for (const { itemId, profile } of items) {
            const checked = selectedItems.includes(itemId) ? 'checked' : '';
            const icon = profile.icon || 'fa-box';
            const iconColor = profile.iconColor || '#888';
            const shortName = profile.name.length > 12 ? profile.name.substring(0, 10) + '...' : profile.name;
            html += `<label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="${itemId}" ${checked}><i class="fa-solid ${icon}" style="color:${iconColor};"></i> ${shortName}</label>`;
        }
        html += '</div>';
    }

    return html;
}

// =============================================================================
// v1.9.0: CENTRALIZED REGISTRY HELPERS
// =============================================================================

/**
 * Get all available theme names (built-in + custom)
 * v1.9.0: Replaces hardcoded theme arrays throughout the codebase
 * @returns {string[]} Array of theme IDs
 */
function getAvailableThemes() {
    // Get themes from DEFAULT_FACTION_PROFILES (source of truth)
    const builtInThemes = Object.keys(DEFAULT_FACTION_PROFILES);
    // Add any custom themes from settings
    const customThemes = Object.keys(extensionSettings.customThemes || {});
    return [...new Set([...builtInThemes, ...customThemes])];
}

/**
 * Get all available difficulty tier names
 * v1.9.0: Replaces hardcoded difficulty arrays
 * @returns {string[]} Array of difficulty IDs
 */
function getAvailableDifficulties() {
    return Object.keys(DIFFICULTY_TIERS);
}

/**
 * Get all available map style names (built-in + aliases)
 * v1.9.0: Replaces hardcoded map style arrays
 * @returns {string[]} Array of style IDs
 */
function getAvailableMapStyles() {
    // Get all styles from STYLE_TO_BSP_CONFIG
    const builtInStyles = Object.keys(STYLE_TO_BSP_CONFIG);
    // Add any custom styles from settings
    const customStyles = Object.keys(extensionSettings.customMapStyles || {});
    return [...new Set([...builtInStyles, ...customStyles])];
}

/**
 * Get display name for a theme
 * @param {string} themeId - The theme ID
 * @returns {string} Human-readable theme name
 */
function getThemeDisplayName(themeId) {
    const profile = DEFAULT_FACTION_PROFILES[themeId];
    if (profile?.name) return profile.name;
    // Capitalize first letter for custom themes
    return themeId.charAt(0).toUpperCase() + themeId.slice(1);
}

/**
 * Get display name for a difficulty tier
 * @param {string} difficultyId - The difficulty ID
 * @returns {string} Human-readable difficulty name
 */
function getDifficultyDisplayName(difficultyId) {
    const tier = DIFFICULTY_TIERS[difficultyId];
    if (tier?.name) return tier.name;
    return difficultyId.charAt(0).toUpperCase() + difficultyId.slice(1);
}

/**
 * Get display name for a map style
 * @param {string} styleId - The style ID
 * @returns {string} Human-readable style name
 */
function getMapStyleDisplayName(styleId) {
    // Style display name mappings
    const styleNames = {
        'maze': 'Classic Maze',
        'dungeon': 'Dungeon',
        'city': 'City Streets',
        'forest': 'Forest',
        'spaceship': 'Spaceship',
        'spacestation': 'Space Station',
        'outpost': 'Outpost',
        'college': 'College Campus',
        'apartment': 'Apartment Complex',
        'neotokyo': 'Neo Tokyo',
        'arena': 'Battle Arena',
        'hospital': 'Hospital',
        'highrise': 'Abandoned Highrise',
    };
    return styleNames[styleId] || styleId.charAt(0).toUpperCase() + styleId.slice(1);
}

/**
 * Generate dynamic HTML options for theme dropdown
 * @param {string} selectedTheme - Currently selected theme
 * @returns {string} HTML options string
 */
function generateThemeOptionsHTML(selectedTheme = 'fantasy') {
    return getAvailableThemes().map(themeId => {
        const selected = themeId === selectedTheme ? 'selected' : '';
        return `<option value="${themeId}" ${selected}>${getThemeDisplayName(themeId)}</option>`;
    }).join('\n');
}

/**
 * Generate dynamic HTML options for difficulty dropdown
 * @param {string} selectedDifficulty - Currently selected difficulty
 * @returns {string} HTML options string
 */
function generateDifficultyOptionsHTML(selectedDifficulty = 'normal') {
    return getAvailableDifficulties().map(diffId => {
        const selected = diffId === selectedDifficulty ? 'selected' : '';
        return `<option value="${diffId}" ${selected}>${getDifficultyDisplayName(diffId)}</option>`;
    }).join('\n');
}

/**
 * Generate dynamic HTML options for map style dropdown
 * @param {string} selectedStyle - Currently selected style
 * @returns {string} HTML options string
 */
function generateMapStyleOptionsHTML(selectedStyle = 'maze') {
    return getAvailableMapStyles().map(styleId => {
        const selected = styleId === selectedStyle ? 'selected' : '';
        return `<option value="${styleId}" ${selected}>${getMapStyleDisplayName(styleId)}</option>`;
    }).join('\n');
}

/**
 * Check if an item is allowed to drop in the current maze based on item pool settings
 * When itemPool is disabled or empty, all items can drop (backwards compatible)
 * STScript /mazeitem commands bypass this check - they always work
 * @param {string} itemId - The item ID to check
 * @param {object} [profile] - Optional maze profile (uses currentMaze.profile if not provided)
 * @returns {boolean} True if item can drop, false if restricted by pool
 */
function isItemInPool(itemId, profile = null) {
    const p = profile || currentMaze?.profile;
    // If no profile or pool not enabled, allow all items
    if (!p?.itemPool?.enabled) return true;
    // If pool is enabled but empty, allow all items (edge case)
    if (!p.itemPool.items?.length) return true;
    // Check if item is in the allowed list
    return p.itemPool.items.includes(itemId);
}

/**
 * Get themed display name for an item
 * @param {string} itemId - The item ID
 * @param {string} theme - The current theme (fantasy, horror, etc.)
 * @returns {string} The themed name or default name
 */
function getItemDisplayName(itemId, theme) {
    const profile = getItemProfile(itemId);
    if (!profile) return itemId;

    // Check profile aliases first
    if (profile.aliases && profile.aliases[theme]) {
        return profile.aliases[theme];
    }

    // Fall back to SCENARIO_THEMES if exists
    const scenarioTheme = SCENARIO_THEMES[theme];
    if (scenarioTheme?.itemAliases?.[itemId]) {
        return scenarioTheme.itemAliases[itemId];
    }

    return profile.name || itemId;
}

/**
 * Save a custom item profile
 * @param {string} itemId - The item ID
 * @param {object} data - The profile data
 */
function saveItemProfile(itemId, data) {
    if (!extensionSettings.itemProfiles) extensionSettings.itemProfiles = {};
    extensionSettings.itemProfiles[itemId] = data;
    saveSettingsDebounced();
}

/**
 * Delete a custom item profile (reverts to default)
 * @param {string} itemId - The item ID to delete
 */
function deleteItemProfile(itemId) {
    if (extensionSettings.itemProfiles?.[itemId]) {
        delete extensionSettings.itemProfiles[itemId];
        saveSettingsDebounced();
    }
}

// =============================================================================
// ITEM CHARGE TRACKING (v1.7.0)
// =============================================================================

/**
 * Initialize charge tracking for an item when added to inventory
 * Called when equipment with charges is added
 * @param {string} itemId - The item ID
 */
function initializeItemCharges(itemId) {
    if (!currentMaze.itemCharges) currentMaze.itemCharges = {};

    const profile = getItemProfile(itemId);
    if (!profile || !profile.charges) return;

    // Initialize charges array if not exists
    if (!currentMaze.itemCharges[itemId]) {
        currentMaze.itemCharges[itemId] = [];
    }

    // Add a new item with full charges
    currentMaze.itemCharges[itemId].push(profile.charges);
}

/**
 * Get current charges for the first item in stack
 * @param {string} itemId - The item ID
 * @returns {number} Current charges (0 if no charges or item not found)
 */
function getItemCharges(itemId) {
    if (!currentMaze.itemCharges?.[itemId]?.length) return 0;
    return currentMaze.itemCharges[itemId][0] || 0;
}

/**
 * Get total charges across all items in stack
 * @param {string} itemId - The item ID
 * @returns {number} Total charges across all items
 */
function getTotalItemCharges(itemId) {
    if (!currentMaze.itemCharges?.[itemId]?.length) return 0;
    return currentMaze.itemCharges[itemId].reduce((sum, c) => sum + c, 0);
}

/**
 * Consume one charge from an item
 * If charges reach 0, removes that item from the charge array
 * @param {string} itemId - The item ID
 * @returns {number} Remaining charges on first item (0 if depleted)
 */
function consumeItemCharge(itemId) {
    if (!currentMaze.itemCharges?.[itemId]?.length) return 0;

    // Decrement first item's charges
    currentMaze.itemCharges[itemId][0]--;

    const remaining = currentMaze.itemCharges[itemId][0];

    // If depleted, remove from charge array
    if (remaining <= 0) {
        currentMaze.itemCharges[itemId].shift();
    }

    return remaining;
}

/**
 * Remove charge tracking for an item (when removed from inventory)
 * @param {string} itemId - The item ID
 */
function removeItemCharges(itemId) {
    if (currentMaze.itemCharges?.[itemId]?.length) {
        currentMaze.itemCharges[itemId].shift();
        if (currentMaze.itemCharges[itemId].length === 0) {
            delete currentMaze.itemCharges[itemId];
        }
    }
}

/**
 * Check if an item has charges that can absorb damage
 * @param {string} itemId - The item ID
 * @param {string} source - The damage source (trap, battlebar, etc.)
 * @returns {boolean} True if item can absorb this damage type
 */
function canItemAbsorbDamage(itemId, source) {
    const profile = getItemProfile(itemId);
    if (!profile || profile.type !== 'equipment') return false;
    if (!profile.autoUse) return false;
    if (getItemCharges(itemId) <= 0) return false;

    const triggers = profile.triggers || [];
    const combatSources = ['battlebar', 'turnbased', 'qte', 'dice', 'stealth', 'negotiation', 'puzzle'];
    const isCombat = combatSources.includes(source);

    return (source === 'trap' && triggers.includes('trap')) ||
           (isCombat && triggers.includes('combat'));
}

/**
 * Faction reputation profiles for faction system
 * Controls faction relationships, tiers, and reputation mechanics
 */
const DEFAULT_FACTION_PROFILES = {
    // v1.6.0: Renamed 'default' to 'fantasy' and added theme-specific faction profiles
    fantasy: {
        name: 'Fantasy',
        description: 'Classic fantasy factions for dungeon crawling adventures',
        factions: [
            {
                id: 'merchants_guild',
                name: "Merchants' Guild",
                description: 'Traders and shopkeepers who value fair deals',
                color: '#f39c12',
                icon: 'fa-coins',
                initialStanding: 0,
            },
            {
                id: 'thieves_guild',
                name: "Thieves' Guild",
                description: 'Masters of stealth and subterfuge',
                color: '#9b59b6',
                icon: 'fa-mask',
                initialStanding: -10,
            },
            {
                id: 'royal_guard',
                name: 'Royal Guard',
                description: 'Protectors of the realm and enforcers of law',
                color: '#3498db',
                icon: 'fa-shield-halved',
                initialStanding: 0,
            },
            {
                id: 'mages_circle',
                name: "Mages' Circle",
                description: 'Practitioners of the arcane arts',
                color: '#8e44ad',
                icon: 'fa-wand-sparkles',
                initialStanding: 0,
            },
        ],
        tiers: {
            hostile: { min: -100, max: -50, behavior: 'attack', label: 'Hostile' },
            unfriendly: { min: -49, max: -10, behavior: 'refuse', label: 'Unfriendly' },
            neutral: { min: -9, max: 9, behavior: 'wary', label: 'Neutral' },
            friendly: { min: 10, max: 49, behavior: 'help', label: 'Friendly' },
            allied: { min: 50, max: 100, behavior: 'loyal', label: 'Allied' },
        },
        relationships: {
            'thieves_guild': { 'royal_guard': -0.5 },
            'royal_guard': { 'thieves_guild': -0.5 },
            'merchants_guild': { 'thieves_guild': -0.3 },
        },
        spilloverMultiplier: 0.25,
        // STScript hooks
        onReputationChange: '',
        onFactionHostile: '',
        onFactionFriendly: '',
        onTierChange: '',
    },
    scifi: {
        name: 'Sci-Fi',
        description: 'Futuristic faction configuration for sci-fi settings',
        factions: [
            {
                id: 'corporation',
                name: 'The Corporation',
                description: 'Megacorp controlling trade and resources',
                color: '#2ecc71',
                icon: 'fa-building',
                initialStanding: 0,
            },
            {
                id: 'rebels',
                name: 'Resistance',
                description: 'Freedom fighters opposing corporate control',
                color: '#e74c3c',
                icon: 'fa-fist-raised',
                initialStanding: 0,
            },
            {
                id: 'scientists',
                name: 'Science Division',
                description: 'Researchers and technologists',
                color: '#3498db',
                icon: 'fa-flask',
                initialStanding: 10,
            },
            {
                id: 'syndicate',
                name: 'Criminal Syndicate',
                description: 'Organized crime operating in the shadows',
                color: '#34495e',
                icon: 'fa-skull',
                initialStanding: -20,
            },
        ],
        tiers: {
            hostile: { min: -100, max: -50, behavior: 'attack', label: 'Enemy' },
            unfriendly: { min: -49, max: -10, behavior: 'refuse', label: 'Distrusted' },
            neutral: { min: -9, max: 9, behavior: 'wary', label: 'Unknown' },
            friendly: { min: 10, max: 49, behavior: 'help', label: 'Trusted' },
            allied: { min: 50, max: 100, behavior: 'loyal', label: 'Ally' },
        },
        relationships: {
            'corporation': { 'rebels': -0.8 },
            'rebels': { 'corporation': -0.8 },
            'syndicate': { 'corporation': -0.3 },
        },
        spilloverMultiplier: 0.3,
        onReputationChange: '',
        onFactionHostile: '',
        onFactionFriendly: '',
        onTierChange: '',
    },
    horror: {
        name: 'Horror',
        description: 'Dark factions for horror and supernatural settings',
        factions: [
            {
                id: 'cult_of_shadows',
                name: 'Cult of Shadows',
                description: 'Dark worshippers seeking forbidden power',
                color: '#2c3e50',
                icon: 'fa-moon',
                initialStanding: -20,
            },
            {
                id: 'hunters_order',
                name: "Hunters' Order",
                description: 'Monster hunters protecting the innocent',
                color: '#c0392b',
                icon: 'fa-crosshairs',
                initialStanding: 10,
            },
            {
                id: 'restless_dead',
                name: 'The Restless Dead',
                description: 'Spirits and undead with their own agenda',
                color: '#7f8c8d',
                icon: 'fa-ghost',
                initialStanding: -30,
            },
            {
                id: 'asylum_staff',
                name: 'Asylum Staff',
                description: 'Wardens and doctors of the institution',
                color: '#1abc9c',
                icon: 'fa-user-doctor',
                initialStanding: 0,
            },
        ],
        tiers: {
            hostile: { min: -100, max: -50, behavior: 'attack', label: 'Hunted' },
            unfriendly: { min: -49, max: -10, behavior: 'refuse', label: 'Suspicious' },
            neutral: { min: -9, max: 9, behavior: 'wary', label: 'Watched' },
            friendly: { min: 10, max: 49, behavior: 'help', label: 'Accepted' },
            allied: { min: 50, max: 100, behavior: 'loyal', label: 'Trusted' },
        },
        relationships: {
            'cult_of_shadows': { 'hunters_order': -1.0, 'restless_dead': 0.3 },
            'hunters_order': { 'cult_of_shadows': -1.0, 'restless_dead': -0.5 },
            'restless_dead': { 'hunters_order': -0.5 },
        },
        spilloverMultiplier: 0.3,
        onReputationChange: '',
        onFactionHostile: '',
        onFactionFriendly: '',
        onTierChange: '',
    },
    cyberpunk: {
        name: 'Cyberpunk',
        description: 'Neon-lit factions for cyberpunk dystopias',
        factions: [
            {
                id: 'megacorp',
                name: 'Arasaka Corp',
                description: 'Megacorporation controlling the city',
                color: '#e74c3c',
                icon: 'fa-building',
                initialStanding: 0,
            },
            {
                id: 'street_gang',
                name: 'Maelstrom Gang',
                description: 'Cyberpsycho gang ruling the streets',
                color: '#9b59b6',
                icon: 'fa-skull-crossbones',
                initialStanding: -10,
            },
            {
                id: 'netrunners',
                name: 'Netrunner Collective',
                description: 'Hackers and data thieves',
                color: '#00ff88',
                icon: 'fa-microchip',
                initialStanding: 0,
            },
            {
                id: 'nomads',
                name: 'Nomad Clans',
                description: 'Road warriors living outside the city',
                color: '#f39c12',
                icon: 'fa-car-side',
                initialStanding: 10,
            },
        ],
        tiers: {
            hostile: { min: -100, max: -50, behavior: 'attack', label: 'Kill on Sight' },
            unfriendly: { min: -49, max: -10, behavior: 'refuse', label: 'Blacklisted' },
            neutral: { min: -9, max: 9, behavior: 'wary', label: 'Unknown' },
            friendly: { min: 10, max: 49, behavior: 'help', label: 'Connected' },
            allied: { min: 50, max: 100, behavior: 'loyal', label: 'Family' },
        },
        relationships: {
            'megacorp': { 'street_gang': -0.5, 'netrunners': -0.3, 'nomads': -0.2 },
            'street_gang': { 'megacorp': -0.5 },
            'netrunners': { 'megacorp': -0.3 },
        },
        spilloverMultiplier: 0.25,
        onReputationChange: '',
        onFactionHostile: '',
        onFactionFriendly: '',
        onTierChange: '',
    },
    western: {
        name: 'Western',
        description: 'Frontier factions for Wild West adventures',
        factions: [
            {
                id: 'lawmen',
                name: 'Town Marshal',
                description: 'Law and order in the frontier',
                color: '#f1c40f',
                icon: 'fa-star',
                initialStanding: 0,
            },
            {
                id: 'outlaws',
                name: 'Outlaw Gang',
                description: 'Bandits and desperados',
                color: '#c0392b',
                icon: 'fa-hat-cowboy',
                initialStanding: -10,
            },
            {
                id: 'natives',
                name: 'Native Tribes',
                description: 'Indigenous peoples of the land',
                color: '#27ae60',
                icon: 'fa-feather',
                initialStanding: 0,
            },
            {
                id: 'railroad',
                name: 'Railroad Company',
                description: 'Industrial barons expanding westward',
                color: '#34495e',
                icon: 'fa-train',
                initialStanding: 0,
            },
        ],
        tiers: {
            hostile: { min: -100, max: -50, behavior: 'attack', label: 'Wanted' },
            unfriendly: { min: -49, max: -10, behavior: 'refuse', label: 'Distrusted' },
            neutral: { min: -9, max: 9, behavior: 'wary', label: 'Stranger' },
            friendly: { min: 10, max: 49, behavior: 'help', label: 'Partner' },
            allied: { min: 50, max: 100, behavior: 'loyal', label: 'Blood Brother' },
        },
        relationships: {
            'lawmen': { 'outlaws': -0.8 },
            'outlaws': { 'lawmen': -0.8, 'railroad': -0.3 },
            'natives': { 'railroad': -0.5 },
            'railroad': { 'natives': -0.5 },
        },
        spilloverMultiplier: 0.3,
        onReputationChange: '',
        onFactionHostile: '',
        onFactionFriendly: '',
        onTierChange: '',
    },
    action: {
        name: 'Action',
        description: 'Military factions for action and espionage settings',
        factions: [
            {
                id: 'allied_command',
                name: 'Allied Command',
                description: 'Your commanding officers and support',
                color: '#3498db',
                icon: 'fa-flag',
                initialStanding: 25,
            },
            {
                id: 'insurgents',
                name: 'Insurgent Forces',
                description: 'Enemy combatants and terrorists',
                color: '#e74c3c',
                icon: 'fa-bomb',
                initialStanding: -50,
            },
            {
                id: 'mercs',
                name: 'PMC Operators',
                description: 'Private military contractors for hire',
                color: '#f39c12',
                icon: 'fa-dollar-sign',
                initialStanding: 0,
            },
            {
                id: 'civilians',
                name: 'Local Population',
                description: 'Non-combatants caught in the crossfire',
                color: '#2ecc71',
                icon: 'fa-users',
                initialStanding: 0,
            },
        ],
        tiers: {
            hostile: { min: -100, max: -50, behavior: 'attack', label: 'Enemy' },
            unfriendly: { min: -49, max: -10, behavior: 'refuse', label: 'Suspicious' },
            neutral: { min: -9, max: 9, behavior: 'wary', label: 'Unknown' },
            friendly: { min: 10, max: 49, behavior: 'help', label: 'Cooperative' },
            allied: { min: 50, max: 100, behavior: 'loyal', label: 'Comrade' },
        },
        relationships: {
            'allied_command': { 'insurgents': -1.0, 'mercs': -0.2 },
            'insurgents': { 'allied_command': -1.0, 'civilians': -0.3 },
            'civilians': { 'insurgents': -0.3, 'mercs': -0.2 },
        },
        spilloverMultiplier: 0.25,
        onReputationChange: '',
        onFactionHostile: '',
        onFactionFriendly: '',
        onTierChange: '',
    },
    none: {
        name: 'None',
        description: 'No faction system - disabled',
        factions: [],
        tiers: {},
        relationships: {},
        spilloverMultiplier: 0,
        onReputationChange: '',
        onFactionHostile: '',
        onFactionFriendly: '',
        onTierChange: '',
    },
};

// =============================================================================
// EQUIPMENT SYSTEM (v1.5.0)
// =============================================================================

/**
 * Equipment item database
 * Each item has: id, name, slot, rarity, attack, defense, critBonus, special, icon, description
 */
const DEFAULT_EQUIPMENT = {
    // ===== WEAPONS =====
    'weapon_rusty_sword': {
        id: 'weapon_rusty_sword',
        name: 'Rusty Sword',
        slot: 'weapon',
        rarity: 'common',
        attack: 2,
        defense: 0,
        critBonus: 0,
        special: null,
        icon: 'fa-sword',
        description: 'A worn blade, better than nothing.',
        durability: 10,
        maxDurability: 10,
    },
    'weapon_iron_sword': {
        id: 'weapon_iron_sword',
        name: 'Iron Sword',
        slot: 'weapon',
        rarity: 'common',
        attack: 5,
        defense: 0,
        critBonus: 0,
        special: null,
        icon: 'fa-sword',
        description: 'A reliable blade forged from iron.',
        durability: 15,
        maxDurability: 15,
    },
    'weapon_steel_blade': {
        id: 'weapon_steel_blade',
        name: 'Steel Blade',
        slot: 'weapon',
        rarity: 'uncommon',
        attack: 8,
        defense: 0,
        critBonus: 2,
        special: null,
        icon: 'fa-sword',
        description: 'Sharp and well-balanced for precise strikes.',
        durability: 20,
        maxDurability: 20,
    },
    'weapon_enchanted_blade': {
        id: 'weapon_enchanted_blade',
        name: 'Enchanted Blade',
        slot: 'weapon',
        rarity: 'rare',
        attack: 12,
        defense: 0,
        critBonus: 5,
        special: { type: 'fire', value: 3 },
        icon: 'fa-sword',
        description: 'Wreathed in magical flames that sear foes.',
        durability: 25,
        maxDurability: 25,
    },
    'weapon_shadow_dagger': {
        id: 'weapon_shadow_dagger',
        name: 'Shadow Dagger',
        slot: 'weapon',
        rarity: 'rare',
        attack: 7,
        defense: 0,
        critBonus: 10,
        special: { type: 'backstab', value: 25 },
        icon: 'fa-khanda',
        description: 'A dark blade that strikes from the shadows.',
        durability: 18,
        maxDurability: 18,
    },

    // ===== ARMOR =====
    'armor_leather': {
        id: 'armor_leather',
        name: 'Leather Armor',
        slot: 'armor',
        rarity: 'common',
        attack: 0,
        defense: 3,
        critBonus: 0,
        special: null,
        icon: 'fa-vest',
        description: 'Basic protection that allows freedom of movement.',
        durability: 12,
        maxDurability: 12,
    },
    'armor_chainmail': {
        id: 'armor_chainmail',
        name: 'Chainmail',
        slot: 'armor',
        rarity: 'uncommon',
        attack: 0,
        defense: 6,
        critBonus: 0,
        special: null,
        icon: 'fa-shield',
        description: 'Interlocking steel rings provide solid defense.',
        durability: 18,
        maxDurability: 18,
    },
    'armor_plate': {
        id: 'armor_plate',
        name: 'Plate Armor',
        slot: 'armor',
        rarity: 'rare',
        attack: 0,
        defense: 10,
        critBonus: 0,
        special: null,
        icon: 'fa-shield-halved',
        description: 'Heavy but extremely protective steel plates.',
        durability: 25,
        maxDurability: 25,
    },

    // ===== ACCESSORIES =====
    'accessory_ring_power': {
        id: 'accessory_ring_power',
        name: 'Ring of Power',
        slot: 'accessory',
        rarity: 'uncommon',
        attack: 3,
        defense: 0,
        critBonus: 0,
        special: null,
        icon: 'fa-ring',
        description: 'Channels raw energy into your strikes.',
        durability: 20,
        maxDurability: 20,
    },
    'accessory_amulet_protection': {
        id: 'accessory_amulet_protection',
        name: 'Amulet of Protection',
        slot: 'accessory',
        rarity: 'uncommon',
        attack: 0,
        defense: 3,
        critBonus: 0,
        special: null,
        icon: 'fa-gem',
        description: 'Wards off incoming harm with ancient magic.',
        durability: 20,
        maxDurability: 20,
    },
    'accessory_lucky_charm': {
        id: 'accessory_lucky_charm',
        name: 'Lucky Charm',
        slot: 'accessory',
        rarity: 'rare',
        attack: 2,
        defense: 2,
        critBonus: 5,
        special: null,
        icon: 'fa-clover',
        description: 'Fortune favors those who carry this talisman.',
        durability: 25,
        maxDurability: 25,
    },
    'accessory_vampiric_pendant': {
        id: 'accessory_vampiric_pendant',
        name: 'Vampiric Pendant',
        slot: 'accessory',
        rarity: 'epic',
        attack: 0,
        defense: 0,
        critBonus: 0,
        special: { type: 'lifesteal', value: 10 },
        icon: 'fa-droplet',
        description: 'Drains life from enemies to heal the wearer.',
        durability: 30,
        maxDurability: 30,
    },

    // ===== CONSUMABLE ARMOR =====
    'ironGuard': {
        id: 'ironGuard',
        name: 'Iron Guard',
        slot: 'armor',
        rarity: 'uncommon',
        attack: 0,
        defense: 5,
        critBonus: 0,
        special: { type: 'absorb', value: 3, charges: 3 },
        icon: 'fa-shield-halved',
        description: 'Absorbs 3 hits from combat or traps before breaking.',
        durability: 3,
        maxDurability: 3,
    },
};

/**
 * Equipment drop tables by rarity weight
 */
const EQUIPMENT_RARITY_WEIGHTS = {
    common: 60,
    uncommon: 30,
    rare: 8,
    epic: 2,
};

/**
 * Get all equipment items matching a rarity
 */
function getEquipmentByRarity(rarity) {
    return Object.values(DEFAULT_EQUIPMENT).filter(e => e.rarity === rarity);
}

/**
 * Roll for random equipment based on rarity weights
 * @param {number} luckModifier - Bonus to rare/epic chances (0-100)
 * @returns {object|null} Equipment item or null
 */
function rollEquipmentDrop(luckModifier = 0) {
    // Adjust weights based on luck
    const weights = { ...EQUIPMENT_RARITY_WEIGHTS };
    weights.rare += Math.floor(luckModifier / 10);
    weights.epic += Math.floor(luckModifier / 25);
    weights.common = Math.max(20, weights.common - luckModifier);

    const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
    let roll = Math.random() * totalWeight;

    for (const [rarity, weight] of Object.entries(weights)) {
        roll -= weight;
        if (roll <= 0) {
            const items = getEquipmentByRarity(rarity);
            if (items.length > 0) {
                return items[Math.floor(Math.random() * items.length)];
            }
        }
    }
    return null;
}

// =============================================================================
// SKILLS DATABASE (v1.5.0)
// =============================================================================

/**
 * Skill tree definitions
 * Each skill has: id, name, tree, tier, type, description, effects per rank, cooldown, prerequisites
 */
const SKILL_TREES = {
    combat: {
        name: 'Combat',
        color: '#e74c3c',
        icon: 'fa-sword',
        description: 'Master the art of physical warfare',
    },
    magic: {
        name: 'Magic',
        color: '#3498db',
        icon: 'fa-wand-sparkles',
        description: 'Harness arcane energies',
    },
    stealth: {
        name: 'Stealth',
        color: '#9b59b6',
        icon: 'fa-user-ninja',
        description: 'Strike from the shadows',
    },
};

/**
 * All available skills
 * type: 'active' (usable in combat) or 'passive' (always active)
 * ranks: array of effect values per rank (1-3)
 */
const DEFAULT_SKILLS = {
    // === COMBAT TREE ===
    'combat_power_strike': {
        id: 'combat_power_strike',
        name: 'Power Strike',
        tree: 'combat',
        tier: 1,
        type: 'active',
        description: 'A devastating blow dealing increased damage',
        cooldown: 3,
        ranks: [
            { damageMultiplier: 1.5, description: '150% damage' },
            { damageMultiplier: 1.75, description: '175% damage' },
            { damageMultiplier: 2.0, description: '200% damage' },
        ],
        prerequisites: [],
    },
    'combat_critical_eye': {
        id: 'combat_critical_eye',
        name: 'Critical Eye',
        tree: 'combat',
        tier: 1,
        type: 'passive',
        description: 'Increased critical hit chance',
        cooldown: 0,
        ranks: [
            { critBonus: 5, description: '+5% crit chance' },
            { critBonus: 10, description: '+10% crit chance' },
            { critBonus: 15, description: '+15% crit chance' },
        ],
        prerequisites: [],
    },
    'combat_lifesteal': {
        id: 'combat_lifesteal',
        name: 'Lifesteal',
        tree: 'combat',
        tier: 2,
        type: 'passive',
        description: 'Heal for a portion of damage dealt',
        cooldown: 0,
        ranks: [
            { lifestealPercent: 5, description: 'Heal 5% of damage' },
            { lifestealPercent: 8, description: 'Heal 8% of damage' },
            { lifestealPercent: 10, description: 'Heal 10% of damage' },
        ],
        prerequisites: ['combat_power_strike'],
    },
    'combat_berserker': {
        id: 'combat_berserker',
        name: 'Berserker Rage',
        tree: 'combat',
        tier: 3,
        type: 'active',
        description: 'Enter a fury, greatly increasing damage',
        cooldown: 5,
        duration: 3,
        ranks: [
            { damageBonus: 30, description: '+30% damage for 3 turns' },
            { damageBonus: 40, description: '+40% damage for 3 turns' },
            { damageBonus: 50, description: '+50% damage for 3 turns' },
        ],
        prerequisites: ['combat_lifesteal'],
    },
    'combat_execute': {
        id: 'combat_execute',
        name: 'Execute',
        tree: 'combat',
        tier: 4,
        type: 'active',
        description: 'Instantly kill low HP enemies',
        cooldown: 8,
        ranks: [
            { executeThreshold: 15, description: 'Kill enemies below 15% HP' },
            { executeThreshold: 20, description: 'Kill enemies below 20% HP' },
            { executeThreshold: 25, description: 'Kill enemies below 25% HP' },
        ],
        prerequisites: ['combat_berserker'],
    },

    // === MAGIC TREE ===
    'magic_fireball': {
        id: 'magic_fireball',
        name: 'Fireball',
        tree: 'magic',
        tier: 1,
        type: 'active',
        description: 'Hurl a ball of fire at the enemy',
        cooldown: 2,
        ranks: [
            { damage: 20, burnChance: 20, description: '20 fire damage, 20% burn' },
            { damage: 30, burnChance: 30, description: '30 fire damage, 30% burn' },
            { damage: 40, burnChance: 40, description: '40 fire damage, 40% burn' },
        ],
        prerequisites: [],
    },
    'magic_ice_shield': {
        id: 'magic_ice_shield',
        name: 'Ice Shield',
        tree: 'magic',
        tier: 1,
        type: 'active',
        description: 'Create a shield of ice that blocks damage',
        cooldown: 4,
        duration: 2,
        ranks: [
            { damageReduction: 30, freezeChance: 15, description: '-30% damage taken, 15% freeze' },
            { damageReduction: 40, freezeChance: 20, description: '-40% damage taken, 20% freeze' },
            { damageReduction: 50, freezeChance: 25, description: '-50% damage taken, 25% freeze' },
        ],
        prerequisites: [],
    },
    'magic_teleport': {
        id: 'magic_teleport',
        name: 'Teleport',
        tree: 'magic',
        tier: 2,
        type: 'active',
        description: 'Teleport to any revealed tile on the map',
        cooldown: 10,
        usableOutsideCombat: true,
        ranks: [
            { range: 5, description: 'Teleport up to 5 tiles' },
            { range: 8, description: 'Teleport up to 8 tiles' },
            { range: -1, description: 'Teleport anywhere revealed' },
        ],
        prerequisites: ['magic_fireball', 'magic_ice_shield'],
    },
    'magic_mana_surge': {
        id: 'magic_mana_surge',
        name: 'Mana Surge',
        tree: 'magic',
        tier: 3,
        type: 'passive',
        description: 'Reduce cooldowns on all abilities',
        cooldown: 0,
        ranks: [
            { cooldownReduction: 1, description: '-1 turn on all cooldowns' },
            { cooldownReduction: 1, tickOnTurnEnd: true, description: '-1 cooldown + tick on turn end' },
            { cooldownReduction: 2, description: '-2 turns on all cooldowns' },
        ],
        prerequisites: ['magic_teleport'],
    },
    'magic_arcane_blast': {
        id: 'magic_arcane_blast',
        name: 'Arcane Blast',
        tree: 'magic',
        tier: 4,
        type: 'active',
        description: 'Unleash devastating arcane energy',
        cooldown: 6,
        ranks: [
            { damage: 50, ignoreDefense: 25, description: '50 damage, ignores 25% defense' },
            { damage: 65, ignoreDefense: 40, description: '65 damage, ignores 40% defense' },
            { damage: 80, ignoreDefense: 50, description: '80 damage, ignores 50% defense' },
        ],
        prerequisites: ['magic_mana_surge'],
    },

    // === STEALTH TREE ===
    'stealth_shadowstep': {
        id: 'stealth_shadowstep',
        name: 'Shadowstep',
        tree: 'stealth',
        tier: 1,
        type: 'active',
        description: 'Phase through a single wall',
        cooldown: 3,
        usableOutsideCombat: true,
        ranks: [
            { wallsPassable: 1, description: 'Pass through 1 wall' },
            { wallsPassable: 1, noDetection: true, description: 'Pass through 1 wall undetected' },
            { wallsPassable: 2, noDetection: true, description: 'Pass through 2 walls undetected' },
        ],
        prerequisites: [],
    },
    'stealth_backstab': {
        id: 'stealth_backstab',
        name: 'Backstab',
        tree: 'stealth',
        tier: 1,
        type: 'passive',
        description: 'Deal bonus damage on first strike',
        cooldown: 0,
        ranks: [
            { firstStrikeBonus: 25, description: '+25% first strike damage' },
            { firstStrikeBonus: 50, description: '+50% first strike damage' },
            { firstStrikeBonus: 75, description: '+75% first strike damage' },
        ],
        prerequisites: [],
    },
    'stealth_smoke_bomb': {
        id: 'stealth_smoke_bomb',
        name: 'Smoke Bomb',
        tree: 'stealth',
        tier: 2,
        type: 'active',
        description: 'Escape from combat instantly',
        cooldown: 5,
        ranks: [
            { escapeChance: 100, description: 'Guaranteed escape' },
            { escapeChance: 100, confuseTurns: 1, description: 'Escape + confuse enemy 1 turn' },
            { escapeChance: 100, confuseTurns: 2, description: 'Escape + confuse enemy 2 turns' },
        ],
        prerequisites: ['stealth_backstab'],
    },
    'stealth_assassinate': {
        id: 'stealth_assassinate',
        name: 'Assassinate',
        tree: 'stealth',
        tier: 3,
        type: 'active',
        description: 'Chance to instantly kill on first strike',
        cooldown: 0, // Only works on combat start
        ranks: [
            { instantKillChance: 15, description: '15% instant kill on first strike' },
            { instantKillChance: 25, description: '25% instant kill on first strike' },
            { instantKillChance: 35, description: '35% instant kill on first strike' },
        ],
        prerequisites: ['stealth_smoke_bomb'],
    },
    'stealth_vanish': {
        id: 'stealth_vanish',
        name: 'Vanish',
        tree: 'stealth',
        tier: 4,
        type: 'active',
        description: 'Become invisible, guaranteeing critical hits',
        cooldown: 8,
        usableOutsideCombat: true,
        ranks: [
            { invisibleMoves: 3, guaranteedCrit: true, description: 'Invisible 3 moves, guaranteed crits' },
            { invisibleMoves: 4, guaranteedCrit: true, avoidEncounters: true, description: 'Invisible 4 moves, avoid encounters' },
            { invisibleMoves: 5, guaranteedCrit: true, avoidEncounters: true, description: 'Invisible 5 moves, full stealth' },
        ],
        prerequisites: ['stealth_assassinate'],
    },
};

/**
 * Get skill definition by ID
 */
function getSkill(skillId) {
    return DEFAULT_SKILLS[skillId] || null;
}

/**
 * Get all skills in a specific tree
 */
function getSkillsByTree(treeName) {
    return Object.values(DEFAULT_SKILLS).filter(skill => skill.tree === treeName);
}

/**
 * Get skill effect for a specific rank
 */
function getSkillEffect(skillId, rank = 1) {
    const skill = getSkill(skillId);
    if (!skill || rank < 1 || rank > skill.ranks.length) return null;
    return { ...skill.ranks[rank - 1], skillId, rank };
}

// =============================================================================
// STATUS EFFECTS DATABASE (v1.5.0)
// =============================================================================

/**
 * Status effect definitions
 * Each effect has: id, name, type (dot/cc/buff/debuff), duration, icon, color
 */
const STATUS_EFFECTS = {
    burning: {
        id: 'burning',
        name: 'Burning',
        type: 'dot',
        duration: 3,
        dotPercent: 5,       // 5% max HP per turn
        icon: 'fa-fire',
        color: '#e74c3c',
        description: 'Taking fire damage each turn',
        applyMessage: 'is burning!',
        tickMessage: 'takes burn damage',
        expireMessage: 'is no longer burning',
    },
    poisoned: {
        id: 'poisoned',
        name: 'Poisoned',
        type: 'dot',
        duration: 4,
        dotPercent: 3,       // 3% max HP per turn
        icon: 'fa-skull-crossbones',
        color: '#27ae60',
        description: 'Taking poison damage each turn',
        applyMessage: 'is poisoned!',
        tickMessage: 'takes poison damage',
        expireMessage: 'is no longer poisoned',
    },
    frozen: {
        id: 'frozen',
        name: 'Frozen',
        type: 'cc',
        duration: 1,
        skipTurn: true,
        icon: 'fa-snowflake',
        color: '#3498db',
        description: 'Cannot act this turn',
        applyMessage: 'is frozen solid!',
        tickMessage: 'is frozen and cannot act',
        expireMessage: 'thaws out',
    },
    stunned: {
        id: 'stunned',
        name: 'Stunned',
        type: 'cc',
        duration: 1,
        skipTurn: true,
        icon: 'fa-star',
        color: '#f1c40f',
        description: 'Cannot act this turn',
        applyMessage: 'is stunned!',
        tickMessage: 'is stunned and cannot act',
        expireMessage: 'recovers from stun',
    },
    bleeding: {
        id: 'bleeding',
        name: 'Bleeding',
        type: 'dot',
        duration: 3,
        dotPercent: 4,       // 4% max HP per turn
        icon: 'fa-droplet',
        color: '#c0392b',
        description: 'Losing blood each turn',
        applyMessage: 'is bleeding!',
        tickMessage: 'bleeds',
        expireMessage: 'stops bleeding',
    },
    weakened: {
        id: 'weakened',
        name: 'Weakened',
        type: 'debuff',
        duration: 2,
        damageReduction: 25,  // Deal 25% less damage
        icon: 'fa-down-long',
        color: '#7f8c8d',
        description: 'Dealing reduced damage',
        applyMessage: 'is weakened!',
        tickMessage: '',
        expireMessage: 'is no longer weakened',
    },
    enraged: {
        id: 'enraged',
        name: 'Enraged',
        type: 'buff',
        duration: 2,
        damageBonus: 25,      // Deal 25% more damage
        icon: 'fa-up-long',
        color: '#e74c3c',
        description: 'Dealing increased damage',
        applyMessage: 'is enraged!',
        tickMessage: '',
        expireMessage: 'calms down',
    },
    shielded: {
        id: 'shielded',
        name: 'Shielded',
        type: 'buff',
        duration: 2,
        damageReduction: 30,  // Take 30% less damage
        icon: 'fa-shield-halved',
        color: '#3498db',
        description: 'Taking reduced damage',
        applyMessage: 'is shielded!',
        tickMessage: '',
        expireMessage: 'shield fades',
    },
};

/**
 * Get status effect definition
 */
function getStatusEffect(effectId) {
    return STATUS_EFFECTS[effectId] || null;
}

// =============================================================================
// ENEMY ABILITIES DATABASE (v1.5.0)
// =============================================================================

/**
 * Enemy type definitions with their available abilities
 * Each enemy type has base stats and a pool of abilities
 */
const ENEMY_TYPES = {
    warrior: {
        id: 'warrior',
        name: 'Warrior',
        baseAttack: 12,
        baseDefense: 8,
        abilities: [
            {
                id: 'heavy_strike',
                name: 'Heavy Strike',
                weight: 40,
                damageMultiplier: 1.5,
                description: 'A powerful blow',
                message: 'swings a heavy strike!',
            },
            {
                id: 'shield_bash',
                name: 'Shield Bash',
                weight: 25,
                damageMultiplier: 0.8,
                statusEffect: 'stunned',
                statusChance: 50,
                description: 'Bash that may stun',
                message: 'bashes with their shield!',
            },
            {
                id: 'battle_cry',
                name: 'Battle Cry',
                weight: 15,
                selfBuff: 'enraged',
                damageMultiplier: 0.5,
                description: 'Buff that increases damage',
                message: 'lets out a battle cry!',
            },
            {
                id: 'basic_attack',
                name: 'Attack',
                weight: 20,
                damageMultiplier: 1.0,
                description: 'Basic attack',
                message: 'attacks!',
            },
        ],
    },
    mage: {
        id: 'mage',
        name: 'Mage',
        baseAttack: 15,
        baseDefense: 4,
        abilities: [
            {
                id: 'fireball',
                name: 'Fireball',
                weight: 35,
                damageMultiplier: 1.2,
                statusEffect: 'burning',
                statusChance: 40,
                description: 'Fire magic that may burn',
                message: 'casts Fireball!',
            },
            {
                id: 'ice_shard',
                name: 'Ice Shard',
                weight: 30,
                damageMultiplier: 1.0,
                statusEffect: 'frozen',
                statusChance: 30,
                description: 'Ice magic that may freeze',
                message: 'hurls an Ice Shard!',
            },
            {
                id: 'arcane_bolt',
                name: 'Arcane Bolt',
                weight: 25,
                damageMultiplier: 1.3,
                description: 'Pure arcane damage',
                message: 'fires an Arcane Bolt!',
            },
            {
                id: 'magic_shield',
                name: 'Magic Shield',
                weight: 10,
                selfBuff: 'shielded',
                damageMultiplier: 0,
                description: 'Defensive buff',
                message: 'conjures a Magic Shield!',
            },
        ],
    },
    assassin: {
        id: 'assassin',
        name: 'Assassin',
        baseAttack: 14,
        baseDefense: 5,
        abilities: [
            {
                id: 'poison_blade',
                name: 'Poison Blade',
                weight: 35,
                damageMultiplier: 1.0,
                statusEffect: 'poisoned',
                statusChance: 60,
                description: 'Attack that may poison',
                message: 'strikes with a poisoned blade!',
            },
            {
                id: 'vanish_strike',
                name: 'Vanish Strike',
                weight: 25,
                damageMultiplier: 2.0,
                description: 'High damage from shadows',
                message: 'strikes from the shadows!',
            },
            {
                id: 'crippling_blow',
                name: 'Crippling Blow',
                weight: 20,
                damageMultiplier: 0.9,
                statusEffect: 'weakened',
                statusChance: 50,
                description: 'Attack that may weaken',
                message: 'delivers a crippling blow!',
            },
            {
                id: 'quick_slash',
                name: 'Quick Slash',
                weight: 20,
                damageMultiplier: 1.1,
                description: 'Fast attack',
                message: 'slashes quickly!',
            },
        ],
    },
    beast: {
        id: 'beast',
        name: 'Beast',
        baseAttack: 13,
        baseDefense: 6,
        abilities: [
            {
                id: 'savage_bite',
                name: 'Savage Bite',
                weight: 35,
                damageMultiplier: 1.3,
                statusEffect: 'bleeding',
                statusChance: 40,
                description: 'Bite that may cause bleeding',
                message: 'bites savagely!',
            },
            {
                id: 'pounce',
                name: 'Pounce',
                weight: 25,
                damageMultiplier: 1.5,
                description: 'Leaping attack',
                message: 'pounces!',
            },
            {
                id: 'feral_rage',
                name: 'Feral Rage',
                weight: 15,
                selfBuff: 'enraged',
                damageMultiplier: 0.5,
                description: 'Becomes enraged',
                message: 'enters a feral rage!',
            },
            {
                id: 'claw_swipe',
                name: 'Claw Swipe',
                weight: 25,
                damageMultiplier: 1.0,
                description: 'Basic claw attack',
                message: 'swipes with claws!',
            },
        ],
    },
    undead: {
        id: 'undead',
        name: 'Undead',
        baseAttack: 11,
        baseDefense: 7,
        abilities: [
            {
                id: 'life_drain',
                name: 'Life Drain',
                weight: 30,
                damageMultiplier: 1.0,
                lifesteal: 50,       // Heal 50% of damage dealt
                description: 'Drains life force',
                message: 'drains your life force!',
            },
            {
                id: 'cursed_touch',
                name: 'Cursed Touch',
                weight: 25,
                damageMultiplier: 0.8,
                statusEffect: 'weakened',
                statusChance: 60,
                description: 'Touch that weakens',
                message: 'touches with cursed hands!',
            },
            {
                id: 'bone_shards',
                name: 'Bone Shards',
                weight: 25,
                damageMultiplier: 1.2,
                description: 'Projectile bone attack',
                message: 'hurls bone shards!',
            },
            {
                id: 'unholy_strength',
                name: 'Unholy Strength',
                weight: 20,
                selfBuff: 'enraged',
                damageMultiplier: 0.3,
                description: 'Dark power buff',
                message: 'draws upon unholy strength!',
            },
        ],
    },
};

/**
 * Get enemy type definition
 */
function getEnemyType(typeId) {
    return ENEMY_TYPES[typeId] || ENEMY_TYPES.warrior;
}

/**
 * Select an ability for an enemy based on weighted random
 * @param {string} enemyTypeId - The enemy type
 * @returns {object} Selected ability
 */
function selectEnemyAbility(enemyTypeId) {
    const enemyType = getEnemyType(enemyTypeId);
    const abilities = enemyType.abilities;

    // Calculate total weight
    const totalWeight = abilities.reduce((sum, a) => sum + a.weight, 0);
    let roll = Math.random() * totalWeight;

    for (const ability of abilities) {
        roll -= ability.weight;
        if (roll <= 0) {
            return ability;
        }
    }

    // Fallback to basic attack
    return abilities[abilities.length - 1];
}

// =============================================================================
// QUEST SYSTEM DATABASE (v1.5.0)
// =============================================================================

/**
 * Quest type definitions
 * Types: fetch, defeat, explore, secret, survive, custom
 */
const QUEST_TYPES = {
    fetch: {
        id: 'fetch',
        name: 'Fetch Item',
        description: 'Collect a specific item or number of items',
        trackingField: 'itemsCollected',
        icon: 'fa-box',
    },
    defeat: {
        id: 'defeat',
        name: 'Defeat Enemies',
        description: 'Defeat a number of enemies in combat',
        trackingField: 'enemiesDefeated',
        icon: 'fa-skull',
    },
    explore: {
        id: 'explore',
        name: 'Explore Area',
        description: 'Explore a percentage of the maze',
        trackingField: 'explorationPercent',
        icon: 'fa-map',
    },
    secret: {
        id: 'secret',
        name: 'Find Secret',
        description: 'Discover hidden rooms or passages',
        trackingField: 'secretsFound',
        icon: 'fa-eye',
    },
    survive: {
        id: 'survive',
        name: 'Survive Turns',
        description: 'Survive a number of combat turns',
        trackingField: 'turnsSurvived',
        icon: 'fa-heart',
    },
    custom: {
        id: 'custom',
        name: 'Custom',
        description: 'Custom objective tracked via STScript',
        trackingField: 'customProgress',
        icon: 'fa-scroll',
    },
};

/**
 * Default quest templates
 * These are starter templates that users can customize
 */
const DEFAULT_QUESTS = {
    'quest_collect_keys': {
        id: 'quest_collect_keys',
        name: 'Key Collector',
        type: 'fetch',
        description: 'Collect keys scattered throughout the maze.',
        objective: {
            target: 'key',
            count: 3,
        },
        rewards: {
            xp: 50,
            items: [],
        },
        useLLM: false,
    },
    'quest_defeat_5': {
        id: 'quest_defeat_5',
        name: 'Pest Control',
        type: 'defeat',
        description: 'Clear out the creatures infesting this maze.',
        objective: {
            target: 'any',
            count: 5,
        },
        rewards: {
            xp: 75,
            items: [],
        },
        useLLM: false,
    },
    'quest_explore_75': {
        id: 'quest_explore_75',
        name: 'Cartographer',
        type: 'explore',
        description: 'Map out most of the maze.',
        objective: {
            target: null,
            count: 75, // 75%
        },
        rewards: {
            xp: 100,
            items: [],
        },
        useLLM: false,
    },
    'quest_find_secret': {
        id: 'quest_find_secret',
        name: 'Hidden Depths',
        type: 'secret',
        description: 'Discover a hidden room in the maze.',
        objective: {
            target: 'hidden_room',
            count: 1,
        },
        rewards: {
            xp: 60,
            items: [],
        },
        useLLM: false,
    },
    'quest_survive_combat': {
        id: 'quest_survive_combat',
        name: 'Battle Hardened',
        type: 'survive',
        description: 'Survive 20 turns of combat.',
        objective: {
            target: 'turn',
            count: 20,
        },
        rewards: {
            xp: 80,
            items: [],
        },
        useLLM: false,
    },
    'quest_treasure_hunter': {
        id: 'quest_treasure_hunter',
        name: 'Treasure Hunter',
        type: 'fetch',
        description: 'Find valuable treasure in chests.',
        objective: {
            target: 'chest',
            count: 3,
        },
        rewards: {
            xp: 60,
            items: [],
        },
        useLLM: false,
    },
    'quest_boss_slayer': {
        id: 'quest_boss_slayer',
        name: 'Boss Slayer',
        type: 'defeat',
        description: 'Defeat the powerful guardian of the maze.',
        objective: {
            target: 'boss',
            count: 1,
        },
        rewards: {
            xp: 150,
            items: ['equipment_enchanted_blade'],
        },
        useLLM: false,
    },
    'quest_full_clear': {
        id: 'quest_full_clear',
        name: 'Completionist',
        type: 'explore',
        description: 'Leave no stone unturned.',
        objective: {
            target: null,
            count: 100, // 100%
        },
        rewards: {
            xp: 200,
            items: [],
        },
        useLLM: false,
    },
    // v2.0.3: Additional quests for variety
    'quest_defeat_10': {
        id: 'quest_defeat_10',
        name: 'Exterminator',
        type: 'defeat',
        description: 'Eliminate a significant number of threats.',
        objective: {
            target: 'any',
            count: 10,
        },
        rewards: {
            xp: 120,
            items: [],
        },
        useLLM: false,
    },
    'quest_explore_50': {
        id: 'quest_explore_50',
        name: 'Scout',
        type: 'explore',
        description: 'Survey half of the maze.',
        objective: {
            target: null,
            count: 50,
        },
        rewards: {
            xp: 50,
            items: [],
        },
        useLLM: false,
    },
    'quest_open_5_chests': {
        id: 'quest_open_5_chests',
        name: 'Looter',
        type: 'fetch',
        description: 'Search the maze for valuable containers.',
        objective: {
            target: 'chest',
            count: 5,
        },
        rewards: {
            xp: 80,
            items: [],
        },
        useLLM: false,
    },
    'quest_find_3_secrets': {
        id: 'quest_find_3_secrets',
        name: 'Secret Seeker',
        type: 'secret',
        description: 'Uncover multiple hidden passages.',
        objective: {
            target: 'hidden_room',
            count: 3,
        },
        rewards: {
            xp: 120,
            items: [],
        },
        useLLM: false,
    },
    'quest_survive_10_turns': {
        id: 'quest_survive_10_turns',
        name: 'Survivor',
        type: 'survive',
        description: 'Endure through dangerous encounters.',
        objective: {
            target: 'turn',
            count: 10,
        },
        rewards: {
            xp: 40,
            items: [],
        },
        useLLM: false,
    },
    'quest_collect_5_keys': {
        id: 'quest_collect_5_keys',
        name: 'Keymaster',
        type: 'fetch',
        description: 'Gather all the keys you can find.',
        objective: {
            target: 'key',
            count: 5,
        },
        rewards: {
            xp: 80,
            items: [],
        },
        useLLM: false,
    },
    'quest_defeat_3': {
        id: 'quest_defeat_3',
        name: 'First Blood',
        type: 'defeat',
        description: 'Handle a few threats along the way.',
        objective: {
            target: 'any',
            count: 3,
        },
        rewards: {
            xp: 30,
            items: [],
        },
        useLLM: false,
    },
    'quest_explore_90': {
        id: 'quest_explore_90',
        name: 'Thorough Explorer',
        type: 'explore',
        description: 'Map nearly the entire maze.',
        objective: {
            target: null,
            count: 90,
        },
        rewards: {
            xp: 150,
            items: [],
        },
        useLLM: false,
    },
};

/**
 * Get quest type definition
 */
function getQuestType(typeId) {
    return QUEST_TYPES[typeId] || QUEST_TYPES.custom;
}

/**
 * Get quest template from extension settings or defaults
 */
function getQuest(questId) {
    const extensionSettings = SillyTavern.getContext().extensionSettings.mazemaster || {};
    return extensionSettings.quests?.[questId] || DEFAULT_QUESTS[questId] || null;
}

/**
 * Get all available quests (both default and custom)
 */
function getAllQuests() {
    const extensionSettings = SillyTavern.getContext().extensionSettings.mazemaster || {};
    const customQuests = extensionSettings.quests || {};
    return { ...DEFAULT_QUESTS, ...customQuests };
}

/**
 * Save a quest template to extension settings
 */
function saveQuest(questId, questData) {
    const context = SillyTavern.getContext();
    if (!context.extensionSettings.mazemaster) {
        context.extensionSettings.mazemaster = {};
    }
    if (!context.extensionSettings.mazemaster.quests) {
        context.extensionSettings.mazemaster.quests = {};
    }
    context.extensionSettings.mazemaster.quests[questId] = questData;
    context.saveSettingsDebounced();
}

/**
 * Delete a quest template from extension settings
 */
function deleteQuest(questId) {
    const context = SillyTavern.getContext();
    if (context.extensionSettings.mazemaster?.quests?.[questId]) {
        delete context.extensionSettings.mazemaster.quests[questId];
        context.saveSettingsDebounced();
    }
}

/**
 * Initialize quest state for a new maze
 */
function initializeQuestState() {
    return {
        active: [],      // [{ questId, progress, accepted: true, startTurn }]
        available: [],   // [{ questId, offered: true, generatedText }]
        completed: [],   // [questId, ...]
        maxActive: 3,    // Max simultaneous active quests
    };
}

/**
 * Offer random quests from maze profile's quest pool
 */
function offerRandomQuests(mazeProfile, count = 2) {
    const pool = mazeProfile?.questPool || [];
    if (pool.length === 0) return [];

    const offered = [];
    const totalChance = pool.reduce((sum, q) => sum + (q.chance || 50), 0);

    for (let i = 0; i < count && offered.length < pool.length; i++) {
        let roll = Math.random() * totalChance;
        for (const poolEntry of pool) {
            if (offered.includes(poolEntry.questId)) continue;
            roll -= poolEntry.chance || 50;
            if (roll <= 0) {
                offered.push(poolEntry.questId);
                break;
            }
        }
    }

    return offered.map(questId => ({
        questId,
        offered: true,
        generatedText: null,
    }));
}

/**
 * Accept a quest (move from available to active)
 */
function acceptQuest(questId) {
    if (!currentMaze.quests) return false;

    const availableIndex = currentMaze.quests.available.findIndex(q => q.questId === questId);
    if (availableIndex === -1) return false;

    if (currentMaze.quests.active.length >= currentMaze.quests.maxActive) {
        toastr.warning('Maximum active quests reached');
        return false;
    }

    const quest = getQuest(questId);
    if (!quest) return false;

    // Remove from available
    currentMaze.quests.available.splice(availableIndex, 1);

    // Add to active with progress tracking
    currentMaze.quests.active.push({
        questId,
        progress: 0,
        accepted: true,
        startTurn: currentMaze.turn || 0,
    });

    toastr.success(`Quest accepted: ${quest.name}`);
    return true;
}

/**
 * Abandon a quest (remove from active)
 */
function abandonQuest(questId) {
    if (!currentMaze.quests) return false;

    const activeIndex = currentMaze.quests.active.findIndex(q => q.questId === questId);
    if (activeIndex === -1) return false;

    const quest = getQuest(questId);
    currentMaze.quests.active.splice(activeIndex, 1);

    toastr.info(`Quest abandoned: ${quest?.name || questId}`);
    return true;
}

/**
 * Update progress on active quests
 * @param {string} type - Quest type (fetch, defeat, explore, etc.)
 * @param {string} target - Specific target (item type, enemy type, etc.) or null for any
 * @param {number} delta - Amount to add (or absolute value for explore)
 */
async function updateQuestProgress(type, target, delta = 1) {
    if (!currentMaze.quests?.active) return;

    for (const activeQuest of currentMaze.quests.active) {
        const quest = getQuest(activeQuest.questId);
        if (!quest || quest.type !== type) continue;

        // Check if target matches (null target = any)
        const questTarget = quest.objective?.target;
        if (questTarget && questTarget !== 'any' && questTarget !== target) continue;

        // Update progress
        if (type === 'explore') {
            // Explore uses absolute value, not delta
            activeQuest.progress = Math.max(activeQuest.progress, delta);
        } else {
            activeQuest.progress += delta;
        }

        // Check completion
        const requiredCount = quest.objective?.count || 1;
        if (activeQuest.progress >= requiredCount) {
            await completeQuest(activeQuest.questId);
        }
    }
}

/**
 * Complete a quest and grant rewards
 */
async function completeQuest(questId) {
    if (!currentMaze.quests) return;

    const activeIndex = currentMaze.quests.active.findIndex(q => q.questId === questId);
    if (activeIndex === -1) return;

    const quest = getQuest(questId);
    if (!quest) return;

    // Remove from active
    currentMaze.quests.active.splice(activeIndex, 1);

    // Add to completed
    if (!currentMaze.quests.completed.includes(questId)) {
        currentMaze.quests.completed.push(questId);
    }

    // Grant rewards
    if (quest.rewards?.xp) {
        await grantXp(quest.rewards.xp, `Quest: ${quest.name}`);
    }

    if (quest.rewards?.items) {
        for (const itemId of quest.rewards.items) {
            const equipment = getEquipment(itemId);
            if (equipment) {
                addToInventory({ ...equipment, quantity: 1 });
                toastr.info(`Received: ${equipment.name}`);
            }
        }
    }

    toastr.success(`Quest Complete: ${quest.name}!`);

    // Fire hook
    await fireHook('onQuestComplete', {
        questId,
        questName: quest.name,
        rewards: quest.rewards,
    });

    updateQuestDisplay();

    // v1.7.0: Check for quest-based zone/floor unlocks
    await onQuestCompleteCheckProgression(questId);
}

// =============================================
// QUEST PROFILE SYSTEM (v1.7.0)
// =============================================

/**
 * Get all quest profile names (default + custom)
 */
function getQuestProfileNames() {
    const defaultNames = Object.keys(DEFAULT_QUEST_PROFILES);
    const customNames = Object.keys(extensionSettings.questProfiles || {});
    // Combine and deduplicate (custom overrides default)
    const allNames = [...new Set([...defaultNames, ...customNames])];
    return allNames.sort();
}

/**
 * Get quest profile data by name (custom overrides default)
 */
function getQuestProfileData(name) {
    if (!name || name === 'none') return null;

    // Check custom profiles first
    if (extensionSettings.questProfiles?.[name]) {
        return extensionSettings.questProfiles[name];
    }

    // Fall back to defaults
    if (DEFAULT_QUEST_PROFILES[name]) {
        return DEFAULT_QUEST_PROFILES[name];
    }

    return null;
}

/**
 * Save a custom quest profile
 */
function saveQuestProfile(name, data) {
    if (!name) return false;

    if (!extensionSettings.questProfiles) {
        extensionSettings.questProfiles = {};
    }

    extensionSettings.questProfiles[name] = {
        ...data,
        name: name,
    };

    saveExtensionSettings();
    return true;
}

/**
 * Delete a custom quest profile (cannot delete defaults)
 */
function deleteQuestProfile(name) {
    if (!name) return false;

    // Cannot delete default profiles
    if (DEFAULT_QUEST_PROFILES[name] && !extensionSettings.questProfiles?.[name]) {
        toastr.warning('Cannot delete default profiles');
        return false;
    }

    if (extensionSettings.questProfiles?.[name]) {
        delete extensionSettings.questProfiles[name];
        saveExtensionSettings();
        return true;
    }

    return false;
}

/**
 * Get the current maze's active quest profile data
 */
function getActiveQuestProfile() {
    if (!currentMaze.profile?.questProfile || currentMaze.profile.questProfile === 'none') {
        return null;
    }
    return getQuestProfileData(currentMaze.profile.questProfile);
}

/**
 * Initialize quests from the maze's quest profile on maze start
 */
function initializeQuestsFromProfile() {
    const profile = getActiveQuestProfile();
    if (!profile || !profile.quests) return;

    // Initialize quest tracking if needed
    if (!currentMaze.quests) {
        currentMaze.quests = {
            active: [],
            completed: [],
            failed: [],
        };
    }

    // Track quest profile metadata for progression
    currentMaze.questProfileMeta = {
        profileName: currentMaze.profile.questProfile,
        gatingMode: profile.gatingMode || 'none',
        questGatingEnabled: currentMaze.profile.questGatingEnabled ?? false,
    };

    // Auto-accept quests marked as autoAccept
    for (const questEntry of profile.quests) {
        if (questEntry.autoAccept) {
            // Check if quest template exists in the pool
            const quest = getQuest(questEntry.questId);
            if (quest) {
                // Add to active quests with profile metadata
                currentMaze.quests.active.push({
                    questId: questEntry.questId,
                    progress: 0,
                    profileEntry: questEntry, // Store progression config
                });
            }
        }
    }

    // Fire profile load hook if defined
    if (profile.onQuestProfileLoad) {
        executeSTScript(profile.onQuestProfileLoad);
    }

    updateQuestDisplay();
}

/**
 * Check if an area (zone/floor) is unlocked by quest completion
 * @param {string} type - 'zone' or 'floor'
 * @param {number} targetId - Zone index or floor number
 */
function isAreaUnlockedByQuest(type, targetId) {
    const profile = getActiveQuestProfile();
    if (!profile || !currentMaze.questProfileMeta?.questGatingEnabled) {
        return true; // No quest gating, area is unlocked
    }

    const completedQuests = currentMaze.quests?.completed || [];
    const gatingMode = currentMaze.questProfileMeta.gatingMode;

    // Find quests that gate this specific area
    const gatingQuests = profile.quests.filter(q =>
        q.progressionType === type && q.progressionTarget === targetId
    );

    if (gatingQuests.length === 0) {
        return true; // No quests gate this area
    }

    if (gatingMode === 'any') {
        // Any one of the gating quests completed unlocks
        return gatingQuests.some(q => completedQuests.includes(q.questId));
    } else if (gatingMode === 'sequential') {
        // All gating quests must be completed
        return gatingQuests.every(q => completedQuests.includes(q.questId));
    }

    // gatingMode === 'none' or default - no gating
    return true;
}

/**
 * Get a hint about what quest unlocks an area
 */
function getQuestUnlockHint(type, targetId) {
    const profile = getActiveQuestProfile();
    if (!profile) return 'Area locked.';

    const gatingQuests = profile.quests.filter(q =>
        q.progressionType === type && q.progressionTarget === targetId
    );

    if (gatingQuests.length === 0) return 'Area locked.';

    const completedQuests = currentMaze.quests?.completed || [];
    const incompleteQuests = gatingQuests.filter(q => !completedQuests.includes(q.questId));

    if (incompleteQuests.length === 0) return 'Area unlocked!';

    // Get quest names
    const questNames = incompleteQuests.map(q => {
        const quest = getQuest(q.questId);
        return quest?.name || q.questId;
    });

    if (currentMaze.questProfileMeta?.gatingMode === 'any') {
        return `Complete any: ${questNames.join(' or ')}`;
    }
    return `Complete: ${questNames.join(', ')}`;
}

/**
 * Check all zone/floor unlocks based on quest completion
 * Call this after quest completion to update zone access
 */
function checkQuestBasedZoneUnlocks() {
    if (!currentMaze.zones || !currentMaze.questProfileMeta?.questGatingEnabled) return;

    // Check each zone
    for (let i = 0; i < currentMaze.zones.length; i++) {
        const zone = currentMaze.zones[i];
        if (!zone.isUnlocked && isAreaUnlockedByQuest('zone', i)) {
            zone.isUnlocked = true;
            toastr.info(`Zone ${i + 1} unlocked!`);
        }
    }
}

/**
 * Called when a quest is completed to check for progression unlocks
 */
async function onQuestCompleteCheckProgression(questId) {
    if (!currentMaze.questProfileMeta?.questGatingEnabled) return;

    const profile = getActiveQuestProfile();
    if (!profile) return;

    // Find this quest in the profile
    const questEntry = profile.quests.find(q => q.questId === questId);
    if (!questEntry) return;

    // Check if this quest unlocks anything
    if (questEntry.progressionType === 'zone' && questEntry.progressionTarget !== null) {
        checkQuestBasedZoneUnlocks();
    } else if (questEntry.progressionType === 'floor' && questEntry.progressionTarget !== null) {
        // Floor unlocking would be handled separately if needed
        toastr.info(`Floor ${questEntry.progressionTarget + 1} access granted!`);
    }

    // Fire progression hook if defined
    await fireHook('onQuestProgression', {
        questId,
        progressionType: questEntry.progressionType,
        progressionTarget: questEntry.progressionTarget,
    });
}

const EXTENSION_NAME = 'MazeMaster';

// Helper to resolve extension asset paths
function getExtensionImagePath(relativePath) {
    if (!relativePath) return '';

    // If it's an external URL, return as-is
    if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
        return relativePath;
    }

    // Check if this is an old-style absolute path to our extension's images
    // e.g., /scripts/extensions/third-party/MazeMaster/images/herald.jpeg
    // We need to extract the relative part and use the current folder name
    const extensionPathMatch = relativePath.match(/\/scripts\/extensions\/third-party\/[^/]+\/(.+)/);
    if (extensionPathMatch) {
        // Extract the relative path after the folder name
        const extractedRelativePath = extensionPathMatch[1];
        return `/scripts/extensions/third-party/${EXTENSION_FOLDER_NAME}/${extractedRelativePath}`;
    }

    // If it starts with /, assume it's some other absolute path and return as-is
    if (relativePath.startsWith('/')) {
        return relativePath;
    }

    // Use the dynamically detected folder name for the extension path
    // This works whether the extension is installed as 'MazeMaster' or 'SillyTavern-MazeMaster'
    return `/scripts/extensions/third-party/${EXTENSION_FOLDER_NAME}/${relativePath}`;
}

const DEFAULT_MINIONS = {
    // ===== FANTASY PACK =====
    'fantasy_herald': {
        name: 'The Herald',
        imagePath: '',
        type: 'messenger',
        description: 'A cloaked messenger who appears from the shadows with cryptic warnings about the dungeon ahead.',
        messages: ['Greetings, adventurer...', 'The maze master watches your every step...', 'Beware the darkness that lies ahead!', 'Many have entered. Few have returned.'],
        encounterScript: '',
    },
    'fantasy_guardian': {
        name: 'Dungeon Guardian',
        imagePath: '',
        type: 'battlebar',
        description: 'A stalwart armored warrior sworn to protect this passage from intruders.',
        battlebarProfiles: ['Fantasy - Normal', 'Fantasy - Hard'],
        messages: ['None shall pass!', 'Prepare yourself, intruder!', 'Only the worthy may continue!'],
        encounterScript: '',
    },
    'fantasy_oracle': {
        name: 'The Oracle',
        imagePath: '',
        type: 'prizewheel',
        description: 'An ancient mystic with glowing eyes who offers to reveal your fate through a magical spinning wheel.',
        wheelProfiles: ['Fantasy - Normal', 'Fantasy - Hard'],
        messages: ['Spin the wheel of fate!', 'Let destiny reveal itself!', 'Fortune favors the bold...'],
        encounterScript: '',
    },
    'fantasy_merchant': {
        name: 'Wandering Merchant',
        imagePath: '',
        type: 'merchant',
        description: 'A shrewd trader draped in exotic fabrics who deals in magical wares.',
        merchantItemCount: { min: 2, max: 4 },
        merchantItemPool: 'Adventurer Supplies',
        messages: ['Rare goods for a rare adventurer!', 'A fair trade benefits us both.', 'Perhaps something catches your eye?'],
        encounterScript: '',
    },
    // ===== HORROR PACK =====
    'horror_spirit': {
        name: 'Whispering Spirit',
        imagePath: '',
        type: 'messenger',
        description: 'A translucent specter that whispers unsettling warnings from beyond the grave.',
        messages: ['You should not be here...', 'They are watching... always watching...', 'Turn back while you still can...', 'Join usssss...'],
        encounterScript: '',
    },
    'horror_revenant': {
        name: 'The Revenant',
        imagePath: '',
        type: 'battlebar',
        description: 'An undying horror that claws its way from the shadows to claim another victim.',
        battlebarProfiles: ['Horror - Normal', 'Horror - Hard'],
        messages: ['Your soul... will be mine...', 'Death is only the beginning!', 'YOU CANNOT ESCAPE!'],
        encounterScript: '',
    },
    'horror_gambler': {
        name: 'Cursed Gambler',
        imagePath: '',
        type: 'prizewheel',
        description: 'A ghastly figure bound to an eternal game of chance. Win at your peril.',
        wheelProfiles: ['Horror - Normal', 'Horror - Hard'],
        messages: ['Care to play a little game?', 'The stakes are... everything.', 'Fortune rarely favors the living here...'],
        encounterScript: '',
    },
    'horror_graverobber': {
        name: 'Graverobber',
        imagePath: '',
        type: 'merchant',
        description: 'A hunched figure who deals in items "liberated" from the dead. Don\'t ask where they came from.',
        merchantItemCount: { min: 2, max: 4 },
        merchantItemPool: 'Dark Market',
        messages: ['Fresh stock... freshly acquired...', 'The dead have no need for such things.', 'A trade? The living always want something...'],
        encounterScript: '',
    },
    // ===== SCI-FI PACK =====
    'scifi_ai': {
        name: 'AI Assistant',
        imagePath: '',
        type: 'messenger',
        description: 'A holographic interface that provides technical readouts and mission updates.',
        messages: ['ALERT: Hostile activity detected in adjacent sectors.', 'Scanning complete. Multiple life forms ahead.', 'Recommended route calculated. Proceed with caution.', 'Mission parameters updated.'],
        encounterScript: '',
    },
    'scifi_bot': {
        name: 'Security Bot',
        imagePath: '',
        type: 'battlebar',
        description: 'An automated defense unit programmed to eliminate all unauthorized personnel.',
        battlebarProfiles: ['Sci-Fi - Normal', 'Sci-Fi - Hard'],
        messages: ['HALT. IDENTIFICATION REQUIRED.', 'INTRUDER DETECTED. ENGAGING COMBAT PROTOCOLS.', 'RESISTANCE IS INEFFICIENT.'],
        encounterScript: '',
    },
    'scifi_matrix': {
        name: 'Probability Matrix',
        imagePath: '',
        type: 'prizewheel',
        description: 'A quantum randomization terminal that dispenses rewards based on probability algorithms.',
        wheelProfiles: ['Sci-Fi - Normal', 'Sci-Fi - Hard'],
        messages: ['INITIATING PROBABILITY CASCADE...', 'QUANTUM OUTCOME GENERATOR READY.', 'CALCULATING OPTIMAL REWARD DISTRIBUTION...'],
        encounterScript: '',
    },
    'scifi_terminal': {
        name: 'Supply Terminal',
        imagePath: '',
        type: 'merchant',
        description: 'An automated supply kiosk that exchanges resources for equipment.',
        merchantItemCount: { min: 2, max: 4 },
        merchantItemPool: 'Rare Artifacts',
        messages: ['SUPPLY EXCHANGE TERMINAL ONLINE.', 'TRADE PROTOCOLS ACTIVATED.', 'RESOURCES DETECTED. INITIATING EXCHANGE.'],
        encounterScript: '',
    },
    // ===== CYBERPUNK PACK =====
    'cyber_fixer': {
        name: 'Street Fixer',
        imagePath: '',
        type: 'messenger',
        description: 'A well-connected operative with chrome implants who deals in underground intel.',
        messages: ['Word on the street is things are about to get hot.', 'Got a tip for you, choom. For free this time.', 'Corp goons are crawling all over this sector.', 'Watch your back. Trust no one.'],
        encounterScript: '',
    },
    'cyber_enforcer': {
        name: 'Corp Enforcer',
        imagePath: '',
        type: 'battlebar',
        description: 'A heavily augmented corporate security agent with combat-grade cyberware.',
        battlebarProfiles: ['Cyberpunk - Normal', 'Cyberpunk - Hard'],
        messages: ['You\'re in restricted space, meat.', 'Corporate property. No trespassing.', 'This won\'t take long.'],
        encounterScript: '',
    },
    'cyber_casino': {
        name: 'Underground Casino',
        imagePath: '',
        type: 'prizewheel',
        description: 'An illegal gambling den hidden in the neon underbelly of the city.',
        wheelProfiles: ['Cyberpunk - Normal', 'Cyberpunk - Hard'],
        messages: ['Step right up, choom. Feeling lucky?', 'The house always wins... usually.', 'High stakes, high rewards. You in?'],
        encounterScript: '',
    },
    'cyber_market': {
        name: 'Black Market',
        imagePath: '',
        type: 'merchant',
        description: 'A shady dealer offering hot merchandise with no questions asked.',
        merchantItemCount: { min: 2, max: 4 },
        merchantItemPool: 'Black Market Tech',
        messages: ['Fell off a truck. Very recently.', 'You didn\'t get this from me.', 'Best prices in Night City. Untraceable.'],
        encounterScript: '',
    },
    // ===== WESTERN PACK =====
    'western_crier': {
        name: 'Town Crier',
        imagePath: '',
        type: 'messenger',
        description: 'A weathered old-timer who shares news and gossip from around these parts.',
        messages: ['Howdy, stranger! Word is there\'s trouble ahead.', 'Outlaws been seen in these parts lately.', 'Watch your back out there, partner.', 'This here\'s dangerous territory.'],
        encounterScript: '',
    },
    'western_outlaw': {
        name: 'Outlaw',
        imagePath: '',
        type: 'battlebar',
        description: 'A notorious desperado with a quick draw and a mean streak.',
        battlebarProfiles: ['Western - Normal', 'Western - Hard'],
        messages: ['This town ain\'t big enough for the both of us.', 'Draw, stranger!', 'Your money or your life!'],
        encounterScript: '',
    },
    'western_gambler': {
        name: 'Saloon Gambler',
        imagePath: '',
        type: 'prizewheel',
        description: 'A slick card shark who runs games of chance in the back room.',
        wheelProfiles: ['Western - Normal', 'Western - Hard'],
        messages: ['Care to try your luck, partner?', 'The wheel never lies.', 'Fortune favors the bold... sometimes.'],
        encounterScript: '',
    },
    'western_trader': {
        name: 'Traveling Trader',
        imagePath: '',
        type: 'merchant',
        description: 'A dusty merchant with a wagon full of frontier supplies.',
        merchantItemCount: { min: 2, max: 4 },
        merchantItemPool: 'Frontier Trading Post',
        messages: ['Got supplies fresh from back East!', 'Fair prices for fair folks.', 'Need anything for the trail ahead?'],
        encounterScript: '',
    },
    // ===== ACTION PACK =====
    'action_intel': {
        name: 'Intel Officer',
        imagePath: '',
        type: 'messenger',
        description: 'A tactical advisor providing real-time mission intelligence via secure comms.',
        messages: ['Intel update: multiple hostiles in your AO.', 'HQ reports enemy movement ahead.', 'Objective markers updated. Stay frosty.', 'Watch your sectors, operator.'],
        encounterScript: '',
    },
    'action_combatant': {
        name: 'Enemy Combatant',
        imagePath: '',
        type: 'battlebar',
        description: 'A heavily armed hostile operative blocking your route to the objective.',
        battlebarProfiles: ['Action - Normal', 'Action - Hard'],
        messages: ['Contact! Engaging!', 'You\'re not getting past me!', 'Target acquired!'],
        encounterScript: '',
    },
    'action_supply': {
        name: 'Supply Drop',
        imagePath: '',
        type: 'prizewheel',
        description: 'An airdropped supply crate with randomized military-grade equipment.',
        wheelProfiles: ['Action - Normal', 'Action - Hard'],
        messages: ['Supply drop inbound. Contents unknown.', 'Field requisition package received.', 'Let\'s see what command sent us...'],
        encounterScript: '',
    },
    'action_dealer': {
        name: 'Arms Dealer',
        imagePath: '',
        type: 'merchant',
        description: 'A private military contractor offering tactical equipment trades.',
        merchantItemCount: { min: 2, max: 4 },
        merchantItemPool: 'Rare Artifacts',
        messages: ['Need to gear up, soldier?', 'Top-shelf hardware. Fair exchange.', 'Got what you need to complete the mission.'],
        encounterScript: '',
    },

    // ===== TURN-BASED COMBAT MINIONS (PRIORITY) =====
    // Fantasy Turn-Based
    'fantasy_knight': {
        name: 'Dark Knight',
        imagePath: '',
        type: 'turnbased',
        description: 'A corrupted paladin wielding a cursed blade, challenging all who pass.',
        turnbasedProfiles: ['Fantasy - Normal', 'Fantasy - Hard'],
        messages: ['My blade hungers for battle!', 'You shall fall like all the others!', 'Honor demands we fight!'],
        encounterScript: '',
    },
    'fantasy_mage': {
        name: 'Arcane Duelist',
        imagePath: '',
        type: 'turnbased',
        description: 'A battle mage who tests worthy opponents with magical combat.',
        turnbasedProfiles: ['Fantasy - Hard', 'Fantasy - Normal'],
        messages: ['Your skills shall be tested!', 'Face the power of the arcane!', 'Magic and steel shall decide this!'],
        encounterScript: '',
    },
    // Horror Turn-Based
    'horror_wraith': {
        name: 'Vengeful Wraith',
        imagePath: '',
        type: 'turnbased',
        description: 'A tortured spirit seeking to drag the living into eternal darkness.',
        turnbasedProfiles: ['Horror - Normal', 'Horror - Hard'],
        messages: ['JOIN USSS IN DEATH...', 'Your soul will never escape!', 'The grave awaits you!'],
        encounterScript: '',
    },
    'horror_butcher': {
        name: 'The Butcher',
        imagePath: '',
        type: 'turnbased',
        description: 'A massive, blood-soaked figure wielding a cleaver, blocking the only exit.',
        turnbasedProfiles: ['Horror - Nightmare', 'Horror - Hard'],
        messages: ['Fresh meat...', 'No one leaves alive!', 'I\'ll add you to my collection!'],
        encounterScript: '',
    },
    // Sci-Fi Turn-Based
    'scifi_commander': {
        name: 'Rogue Commander',
        imagePath: '',
        type: 'turnbased',
        description: 'A cybernetically enhanced military officer who went AWOL.',
        turnbasedProfiles: ['Sci-Fi - Normal', 'Sci-Fi - Hard'],
        messages: ['TACTICAL ENGAGEMENT INITIATED.', 'You are outmatched, organic.', 'Combat protocols: Maximum force.'],
        encounterScript: '',
    },
    'scifi_mech': {
        name: 'Combat Mech',
        imagePath: '',
        type: 'turnbased',
        description: 'A bipedal war machine with heavy armor and integrated weapons.',
        turnbasedProfiles: ['Sci-Fi - Nightmare', 'Sci-Fi - Hard'],
        messages: ['TARGET LOCKED.', 'WEAPONS SYSTEMS ONLINE.', 'RESISTANCE IS FUTILE.'],
        encounterScript: '',
    },
    // Cyberpunk Turn-Based
    'cyber_samurai': {
        name: 'Street Samurai',
        imagePath: '',
        type: 'turnbased',
        description: 'A chrome-plated warrior following an ancient code of combat.',
        turnbasedProfiles: ['Cyberpunk - Normal', 'Cyberpunk - Hard'],
        messages: ['My blade cuts faster than your reflexes.', 'This is your only warning, choom.', 'Honor demands satisfaction.'],
        encounterScript: '',
    },
    'cyber_boss': {
        name: 'Corp Executive',
        imagePath: '',
        type: 'turnbased',
        description: 'A heavily augmented corporate overlord with military-grade implants.',
        turnbasedProfiles: ['Cyberpunk - Nightmare', 'Cyberpunk - Hard'],
        messages: ['You think you can hurt me?', 'I own this entire district.', 'Time to flatline, street trash.'],
        encounterScript: '',
    },
    // Western Turn-Based
    'western_sheriff': {
        name: 'Corrupt Sheriff',
        imagePath: '',
        type: 'turnbased',
        description: 'A lawman gone bad, enforcing his own twisted version of justice.',
        turnbasedProfiles: ['Western - Normal', 'Western - Hard'],
        messages: ['The law says you die today.', 'I AM the law in these parts!', 'Draw, outlaw!'],
        encounterScript: '',
    },
    'western_bandit': {
        name: 'Bandit Leader',
        imagePath: '',
        type: 'turnbased',
        description: 'The notorious head of a ruthless gang of desperados.',
        turnbasedProfiles: ['Western - Nightmare', 'Western - Hard'],
        messages: ['My gang will avenge me!', 'You\'ll never take me alive!', 'This territory belongs to me!'],
        encounterScript: '',
    },
    // Action Turn-Based
    'action_soldier': {
        name: 'Elite Soldier',
        imagePath: '',
        type: 'turnbased',
        description: 'A highly trained special forces operator guarding a critical position.',
        turnbasedProfiles: ['Action - Normal', 'Action - Hard'],
        messages: ['Engage! Engage!', 'You picked the wrong fight!', 'This position will not fall!'],
        encounterScript: '',
    },
    'action_warlord': {
        name: 'Warlord',
        imagePath: '',
        type: 'turnbased',
        description: 'A legendary mercenary commander with countless victories.',
        turnbasedProfiles: ['Action - Nightmare', 'Action - Hard'],
        messages: ['I\'ve killed a hundred like you.', 'No retreat, no surrender!', 'Your death will be glorious!'],
        encounterScript: '',
    },

    // ===== QTE COMBAT MINIONS =====
    // Fantasy QTE
    'fantasy_assassin': {
        name: 'Shadow Assassin',
        imagePath: '',
        type: 'qte',
        description: 'A deadly assassin who strikes from the shadows with lightning speed.',
        qteProfiles: ['Fantasy - Normal', 'Fantasy - Hard'],
        messages: ['Can you match my speed?', 'Reflexes determine survival!', 'Too slow means death!'],
        encounterScript: '',
    },
    // Horror QTE
    'horror_crawler': {
        name: 'Ceiling Crawler',
        imagePath: '',
        type: 'qte',
        description: 'A twisted creature that drops from above, attacking with terrifying speed.',
        qteProfiles: ['Horror - Normal', 'Horror - Hard'],
        messages: ['*skittering sounds*', 'AHHHHHH!', '*inhuman screech*'],
        encounterScript: '',
    },
    // Sci-Fi QTE
    'scifi_drone': {
        name: 'Attack Drone',
        imagePath: '',
        type: 'qte',
        description: 'An agile combat drone that requires quick reflexes to evade.',
        qteProfiles: ['Sci-Fi - Normal', 'Sci-Fi - Hard'],
        messages: ['EVASION PROTOCOL ACTIVE.', 'TRACKING TARGET.', 'ATTACK RUN INITIATED.'],
        encounterScript: '',
    },
    // Cyberpunk QTE
    'cyber_netrunner': {
        name: 'Hostile Netrunner',
        imagePath: '',
        type: 'qte',
        description: 'A hacker attempting to fry your neural implants remotely.',
        qteProfiles: ['Cyberpunk - Hard', 'Cyberpunk - Nightmare'],
        messages: ['Jacking into your system...', 'Let\'s see how fast you really are.', 'Your ICE is pathetic.'],
        encounterScript: '',
    },
    // Western QTE
    'western_quickdraw': {
        name: 'Quick Draw Duelist',
        imagePath: '',
        type: 'qte',
        description: 'A legendary gunslinger known for the fastest draw in the West.',
        qteProfiles: ['Western - Normal', 'Western - Hard'],
        messages: ['On the count of three...', 'Fastest hand wins.', 'Hope you made your peace.'],
        encounterScript: '',
    },
    // Action QTE
    'action_sniper': {
        name: 'Enemy Sniper',
        imagePath: '',
        type: 'qte',
        description: 'A hidden marksman forcing you to react quickly to laser sights.',
        qteProfiles: ['Action - Normal', 'Action - Hard'],
        messages: ['*laser sight on your chest*', 'SNIPER! GET DOWN!', 'Contact! Overwatch position!'],
        encounterScript: '',
    },

    // ===== DICE COMBAT MINIONS =====
    // Fantasy Dice
    'fantasy_sphinx': {
        name: 'The Sphinx',
        imagePath: '',
        type: 'dice',
        description: 'An ancient creature that tests travelers with games of chance and skill.',
        diceProfiles: ['Fantasy - Normal', 'Fantasy - Hard'],
        messages: ['Answer my challenge or perish!', 'Fate shall decide your worth.', 'Roll the bones of destiny!'],
        encounterScript: '',
    },
    // Horror Dice
    'horror_demon': {
        name: 'Gambling Demon',
        imagePath: '',
        type: 'dice',
        description: 'A fiend who wagers souls in games of infernal chance.',
        diceProfiles: ['Horror - Hard', 'Horror - Nightmare'],
        messages: ['Care to wager your soul?', 'The dice are loaded with destiny!', 'Even demons play fair... sometimes.'],
        encounterScript: '',
    },
    // Sci-Fi Dice
    'scifi_quantum': {
        name: 'Quantum Entity',
        imagePath: '',
        type: 'dice',
        description: 'A being existing in multiple probability states simultaneously.',
        diceProfiles: ['Sci-Fi - Normal', 'Sci-Fi - Hard'],
        messages: ['PROBABILITY COLLAPSE IMMINENT.', 'YOUR FATE EXISTS IN SUPERPOSITION.', 'OBSERVE THE OUTCOME.'],
        encounterScript: '',
    },
    // Cyberpunk Dice
    'cyber_ripperdoc': {
        name: 'Back-Alley Ripperdoc',
        imagePath: '',
        type: 'dice',
        description: 'An unlicensed surgeon who might save you... or butcher you.',
        diceProfiles: ['Cyberpunk - Easy', 'Cyberpunk - Normal'],
        messages: ['Steady hands? Let\'s find out.', 'Don\'t worry, I\'ve done this before. Mostly.', 'Surgery is just controlled dice rolls.'],
        encounterScript: '',
    },
    // Western Dice
    'western_dealer': {
        name: 'Card Sharp',
        imagePath: '',
        type: 'dice',
        description: 'A professional gambler who stakes high and never loses... fairly.',
        diceProfiles: ['Western - Normal', 'Western - Hard'],
        messages: ['Lady luck is fickle today.', 'All in, stranger?', 'The cards never lie.'],
        encounterScript: '',
    },
    // Action Dice
    'action_defuser': {
        name: 'Bomb Disposal',
        imagePath: '',
        type: 'dice',
        description: 'A tense situation requiring precision and luck to disarm an explosive.',
        diceProfiles: ['Action - Hard', 'Action - Nightmare'],
        messages: ['Red wire or blue wire...', 'Steady... steady...', 'One wrong move and we\'re all dead.'],
        encounterScript: '',
    },

    // ===== STEALTH COMBAT MINIONS =====
    // Fantasy Stealth
    'fantasy_patrol': {
        name: 'Castle Guards',
        imagePath: '',
        type: 'stealth',
        description: 'Vigilant sentries patrolling the castle corridors.',
        stealthProfiles: ['Fantasy - Normal', 'Fantasy - Hard'],
        messages: ['Did you hear something?', 'All clear in sector seven.', 'Stay alert, men!'],
        encounterScript: '',
    },
    // Horror Stealth
    'horror_stalker': {
        name: 'The Stalker',
        imagePath: '',
        type: 'stealth',
        description: 'A relentless hunter that tracks by sound and smell.',
        stealthProfiles: ['Horror - Hard', 'Horror - Nightmare'],
        messages: ['*sniffing sounds*', 'I can smell your fear...', 'You cannot hide from me!'],
        encounterScript: '',
    },
    // Sci-Fi Stealth
    'scifi_sensors': {
        name: 'Security Grid',
        imagePath: '',
        type: 'stealth',
        description: 'An automated sensor network scanning for intruders.',
        stealthProfiles: ['Sci-Fi - Normal', 'Sci-Fi - Hard'],
        messages: ['MOTION DETECTED. SCANNING...', 'THERMAL SIGNATURES ANALYZED.', 'SECTOR SWEEP IN PROGRESS.'],
        encounterScript: '',
    },
    // Cyberpunk Stealth
    'cyber_patrol': {
        name: 'Corp Security',
        imagePath: '',
        type: 'stealth',
        description: 'Corporate security forces with state-of-the-art surveillance.',
        stealthProfiles: ['Cyberpunk - Normal', 'Cyberpunk - Hard'],
        messages: ['Sweep the perimeter.', 'Thermal scan clear... wait.', 'Something tripped the sensors.'],
        encounterScript: '',
    },
    // Western Stealth
    'western_posse': {
        name: 'Sheriff\'s Posse',
        imagePath: '',
        type: 'stealth',
        description: 'A group of lawmen searching for fugitives.',
        stealthProfiles: ['Western - Easy', 'Western - Normal'],
        messages: ['Fan out! They\'re here somewhere!', 'Check behind those barrels!', 'We\'ll smoke \'em out!'],
        encounterScript: '',
    },
    // Action Stealth
    'action_patrol': {
        name: 'Guard Patrol',
        imagePath: '',
        type: 'stealth',
        description: 'Military guards with NVGs and motion sensors.',
        stealthProfiles: ['Action - Hard', 'Action - Nightmare'],
        messages: ['Movement. Sector four.', 'Checking blind spots.', 'Stay frosty. We got activity.'],
        encounterScript: '',
    },

    // ===== PUZZLE COMBAT MINIONS =====
    // Fantasy Puzzle
    'fantasy_golem': {
        name: 'Puzzle Golem',
        imagePath: '',
        type: 'puzzle',
        description: 'An ancient construct that only allows passage to those who solve its riddles.',
        puzzleProfiles: ['Fantasy - Normal', 'Fantasy - Hard'],
        messages: ['Solve my puzzle or be destroyed.', 'Your mind shall be tested.', 'Only the clever may pass.'],
        encounterScript: '',
    },
    // Horror Puzzle
    'horror_mirror': {
        name: 'Puzzle Box',
        imagePath: '',
        type: 'puzzle',
        description: 'A sinister device that must be solved to prevent something terrible.',
        puzzleProfiles: ['Horror - Normal', 'Horror - Hard'],
        messages: ['The box... you opened it...', 'Solve it or suffer eternal torment!', 'Your mind against the void...'],
        encounterScript: '',
    },
    // Sci-Fi Puzzle
    'scifi_terminal_puzzle': {
        name: 'Security Terminal',
        imagePath: '',
        type: 'puzzle',
        description: 'A locked terminal requiring a sequence bypass to access.',
        puzzleProfiles: ['Sci-Fi - Normal', 'Sci-Fi - Hard'],
        messages: ['ACCESS DENIED. INITIATING SEQUENCE TEST.', 'AUTHENTICATE VIA PATTERN RECOGNITION.', 'UNAUTHORIZED ACCESS ATTEMPT LOGGED.'],
        encounterScript: '',
    },
    // Cyberpunk Puzzle
    'cyber_ice': {
        name: 'Black ICE',
        imagePath: '',
        type: 'puzzle',
        description: 'Lethal intrusion countermeasures requiring precise mental navigation.',
        puzzleProfiles: ['Cyberpunk - Hard', 'Cyberpunk - Nightmare'],
        messages: ['ICE DETECTED. BEGINNING BREACH.', 'Neural firewall engaged.', 'Crack the code or fry your brain.'],
        encounterScript: '',
    },
    // Western Puzzle
    'western_safe': {
        name: 'Bank Vault',
        imagePath: '',
        type: 'puzzle',
        description: 'A complex combination lock protecting the town\'s valuables.',
        puzzleProfiles: ['Western - Normal', 'Western - Hard'],
        messages: ['Four turns left, three right...', 'Listen for the click...', 'One wrong move and the alarm sounds.'],
        encounterScript: '',
    },
    // Action Puzzle
    'action_bomb': {
        name: 'Bomb Defusal',
        imagePath: '',
        type: 'puzzle',
        description: 'A ticking bomb that must be disarmed following a specific sequence.',
        puzzleProfiles: ['Action - Normal', 'Action - Hard'],
        messages: ['60 seconds on the clock!', 'Follow the sequence exactly!', 'No pressure... just don\'t mess up.'],
        encounterScript: '',
    },

    // ===== NEGOTIATION COMBAT MINIONS =====
    // Fantasy Negotiation
    'fantasy_diplomat': {
        name: 'Royal Emissary',
        imagePath: '',
        type: 'negotiation',
        description: 'A noble diplomat who might grant passage for the right price or persuasion.',
        negotiationProfiles: ['Fantasy - Easy', 'Fantasy - Normal'],
        messages: ['Perhaps we can reach an arrangement.', 'The crown demands respect.', 'State your business, traveler.'],
        encounterScript: '',
    },
    // Horror Negotiation
    'horror_pact': {
        name: 'Dark Bargainer',
        imagePath: '',
        type: 'negotiation',
        description: 'An otherworldly entity offering terrible deals.',
        negotiationProfiles: ['Horror - Hard', 'Horror - Nightmare'],
        messages: ['I offer you... a deal.', 'Your soul is of interest to me.', 'Everything has a price...'],
        encounterScript: '',
    },
    // Sci-Fi Negotiation
    'scifi_bureaucrat': {
        name: 'Station Administrator',
        imagePath: '',
        type: 'negotiation',
        description: 'A by-the-book official who controls access to restricted areas.',
        negotiationProfiles: ['Sci-Fi - Easy', 'Sci-Fi - Normal'],
        messages: ['AUTHORIZATION REQUIRED.', 'Perhaps we can expedite your paperwork.', 'Regulations must be followed... usually.'],
        encounterScript: '',
    },
    // Cyberpunk Negotiation
    'cyber_fixer_deal': {
        name: 'Connected Fixer',
        imagePath: '',
        type: 'negotiation',
        description: 'A well-connected middleman who can make things happen... for a price.',
        negotiationProfiles: ['Cyberpunk - Normal', 'Cyberpunk - Hard'],
        messages: ['Everything\'s negotiable in Night City.', 'I know people who know people.', 'What\'s this worth to you, choom?'],
        encounterScript: '',
    },
    // Western Negotiation
    'western_mayor': {
        name: 'Corrupt Mayor',
        imagePath: '',
        type: 'negotiation',
        description: 'The town\'s crooked leader who can be persuaded with the right approach.',
        negotiationProfiles: ['Western - Normal', 'Western - Hard'],
        messages: ['This town runs on my schedule.', 'Perhaps we can help each other.', 'Gold speaks louder than words.'],
        encounterScript: '',
    },
    // Action Negotiation
    'action_commander_deal': {
        name: 'Field Commander',
        imagePath: '',
        type: 'negotiation',
        description: 'An enemy officer who might be convinced to stand down.',
        negotiationProfiles: ['Action - Normal', 'Action - Hard'],
        messages: ['You want to avoid bloodshed? Talk.', 'I have orders... but orders can change.', 'Make it worth my while.'],
        encounterScript: '',
    },
};

const DEFAULT_TRAPS = {
    // ===== FANTASY TRAPS =====
    'spike_trap': {
        name: 'Spike Trap',
        imagePath: '',
        message: 'Sharp spikes shoot up from ancient pressure plates!',
        script: '/setvar key=trapdmg {{roll:2d4}} | /mazedamage amount={{getvar::trapdmg}} source="spike trap" | /echo {{user}} took {{getvar::trapdmg}} damage from the spikes!',
        avoidChance: 25,
        avoidMessage: 'You leap back just as the spikes shoot up!',
        avoidScript: '/echo {{user}} narrowly avoided the spike trap!',
    },
    'poison_dart': {
        name: 'Poison Dart',
        imagePath: '',
        message: 'Darts fly from hidden slits in the wall!',
        script: '/setvar key=trapdmg {{roll:1d6+2}} | /mazedamage amount={{getvar::trapdmg}} source="poison dart" | /echo {{user}} was struck by poisoned darts for {{getvar::trapdmg}} damage!',
        avoidChance: 30,
        avoidMessage: 'You duck just in time as darts whistle overhead!',
        avoidScript: '/echo {{user}} dodged the poison darts!',
    },
    'magic_rune': {
        name: 'Magic Rune',
        imagePath: '',
        message: 'An arcane glyph flares to life beneath your feet!',
        script: '/setvar key=trapdmg {{roll:2d6}} | /mazedamage amount={{getvar::trapdmg}} source="magic rune" | /echo The rune explodes! {{user}} takes {{getvar::trapdmg}} arcane damage!',
        avoidChance: 20,
        avoidMessage: 'You sense the magic and step aside as the rune flares!',
        avoidScript: '/echo {{user}} sensed the magical trap and avoided it!',
    },
    // ===== HORROR TRAPS =====
    'ghostly_grasp': {
        name: 'Ghostly Grasp',
        imagePath: '',
        message: 'Spectral hands reach up from the floor!',
        script: '/setvar key=trapdmg {{roll:1d6+1}} | /mazedamage amount={{getvar::trapdmg}} source="ghostly grasp" | /echo Icy fingers drain {{getvar::trapdmg}} life from {{user}}!',
        avoidChance: 25,
        avoidMessage: 'The spectral hands grasp at empty air as you pull away!',
        avoidScript: '/echo {{user}} escaped the ghostly grasp!',
    },
    'blood_pool': {
        name: 'Blood Pool',
        imagePath: '',
        message: 'The floor gives way to a pool of viscous crimson!',
        script: '/setvar key=trapdmg {{roll:2d4}} | /mazedamage amount={{getvar::trapdmg}} source="blood pool" | /echo The cursed blood burns {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 20,
        avoidMessage: 'You grab the edge and pull yourself back before falling in!',
        avoidScript: '/echo {{user}} narrowly avoided falling into the blood pool!',
    },
    'cursed_mirror': {
        name: 'Cursed Mirror',
        imagePath: '',
        message: 'Your reflection grins and reaches through the glass!',
        script: '/setvar key=trapdmg {{roll:2d6}} | /mazedamage amount={{getvar::trapdmg}} source="cursed mirror" | /echo Your doppelganger claws {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 15,
        avoidMessage: 'You avert your eyes just as your reflection reaches out!',
        avoidScript: '/echo {{user}} refused to look at the cursed mirror!',
    },
    // ===== SCI-FI TRAPS =====
    'laser_grid': {
        name: 'Laser Grid',
        imagePath: '',
        message: 'Red laser beams crisscross the corridor!',
        script: '/setvar key=trapdmg {{roll:2d4+2}} | /mazedamage amount={{getvar::trapdmg}} source="laser grid" | /echo Security lasers burn {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 30,
        avoidMessage: 'You contort through the laser grid without triggering it!',
        avoidScript: '/echo {{user}} gracefully navigated the laser grid!',
    },
    'gas_leak': {
        name: 'Gas Leak',
        imagePath: '',
        message: 'A ruptured pipe sprays toxic coolant!',
        script: '/setvar key=trapdmg {{roll:1d8+1}} | /mazedamage amount={{getvar::trapdmg}} source="gas leak" | /echo Toxic gas burns {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 25,
        avoidMessage: 'You hold your breath and rush past the gas leak!',
        avoidScript: '/echo {{user}} held their breath and avoided the toxic gas!',
    },
    'gravity_trap': {
        name: 'Gravity Trap',
        imagePath: '',
        message: 'The gravity plating malfunctions violently!',
        script: '/setvar key=trapdmg {{roll:2d6}} | /mazedamage amount={{getvar::trapdmg}} source="gravity trap" | /echo {{user}} slams into the ceiling for {{getvar::trapdmg}} damage!',
        avoidChance: 20,
        avoidMessage: 'You grab a handhold as the gravity fluctuates!',
        avoidScript: '/echo {{user}} braced themselves against the gravity shift!',
    },
    // ===== CYBERPUNK TRAPS =====
    'electric_floor': {
        name: 'Electric Floor',
        imagePath: '',
        message: 'The chrome flooring crackles with lethal voltage!',
        script: '/setvar key=trapdmg {{roll:2d4+3}} | /mazedamage amount={{getvar::trapdmg}} source="electric floor" | /echo Electricity surges through {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 25,
        avoidMessage: 'You leap to a non-conductive surface just in time!',
        avoidScript: '/echo {{user}} jumped clear of the electric floor!',
    },
    'neural_spike': {
        name: 'Neural Spike',
        imagePath: '',
        message: 'A hidden ICE program attacks your neural interface!',
        script: '/setvar key=trapdmg {{roll:2d6}} | /mazedamage amount={{getvar::trapdmg}} source="neural spike" | /echo The ICE fries your synapses for {{getvar::trapdmg}} damage!',
        avoidChance: 20,
        avoidMessage: 'Your firewall blocks the ICE attack!',
        avoidScript: '/echo Your cyberdeck deflected the neural spike!',
    },
    'security_turret': {
        name: 'Security Turret',
        imagePath: '',
        message: 'An automated turret drops from the ceiling!',
        script: '/setvar key=trapdmg {{roll:3d4}} | /mazedamage amount={{getvar::trapdmg}} source="security turret" | /echo The turret peppers {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 30,
        avoidMessage: 'You dive behind cover as the turret opens fire!',
        avoidScript: '/echo {{user}} took cover before the turret could lock on!',
    },
    // ===== WESTERN TRAPS =====
    'bear_trap': {
        name: 'Bear Trap',
        imagePath: '',
        message: 'A rusted bear trap snaps shut on your leg!',
        script: '/setvar key=trapdmg {{roll:2d4+2}} | /mazedamage amount={{getvar::trapdmg}} source="bear trap" | /echo The iron jaws bite {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 25,
        avoidMessage: 'You spot the bear trap and step around it!',
        avoidScript: '/echo {{user}} carefully avoided the bear trap!',
    },
    'dynamite': {
        name: 'Dynamite',
        imagePath: '',
        message: 'A tripwire ignites a bundle of dynamite!',
        script: '/setvar key=trapdmg {{roll:3d6}} | /mazedamage amount={{getvar::trapdmg}} source="dynamite" | /echo BOOM! {{user}} takes {{getvar::trapdmg}} explosion damage!',
        avoidChance: 20,
        avoidMessage: 'You cut the tripwire before it triggers the dynamite!',
        avoidScript: '/echo {{user}} disarmed the dynamite trap!',
    },
    'snake_pit': {
        name: 'Snake Pit',
        imagePath: '',
        message: 'The floor collapses into a writhing pit of rattlesnakes!',
        script: '/setvar key=trapdmg {{roll:2d4+1}} | /mazedamage amount={{getvar::trapdmg}} source="snake pit" | /echo The snakes strike {{user}} for {{getvar::trapdmg}} venom damage!',
        avoidChance: 25,
        avoidMessage: 'You jump back as the floor crumbles away!',
        avoidScript: '/echo {{user}} leapt clear of the snake pit!',
    },
    // ===== ACTION TRAPS =====
    'tripwire': {
        name: 'Tripwire',
        imagePath: '',
        message: 'Your foot catches a nearly invisible wire!',
        script: '/setvar key=trapdmg {{roll:2d6+2}} | /mazedamage amount={{getvar::trapdmg}} source="tripwire" | /echo The explosive detonates! {{user}} takes {{getvar::trapdmg}} damage!',
        avoidChance: 30,
        avoidMessage: 'You spot the tripwire and step over it!',
        avoidScript: '/echo {{user}} spotted and avoided the tripwire!',
    },
    'flashbang': {
        name: 'Flashbang',
        imagePath: '',
        message: 'A proximity sensor triggers a flashbang grenade!',
        script: '/setvar key=trapdmg {{roll:1d6+2}} | /mazedamage amount={{getvar::trapdmg}} source="flashbang" | /echo The blast disorients {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 25,
        avoidMessage: 'You shield your eyes and ears as the flashbang detonates!',
        avoidScript: '/echo {{user}} braced for the flashbang!',
    },
    'claymore': {
        name: 'Claymore',
        imagePath: '',
        message: 'You step into the kill zone of a claymore mine!',
        script: '/setvar key=trapdmg {{roll:4d6}} | /mazedamage amount={{getvar::trapdmg}} source="claymore" | /echo Steel balls shred {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 15,
        avoidMessage: 'You freeze and slowly back out of the kill zone!',
        avoidScript: '/echo {{user}} carefully retreated from the claymore!',
    },
};

// Default merchant item pools - configurable item pools that merchants can offer
const DEFAULT_MERCHANT_ITEM_POOLS = {
    'Common Goods': {
        description: 'Basic supplies and common items',
        items: [
            { id: 'key', name: 'Key', description: 'Opens locked doors', icon: '🗝️', weight: 30 },
            { id: 'stealth', name: 'Stealth Cloak', description: 'Slip past one encounter', icon: '👤', weight: 25 },
            { id: 'strike', name: 'Strike', description: 'Power attack in combat', icon: '⚡', weight: 25 },
            { id: 'healingPotion', name: 'Healing Potion', description: 'Restores health', icon: '🧪', weight: 20 },
        ],
    },
    'Adventurer Supplies': {
        description: 'Essential gear for dungeon delvers',
        items: [
            { id: 'key', name: 'Key', description: 'Opens locked doors', icon: '🗝️', weight: 20 },
            { id: 'stealth', name: 'Stealth Cloak', description: 'Slip past one encounter', icon: '👤', weight: 20 },
            { id: 'strike', name: 'Strike', description: 'Power attack in combat', icon: '⚡', weight: 20 },
            { id: 'execute', name: 'Grandstrike', description: 'Devastating finishing blow', icon: '💥', weight: 10 },
            { id: 'floorKey', name: 'Floor Key', description: 'Access the next floor', icon: '🚪', weight: 10 },
            { id: 'healingPotion', name: 'Healing Potion', description: 'Restores health', icon: '🧪', weight: 20 },
        ],
    },
    'Rare Artifacts': {
        description: 'Magical items of significant power',
        items: [
            { id: 'execute', name: 'Grandstrike', description: 'Devastating finishing blow', icon: '💥', weight: 15 },
            { id: 'floorKey', name: 'Floor Key', description: 'Access the next floor', icon: '🚪', weight: 15 },
            { id: 'portalStone', name: 'Portal Stone', description: 'Teleport to safety', icon: '🌀', weight: 15 },
            { id: 'minionBane', name: 'Minion Bane', description: 'Instantly defeats a minion', icon: '💀', weight: 15 },
            { id: 'greaterHealing', name: 'Greater Healing', description: 'Fully restores health', icon: '💎', weight: 20 },
            { id: 'mapFragment', name: 'Map Fragment', description: 'Reveals the maze', icon: '🗺️', weight: 20 },
        ],
    },
    'Dark Market': {
        description: 'Forbidden wares from the underworld',
        items: [
            { id: 'minionBane', name: 'Minion Bane', description: 'Instantly defeats a minion', icon: '💀', weight: 20 },
            { id: 'voidWalk', name: 'Void Walk', description: 'Phase through walls', icon: '👻', weight: 15 },
            { id: 'timeShard', name: 'Time Shard', description: 'Manipulate time', icon: '⏳', weight: 15 },
            { id: 'execute', name: 'Grandstrike', description: 'Devastating finishing blow', icon: '💥', weight: 20 },
            { id: 'elixir', name: 'Elixir', description: 'Powerful restorative', icon: '🍷', weight: 15 },
            { id: 'revivalCharm', name: 'Revival Charm', description: 'Return from defeat', icon: '💫', weight: 15 },
        ],
    },
    'Frontier Trading Post': {
        description: 'Supplies for the open frontier',
        items: [
            { id: 'key', name: 'Key', description: 'Opens locked doors', icon: '🗝️', weight: 20 },
            { id: 'strike', name: 'Strike', description: 'Power attack in combat', icon: '⚡', weight: 25 },
            { id: 'stealth', name: 'Stealth Cloak', description: 'Slip past one encounter', icon: '👤', weight: 15 },
            { id: 'healingPotion', name: 'Healing Potion', description: 'Restores health', icon: '🧪', weight: 25 },
            { id: 'execute', name: 'Grandstrike', description: 'Devastating finishing blow', icon: '💥', weight: 15 },
        ],
    },
    'Black Market Tech': {
        description: 'Cutting-edge contraband tech',
        items: [
            { id: 'voidWalk', name: 'Phase Implant', description: 'Phase through walls', icon: '👻', weight: 15 },
            { id: 'minionBane', name: 'EMP Grenade', description: 'Instantly defeats a minion', icon: '💀', weight: 20 },
            { id: 'mapFragment', name: 'Scanner Chip', description: 'Reveals the maze', icon: '🗺️', weight: 20 },
            { id: 'portalStone', name: 'Teleport Beacon', description: 'Teleport to safety', icon: '🌀', weight: 15 },
            { id: 'execute', name: 'Overcharge Cell', description: 'Devastating finishing blow', icon: '💥', weight: 15 },
            { id: 'timeShard', name: 'Stasis Field', description: 'Manipulate time', icon: '⏳', weight: 15 },
        ],
    },
};

// Default minion profile (a saved set of minions)
// Minion profiles are collections of minion IDs that can be used together
const DEFAULT_MINION_PROFILES = {
    // ===== ZONE-TIERED MINION PACKS (v1.6.0) =====
    // Tier 1: Messengers, merchants, weak encounters (Zones 1-2)
    // Tier 2: Guards, puzzlers, medium combat (Zones 3-4)
    // Tier 3: Elites, bosses, hardest encounters (Final Zones)

    // Fantasy Tiered
    'Fantasy Tier 1': {
        minions: ['fantasy_herald', 'fantasy_merchant', 'fantasy_diplomat'],
        description: 'Early zone encounters: messengers, traders, negotiators',
    },
    'Fantasy Tier 2': {
        minions: ['fantasy_guardian', 'fantasy_oracle', 'fantasy_patrol', 'fantasy_golem'],
        description: 'Mid zone encounters: guards, seers, puzzle guardians',
    },
    'Fantasy Tier 3': {
        minions: ['fantasy_knight', 'fantasy_mage', 'fantasy_assassin', 'fantasy_sphinx'],
        description: 'Final zone encounters: elite warriors, powerful mages',
    },

    // Horror Tiered
    'Horror Tier 1': {
        minions: ['horror_gambler', 'horror_graverobber', 'horror_pact'],
        description: 'Early zone encounters: gamblers, scavengers, deal-makers',
    },
    'Horror Tier 2': {
        minions: ['horror_spirit', 'horror_revenant', 'horror_stalker', 'horror_mirror'],
        description: 'Mid zone encounters: restless spirits, puzzle boxes',
    },
    'Horror Tier 3': {
        minions: ['horror_wraith', 'horror_butcher', 'horror_crawler', 'horror_demon'],
        description: 'Final zone encounters: deadly horrors, demons',
    },

    // Sci-Fi Tiered
    'Sci-Fi Tier 1': {
        minions: ['scifi_terminal', 'scifi_ai', 'scifi_bureaucrat'],
        description: 'Early zone encounters: terminals, basic AI, officials',
    },
    'Sci-Fi Tier 2': {
        minions: ['scifi_bot', 'scifi_sensors', 'scifi_terminal_puzzle', 'scifi_matrix'],
        description: 'Mid zone encounters: security bots, sensor grids',
    },
    'Sci-Fi Tier 3': {
        minions: ['scifi_commander', 'scifi_mech', 'scifi_drone', 'scifi_quantum'],
        description: 'Final zone encounters: commanders, heavy mechs',
    },

    // Cyberpunk Tiered
    'Cyberpunk Tier 1': {
        minions: ['cyber_market', 'cyber_fixer', 'cyber_fixer_deal'],
        description: 'Early zone encounters: black markets, fixers',
    },
    'Cyberpunk Tier 2': {
        minions: ['cyber_enforcer', 'cyber_patrol', 'cyber_ice', 'cyber_casino'],
        description: 'Mid zone encounters: corp security, ICE programs',
    },
    'Cyberpunk Tier 3': {
        minions: ['cyber_samurai', 'cyber_boss', 'cyber_netrunner', 'cyber_ripperdoc'],
        description: 'Final zone encounters: street samurai, crime bosses',
    },

    // Western Tiered
    'Western Tier 1': {
        minions: ['western_crier', 'western_trader', 'western_gambler'],
        description: 'Early zone encounters: town criers, traders, gamblers',
    },
    'Western Tier 2': {
        minions: ['western_outlaw', 'western_posse', 'western_safe', 'western_mayor'],
        description: 'Mid zone encounters: outlaws, lawmen, puzzles',
    },
    'Western Tier 3': {
        minions: ['western_sheriff', 'western_bandit', 'western_quickdraw', 'western_dealer'],
        description: 'Final zone encounters: sheriffs, deadly gunslingers',
    },

    // Action Tiered
    'Action Tier 1': {
        minions: ['action_intel', 'action_supply', 'action_dealer'],
        description: 'Early zone encounters: intel officers, supply caches',
    },
    'Action Tier 2': {
        minions: ['action_combatant', 'action_patrol', 'action_bomb', 'action_commander_deal'],
        description: 'Mid zone encounters: soldiers, bomb defusals',
    },
    'Action Tier 3': {
        minions: ['action_soldier', 'action_warlord', 'action_sniper', 'action_defuser'],
        description: 'Final zone encounters: elite soldiers, warlords',
    },

    // ===== FULL THEME PACKS (all tiers combined) =====
    'Fantasy Full': {
        minions: [
            'fantasy_herald', 'fantasy_merchant', 'fantasy_diplomat',
            'fantasy_guardian', 'fantasy_oracle', 'fantasy_patrol', 'fantasy_golem',
            'fantasy_knight', 'fantasy_mage', 'fantasy_assassin', 'fantasy_sphinx'
        ],
        description: 'Complete fantasy minion set across all zone tiers',
    },
    'Horror Full': {
        minions: [
            'horror_gambler', 'horror_graverobber', 'horror_pact',
            'horror_spirit', 'horror_revenant', 'horror_stalker', 'horror_mirror',
            'horror_wraith', 'horror_butcher', 'horror_crawler', 'horror_demon'
        ],
        description: 'Complete horror minion set across all zone tiers',
    },
    'Sci-Fi Full': {
        minions: [
            'scifi_terminal', 'scifi_ai', 'scifi_bureaucrat',
            'scifi_bot', 'scifi_sensors', 'scifi_terminal_puzzle', 'scifi_matrix',
            'scifi_commander', 'scifi_mech', 'scifi_drone', 'scifi_quantum'
        ],
        description: 'Complete sci-fi minion set across all zone tiers',
    },
    'Cyberpunk Full': {
        minions: [
            'cyber_market', 'cyber_fixer', 'cyber_fixer_deal',
            'cyber_enforcer', 'cyber_patrol', 'cyber_ice', 'cyber_casino',
            'cyber_samurai', 'cyber_boss', 'cyber_netrunner', 'cyber_ripperdoc'
        ],
        description: 'Complete cyberpunk minion set across all zone tiers',
    },
    'Western Full': {
        minions: [
            'western_crier', 'western_trader', 'western_gambler',
            'western_outlaw', 'western_posse', 'western_safe', 'western_mayor',
            'western_sheriff', 'western_bandit', 'western_quickdraw', 'western_dealer'
        ],
        description: 'Complete western minion set across all zone tiers',
    },
    'Action Full': {
        minions: [
            'action_intel', 'action_supply', 'action_dealer',
            'action_combatant', 'action_patrol', 'action_bomb', 'action_commander_deal',
            'action_soldier', 'action_warlord', 'action_sniper', 'action_defuser'
        ],
        description: 'Complete action minion set across all zone tiers',
    },

    // ===== LEGACY PACKS (backwards compatibility) =====
    'Fantasy Pack': {
        minions: ['fantasy_herald', 'fantasy_guardian', 'fantasy_oracle', 'fantasy_merchant'],
    },
    'Horror Pack': {
        minions: ['horror_spirit', 'horror_revenant', 'horror_gambler', 'horror_graverobber'],
    },
    'Sci-Fi Pack': {
        minions: ['scifi_ai', 'scifi_bot', 'scifi_matrix', 'scifi_terminal'],
    },
    'Cyberpunk Pack': {
        minions: ['cyber_fixer', 'cyber_enforcer', 'cyber_casino', 'cyber_market'],
    },
    'Western Pack': {
        minions: ['western_crier', 'western_outlaw', 'western_gambler', 'western_trader'],
    },
    'Action Pack': {
        minions: ['action_intel', 'action_combatant', 'action_supply', 'action_dealer'],
    },
    'Fantasy Extended': {
        minions: [
            'fantasy_herald', 'fantasy_guardian', 'fantasy_oracle', 'fantasy_merchant',
            'fantasy_knight', 'fantasy_mage', 'fantasy_assassin', 'fantasy_sphinx',
            'fantasy_patrol', 'fantasy_golem', 'fantasy_diplomat'
        ],
    },
    'Horror Extended': {
        minions: [
            'horror_spirit', 'horror_revenant', 'horror_gambler', 'horror_graverobber',
            'horror_wraith', 'horror_butcher', 'horror_crawler', 'horror_demon',
            'horror_stalker', 'horror_mirror', 'horror_pact'
        ],
    },
    'Sci-Fi Extended': {
        minions: [
            'scifi_ai', 'scifi_bot', 'scifi_matrix', 'scifi_terminal',
            'scifi_commander', 'scifi_mech', 'scifi_drone', 'scifi_quantum',
            'scifi_sensors', 'scifi_terminal_puzzle', 'scifi_bureaucrat'
        ],
    },
    'Cyberpunk Extended': {
        minions: [
            'cyber_fixer', 'cyber_enforcer', 'cyber_casino', 'cyber_market',
            'cyber_samurai', 'cyber_boss', 'cyber_netrunner', 'cyber_ripperdoc',
            'cyber_patrol', 'cyber_ice', 'cyber_fixer_deal'
        ],
    },
    'Western Extended': {
        minions: [
            'western_crier', 'western_outlaw', 'western_gambler', 'western_trader',
            'western_sheriff', 'western_bandit', 'western_quickdraw', 'western_dealer',
            'western_posse', 'western_safe', 'western_mayor'
        ],
    },
    'Action Extended': {
        minions: [
            'action_intel', 'action_combatant', 'action_supply', 'action_dealer',
            'action_soldier', 'action_warlord', 'action_sniper', 'action_defuser',
            'action_patrol', 'action_bomb', 'action_commander_deal'
        ],
    },
};

// Trap profiles are collections of trap IDs that can be used together
const DEFAULT_TRAP_PROFILES = {
    'Fantasy Traps': {
        traps: ['spike_trap', 'poison_dart', 'magic_rune'],
    },
    'Horror Traps': {
        traps: ['ghostly_grasp', 'blood_pool', 'cursed_mirror'],
    },
    'Sci-Fi Traps': {
        traps: ['laser_grid', 'gas_leak', 'gravity_trap'],
    },
    'Cyberpunk Traps': {
        traps: ['electric_floor', 'neural_spike', 'security_turret'],
    },
    'Western Traps': {
        traps: ['bear_trap', 'dynamite', 'snake_pit'],
    },
    'Action Traps': {
        traps: ['tripwire', 'flashbang', 'claymore'],
    },
};

const DEFAULT_MAZE_PROFILE = {
    // ===================================================================
    // v1.6.0 COMPLETE PROFILE SYSTEM - Zone-Minded, Feature-Rich Defaults
    // ===================================================================
    // Structure: 1 Tutorial + 30 Theme×Difficulty profiles (6 themes × 5 difficulties)
    // All profiles utilize: BSP zones, find early, vision profiles, faction systems,
    // combat mechanics profiles, tiered minions, fairness mechanics, and permadeath options

    // ===== TUTORIAL (Theme-Agnostic) =====
    'Tutorial: First Steps': {
        gridSize: 5, floors: 1, difficulty: 'tutorial', theme: 'fantasy', mapStyle: 'dungeon', mapVisibility: 'showAll',
        winCommand: '/echo Tutorial complete! You\'re ready for real adventures!',
        loseCommand: '/echo Don\'t worry! Try again - tutorials are meant for learning!',
        winMessage: 'Congratulations! You\'ve learned the basics of dungeon exploration!',
        winImage: '',
        mainMinion: 'fantasy_herald',
        mainMinionIntroMessage: 'Welcome, adventurer! I\'ll guide you through this tutorial dungeon.',
        mainMinionRandomChance: 30,
        mainMinionRandomMessages: ['Remember to check chests for supplies!', 'Look for the exit marked on your map!', 'Use items wisely!'],
        mainMinionExitType: 'messenger', mainMinionExitProfile: '',
        minionEncounters: [
            { minionId: 'fantasy_herald', percent: 5, zoneMin: 0, zoneMax: 99 },
            { minionId: 'fantasy_merchant', percent: 3, zoneMin: 0, zoneMax: 99 },
        ],
        trapEncounters: [],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 15, chestLockedPercent: 10, chestLockedBonusPercent: 30, chestMimicPercent: 0,
        chestLootMin: 3, chestLootMax: 5,
        chestKeyChance: 50, chestStrikeChance: 50, chestStealthChance: 30, chestExecuteChance: 5,
        lockedChestKeyChance: 40, lockedChestStrikeChance: 60, lockedChestStealthChance: 40, lockedChestExecuteChance: 10,
        startingInventory: { key: 3, strike: 3, stealth: 2, execute: 1, healingPotion: 5, greaterHealing: 2, elixir: 1, revivalCharm: 1 },
        hpEnabled: true, maxHP: 200, battlebarDamageMultiplier: 0.3, onDeath: 'respawn', respawnHPPercent: 100,
        safeRoomCount: 5, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 50, restCooldown: 1, restInterruptChance: 0, restInterruptScript: '',
        storyConfig: { mainStory: 'Welcome, novice adventurer! This training dungeon will teach you everything you need to survive. Explore rooms, open chests, and find the exit. Your guide awaits within.' },
        findEarly: { radius: 6, items: ['lantern', 'torch', 'healingPotion', 'mapFragment', 'key', 'strike'], itemsPerChest: 3 },
        fairness: { enabled: true, keyPityThreshold: 2, healingPityThreshold: 2, lowHpThreshold: 0.5, mercyUnlock: true, mercyUnlockThreshold: 1 },
        bspConfig: { zoneCount: 1, secretDensity: 0, zonesRequireClear: false, secretHints: true, floorComplexityScaling: false },
        safeStartRadius: 4,
        visionProfile: 'fullvisibility',
        combatMechanicsProfile: 'none',
        factionProfile: 'fantasy',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Tutorial: First Steps',
        questGatingEnabled: false,
        questPool: [
            { questId: 'quest_collect_keys', chance: 100 },
            { questId: 'quest_explore_75', chance: 100 },
            { questId: 'quest_treasure_hunter', chance: 100 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },

    // ===== FANTASY THEME =====
    'The Ancient Crypt': {
        gridSize: 8, floors: 1, difficulty: 'easy', theme: 'fantasy', mapStyle: 'dungeon', mapVisibility: 'showAll',
        winCommand: '/echo Congratulations! You escaped the dungeon!',
        loseCommand: '/echo The dungeon claims another victim...',
        winMessage: 'You found the exit and escaped the ancient dungeon!',
        winImage: '',
        mainMinion: 'fantasy_guardian',
        mainMinionIntroMessage: 'Welcome to my dungeon, adventurer. Find the exit... if you can!',
        mainMinionRandomChance: 15,
        mainMinionRandomMessages: ['Still wandering, I see...', 'Many have tried. Few have succeeded.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Fantasy - Normal',
        minionEncounters: [
            { minionId: 'fantasy_herald', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'fantasy_merchant', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'fantasy_guardian', percent: 2, zoneMin: 1, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 1 }, { trapId: 'poison_dart', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 10, chestLockedPercent: 20, chestLockedBonusPercent: 50, chestMimicPercent: 5,
        chestLootMin: 2, chestLootMax: 4,
        chestKeyChance: 40, chestStrikeChance: 50, chestStealthChance: 20, chestExecuteChance: 2,
        lockedChestKeyChance: 30, lockedChestStrikeChance: 60, lockedChestStealthChance: 30, lockedChestExecuteChance: 5,
        startingInventory: { key: 2, strike: 2, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 130, battlebarDamageMultiplier: 0.7, onDeath: 'respawn', respawnHPPercent: 75,
        safeRoomCount: 4, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 30, restCooldown: 2, restInterruptChance: 0, restInterruptScript: '',
        storyConfig: { mainStory: 'Cobwebs shroud the entrance to a forgotten crypt. Local villagers whisper of treasures within, guarded only by dust and shadow. A perfect first adventure.' },
        findEarly: { radius: 5, items: ['lantern', 'torch', 'healingPotion', 'mapFragment'], itemsPerChest: 2 },
        fairness: { enabled: true, keyPityThreshold: 3, healingPityThreshold: 4, lowHpThreshold: 0.4, mercyUnlock: true, mercyUnlockThreshold: 2 },
        bspConfig: { zoneCount: 2, secretDensity: 0.02, zonesRequireClear: true, clearThreshold: 0.5, secretHints: true, floorComplexityScaling: false },
        safeStartRadius: 3,
        visionProfile: 'explorer',
        combatMechanicsProfile: 'simple',
        factionProfile: 'fantasy',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Fantasy - Easy',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_collect_keys', chance: 80 },
            { questId: 'quest_defeat_5', chance: 60 },
            { questId: 'quest_treasure_hunter', chance: 70 },
        ],
        itemPool: { enabled: true, items: ['key', 'strike', 'stealth', 'healingPotion', 'greaterHealing', 'torch', 'lantern', 'mapFragment', 'weapon_rusty_sword', 'weapon_iron_sword', 'armor_leather', 'accessory_ring_power', 'repairKit'] },
    },
    'Guardian\'s Domain': {
        gridSize: 10, floors: 2, difficulty: 'normal', theme: 'fantasy', mapStyle: 'dungeon', mapVisibility: 'fogOfWar',
        winCommand: '/echo You emerge victorious from the depths!',
        loseCommand: '/echo The dungeon claims another soul...',
        winMessage: 'Through cunning and courage, you conquered the dungeon!',
        winImage: '',
        mainMinion: 'fantasy_guardian',
        mainMinionIntroMessage: 'The ancient stones whisper of your arrival. Prove yourself worthy!',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['The deeper zones grow more treacherous...', 'Have you found the secrets?'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Fantasy - Normal',
        minionEncounters: [
            { minionId: 'fantasy_herald', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'fantasy_merchant', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'fantasy_guardian', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'fantasy_oracle', percent: 2, zoneMin: 1, zoneMax: 2 },
            { minionId: 'fantasy_knight', percent: 2, zoneMin: 2, zoneMax: 99 },
            { minionId: 'fantasy_mage', percent: 1, zoneMin: 2, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 2 }, { trapId: 'poison_dart', percent: 2 }, { trapId: 'magic_rune', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 8, chestLockedPercent: 30, chestLockedBonusPercent: 50, chestMimicPercent: 10,
        chestLootMin: 1, chestLootMax: 3,
        chestKeyChance: 35, chestStrikeChance: 45, chestStealthChance: 20, chestExecuteChance: 3,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 6,
        startingInventory: { key: 1, strike: 1, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 100, battlebarDamageMultiplier: 1.0, onDeath: 'respawn', respawnHPPercent: 50,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 20, restCooldown: 3, restInterruptChance: 10, restInterruptScript: '',
        storyConfig: { mainStory: 'The Dungeon Guardian has ruled these halls for centuries. Many adventurers have entered seeking glory—their bones now decorate the walls. Will you be different?' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'mapFragment'], itemsPerChest: 1 },
        fairness: { enabled: true, keyPityThreshold: 4, healingPityThreshold: 5, lowHpThreshold: 0.35, mercyUnlock: true, mercyUnlockThreshold: 3 },
        bspConfig: { zoneCount: 3, secretDensity: 0.04, zonesRequireClear: true, clearThreshold: 0.75, secretHints: true, floorComplexityScaling: true },
        safeStartRadius: 2,
        visionProfile: 'default',
        combatMechanicsProfile: 'default',
        factionProfile: 'fantasy',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Fantasy - Normal',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_collect_keys', chance: 70 },
            { questId: 'quest_defeat_5', chance: 80 },
            { questId: 'quest_explore_75', chance: 60 },
            { questId: 'quest_treasure_hunter', chance: 50 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'minionBane', 'portalStone', 'mapFragment', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_shadow_dagger', 'armor_leather', 'armor_chainmail', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'repairKit'] },
    },
    'The Abyss Gauntlet': {
        gridSize: 12, floors: 3, difficulty: 'hard', theme: 'fantasy', mapStyle: 'dungeon', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Glory! You have conquered the depths!',
        loseCommand: '/echo The abyss swallows another soul...',
        winMessage: 'Through blood and steel, you conquered three floors of terror!',
        winImage: '',
        mainMinion: 'fantasy_knight',
        mainMinionIntroMessage: 'You dare challenge my domain? Prove your worth against the gauntlet!',
        mainMinionRandomChance: 25,
        mainMinionRandomMessages: ['Your bones will join the others...', 'The deeper you go, the darker it gets.'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Fantasy - Hard',
        minionEncounters: [
            { minionId: 'fantasy_herald', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'fantasy_guardian', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'fantasy_patrol', percent: 2, zoneMin: 1, zoneMax: 2 },
            { minionId: 'fantasy_knight', percent: 3, zoneMin: 2, zoneMax: 3 },
            { minionId: 'fantasy_mage', percent: 2, zoneMin: 3, zoneMax: 99 },
            { minionId: 'fantasy_assassin', percent: 1, zoneMin: 3, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 3 }, { trapId: 'poison_dart', percent: 3 }, { trapId: 'magic_rune', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 6, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 15,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 40, chestStealthChance: 15, chestExecuteChance: 4,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 8,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.3, onDeath: 'respawnPenalty', respawnHPPercent: 50,
        safeRoomCount: 2, safeRoomHealPercent: 75, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 25, restInterruptScript: '',
        storyConfig: { mainStory: 'The Abyss Gauntlet—three floors of lethal trials designed by a mad archmage. Each zone must be cleared completely. Only the worthy survive.' },
        findEarly: { radius: 3, items: ['torch', 'healingPotion'], itemsPerChest: 1 },
        fairness: { enabled: true, keyPityThreshold: 5, healingPityThreshold: 6, lowHpThreshold: 0.3, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 4, secretDensity: 0.05, zonesRequireClear: true, clearThreshold: 0.9, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 1,
        visionProfile: 'survival',
        combatMechanicsProfile: 'default',
        factionProfile: 'fantasy',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Fantasy - Hard',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 80 },
            { questId: 'quest_explore_75', chance: 70 },
            { questId: 'quest_find_secret', chance: 60 },
            { questId: 'quest_survive_combat', chance: 70 },
            { questId: 'quest_boss_slayer', chance: 50 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
    'Trial of the Damned': {
        gridSize: 14, floors: 4, difficulty: 'nightmare', theme: 'fantasy', mapStyle: 'dungeon', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Against all odds, you have emerged victorious!',
        loseCommand: '/echo Your name joins the list of the fallen...',
        winMessage: 'A true legend! You conquered the nightmare dungeon!',
        winImage: '',
        mainMinion: 'fantasy_mage',
        mainMinionIntroMessage: 'Foolish mortal! None have survived my trials. Your death will be... entertaining.',
        mainMinionRandomChance: 30,
        mainMinionRandomMessages: ['Your suffering has only begun!', 'The dead do not rest here...', 'Run while you still can!'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Fantasy - Nightmare',
        minionEncounters: [
            { minionId: 'fantasy_guardian', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'fantasy_patrol', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'fantasy_knight', percent: 3, zoneMin: 2, zoneMax: 3 },
            { minionId: 'fantasy_mage', percent: 3, zoneMin: 3, zoneMax: 99 },
            { minionId: 'fantasy_assassin', percent: 2, zoneMin: 3, zoneMax: 99 },
            { minionId: 'fantasy_sphinx', percent: 1, zoneMin: 3, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 4 }, { trapId: 'poison_dart', percent: 4 }, { trapId: 'magic_rune', percent: 3 }],
        onBattlebarLoss: 'gameover',
        chestTilePercent: 5, chestLockedPercent: 50, chestLockedBonusPercent: 70, chestMimicPercent: 25,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 25, chestStrikeChance: 35, chestStealthChance: 15, chestExecuteChance: 5,
        lockedChestKeyChance: 20, lockedChestStrikeChance: 50, lockedChestStealthChance: 25, lockedChestExecuteChance: 10,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, ironGuard: 1 },
        hpEnabled: true, maxHP: 70, battlebarDamageMultiplier: 1.5, onDeath: 'gameover', respawnHPPercent: 25,
        safeRoomCount: 2, safeRoomHealPercent: 60, safeRoomUseLLM: true,
        restEnabled: true, restHealPercent: 10, restCooldown: 5, restInterruptChance: 35, restInterruptScript: '',
        storyConfig: { mainStory: 'The Trial of the Damned—four floors where the souls of fallen heroes wander eternally. No supplies. No mercy. Permadeath. Your legend begins or ends here.' },
        findEarly: { radius: 2, items: ['torch'], itemsPerChest: 1 },
        fairness: { enabled: false, keyPityThreshold: 0, healingPityThreshold: 0, lowHpThreshold: 0, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 4, secretDensity: 0.06, zonesRequireClear: true, clearThreshold: 1.0, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 0,
        visionProfile: 'survival',
        combatMechanicsProfile: 'aggressive',
        factionProfile: 'fantasy',
        permadeathEnabled: true,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Fantasy - Nightmare',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 90 },
            { questId: 'quest_explore_75', chance: 80 },
            { questId: 'quest_find_secret', chance: 70 },
            { questId: 'quest_survive_combat', chance: 80 },
            { questId: 'quest_boss_slayer', chance: 60 },
            { questId: 'quest_full_clear', chance: 40 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
    'Extinction\'s Edge': {
        gridSize: 16, floors: 5, difficulty: 'apocalypse', theme: 'fantasy', mapStyle: 'dungeon', mapVisibility: 'hideUnexplored',
        winCommand: '/echo IMPOSSIBLE! You have achieved the impossible!',
        loseCommand: '/echo As expected. The apocalypse spares no one.',
        winMessage: 'LEGENDARY! You conquered the apocalypse dungeon! Your name echoes through eternity!',
        winImage: '',
        mainMinion: 'fantasy_sphinx',
        mainMinionIntroMessage: 'The ultimate challenge awaits. Five floors. No mercy. Only legends survive.',
        mainMinionRandomChance: 35,
        mainMinionRandomMessages: ['DEATH COMES FOR ALL!', 'YOUR SOUL IS MINE!', 'NONE ESCAPE THE APOCALYPSE!'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Fantasy - Apocalypse',
        minionEncounters: [
            { minionId: 'fantasy_patrol', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'fantasy_knight', percent: 4, zoneMin: 1, zoneMax: 2 },
            { minionId: 'fantasy_mage', percent: 4, zoneMin: 2, zoneMax: 3 },
            { minionId: 'fantasy_assassin', percent: 3, zoneMin: 3, zoneMax: 4 },
            { minionId: 'fantasy_sphinx', percent: 2, zoneMin: 4, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 5 }, { trapId: 'poison_dart', percent: 5 }, { trapId: 'magic_rune', percent: 4 }],
        onBattlebarLoss: 'gameover',
        chestTilePercent: 4, chestLockedPercent: 60, chestLockedBonusPercent: 80, chestMimicPercent: 35,
        chestLootMin: 1, chestLootMax: 1,
        chestKeyChance: 20, chestStrikeChance: 30, chestStealthChance: 10, chestExecuteChance: 5,
        lockedChestKeyChance: 15, lockedChestStrikeChance: 45, lockedChestStealthChance: 20, lockedChestExecuteChance: 12,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, ironGuard: 1 },
        hpEnabled: true, maxHP: 60, battlebarDamageMultiplier: 2.0, onDeath: 'gameover', respawnHPPercent: 0,
        safeRoomCount: 1, safeRoomHealPercent: 40, safeRoomUseLLM: true,
        restEnabled: true, restHealPercent: 5, restCooldown: 6, restInterruptChance: 50, restInterruptScript: '',
        storyConfig: { mainStory: 'EXTINCTION\'S EDGE—the final test. Five floors of absolute death where ancient evils await. No equipment. No second chances. Your run will be recorded in the halls of legend... or forgotten forever.' },
        findEarly: { radius: 0, items: [], itemsPerChest: 0 },
        fairness: { enabled: false, keyPityThreshold: 0, healingPityThreshold: 0, lowHpThreshold: 0, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 5, secretDensity: 0.08, zonesRequireClear: true, clearThreshold: 1.0, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 0,
        visionProfile: 'survival',
        combatMechanicsProfile: 'lethal',
        factionProfile: 'fantasy',
        permadeathEnabled: true,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Fantasy - Apocalypse',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 100 },
            { questId: 'quest_explore_75', chance: 90 },
            { questId: 'quest_find_secret', chance: 80 },
            { questId: 'quest_survive_combat', chance: 90 },
            { questId: 'quest_boss_slayer', chance: 70 },
            { questId: 'quest_full_clear', chance: 60 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },

    // ===== HORROR THEME =====
    'The Haunted Manor': {
        gridSize: 8, floors: 1, difficulty: 'easy', theme: 'horror', mapStyle: 'apartment', mapVisibility: 'showAll',
        winCommand: '/echo You escape the haunted manor!',
        loseCommand: '/echo The spirits claim another soul...',
        winMessage: 'You escaped the haunted manor... but the nightmares will follow.',
        winImage: '',
        mainMinion: 'horror_revenant',
        mainMinionIntroMessage: 'Welcome to my home... you will never leave...',
        mainMinionRandomChance: 15,
        mainMinionRandomMessages: ['I can smell your fear...', 'The walls are watching...'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Horror - Normal',
        minionEncounters: [
            { minionId: 'horror_gambler', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'horror_graverobber', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'horror_spirit', percent: 2, zoneMin: 1, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'ghostly_grasp', percent: 1 }, { trapId: 'blood_pool', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 10, chestLockedPercent: 20, chestLockedBonusPercent: 50, chestMimicPercent: 10,
        chestLootMin: 2, chestLootMax: 4,
        chestKeyChance: 40, chestStrikeChance: 50, chestStealthChance: 25, chestExecuteChance: 2,
        lockedChestKeyChance: 30, lockedChestStrikeChance: 55, lockedChestStealthChance: 30, lockedChestExecuteChance: 5,
        startingInventory: { key: 2, strike: 2, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 130, battlebarDamageMultiplier: 0.7, onDeath: 'respawn', respawnHPPercent: 75,
        safeRoomCount: 4, safeRoomHealPercent: 100, safeRoomUseLLM: true,
        restEnabled: true, restHealPercent: 30, restCooldown: 2, restInterruptChance: 15, restInterruptScript: '',
        storyConfig: { mainStory: 'The old Blackwood Manor has stood empty for decades. Tonight, lights flicker in the windows. The door creaks open as you approach, as if expecting you...' },
        findEarly: { radius: 5, items: ['lantern', 'torch', 'healingPotion', 'mapFragment'], itemsPerChest: 2 },
        fairness: { enabled: true, keyPityThreshold: 3, healingPityThreshold: 4, lowHpThreshold: 0.4, mercyUnlock: true, mercyUnlockThreshold: 2 },
        bspConfig: { zoneCount: 2, secretDensity: 0.02, zonesRequireClear: true, clearThreshold: 0.5, secretHints: true, floorComplexityScaling: false },
        safeStartRadius: 3,
        visionProfile: 'explorer',
        combatMechanicsProfile: 'simple',
        factionProfile: 'horror',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Horror - Easy',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_collect_keys', chance: 80 },
            { questId: 'quest_defeat_5', chance: 60 },
            { questId: 'quest_treasure_hunter', chance: 70 },
        ],
        itemPool: { enabled: true, items: ['key', 'strike', 'stealth', 'healingPotion', 'greaterHealing', 'torch', 'lantern', 'mapFragment', 'weapon_rusty_sword', 'weapon_iron_sword', 'armor_leather', 'accessory_ring_power', 'repairKit'] },
    },
    'Asylum of Whispers': {
        gridSize: 10, floors: 2, difficulty: 'normal', theme: 'horror', mapStyle: 'hospital', mapVisibility: 'fogOfWar',
        winCommand: '/echo You escape the asylum!',
        loseCommand: '/echo The darkness consumes you...',
        winMessage: 'You escaped the cursed hospital, but the memories remain...',
        winImage: '',
        mainMinion: 'horror_revenant',
        mainMinionIntroMessage: 'The patients are restless tonight... and so are the dead.',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['Do you hear the whispers?', 'Something is following you...', 'The shadows move...'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Horror Encounter',
        minionEncounters: [
            { minionId: 'horror_gambler', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'horror_pact', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'horror_spirit', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'horror_revenant', percent: 2, zoneMin: 1, zoneMax: 2 },
            { minionId: 'horror_wraith', percent: 2, zoneMin: 2, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'ghostly_grasp', percent: 2 }, { trapId: 'blood_pool', percent: 2 }, { trapId: 'cursed_mirror', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 8, chestLockedPercent: 30, chestLockedBonusPercent: 50, chestMimicPercent: 15,
        chestLootMin: 1, chestLootMax: 3,
        chestKeyChance: 35, chestStrikeChance: 45, chestStealthChance: 25, chestExecuteChance: 3,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 30, lockedChestExecuteChance: 6,
        startingInventory: { key: 1, strike: 1, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 100, battlebarDamageMultiplier: 1.0, onDeath: 'respawn', respawnHPPercent: 50,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: true,
        restEnabled: true, restHealPercent: 20, restCooldown: 3, restInterruptChance: 20, restInterruptScript: '',
        storyConfig: { mainStory: 'The abandoned hospital looms before you. Two floors of terror await...' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'mapFragment'], itemsPerChest: 1 },
        fairness: { enabled: true, keyPityThreshold: 4, healingPityThreshold: 5, lowHpThreshold: 0.35, mercyUnlock: true, mercyUnlockThreshold: 3 },
        bspConfig: { zoneCount: 3, secretDensity: 0.04, zonesRequireClear: true, clearThreshold: 0.75, secretHints: true, floorComplexityScaling: true },
        safeStartRadius: 2,
        visionProfile: 'default',
        combatMechanicsProfile: 'default',
        factionProfile: 'horror',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Horror - Normal',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_collect_keys', chance: 70 },
            { questId: 'quest_defeat_5', chance: 80 },
            { questId: 'quest_explore_75', chance: 60 },
            { questId: 'quest_treasure_hunter', chance: 50 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'minionBane', 'portalStone', 'mapFragment', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_shadow_dagger', 'armor_leather', 'armor_chainmail', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'repairKit'] },
    },
    'Catacombs of Dread': {
        gridSize: 12, floors: 3, difficulty: 'hard', theme: 'horror', mapStyle: 'highrise', mapVisibility: 'hideUnexplored',
        winCommand: '/echo You survived the nightmare!',
        loseCommand: '/echo Your screams echo eternally...',
        winMessage: 'Against all odds, you escaped the tower of horrors!',
        winImage: '',
        mainMinion: 'horror_butcher',
        mainMinionIntroMessage: 'Fresh meat... the hunt begins.',
        mainMinionRandomChance: 25,
        mainMinionRandomMessages: ['I can hear your heartbeat...', 'RUN!', 'There is no escape...'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Horror - Hard',
        minionEncounters: [
            { minionId: 'horror_spirit', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'horror_stalker', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'horror_mirror', percent: 2, zoneMin: 1, zoneMax: 2 },
            { minionId: 'horror_wraith', percent: 3, zoneMin: 2, zoneMax: 3 },
            { minionId: 'horror_butcher', percent: 2, zoneMin: 3, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'ghostly_grasp', percent: 3 }, { trapId: 'blood_pool', percent: 3 }, { trapId: 'cursed_mirror', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 6, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 20,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 40, chestStealthChance: 20, chestExecuteChance: 4,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 30, lockedChestExecuteChance: 8,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.3, onDeath: 'respawnPenalty', respawnHPPercent: 50,
        safeRoomCount: 2, safeRoomHealPercent: 75, safeRoomUseLLM: true,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 30, restInterruptScript: '',
        storyConfig: { mainStory: 'Three floors of pure horror. The hunters are everywhere...' },
        findEarly: { radius: 3, items: ['torch', 'healingPotion'], itemsPerChest: 1 },
        fairness: { enabled: true, keyPityThreshold: 5, healingPityThreshold: 6, lowHpThreshold: 0.3, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 4, secretDensity: 0.05, zonesRequireClear: true, clearThreshold: 0.9, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 1,
        visionProfile: 'survival',
        combatMechanicsProfile: 'default',
        factionProfile: 'horror',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Horror - Hard',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 80 },
            { questId: 'quest_explore_75', chance: 70 },
            { questId: 'quest_find_secret', chance: 60 },
            { questId: 'quest_survive_combat', chance: 70 },
            { questId: 'quest_boss_slayer', chance: 50 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
    'The Endless Dark': {
        gridSize: 14, floors: 4, difficulty: 'nightmare', theme: 'horror', mapStyle: 'hospital', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Against all odds, you survived!',
        loseCommand: '/echo Your screams echo for eternity...',
        winMessage: 'You escaped... but at what cost?',
        winImage: '',
        mainMinion: 'horror_demon',
        mainMinionIntroMessage: 'There is no escape. There never was.',
        mainMinionRandomChance: 30,
        mainMinionRandomMessages: ['YOU CANNOT RUN!', 'DEATH IS ONLY THE BEGINNING!', 'JOIN US...'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Horror - Nightmare',
        minionEncounters: [
            { minionId: 'horror_stalker', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'horror_wraith', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'horror_butcher', percent: 3, zoneMin: 2, zoneMax: 3 },
            { minionId: 'horror_crawler', percent: 3, zoneMin: 3, zoneMax: 99 },
            { minionId: 'horror_demon', percent: 2, zoneMin: 3, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'ghostly_grasp', percent: 4 }, { trapId: 'blood_pool', percent: 4 }, { trapId: 'cursed_mirror', percent: 3 }],
        onBattlebarLoss: 'gameover',
        chestTilePercent: 5, chestLockedPercent: 50, chestLockedBonusPercent: 70, chestMimicPercent: 25,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 25, chestStrikeChance: 35, chestStealthChance: 20, chestExecuteChance: 5,
        lockedChestKeyChance: 20, lockedChestStrikeChance: 50, lockedChestStealthChance: 30, lockedChestExecuteChance: 10,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, ironGuard: 1 },
        hpEnabled: true, maxHP: 70, battlebarDamageMultiplier: 1.5, onDeath: 'gameover', respawnHPPercent: 25,
        safeRoomCount: 2, safeRoomHealPercent: 60, safeRoomUseLLM: true,
        restEnabled: true, restHealPercent: 10, restCooldown: 5, restInterruptChance: 40, restInterruptScript: '',
        storyConfig: { mainStory: 'Four floors of pure terror. No supplies. No mercy. Permadeath enabled...' },
        findEarly: { radius: 2, items: ['torch'], itemsPerChest: 1 },
        fairness: { enabled: false, keyPityThreshold: 0, healingPityThreshold: 0, lowHpThreshold: 0, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 4, secretDensity: 0.06, zonesRequireClear: true, clearThreshold: 1.0, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 0,
        visionProfile: 'survival',
        combatMechanicsProfile: 'aggressive',
        factionProfile: 'horror',
        permadeathEnabled: true,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Horror - Nightmare',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 90 },
            { questId: 'quest_explore_75', chance: 80 },
            { questId: 'quest_find_secret', chance: 70 },
            { questId: 'quest_survive_combat', chance: 80 },
            { questId: 'quest_boss_slayer', chance: 60 },
            { questId: 'quest_full_clear', chance: 40 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
    'Hell\'s Threshold': {
        gridSize: 16, floors: 5, difficulty: 'apocalypse', theme: 'horror', mapStyle: 'hospital', mapVisibility: 'hideUnexplored',
        winCommand: '/echo IMPOSSIBLE! You escaped the abyss!',
        loseCommand: '/echo Your soul is claimed forever...',
        winMessage: 'LEGENDARY! You survived the apocalypse nightmare!',
        winImage: '',
        mainMinion: 'horror_demon',
        mainMinionIntroMessage: 'Welcome to hell. Population: soon to include you.',
        mainMinionRandomChance: 35,
        mainMinionRandomMessages: ['YOUR SOUL IS MINE!', 'THERE IS NO GOD HERE!', 'EMBRACE THE VOID!'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Horror - Apocalypse',
        minionEncounters: [
            { minionId: 'horror_wraith', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'horror_butcher', percent: 4, zoneMin: 1, zoneMax: 2 },
            { minionId: 'horror_crawler', percent: 4, zoneMin: 2, zoneMax: 3 },
            { minionId: 'horror_demon', percent: 3, zoneMin: 3, zoneMax: 4 },
        ],
        trapEncounters: [{ trapId: 'ghostly_grasp', percent: 5 }, { trapId: 'blood_pool', percent: 5 }, { trapId: 'cursed_mirror', percent: 4 }],
        onBattlebarLoss: 'gameover',
        chestTilePercent: 4, chestLockedPercent: 60, chestLockedBonusPercent: 80, chestMimicPercent: 35,
        chestLootMin: 1, chestLootMax: 1,
        chestKeyChance: 20, chestStrikeChance: 30, chestStealthChance: 15, chestExecuteChance: 5,
        lockedChestKeyChance: 15, lockedChestStrikeChance: 45, lockedChestStealthChance: 25, lockedChestExecuteChance: 12,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, ironGuard: 1 },
        hpEnabled: true, maxHP: 60, battlebarDamageMultiplier: 2.0, onDeath: 'gameover', respawnHPPercent: 0,
        safeRoomCount: 1, safeRoomHealPercent: 40, safeRoomUseLLM: true,
        restEnabled: true, restHealPercent: 5, restCooldown: 6, restInterruptChance: 50, restInterruptScript: '',
        storyConfig: { mainStory: 'APOCALYPSE MODE: Five floors of hell itself. Your death is certain. Prove us wrong.' },
        findEarly: { radius: 0, items: [], itemsPerChest: 0 },
        fairness: { enabled: false, keyPityThreshold: 0, healingPityThreshold: 0, lowHpThreshold: 0, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 5, secretDensity: 0.08, zonesRequireClear: true, clearThreshold: 1.0, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 0,
        visionProfile: 'survival',
        combatMechanicsProfile: 'lethal',
        factionProfile: 'horror',
        permadeathEnabled: true,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Horror - Apocalypse',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 100 },
            { questId: 'quest_explore_75', chance: 90 },
            { questId: 'quest_find_secret', chance: 80 },
            { questId: 'quest_survive_combat', chance: 90 },
            { questId: 'quest_boss_slayer', chance: 70 },
            { questId: 'quest_full_clear', chance: 60 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },

    // ===== SCI-FI THEME =====
    'Station Orientation': {
        gridSize: 8, floors: 1, difficulty: 'easy', theme: 'scifi', mapStyle: 'spacestation', mapVisibility: 'showAll',
        winCommand: '/echo Mission complete. Extraction successful.',
        loseCommand: '/echo Hull breach detected. Life signs terminated.',
        winMessage: 'You reached the escape pods and evacuated safely!',
        winImage: '',
        mainMinion: 'scifi_bot',
        mainMinionIntroMessage: 'WELCOME ABOARD. PROCEED TO DESIGNATED EXIT POINT.',
        mainMinionRandomChance: 15,
        mainMinionRandomMessages: ['SCANNING AREA...', 'PROCEED WITH CAUTION.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Security Drone',
        minionEncounters: [
            { minionId: 'scifi_terminal', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'scifi_ai', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'scifi_bot', percent: 2, zoneMin: 1, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'laser_grid', percent: 1 }, { trapId: 'gas_leak', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 10, chestLockedPercent: 20, chestLockedBonusPercent: 50, chestMimicPercent: 5,
        chestLootMin: 2, chestLootMax: 4,
        chestKeyChance: 40, chestStrikeChance: 50, chestStealthChance: 20, chestExecuteChance: 2,
        lockedChestKeyChance: 30, lockedChestStrikeChance: 60, lockedChestStealthChance: 30, lockedChestExecuteChance: 5,
        startingInventory: { key: 2, strike: 2, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 130, battlebarDamageMultiplier: 0.7, onDeath: 'respawn', respawnHPPercent: 75,
        safeRoomCount: 4, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 30, restCooldown: 2, restInterruptChance: 0, restInterruptScript: '',
        storyConfig: { mainStory: 'The station awaits. Navigate to the extraction point...' },
        findEarly: { radius: 5, items: ['lantern', 'torch', 'healingPotion', 'mapFragment'], itemsPerChest: 2 },
        fairness: { enabled: true, keyPityThreshold: 3, healingPityThreshold: 4, lowHpThreshold: 0.4, mercyUnlock: true, mercyUnlockThreshold: 2 },
        bspConfig: { zoneCount: 2, secretDensity: 0.02, zonesRequireClear: true, clearThreshold: 0.5, secretHints: true, floorComplexityScaling: false },
        safeStartRadius: 3,
        visionProfile: 'explorer',
        combatMechanicsProfile: 'simple',
        factionProfile: 'scifi',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Sci-Fi - Easy',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_collect_keys', chance: 80 },
            { questId: 'quest_defeat_5', chance: 60 },
            { questId: 'quest_treasure_hunter', chance: 70 },
        ],
        itemPool: { enabled: true, items: ['key', 'strike', 'stealth', 'healingPotion', 'greaterHealing', 'torch', 'lantern', 'mapFragment', 'weapon_rusty_sword', 'weapon_iron_sword', 'armor_leather', 'accessory_ring_power', 'repairKit'] },
    },
    'Lockdown Protocol': {
        gridSize: 10, floors: 2, difficulty: 'normal', theme: 'scifi', mapStyle: 'spacestation', mapVisibility: 'fogOfWar',
        winCommand: '/echo Mission complete. Extraction successful.',
        loseCommand: '/echo Hull breach detected. Life signs terminated.',
        winMessage: 'You reached the escape pods and evacuated safely!',
        winImage: '',
        mainMinion: 'scifi_bot',
        mainMinionIntroMessage: 'UNAUTHORIZED PERSONNEL DETECTED. INITIATING LOCKDOWN.',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['SCANNING... THREAT LEVEL ELEVATED.', 'SECURITY PROTOCOLS ACTIVE.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Security Drone',
        minionEncounters: [
            { minionId: 'scifi_terminal', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'scifi_ai', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'scifi_bot', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'scifi_sensors', percent: 2, zoneMin: 1, zoneMax: 2 },
            { minionId: 'scifi_commander', percent: 1, zoneMin: 2, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'laser_grid', percent: 2 }, { trapId: 'gas_leak', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 8, chestLockedPercent: 30, chestLockedBonusPercent: 50, chestMimicPercent: 10,
        chestLootMin: 1, chestLootMax: 3,
        chestKeyChance: 35, chestStrikeChance: 45, chestStealthChance: 20, chestExecuteChance: 3,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 7,
        startingInventory: { key: 1, strike: 1, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 100, battlebarDamageMultiplier: 1.0, onDeath: 'respawn', respawnHPPercent: 50,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 20, restCooldown: 3, restInterruptChance: 15, restInterruptScript: '',
        storyConfig: { mainStory: 'The station alarms blare. Find the escape pods before it\'s too late...' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'mapFragment'], itemsPerChest: 1 },
        fairness: { enabled: true, keyPityThreshold: 4, healingPityThreshold: 5, lowHpThreshold: 0.35, mercyUnlock: true, mercyUnlockThreshold: 3 },
        bspConfig: { zoneCount: 3, secretDensity: 0.04, zonesRequireClear: true, clearThreshold: 0.75, secretHints: true, floorComplexityScaling: true },
        safeStartRadius: 2,
        visionProfile: 'default',
        combatMechanicsProfile: 'default',
        factionProfile: 'scifi',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Sci-Fi - Normal',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_collect_keys', chance: 70 },
            { questId: 'quest_defeat_5', chance: 80 },
            { questId: 'quest_explore_75', chance: 60 },
            { questId: 'quest_treasure_hunter', chance: 50 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'minionBane', 'portalStone', 'mapFragment', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_shadow_dagger', 'armor_leather', 'armor_chainmail', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'repairKit'] },
    },
    'Rogue AI Uprising': {
        gridSize: 12, floors: 3, difficulty: 'hard', theme: 'scifi', mapStyle: 'spacestation', mapVisibility: 'hideUnexplored',
        winCommand: '/echo EXTRACTION COMPLETE. WELL DONE, OPERATIVE.',
        loseCommand: '/echo MISSION FAILED. ASSET TERMINATED.',
        winMessage: 'Against impossible odds, you escaped the derelict station!',
        winImage: '',
        mainMinion: 'scifi_commander',
        mainMinionIntroMessage: 'CRITICAL ALERT: HOSTILE AI HAS TAKEN CONTROL.',
        mainMinionRandomChance: 25,
        mainMinionRandomMessages: ['RESISTANCE IS FUTILE.', 'ALL SECTORS COMPROMISED.'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'System Override',
        minionEncounters: [
            { minionId: 'scifi_bot', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'scifi_sensors', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'scifi_terminal_puzzle', percent: 2, zoneMin: 1, zoneMax: 2 },
            { minionId: 'scifi_commander', percent: 3, zoneMin: 2, zoneMax: 3 },
            { minionId: 'scifi_mech', percent: 2, zoneMin: 3, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'laser_grid', percent: 3 }, { trapId: 'gas_leak', percent: 3 }, { trapId: 'gravity_trap', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 6, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 15,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 40, chestStealthChance: 15, chestExecuteChance: 4,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 50, lockedChestStealthChance: 25, lockedChestExecuteChance: 8,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.3, onDeath: 'respawnPenalty', respawnHPPercent: 40,
        safeRoomCount: 2, safeRoomHealPercent: 75, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 25, restInterruptScript: '',
        storyConfig: { mainStory: 'Three decks. Rogue AI. Failing life support. Move fast or die...' },
        findEarly: { radius: 3, items: ['torch', 'healingPotion'], itemsPerChest: 1 },
        fairness: { enabled: true, keyPityThreshold: 5, healingPityThreshold: 6, lowHpThreshold: 0.3, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 4, secretDensity: 0.05, zonesRequireClear: true, clearThreshold: 0.9, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 1,
        visionProfile: 'survival',
        combatMechanicsProfile: 'default',
        factionProfile: 'scifi',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Sci-Fi - Hard',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 80 },
            { questId: 'quest_explore_75', chance: 70 },
            { questId: 'quest_find_secret', chance: 60 },
            { questId: 'quest_survive_combat', chance: 70 },
            { questId: 'quest_boss_slayer', chance: 50 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
    'Total System Failure': {
        gridSize: 14, floors: 4, difficulty: 'nightmare', theme: 'scifi', mapStyle: 'spacestation', mapVisibility: 'hideUnexplored',
        winCommand: '/echo IMPOSSIBLE MISSION COMPLETED. YOU ARE A LEGEND.',
        loseCommand: '/echo TOTAL SYSTEM FAILURE. NO SURVIVORS.',
        winMessage: 'You escaped the nightmare station! A true survivor!',
        winImage: '',
        mainMinion: 'scifi_mech',
        mainMinionIntroMessage: 'STATION CONTAINMENT BREACHED. EXTERMINATION PROTOCOL ACTIVE.',
        mainMinionRandomChance: 30,
        mainMinionRandomMessages: ['TERMINATE ALL HOSTILES.', 'NO ESCAPE DETECTED.', 'DEATH IMMINENT.'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Sci-Fi - Nightmare',
        minionEncounters: [
            { minionId: 'scifi_sensors', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'scifi_commander', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'scifi_mech', percent: 3, zoneMin: 2, zoneMax: 3 },
            { minionId: 'scifi_drone', percent: 3, zoneMin: 3, zoneMax: 99 },
            { minionId: 'scifi_quantum', percent: 2, zoneMin: 3, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'laser_grid', percent: 4 }, { trapId: 'gas_leak', percent: 4 }, { trapId: 'gravity_trap', percent: 3 }],
        onBattlebarLoss: 'gameover',
        chestTilePercent: 5, chestLockedPercent: 50, chestLockedBonusPercent: 70, chestMimicPercent: 25,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 25, chestStrikeChance: 35, chestStealthChance: 15, chestExecuteChance: 5,
        lockedChestKeyChance: 20, lockedChestStrikeChance: 50, lockedChestStealthChance: 25, lockedChestExecuteChance: 10,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, ironGuard: 1 },
        hpEnabled: true, maxHP: 70, battlebarDamageMultiplier: 1.5, onDeath: 'gameover', respawnHPPercent: 25,
        safeRoomCount: 2, safeRoomHealPercent: 60, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 10, restCooldown: 5, restInterruptChance: 35, restInterruptScript: '',
        storyConfig: { mainStory: 'Station Prometheus has gone dark. Every system has failed. The AI core has gone rogue and sealed all bulkheads. You have four decks of pure nightmare between you and the last escape pod.' },
        findEarly: { radius: 2, items: ['torch'], itemsPerChest: 1 },
        fairness: { enabled: false, keyPityThreshold: 0, healingPityThreshold: 0, lowHpThreshold: 0, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 4, secretDensity: 0.06, zonesRequireClear: true, clearThreshold: 1.0, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 0,
        visionProfile: 'survival',
        combatMechanicsProfile: 'aggressive',
        factionProfile: 'scifi',
        permadeathEnabled: true,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Sci-Fi - Nightmare',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 90 },
            { questId: 'quest_explore_75', chance: 80 },
            { questId: 'quest_find_secret', chance: 70 },
            { questId: 'quest_survive_combat', chance: 80 },
            { questId: 'quest_boss_slayer', chance: 60 },
            { questId: 'quest_full_clear', chance: 40 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
    'Extinction Event': {
        gridSize: 16, floors: 5, difficulty: 'apocalypse', theme: 'scifi', mapStyle: 'spacestation', mapVisibility: 'hideUnexplored',
        winCommand: '/echo LEGENDARY ACHIEVEMENT UNLOCKED. THE IMPOSSIBLE MADE POSSIBLE.',
        loseCommand: '/echo STATION LOST. OPERATIVE TERMINATED.',
        winMessage: 'LEGENDARY! You escaped the apocalypse station!',
        winImage: '',
        mainMinion: 'scifi_quantum',
        mainMinionIntroMessage: 'APOCALYPSE PROTOCOL INITIATED. SURVIVAL PROBABILITY: 0.001%',
        mainMinionRandomChance: 35,
        mainMinionRandomMessages: ['RESISTANCE IS ILLOGICAL.', 'YOUR ATOMS WILL BE RECYCLED.', 'END SEQUENCE INITIATED.'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Sci-Fi - Apocalypse',
        minionEncounters: [
            { minionId: 'scifi_commander', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'scifi_mech', percent: 4, zoneMin: 1, zoneMax: 2 },
            { minionId: 'scifi_drone', percent: 4, zoneMin: 2, zoneMax: 3 },
            { minionId: 'scifi_quantum', percent: 3, zoneMin: 3, zoneMax: 4 },
        ],
        trapEncounters: [{ trapId: 'laser_grid', percent: 5 }, { trapId: 'gas_leak', percent: 5 }, { trapId: 'gravity_trap', percent: 4 }],
        onBattlebarLoss: 'gameover',
        chestTilePercent: 4, chestLockedPercent: 60, chestLockedBonusPercent: 80, chestMimicPercent: 35,
        chestLootMin: 1, chestLootMax: 1,
        chestKeyChance: 20, chestStrikeChance: 30, chestStealthChance: 10, chestExecuteChance: 5,
        lockedChestKeyChance: 15, lockedChestStrikeChance: 45, lockedChestStealthChance: 20, lockedChestExecuteChance: 12,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, ironGuard: 1 },
        hpEnabled: true, maxHP: 60, battlebarDamageMultiplier: 2.0, onDeath: 'gameover', respawnHPPercent: 0,
        safeRoomCount: 1, safeRoomHealPercent: 40, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 5, restCooldown: 6, restInterruptChance: 50, restInterruptScript: '',
        storyConfig: { mainStory: 'The station has been quarantined. Inside, an extinction-level xenomorph has awakened. Five decks stand between you and the self-destruct override. No one has ever returned from EXTINCTION EVENT.' },
        findEarly: { radius: 0, items: [], itemsPerChest: 0 },
        fairness: { enabled: false, keyPityThreshold: 0, healingPityThreshold: 0, lowHpThreshold: 0, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 5, secretDensity: 0.08, zonesRequireClear: true, clearThreshold: 1.0, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 0,
        visionProfile: 'survival',
        combatMechanicsProfile: 'lethal',
        factionProfile: 'scifi',
        permadeathEnabled: true,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Sci-Fi - Apocalypse',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 100 },
            { questId: 'quest_explore_75', chance: 90 },
            { questId: 'quest_find_secret', chance: 80 },
            { questId: 'quest_survive_combat', chance: 90 },
            { questId: 'quest_boss_slayer', chance: 70 },
            { questId: 'quest_full_clear', chance: 60 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },

    // ===== CYBERPUNK THEME =====
    'Neon Streets': {
        gridSize: 8, floors: 1, difficulty: 'easy', theme: 'cyberpunk', mapStyle: 'neotokyo', mapVisibility: 'showAll',
        winCommand: '/echo Run complete. Easy payout, choom.',
        loseCommand: '/echo Flatlined. Better luck next time.',
        winMessage: 'You navigated the neon streets successfully!',
        winImage: '',
        mainMinion: 'cyber_fixer',
        mainMinionIntroMessage: 'Hey choom, new to the grid? Let me show you around.',
        mainMinionRandomChance: 15,
        mainMinionRandomMessages: ['Stay low, stay alive.', 'The corps are watching.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Street Fight',
        minionEncounters: [
            { minionId: 'cyber_market', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'cyber_fixer', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'cyber_enforcer', percent: 2, zoneMin: 1, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'electric_floor', percent: 1 }, { trapId: 'neural_spike', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 10, chestLockedPercent: 20, chestLockedBonusPercent: 50, chestMimicPercent: 5,
        chestLootMin: 2, chestLootMax: 4,
        chestKeyChance: 40, chestStrikeChance: 50, chestStealthChance: 20, chestExecuteChance: 2,
        lockedChestKeyChance: 30, lockedChestStrikeChance: 60, lockedChestStealthChance: 30, lockedChestExecuteChance: 5,
        startingInventory: { key: 2, strike: 2, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 130, battlebarDamageMultiplier: 0.7, onDeath: 'respawn', respawnHPPercent: 75,
        safeRoomCount: 4, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 30, restCooldown: 2, restInterruptChance: 10, restInterruptScript: '',
        storyConfig: { mainStory: 'Welcome to Night City, choom. The neon-drenched streets are full of opportunity—and danger. A simple courier run awaits. Easy eddies for a new runner.' },
        findEarly: { radius: 5, items: ['lantern', 'torch', 'healingPotion', 'mapFragment'], itemsPerChest: 2 },
        fairness: { enabled: true, keyPityThreshold: 3, healingPityThreshold: 4, lowHpThreshold: 0.4, mercyUnlock: true, mercyUnlockThreshold: 2 },
        bspConfig: { zoneCount: 2, secretDensity: 0.02, zonesRequireClear: true, clearThreshold: 0.5, secretHints: true, floorComplexityScaling: false },
        safeStartRadius: 3,
        visionProfile: 'explorer',
        combatMechanicsProfile: 'simple',
        factionProfile: 'cyberpunk',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Cyberpunk - Easy',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_collect_keys', chance: 80 },
            { questId: 'quest_defeat_5', chance: 60 },
            { questId: 'quest_treasure_hunter', chance: 70 },
        ],
        itemPool: { enabled: true, items: ['key', 'strike', 'stealth', 'healingPotion', 'greaterHealing', 'torch', 'lantern', 'mapFragment', 'weapon_rusty_sword', 'weapon_iron_sword', 'armor_leather', 'accessory_ring_power', 'repairKit'] },
    },
    'Corporate Heist': {
        gridSize: 10, floors: 2, difficulty: 'normal', theme: 'cyberpunk', mapStyle: 'neotokyo', mapVisibility: 'fogOfWar',
        winCommand: '/echo Run complete. Payout received, choom.',
        loseCommand: '/echo Flatlined. Your chrome belongs to the corp now.',
        winMessage: 'You made it through the neon jungle!',
        winImage: '',
        mainMinion: 'cyber_enforcer',
        mainMinionIntroMessage: 'You picked the wrong sector to run through, meat.',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['Corp knows you\'re here.', 'No one escapes the grid.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Street Fight',
        minionEncounters: [
            { minionId: 'cyber_market', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'cyber_fixer', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'cyber_enforcer', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'cyber_patrol', percent: 2, zoneMin: 1, zoneMax: 2 },
            { minionId: 'cyber_samurai', percent: 1, zoneMin: 2, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'electric_floor', percent: 2 }, { trapId: 'neural_spike', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 8, chestLockedPercent: 30, chestLockedBonusPercent: 50, chestMimicPercent: 10,
        chestLootMin: 1, chestLootMax: 3,
        chestKeyChance: 35, chestStrikeChance: 45, chestStealthChance: 20, chestExecuteChance: 3,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 7,
        startingInventory: { key: 1, strike: 1, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 100, battlebarDamageMultiplier: 1.0, onDeath: 'respawn', respawnHPPercent: 50,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 20, restCooldown: 3, restInterruptChance: 20, restInterruptScript: '',
        storyConfig: { mainStory: 'Militech Tower holds the prototype. Your fixer says it\'s worth a fortune. Two floors of corporate security stand between you and the biggest score of your career.' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'mapFragment'], itemsPerChest: 1 },
        fairness: { enabled: true, keyPityThreshold: 4, healingPityThreshold: 5, lowHpThreshold: 0.35, mercyUnlock: true, mercyUnlockThreshold: 3 },
        bspConfig: { zoneCount: 3, secretDensity: 0.04, zonesRequireClear: true, clearThreshold: 0.75, secretHints: true, floorComplexityScaling: true },
        safeStartRadius: 2,
        visionProfile: 'default',
        combatMechanicsProfile: 'default',
        factionProfile: 'cyberpunk',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Cyberpunk - Normal',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_collect_keys', chance: 70 },
            { questId: 'quest_defeat_5', chance: 80 },
            { questId: 'quest_explore_75', chance: 60 },
            { questId: 'quest_treasure_hunter', chance: 50 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'minionBane', 'portalStone', 'mapFragment', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_shadow_dagger', 'armor_leather', 'armor_chainmail', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'repairKit'] },
    },
    'Syndicate Takedown': {
        gridSize: 12, floors: 3, difficulty: 'hard', theme: 'cyberpunk', mapStyle: 'city', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Preem work, choom. You\'re making a name.',
        loseCommand: '/echo Flatlined. The streets claim another.',
        winMessage: 'You survived the corporate kill squads!',
        winImage: '',
        mainMinion: 'cyber_boss',
        mainMinionIntroMessage: 'Corporate has authorized lethal force. Good luck, meat.',
        mainMinionRandomChance: 25,
        mainMinionRandomMessages: ['Your biosigns are being tracked.', 'Every exit is covered.'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Cyberpunk - Hard',
        minionEncounters: [
            { minionId: 'cyber_enforcer', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'cyber_patrol', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'cyber_ice', percent: 2, zoneMin: 1, zoneMax: 2 },
            { minionId: 'cyber_samurai', percent: 3, zoneMin: 2, zoneMax: 3 },
            { minionId: 'cyber_boss', percent: 2, zoneMin: 3, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'electric_floor', percent: 3 }, { trapId: 'neural_spike', percent: 3 }, { trapId: 'security_turret', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 6, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 15,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 40, chestStealthChance: 15, chestExecuteChance: 4,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 50, lockedChestStealthChance: 25, lockedChestExecuteChance: 8,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.3, onDeath: 'respawnPenalty', respawnHPPercent: 50,
        safeRoomCount: 2, safeRoomHealPercent: 75, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 30, restInterruptScript: '',
        storyConfig: { mainStory: 'The Tyger Claws have put a bounty on your head. Three floors of gang territory stand between you and the only safe extract point. Kill squads are mobilizing.' },
        findEarly: { radius: 3, items: ['torch', 'healingPotion'], itemsPerChest: 1 },
        fairness: { enabled: true, keyPityThreshold: 5, healingPityThreshold: 6, lowHpThreshold: 0.3, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 4, secretDensity: 0.05, zonesRequireClear: true, clearThreshold: 0.9, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 1,
        visionProfile: 'survival',
        combatMechanicsProfile: 'default',
        factionProfile: 'cyberpunk',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Cyberpunk - Hard',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 80 },
            { questId: 'quest_explore_75', chance: 70 },
            { questId: 'quest_find_secret', chance: 60 },
            { questId: 'quest_survive_combat', chance: 70 },
            { questId: 'quest_boss_slayer', chance: 50 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
    'Blacksite Infiltration': {
        gridSize: 14, floors: 4, difficulty: 'nightmare', theme: 'cyberpunk', mapStyle: 'city', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Preem run, choom. You\'re a legend now.',
        loseCommand: '/echo Game over. No continues.',
        winMessage: 'LEGENDARY! You survived the nightmare streets!',
        winImage: '',
        mainMinion: 'cyber_netrunner',
        mainMinionIntroMessage: 'Full corpo lockdown. Every camera, every drone, every turret. You\'re dead.',
        mainMinionRandomChance: 30,
        mainMinionRandomMessages: ['Neural tracking active.', 'FLATLINE IMMINENT.', 'No escape.'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Cyberpunk - Nightmare',
        minionEncounters: [
            { minionId: 'cyber_patrol', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'cyber_samurai', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'cyber_boss', percent: 3, zoneMin: 2, zoneMax: 3 },
            { minionId: 'cyber_netrunner', percent: 3, zoneMin: 3, zoneMax: 99 },
            { minionId: 'cyber_ripperdoc', percent: 2, zoneMin: 3, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'electric_floor', percent: 4 }, { trapId: 'neural_spike', percent: 4 }, { trapId: 'security_turret', percent: 3 }],
        onBattlebarLoss: 'gameover',
        chestTilePercent: 5, chestLockedPercent: 50, chestLockedBonusPercent: 70, chestMimicPercent: 25,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 25, chestStrikeChance: 35, chestStealthChance: 20, chestExecuteChance: 5,
        lockedChestKeyChance: 20, lockedChestStrikeChance: 50, lockedChestStealthChance: 30, lockedChestExecuteChance: 10,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, ironGuard: 1 },
        hpEnabled: true, maxHP: 70, battlebarDamageMultiplier: 1.5, onDeath: 'gameover', respawnHPPercent: 25,
        safeRoomCount: 2, safeRoomHealPercent: 60, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 10, restCooldown: 5, restInterruptChance: 40, restInterruptScript: '',
        storyConfig: { mainStory: 'Arasaka\'s blacksite. No one knows it exists. No one who enters has ever left. Four floors of classified nightmares guard the data that could topple the megacorps forever.' },
        findEarly: { radius: 2, items: ['torch'], itemsPerChest: 1 },
        fairness: { enabled: false, keyPityThreshold: 0, healingPityThreshold: 0, lowHpThreshold: 0, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 4, secretDensity: 0.06, zonesRequireClear: true, clearThreshold: 1.0, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 0,
        visionProfile: 'survival',
        combatMechanicsProfile: 'aggressive',
        factionProfile: 'cyberpunk',
        permadeathEnabled: true,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Cyberpunk - Nightmare',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 90 },
            { questId: 'quest_explore_75', chance: 80 },
            { questId: 'quest_find_secret', chance: 70 },
            { questId: 'quest_survive_combat', chance: 80 },
            { questId: 'quest_boss_slayer', chance: 60 },
            { questId: 'quest_full_clear', chance: 40 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
    'Night City Apocalypse': {
        gridSize: 16, floors: 5, difficulty: 'apocalypse', theme: 'cyberpunk', mapStyle: 'city', mapVisibility: 'hideUnexplored',
        winCommand: '/echo LEGENDARY RUN COMPLETE. YOU ARE THE NIGHT CITY CHAMPION.',
        loseCommand: '/echo TOTAL FLATLINE. YOUR MEMORY WILL BE ERASED.',
        winMessage: 'LEGENDARY! You escaped the apocalypse city! Your name echoes through the datastreams!',
        winImage: '',
        mainMinion: 'cyber_ripperdoc',
        mainMinionIntroMessage: 'APOCALYPSE MODE: Five sectors. Full lockdown. Zero mercy. Prove you deserve to live.',
        mainMinionRandomChance: 35,
        mainMinionRandomMessages: ['YOUR DEATH IS CERTAIN.', 'RESISTANCE: FUTILE.', 'FLATLINE IN PROGRESS.'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Cyberpunk - Apocalypse',
        minionEncounters: [
            { minionId: 'cyber_samurai', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'cyber_boss', percent: 4, zoneMin: 1, zoneMax: 2 },
            { minionId: 'cyber_netrunner', percent: 4, zoneMin: 2, zoneMax: 3 },
            { minionId: 'cyber_ripperdoc', percent: 3, zoneMin: 3, zoneMax: 4 },
        ],
        trapEncounters: [{ trapId: 'electric_floor', percent: 5 }, { trapId: 'neural_spike', percent: 5 }, { trapId: 'security_turret', percent: 4 }],
        onBattlebarLoss: 'gameover',
        chestTilePercent: 4, chestLockedPercent: 60, chestLockedBonusPercent: 80, chestMimicPercent: 35,
        chestLootMin: 1, chestLootMax: 1,
        chestKeyChance: 20, chestStrikeChance: 30, chestStealthChance: 10, chestExecuteChance: 5,
        lockedChestKeyChance: 15, lockedChestStrikeChance: 45, lockedChestStealthChance: 20, lockedChestExecuteChance: 12,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, ironGuard: 1 },
        hpEnabled: true, maxHP: 60, battlebarDamageMultiplier: 2.0, onDeath: 'gameover', respawnHPPercent: 0,
        safeRoomCount: 1, safeRoomHealPercent: 40, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 5, restCooldown: 6, restInterruptChance: 50, restInterruptScript: '',
        storyConfig: { mainStory: 'Night City has fallen. Every gang, every corp, every AI has unified against you. Five sectors of pure annihilation. No one believes survival is possible. Prove them wrong, legend.' },
        findEarly: { radius: 0, items: [], itemsPerChest: 0 },
        fairness: { enabled: false, keyPityThreshold: 0, healingPityThreshold: 0, lowHpThreshold: 0, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 5, secretDensity: 0.08, zonesRequireClear: true, clearThreshold: 1.0, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 0,
        visionProfile: 'survival',
        combatMechanicsProfile: 'lethal',
        factionProfile: 'cyberpunk',
        permadeathEnabled: true,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Cyberpunk - Apocalypse',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 100 },
            { questId: 'quest_explore_75', chance: 90 },
            { questId: 'quest_find_secret', chance: 80 },
            { questId: 'quest_survive_combat', chance: 90 },
            { questId: 'quest_boss_slayer', chance: 70 },
            { questId: 'quest_full_clear', chance: 60 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },

    // ===== WESTERN THEME =====
    'Dusty Trail': {
        gridSize: 8, floors: 1, difficulty: 'easy', theme: 'western', mapStyle: 'outpost', mapVisibility: 'showAll',
        winCommand: '/echo You ride off into the sunset, partner.',
        loseCommand: '/echo This town wasn\'t big enough for the both of ya.',
        winMessage: 'You cleared the outpost and rode on to new adventures!',
        winImage: '',
        mainMinion: 'western_outlaw',
        mainMinionIntroMessage: 'Howdy, stranger. Welcome to the frontier.',
        mainMinionRandomChance: 15,
        mainMinionRandomMessages: ['Keep your eyes peeled, partner.', 'The frontier is wild but fair.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Showdown',
        minionEncounters: [
            { minionId: 'western_crier', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'western_trader', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'western_outlaw', percent: 2, zoneMin: 1, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'bear_trap', percent: 1 }, { trapId: 'snake_pit', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 10, chestLockedPercent: 20, chestLockedBonusPercent: 50, chestMimicPercent: 5,
        chestLootMin: 2, chestLootMax: 4,
        chestKeyChance: 40, chestStrikeChance: 50, chestStealthChance: 15, chestExecuteChance: 2,
        lockedChestKeyChance: 30, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 5,
        startingInventory: { key: 2, strike: 2, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 130, battlebarDamageMultiplier: 0.7, onDeath: 'respawn', respawnHPPercent: 75,
        safeRoomCount: 4, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 30, restCooldown: 2, restInterruptChance: 5, restInterruptScript: '',
        storyConfig: { mainStory: 'The dusty trail leads to a small frontier outpost. Word is there\'s gold hidden somewhere in town. Easy pickings for a greenhorn looking to make their name.' },
        findEarly: { radius: 5, items: ['lantern', 'torch', 'healingPotion', 'mapFragment'], itemsPerChest: 2 },
        fairness: { enabled: true, keyPityThreshold: 3, healingPityThreshold: 4, lowHpThreshold: 0.4, mercyUnlock: true, mercyUnlockThreshold: 2 },
        bspConfig: { zoneCount: 2, secretDensity: 0.02, zonesRequireClear: true, clearThreshold: 0.5, secretHints: true, floorComplexityScaling: false },
        safeStartRadius: 3,
        visionProfile: 'explorer',
        combatMechanicsProfile: 'simple',
        factionProfile: 'western',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Western - Easy',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_collect_keys', chance: 80 },
            { questId: 'quest_defeat_5', chance: 60 },
            { questId: 'quest_treasure_hunter', chance: 70 },
        ],
        itemPool: { enabled: true, items: ['key', 'strike', 'stealth', 'healingPotion', 'greaterHealing', 'torch', 'lantern', 'mapFragment', 'weapon_rusty_sword', 'weapon_iron_sword', 'armor_leather', 'accessory_ring_power', 'repairKit'] },
    },
    'Outlaw Territory': {
        gridSize: 10, floors: 2, difficulty: 'normal', theme: 'western', mapStyle: 'outpost', mapVisibility: 'fogOfWar',
        winCommand: '/echo The frontier conquers all but the bravest.',
        loseCommand: '/echo The west claims another...',
        winMessage: 'You survived the wild west!',
        winImage: '',
        mainMinion: 'western_sheriff',
        mainMinionIntroMessage: 'Law and order rules these parts, stranger.',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['Justice comes for all.', 'The frontier has its own rules.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Showdown',
        minionEncounters: [
            { minionId: 'western_crier', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'western_trader', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'western_outlaw', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'western_posse', percent: 2, zoneMin: 1, zoneMax: 2 },
            { minionId: 'western_sheriff', percent: 1, zoneMin: 2, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'bear_trap', percent: 2 }, { trapId: 'snake_pit', percent: 2 }, { trapId: 'dynamite', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 8, chestLockedPercent: 30, chestLockedBonusPercent: 50, chestMimicPercent: 10,
        chestLootMin: 1, chestLootMax: 3,
        chestKeyChance: 35, chestStrikeChance: 45, chestStealthChance: 15, chestExecuteChance: 3,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 7,
        startingInventory: { key: 1, strike: 1, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 100, battlebarDamageMultiplier: 1.0, onDeath: 'respawn', respawnHPPercent: 50,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 20, restCooldown: 3, restInterruptChance: 15, restInterruptScript: '',
        storyConfig: { mainStory: 'The Clayton Gang has taken over Redemption Falls. The sheriff is dead, and the townsfolk are hostages. Two territories of lawless territory await someone brave—or foolish—enough to challenge them.' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'mapFragment'], itemsPerChest: 1 },
        fairness: { enabled: true, keyPityThreshold: 4, healingPityThreshold: 5, lowHpThreshold: 0.35, mercyUnlock: true, mercyUnlockThreshold: 3 },
        bspConfig: { zoneCount: 3, secretDensity: 0.04, zonesRequireClear: true, clearThreshold: 0.75, secretHints: true, floorComplexityScaling: true },
        safeStartRadius: 2,
        visionProfile: 'default',
        combatMechanicsProfile: 'default',
        factionProfile: 'western',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Western - Normal',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_collect_keys', chance: 70 },
            { questId: 'quest_defeat_5', chance: 80 },
            { questId: 'quest_explore_75', chance: 60 },
            { questId: 'quest_treasure_hunter', chance: 50 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'minionBane', 'portalStone', 'mapFragment', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_shadow_dagger', 'armor_leather', 'armor_chainmail', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'repairKit'] },
    },
    'Dead Man\'s Canyon': {
        gridSize: 12, floors: 3, difficulty: 'hard', theme: 'western', mapStyle: 'outpost', mapVisibility: 'hideUnexplored',
        winCommand: '/echo A true gunslinger. The legends will speak of you.',
        loseCommand: '/echo Boot Hill has a new resident...',
        winMessage: 'You survived the deadliest frontier!',
        winImage: '',
        mainMinion: 'western_quickdraw',
        mainMinionIntroMessage: 'This territory belongs to the fastest gun. That ain\'t you.',
        mainMinionRandomChance: 25,
        mainMinionRandomMessages: ['Draw, stranger.', 'The vultures are circling.'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Western - Hard',
        minionEncounters: [
            { minionId: 'western_outlaw', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'western_posse', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'western_safe', percent: 2, zoneMin: 1, zoneMax: 2 },
            { minionId: 'western_bandit', percent: 3, zoneMin: 2, zoneMax: 3 },
            { minionId: 'western_quickdraw', percent: 2, zoneMin: 3, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'bear_trap', percent: 3 }, { trapId: 'snake_pit', percent: 3 }, { trapId: 'dynamite', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 6, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 15,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 40, chestStealthChance: 15, chestExecuteChance: 4,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 50, lockedChestStealthChance: 25, lockedChestExecuteChance: 8,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.3, onDeath: 'respawnPenalty', respawnHPPercent: 50,
        safeRoomCount: 2, safeRoomHealPercent: 75, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 25, restInterruptScript: '',
        storyConfig: { mainStory: 'They call it Dead Man\'s Canyon for a reason. Three territories of sun-bleached bones and ruthless killers. The fastest guns in the west wait at every turn. Only the quickest will survive.' },
        findEarly: { radius: 3, items: ['torch', 'healingPotion'], itemsPerChest: 1 },
        fairness: { enabled: true, keyPityThreshold: 5, healingPityThreshold: 6, lowHpThreshold: 0.3, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 4, secretDensity: 0.05, zonesRequireClear: true, clearThreshold: 0.9, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 1,
        visionProfile: 'survival',
        combatMechanicsProfile: 'default',
        factionProfile: 'western',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Western - Hard',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 80 },
            { questId: 'quest_explore_75', chance: 70 },
            { questId: 'quest_find_secret', chance: 60 },
            { questId: 'quest_survive_combat', chance: 70 },
            { questId: 'quest_boss_slayer', chance: 50 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
    'Blood Mesa': {
        gridSize: 14, floors: 4, difficulty: 'nightmare', theme: 'western', mapStyle: 'outpost', mapVisibility: 'hideUnexplored',
        winCommand: '/echo LEGENDARY GUNSLINGER. The west will never forget.',
        loseCommand: '/echo Another unmarked grave in the badlands...',
        winMessage: 'LEGENDARY! You survived the nightmare frontier!',
        winImage: '',
        mainMinion: 'western_dealer',
        mainMinionIntroMessage: 'Four territories. No law. No mercy. Just death.',
        mainMinionRandomChance: 30,
        mainMinionRandomMessages: ['YOUR GRAVE IS DUG.', 'THE VULTURES FEAST TONIGHT.', 'NO ONE ESCAPES.'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Western - Nightmare',
        minionEncounters: [
            { minionId: 'western_posse', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'western_bandit', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'western_quickdraw', percent: 3, zoneMin: 2, zoneMax: 3 },
            { minionId: 'western_sheriff', percent: 3, zoneMin: 3, zoneMax: 99 },
            { minionId: 'western_dealer', percent: 2, zoneMin: 3, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'bear_trap', percent: 4 }, { trapId: 'snake_pit', percent: 4 }, { trapId: 'dynamite', percent: 3 }],
        onBattlebarLoss: 'gameover',
        chestTilePercent: 5, chestLockedPercent: 50, chestLockedBonusPercent: 70, chestMimicPercent: 25,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 25, chestStrikeChance: 35, chestStealthChance: 15, chestExecuteChance: 5,
        lockedChestKeyChance: 20, lockedChestStrikeChance: 50, lockedChestStealthChance: 25, lockedChestExecuteChance: 10,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, ironGuard: 1 },
        hpEnabled: true, maxHP: 70, battlebarDamageMultiplier: 1.5, onDeath: 'gameover', respawnHPPercent: 25,
        safeRoomCount: 2, safeRoomHealPercent: 60, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 10, restCooldown: 5, restInterruptChance: 35, restInterruptScript: '',
        storyConfig: { mainStory: 'Blood Mesa. The name alone keeps travelers away. Four territories of outlaws so dangerous, the army stopped trying to take them. You ride in with nothing. You\'ll leave a legend—or not at all.' },
        findEarly: { radius: 2, items: ['torch'], itemsPerChest: 1 },
        fairness: { enabled: false, keyPityThreshold: 0, healingPityThreshold: 0, lowHpThreshold: 0, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 4, secretDensity: 0.06, zonesRequireClear: true, clearThreshold: 1.0, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 0,
        visionProfile: 'survival',
        combatMechanicsProfile: 'aggressive',
        factionProfile: 'western',
        permadeathEnabled: true,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Western - Nightmare',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 90 },
            { questId: 'quest_explore_75', chance: 80 },
            { questId: 'quest_find_secret', chance: 70 },
            { questId: 'quest_survive_combat', chance: 80 },
            { questId: 'quest_boss_slayer', chance: 60 },
            { questId: 'quest_full_clear', chance: 40 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
    'The Devil\'s Crossing': {
        gridSize: 16, floors: 5, difficulty: 'apocalypse', theme: 'western', mapStyle: 'outpost', mapVisibility: 'hideUnexplored',
        winCommand: '/echo THE GREATEST GUNSLINGER IN HISTORY.',
        loseCommand: '/echo THE BADLANDS CLAIM ALL.',
        winMessage: 'LEGENDARY! The apocalypse frontier conquered! Your name lives forever!',
        winImage: '',
        mainMinion: 'western_dealer',
        mainMinionIntroMessage: 'APOCALYPSE: Five territories. Death incarnate. No survivors... until now?',
        mainMinionRandomChance: 35,
        mainMinionRandomMessages: ['DEATH RIDES WITH YOU.', 'THE REAPER WATCHES.', 'NO MERCY. NO QUARTER.'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Western - Apocalypse',
        minionEncounters: [
            { minionId: 'western_bandit', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'western_quickdraw', percent: 4, zoneMin: 1, zoneMax: 2 },
            { minionId: 'western_sheriff', percent: 4, zoneMin: 2, zoneMax: 3 },
            { minionId: 'western_dealer', percent: 3, zoneMin: 3, zoneMax: 4 },
        ],
        trapEncounters: [{ trapId: 'bear_trap', percent: 5 }, { trapId: 'snake_pit', percent: 5 }, { trapId: 'dynamite', percent: 4 }],
        onBattlebarLoss: 'gameover',
        chestTilePercent: 4, chestLockedPercent: 60, chestLockedBonusPercent: 80, chestMimicPercent: 35,
        chestLootMin: 1, chestLootMax: 1,
        chestKeyChance: 20, chestStrikeChance: 30, chestStealthChance: 10, chestExecuteChance: 5,
        lockedChestKeyChance: 15, lockedChestStrikeChance: 45, lockedChestStealthChance: 20, lockedChestExecuteChance: 12,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, ironGuard: 1 },
        hpEnabled: true, maxHP: 60, battlebarDamageMultiplier: 2.0, onDeath: 'gameover', respawnHPPercent: 0,
        safeRoomCount: 1, safeRoomHealPercent: 40, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 5, restCooldown: 6, restInterruptChance: 50, restInterruptScript: '',
        storyConfig: { mainStory: 'The Devil\'s Crossing. Five territories where even Death fears to tread. Legend says the devil himself guards the final pass. No one has ever crossed alive. Will you be the first?' },
        findEarly: { radius: 0, items: [], itemsPerChest: 0 },
        fairness: { enabled: false, keyPityThreshold: 0, healingPityThreshold: 0, lowHpThreshold: 0, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 5, secretDensity: 0.08, zonesRequireClear: true, clearThreshold: 1.0, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 0,
        visionProfile: 'survival',
        combatMechanicsProfile: 'lethal',
        factionProfile: 'western',
        permadeathEnabled: true,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Western - Apocalypse',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 100 },
            { questId: 'quest_explore_75', chance: 90 },
            { questId: 'quest_find_secret', chance: 80 },
            { questId: 'quest_survive_combat', chance: 90 },
            { questId: 'quest_boss_slayer', chance: 70 },
            { questId: 'quest_full_clear', chance: 60 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },

    // ===== ACTION THEME =====
    'Basic Training': {
        gridSize: 8, floors: 1, difficulty: 'easy', theme: 'action', mapStyle: 'arena', mapVisibility: 'showAll',
        winCommand: '/echo Mission complete. Good work, operator.',
        loseCommand: '/echo Mission failed. Retry available.',
        winMessage: 'Objective secured! Nice work, rookie!',
        winImage: '',
        mainMinion: 'action_intel',
        mainMinionIntroMessage: 'Welcome to the training facility, operator. Show us what you\'ve got.',
        mainMinionRandomChance: 15,
        mainMinionRandomMessages: ['Stay focused, operator.', 'Clear the AO.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Street Fight',
        minionEncounters: [
            { minionId: 'action_intel', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'action_supply', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'action_combatant', percent: 2, zoneMin: 1, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'tripwire', percent: 1 }, { trapId: 'flashbang', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 10, chestLockedPercent: 20, chestLockedBonusPercent: 50, chestMimicPercent: 5,
        chestLootMin: 2, chestLootMax: 4,
        chestKeyChance: 40, chestStrikeChance: 50, chestStealthChance: 15, chestExecuteChance: 2,
        lockedChestKeyChance: 30, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 5,
        startingInventory: { key: 2, strike: 2, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 130, battlebarDamageMultiplier: 0.7, onDeath: 'respawn', respawnHPPercent: 75,
        safeRoomCount: 4, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 30, restCooldown: 2, restInterruptChance: 5, restInterruptScript: '',
        storyConfig: { mainStory: 'Welcome to Blacksite Training Facility, operator. This is your basic qualification course. Clear the simulated hostiles and prove you\'re ready for field operations.' },
        findEarly: { radius: 5, items: ['lantern', 'torch', 'healingPotion', 'mapFragment'], itemsPerChest: 2 },
        fairness: { enabled: true, keyPityThreshold: 3, healingPityThreshold: 4, lowHpThreshold: 0.4, mercyUnlock: true, mercyUnlockThreshold: 2 },
        bspConfig: { zoneCount: 2, secretDensity: 0.02, zonesRequireClear: true, clearThreshold: 0.5, secretHints: true, floorComplexityScaling: false },
        safeStartRadius: 3,
        visionProfile: 'explorer',
        combatMechanicsProfile: 'simple',
        factionProfile: 'action',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Action - Easy',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_collect_keys', chance: 80 },
            { questId: 'quest_defeat_5', chance: 60 },
            { questId: 'quest_treasure_hunter', chance: 70 },
        ],
        itemPool: { enabled: true, items: ['key', 'strike', 'stealth', 'healingPotion', 'greaterHealing', 'torch', 'lantern', 'mapFragment', 'weapon_rusty_sword', 'weapon_iron_sword', 'armor_leather', 'accessory_ring_power', 'repairKit'] },
    },
    'Hostile Territory': {
        gridSize: 10, floors: 2, difficulty: 'normal', theme: 'action', mapStyle: 'arena', mapVisibility: 'fogOfWar',
        winCommand: '/echo Mission accomplished. Well done, operator.',
        loseCommand: '/echo KIA. Mission failed.',
        winMessage: 'Objective secured! Extraction successful!',
        winImage: '',
        mainMinion: 'action_combatant',
        mainMinionIntroMessage: 'Multiple hostiles in the AO. Weapons hot.',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['Contact left!', 'Stay frosty, operator.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Elite Combat',
        minionEncounters: [
            { minionId: 'action_intel', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'action_supply', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'action_combatant', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'action_patrol', percent: 2, zoneMin: 1, zoneMax: 2 },
            { minionId: 'action_soldier', percent: 1, zoneMin: 2, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'tripwire', percent: 2 }, { trapId: 'flashbang', percent: 2 }, { trapId: 'claymore', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 8, chestLockedPercent: 30, chestLockedBonusPercent: 50, chestMimicPercent: 10,
        chestLootMin: 1, chestLootMax: 3,
        chestKeyChance: 35, chestStrikeChance: 45, chestStealthChance: 15, chestExecuteChance: 3,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 7,
        startingInventory: { key: 1, strike: 1, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 100, battlebarDamageMultiplier: 1.0, onDeath: 'respawn', respawnHPPercent: 50,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 20, restCooldown: 3, restInterruptChance: 15, restInterruptScript: '',
        storyConfig: { mainStory: 'Tactical insertion complete. An insurgent cell has taken control of the warehouse district. Two floors of hostiles stand between you and the extraction point. Weapons hot.' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'mapFragment'], itemsPerChest: 1 },
        fairness: { enabled: true, keyPityThreshold: 4, healingPityThreshold: 5, lowHpThreshold: 0.35, mercyUnlock: true, mercyUnlockThreshold: 3 },
        bspConfig: { zoneCount: 3, secretDensity: 0.04, zonesRequireClear: true, clearThreshold: 0.75, secretHints: true, floorComplexityScaling: true },
        safeStartRadius: 2,
        visionProfile: 'default',
        combatMechanicsProfile: 'default',
        factionProfile: 'action',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Action - Normal',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_collect_keys', chance: 70 },
            { questId: 'quest_defeat_5', chance: 80 },
            { questId: 'quest_explore_75', chance: 60 },
            { questId: 'quest_treasure_hunter', chance: 50 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'minionBane', 'portalStone', 'mapFragment', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_shadow_dagger', 'armor_leather', 'armor_chainmail', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'repairKit'] },
    },
    'Behind Enemy Lines': {
        gridSize: 12, floors: 3, difficulty: 'hard', theme: 'action', mapStyle: 'arena', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Mission accomplished. Outstanding work, operator.',
        loseCommand: '/echo KIA. Mission failed.',
        winMessage: 'Objective secured! Extraction complete!',
        winImage: '',
        mainMinion: 'action_warlord',
        mainMinionIntroMessage: 'Full combat zone. Multiple hostile cells operating in the AO.',
        mainMinionRandomChance: 25,
        mainMinionRandomMessages: ['Contact! Enemy reinforcements!', 'They\'ve got us pinned!'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Action - Hard',
        minionEncounters: [
            { minionId: 'action_combatant', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'action_patrol', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'action_bomb', percent: 2, zoneMin: 1, zoneMax: 2 },
            { minionId: 'action_soldier', percent: 3, zoneMin: 2, zoneMax: 3 },
            { minionId: 'action_warlord', percent: 2, zoneMin: 3, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'tripwire', percent: 3 }, { trapId: 'flashbang', percent: 3 }, { trapId: 'claymore', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 6, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 15,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 45, chestStealthChance: 15, chestExecuteChance: 4,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 8,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.3, onDeath: 'respawnPenalty', respawnHPPercent: 40,
        safeRoomCount: 2, safeRoomHealPercent: 75, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 30, restInterruptScript: '',
        storyConfig: { mainStory: 'You\'ve been dropped behind enemy lines. Three sectors of fortified positions guard the HVT. No air support. No reinforcements. Complete the mission or don\'t come back.' },
        findEarly: { radius: 3, items: ['torch', 'healingPotion'], itemsPerChest: 1 },
        fairness: { enabled: true, keyPityThreshold: 5, healingPityThreshold: 6, lowHpThreshold: 0.3, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 4, secretDensity: 0.05, zonesRequireClear: true, clearThreshold: 0.9, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 1,
        visionProfile: 'survival',
        combatMechanicsProfile: 'default',
        factionProfile: 'action',
        permadeathEnabled: false,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Action - Hard',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 80 },
            { questId: 'quest_explore_75', chance: 70 },
            { questId: 'quest_find_secret', chance: 60 },
            { questId: 'quest_survive_combat', chance: 70 },
            { questId: 'quest_boss_slayer', chance: 50 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
    'No Man\'s Land': {
        gridSize: 14, floors: 4, difficulty: 'nightmare', theme: 'action', mapStyle: 'arena', mapVisibility: 'hideUnexplored',
        winCommand: '/echo LEGENDARY OPERATOR. Mission impossible: completed.',
        loseCommand: '/echo KIA. Your sacrifice will be remembered.',
        winMessage: 'LEGENDARY! You completed the impossible mission!',
        winImage: '',
        mainMinion: 'action_sniper',
        mainMinionIntroMessage: 'Code black. Four sectors of hell. Zero support. Good luck, operator.',
        mainMinionRandomChance: 30,
        mainMinionRandomMessages: ['CONTACT EVERYWHERE!', 'THEY KNOW WE\'RE HERE!', 'NO EXTRACTION POSSIBLE!'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Action - Nightmare',
        minionEncounters: [
            { minionId: 'action_patrol', percent: 2, zoneMin: 0, zoneMax: 1 },
            { minionId: 'action_soldier', percent: 3, zoneMin: 1, zoneMax: 2 },
            { minionId: 'action_warlord', percent: 3, zoneMin: 2, zoneMax: 3 },
            { minionId: 'action_sniper', percent: 3, zoneMin: 3, zoneMax: 99 },
            { minionId: 'action_defuser', percent: 2, zoneMin: 3, zoneMax: 99 },
        ],
        trapEncounters: [{ trapId: 'tripwire', percent: 4 }, { trapId: 'flashbang', percent: 4 }, { trapId: 'claymore', percent: 3 }],
        onBattlebarLoss: 'gameover',
        chestTilePercent: 5, chestLockedPercent: 50, chestLockedBonusPercent: 70, chestMimicPercent: 25,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 25, chestStrikeChance: 35, chestStealthChance: 15, chestExecuteChance: 5,
        lockedChestKeyChance: 20, lockedChestStrikeChance: 50, lockedChestStealthChance: 25, lockedChestExecuteChance: 10,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, ironGuard: 1 },
        hpEnabled: true, maxHP: 70, battlebarDamageMultiplier: 1.5, onDeath: 'gameover', respawnHPPercent: 25,
        safeRoomCount: 2, safeRoomHealPercent: 60, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 10, restCooldown: 5, restInterruptChance: 40, restInterruptScript: '',
        storyConfig: { mainStory: 'They call it No Man\'s Land because no one comes back. Four sectors of pure carnage. Zero support. Zero extraction. You drop in with nothing. If you survive, you\'ll be a legend.' },
        findEarly: { radius: 2, items: ['torch'], itemsPerChest: 1 },
        fairness: { enabled: false, keyPityThreshold: 0, healingPityThreshold: 0, lowHpThreshold: 0, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 4, secretDensity: 0.06, zonesRequireClear: true, clearThreshold: 1.0, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 0,
        visionProfile: 'survival',
        combatMechanicsProfile: 'aggressive',
        factionProfile: 'action',
        permadeathEnabled: true,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Action - Nightmare',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 90 },
            { questId: 'quest_explore_75', chance: 80 },
            { questId: 'quest_find_secret', chance: 70 },
            { questId: 'quest_survive_combat', chance: 80 },
            { questId: 'quest_boss_slayer', chance: 60 },
            { questId: 'quest_full_clear', chance: 40 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
    'Operation Armageddon': {
        gridSize: 16, floors: 5, difficulty: 'apocalypse', theme: 'action', mapStyle: 'arena', mapVisibility: 'hideUnexplored',
        winCommand: '/echo THE LEGEND. THE IMPOSSIBLE MISSION. COMPLETED.',
        loseCommand: '/echo TOTAL ANNIHILATION. MISSION FAILED.',
        winMessage: 'LEGENDARY! You completed the apocalypse mission! Your name echoes through military history!',
        winImage: '',
        mainMinion: 'action_defuser',
        mainMinionIntroMessage: 'APOCALYPSE: Five sectors. Full hostile occupation. Zero survival probability. Prove the odds wrong.',
        mainMinionRandomChance: 35,
        mainMinionRandomMessages: ['TOTAL WAR!', 'NO MERCY!', 'DEATH OR GLORY!'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Action - Apocalypse',
        minionEncounters: [
            { minionId: 'action_soldier', percent: 3, zoneMin: 0, zoneMax: 1 },
            { minionId: 'action_warlord', percent: 4, zoneMin: 1, zoneMax: 2 },
            { minionId: 'action_sniper', percent: 4, zoneMin: 2, zoneMax: 3 },
            { minionId: 'action_defuser', percent: 3, zoneMin: 3, zoneMax: 4 },
        ],
        trapEncounters: [{ trapId: 'tripwire', percent: 5 }, { trapId: 'flashbang', percent: 5 }, { trapId: 'claymore', percent: 4 }],
        onBattlebarLoss: 'gameover',
        chestTilePercent: 4, chestLockedPercent: 60, chestLockedBonusPercent: 80, chestMimicPercent: 35,
        chestLootMin: 1, chestLootMax: 1,
        chestKeyChance: 20, chestStrikeChance: 30, chestStealthChance: 10, chestExecuteChance: 5,
        lockedChestKeyChance: 15, lockedChestStrikeChance: 45, lockedChestStealthChance: 20, lockedChestExecuteChance: 12,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, ironGuard: 1 },
        hpEnabled: true, maxHP: 60, battlebarDamageMultiplier: 2.0, onDeath: 'gameover', respawnHPPercent: 0,
        safeRoomCount: 1, safeRoomHealPercent: 40, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 5, restCooldown: 6, restInterruptChance: 50, restInterruptScript: '',
        storyConfig: { mainStory: 'Operation Armageddon. The mission that ended careers—and lives. Five sectors of absolute annihilation. Every operator before you has failed. Command says it\'s impossible. Prove them wrong.' },
        findEarly: { radius: 0, items: [], itemsPerChest: 0 },
        fairness: { enabled: false, keyPityThreshold: 0, healingPityThreshold: 0, lowHpThreshold: 0, mercyUnlock: false, mercyUnlockThreshold: 0 },
        bspConfig: { zoneCount: 5, secretDensity: 0.08, zonesRequireClear: true, clearThreshold: 1.0, secretHints: false, floorComplexityScaling: true },
        safeStartRadius: 0,
        visionProfile: 'survival',
        combatMechanicsProfile: 'lethal',
        factionProfile: 'action',
        permadeathEnabled: true,
        vfxEnabled: true,
        soundProfile: 'default',
        questProfile: 'Action - Apocalypse',
        questGatingEnabled: true,
        questPool: [
            { questId: 'quest_defeat_5', chance: 100 },
            { questId: 'quest_explore_75', chance: 90 },
            { questId: 'quest_find_secret', chance: 80 },
            { questId: 'quest_survive_combat', chance: 90 },
            { questId: 'quest_boss_slayer', chance: 70 },
            { questId: 'quest_full_clear', chance: 60 },
        ],
        itemPool: { enabled: true, items: ['key', 'floorKey', 'strike', 'stealth', 'execute', 'minionBane', 'portalStone', 'mapFragment', 'voidWalk', 'timeShard', 'healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'heartCrystal', 'torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall', 'ironGuard', 'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_enchanted_blade', 'weapon_shadow_dagger', 'weapon_steel_blade', 'armor_leather', 'armor_chainmail', 'armor_plate', 'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant', 'repairKit'] },
    },
};

let extensionSettings = {};

// Runtime wheel state
let currentWheel = {
    segments: [],
    isOpen: false,
    isSpinning: false,
    pendingRespin: false,
    hasRespun: false,
};

// Runtime battlebar state
let currentBattlebar = {
    isOpen: false,
    profile: null,
    hits: 0,
    misses: 0,
    arrowPosition: 0,
    arrowDirection: 1,
    zoneStart: 0,
    zoneEnd: 0,
    animationId: null,
    lastFrameTime: 0,
    isVictory: false,
    isDefeat: false,
};

// Runtime turn-based combat state
let currentTurnBased = {
    isOpen: false,
    profile: null,
    profileName: '',
    playerHP: 0,
    playerMaxHP: 0,
    enemyHP: 0,
    enemyMaxHP: 0,
    currentTurn: 'player',
    turnCount: 0,
    isDefending: false,
    isVictory: false,
    isDefeat: false,
    isMazeEncounter: false,
    combatLog: [],
    // v1.5.0: Advanced Combat
    playerStatusEffects: [],  // [{ effectId, turnsRemaining }]
    enemyStatusEffects: [],   // [{ effectId, turnsRemaining }]
    enemyType: 'warrior',     // Enemy type for ability selection
    isFirstStrike: true,      // Whether this is player's first attack
    difficulty: 1,            // Combat difficulty (affects enemy stats)
};

// Runtime QTE combat state
let currentQTE = {
    isOpen: false,
    profile: null,
    profileName: '',
    sequence: [],           // Array of keys to press
    currentIndex: 0,        // Current position in sequence
    currentTimeWindow: 0,   // Current time window in ms
    promptStartTime: 0,     // When current prompt started
    timeoutId: null,        // Timeout for current prompt
    successes: 0,           // Number of successful presses
    perfects: 0,            // Number of perfect timing presses
    misses: 0,              // Number of missed prompts
    combo: 0,               // Current combo counter
    maxCombo: 0,            // Best combo achieved
    isComplete: false,      // QTE sequence finished
    isSuccess: false,       // Did player pass the QTE
    combatLog: [],          // Event log
};

// Runtime Dice combat state
let currentDice = {
    isOpen: false,
    profile: null,
    profileName: '',
    diceResults: [],        // Individual die results
    total: 0,               // Sum of dice + modifier
    rawTotal: 0,            // Sum without modifier
    threshold: 0,           // Target to beat
    modifier: 0,            // Applied modifier
    rerollsRemaining: 0,    // Rerolls left
    isCriticalSuccess: false,
    isCriticalFail: false,
    isSuccess: false,
    isComplete: false,
    combatLog: [],
};

// Runtime Stealth encounter state
let currentStealth = {
    isOpen: false,
    profile: null,
    profileName: '',
    currentSection: 0,      // Current section (0-indexed)
    sectionsToPass: 0,      // Total sections to complete
    detection: 0,           // Current detection level
    detectionThreshold: 100,// Max detection before caught
    isSuccess: false,       // Successfully infiltrated
    isCaught: false,        // Was detected
    isComplete: false,      // Encounter finished
    actionsTaken: 0,        // Total actions taken
    combatLog: [],
};

// Runtime Puzzle encounter state
let currentPuzzle = {
    isOpen: false,
    profile: null,
    profileName: '',
    puzzleType: 'sequence',  // sequence, memory, pattern, logic
    gridSize: 3,            // Grid dimension (3x3, 4x4, etc.)
    grid: [],               // The puzzle grid cells
    sequence: [],           // The correct sequence to input
    playerSequence: [],     // Player's current input
    currentStep: 0,         // Current step in sequence
    timeLimit: 0,           // Time limit in seconds
    timeRemaining: 0,       // Remaining time
    timerInterval: null,    // Timer interval reference
    hintsRemaining: 0,      // Hints left to use
    hintsUsed: 0,           // Total hints used
    wrongGuesses: 0,        // Wrong guesses made
    wrongGuessesAllowed: 3, // Max wrong guesses
    score: 0,               // Current score
    isShowingSequence: false, // True during sequence display phase
    isSuccess: false,       // Puzzle solved
    isFailed: false,        // Puzzle failed
    isComplete: false,      // Encounter finished
    combatLog: [],
};

// Runtime Negotiation encounter state
let currentNegotiation = {
    isOpen: false,
    profile: null,
    profileName: '',
    favor: 50,              // Current favor/disposition (0-100)
    favorThreshold: 75,     // Favor needed to succeed
    turnsRemaining: 0,      // Turns left
    turnsUsed: 0,           // Total turns taken
    lastAction: '',         // Last action taken
    lastResult: '',         // Result of last action
    isSuccess: false,       // Negotiation succeeded
    isFailed: false,        // Negotiation failed
    isComplete: false,      // Encounter finished
    combatLog: [],
};

// v1.4.8: Track LLM generation state for visual indicator
let isLLMGenerating = false;

// Runtime maze state
let currentMaze = {
    isOpen: false,
    profile: null,
    profileName: null,
    grid: [],
    size: 10,
    playerX: 0,
    playerY: 0,
    exitX: 0,
    exitY: 0,
    visited: new Set(),
    isVictory: false,
    currentMinion: null,
    // Encounter system
    isPaused: false,              // True during encounters
    pendingEncounter: null,       // Current encounter being processed
    exitEncounterDone: false,     // Has exit boss been defeated
    // v1.2.0 Multi-floor system
    currentFloor: 0,              // Current floor index (0-based)
    totalFloors: 1,               // Total number of floors
    floors: [],                   // Array of floor grids
    // Inventory system
    inventory: {
        key: 0,
        stealth: 0,
        strike: 0,
        execute: 0,
        // v1.2.0 new items
        floorKey: 0,
        portalStone: 0,
        minionBane: 0,
        mapFragment: 0,
        timeShard: 0,
        voidWalk: 0,
        // v1.3.0 HP System items
        healingPotion: 0,
        greaterHealing: 0,
        elixir: 0,
        revivalCharm: 0,
        heartCrystal: 0,
        // v1.3.2 Visibility items
        torch: 0,           // Temporary +2 visibility radius (3 moves)
        lantern: 0,         // Passive +1 visibility radius while held
        revealScroll: 0,    // Reveals entire floor for 1 move
        sightPotion: 0,     // Permanent +1 visibility buff (consumed)
        crystalBall: 0,     // Reveals all minions on current floor
        // v1.7.0 Equipment items
        ironGuard: 0,       // Consumable armor (3 charges, absorbs damage)
    },
    // v1.7.0: Charge tracking for equipment items
    itemCharges: {
        // "itemId": [3, 3] - Array of charges for each item in stack
    },
    // v1.3.2 Visibility system
    visibility: {
        baseRadius: 1,          // Default visibility radius
        tempBonus: 0,           // From torch (decrements each move)
        tempMovesLeft: 0,       // Moves remaining for temp bonus
        permBonus: 0,           // From consumed sightPotion
        floorRevealed: false,   // Reveal scroll active this move
    },
    pendingConfirmation: null,    // { type, minionId, x, y, canSlipAway }
    pendingChest: null,           // { chestData, x, y } for Open/Ignore flow
    voidWalkActive: false,        // v1.2.0: Void Walk active for next move
    messageLog: [],               // v1.2.1: Persistent message history
    chatHistory: [],              // v2.x: In-game chat history for LLM context
    chatEnabled: true,            // v2.x: Whether chat input is enabled
    // v1.3.0 HP System
    hpEnabled: true,
    hp: {
        current: 100,
        max: 100,
        maxBonus: 0,
        reviveCharges: 0,
    },
    // v1.5.0 Equipment System
    equipment: {
        weapon: null,      // Equipped weapon item or null
        armor: null,       // Equipped armor item or null
        accessory: null,   // Equipped accessory item or null
    },
    equipmentInventory: [], // Unequipped equipment items (array of item IDs)
    // v1.5.0 Character Progression
    character: {
        level: 1,
        xp: 0,
        xpToNextLevel: 100,  // Formula: 100 * 1.5^(level-1)
        skillPoints: 0,
        lastExplorationMilestone: 0, // Track last 10% milestone for XP rewards
    },
    // v1.5.0 Skills System
    skills: {
        learned: {},        // { skillId: rank (1-3) }
        cooldowns: {},      // { skillId: turnsRemaining }
        activeEffects: [],  // [{ skillId, effect, turnsRemaining, data }]
        abilityBar: [],     // Hotkey skill slots (up to 5)
    },
    // v1.6.0 Combat Mechanics
    combatMechanics: {
        comboCounter: 0,        // Current combo count
        maxCombo: 0,            // Highest combo this fight
        comboDecayTimer: 0,     // Turns until combo resets
        isBlocking: false,      // Player is blocking this turn
        parryWindow: false,     // Parry timing window active
        parrySuccess: false,    // Parry was successful
        lastAction: null,       // 'attack', 'block', 'parry', 'skill'
    },
    // v1.6.0 Minimap
    minimap: {
        enabled: true,
        markers: [],            // [{ id, x, y, type, label, icon, color }]
        zoom: 1.0,
        position: 'top-right',
    },
    // v1.6.0 Custom Inventory (for custom items)
    customInventory: {},        // { itemId: count }
    // v1.6.0 Enhanced Lighting System
    lighting: {
        ambientLevel: 'normal', // 'dark', 'dim', 'normal', 'bright'
        activeLight: null,      // 'torch', 'lantern', 'sightPotion', null
        lightRadius: 1,         // Calculated effective radius
        torchMovesLeft: 0,      // Remaining moves for torch
        sightPotionMovesLeft: 0, // Remaining moves for sight potion
    },
    // v1.6.0 Faction Reputation System
    factions: {},               // { factionId: { id, name, standing, tier, lastChange } }
    activatedSwitches: null,    // Set of activated switch IDs (for door system)
    // v1.6.0 Permadeath Campaign
    campaign: null,             // { isPermadeath, startTime, endTime, deathCause, finalStats }
};

// Last game results (for macros and tracking)
const lastResults = {
    wheel: {},      // { profileName: { segmentName, command, timestamp } }
    battlebar: {}, // { profileName: { result: 'win'|'lose', hits, misses, timestamp } }
    maze: {},       // { profileName: { result: 'win', timestamp } }
};

// Track processed messages to avoid reprocessing macros
const processedMacroMessages = new WeakSet();

// =============================================================================
// LLM MESSAGE GENERATION
// =============================================================================

/**
 * Generate a minion message using the LLM
 * @param {object} options - Generation options
 * @param {string} options.minionName - Name of the minion speaking
 * @param {string} options.minionDescription - Description of the minion character
 * @param {string} options.baseMessage - Base message/template to expand
 * @param {string} options.mainStory - Main story context (optional)
 * @param {string} options.currentMilestone - Current milestone story update (optional)
 * @param {string} options.minionType - Type of minion (messenger, battlebar, prizewheel, merchant, turnbased, qte, dice, stealth, puzzle, negotiation)
 * @returns {Promise<string>} Generated message or fallback to baseMessage
 */
async function generateMinionMessage(options) {
    const { minionName, minionDescription, baseMessage, mainStory, currentMilestone, minionType } = options;

    // If no baseMessage, nothing to generate
    if (!baseMessage) return '';

    // Check if LLM generation is enabled
    if (extensionSettings.llmEnabled === false) {
        console.log('[MazeMaster] LLM generation disabled, using base message');
        return baseMessage;
    }

    // Check if generateQuietPrompt is available
    if (typeof generateQuietPrompt !== 'function') {
        console.log('[MazeMaster] generateQuietPrompt not available, using base message');
        return baseMessage;
    }

    // Build the context prompt
    let contextParts = [];

    if (mainStory) {
        contextParts.push(`Story Setting: ${mainStory}`);
    }

    if (currentMilestone) {
        contextParts.push(`Current Progress: ${currentMilestone}`);
    }

    // Use custom description if provided, otherwise fall back to type-based role
    const minionRole = minionDescription || {
        messenger: 'a mysterious messenger who delivers cryptic hints',
        battlebar: 'a guardian who challenges travelers to combat',
        prizewheel: 'a fortune teller who offers games of chance',
        merchant: 'a wandering trader who barters for rare items',
    }[minionType] || 'a mysterious figure';

    // Get the player's name for personalization
    const playerName = getCurrentPersonaName();

    const prompt = `You are ${minionName}, ${minionRole}.
The player's name is ${playerName}.

${contextParts.length > 0 ? contextParts.join('\n') + '\n\n' : ''}The player has encountered you in a maze. Based on this message template: "${baseMessage}"

Write a short, atmospheric response (1-2 sentences max, under 100 characters if possible). Stay in character. Be mysterious and engaging. You may address the player by name if appropriate. Do not use quotation marks around your response.`;

    try {
        console.log('[MazeMaster] Generating LLM message for:', minionName);

        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,  // v1.2.0: Disable lorebooks during maze generation
            max_length: 80, // Keep responses short
        });

        if (response && response.trim()) {
            // Clean up the response - remove quotes, trim
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            console.log('[MazeMaster] Generated message:', cleaned);
            return cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] LLM generation failed:', error);
    }

    // Fallback to base message
    return baseMessage;
}

/**
 * Generate a trap message using the LLM
 * @param {object} options - Generation options
 * @param {string} options.trapName - Name of the trap
 * @param {string} options.baseMessage - Base message to expand
 * @param {string} options.mainStory - Main story context (optional)
 * @returns {Promise<string>} Generated message or fallback to baseMessage
 */
async function generateTrapMessage(options) {
    const { trapName, baseMessage, mainStory } = options;

    if (!baseMessage) return '';

    if (extensionSettings.llmEnabled === false) {
        return baseMessage;
    }

    if (typeof generateQuietPrompt !== 'function') {
        return baseMessage;
    }

    const playerName = getCurrentPersonaName();

    const prompt = `The player ${playerName} has triggered a trap called "${trapName}" in a maze.

${mainStory ? `Story Setting: ${mainStory}\n\n` : ''}Based on this trap description: "${baseMessage}"

Write a short, dramatic narration of the trap being triggered (1-2 sentences, under 100 characters). Make it visceral and immediate. You may reference the player by name. Do not use quotation marks.`;

    try {
        console.log('[MazeMaster] Generating LLM message for trap:', trapName);

        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,  // v1.2.0: Disable lorebooks during maze generation
            max_length: 80,
        });

        if (response && response.trim()) {
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            console.log('[MazeMaster] Generated trap message:', cleaned);
            return cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] Trap LLM generation failed:', error);
    }

    return baseMessage;
}

/**
 * Generate a battlebar stage message using the LLM
 * @param {object} options - Generation options
 * @param {string} options.battlebarName - Name of the battlebar/fight
 * @param {string} options.description - Description of the battlebar encounter
 * @param {string} options.stageMessage - Current stage message
 * @param {string} options.mainStory - Main story context (optional)
 * @param {number} options.currentHits - Current hit count
 * @param {number} options.hitsToWin - Hits needed to win
 * @returns {Promise<string>} Generated message or fallback to stageMessage
 */
async function generateBattlebarMessage(options) {
    const { battlebarName, description, stageMessage, mainStory, currentHits, hitsToWin } = options;

    if (!stageMessage) return '';

    if (extensionSettings.llmEnabled === false) {
        return stageMessage;
    }

    if (typeof generateQuietPrompt !== 'function') {
        return stageMessage;
    }

    const progress = currentHits !== undefined && hitsToWin ? `Progress: ${currentHits}/${hitsToWin} hits` : '';
    const battleDesc = description || 'a challenging combat encounter';
    const playerName = getCurrentPersonaName();

    const prompt = `The player ${playerName} is in a battle called "${battlebarName}" - ${battleDesc}.

${mainStory ? `Story Setting: ${mainStory}\n\n` : ''}${progress ? progress + '\n\n' : ''}Based on this stage message: "${stageMessage}"

Write a short, intense combat narration (1-2 sentences, under 100 characters). Make it exciting and dramatic. You may reference the player by name. Do not use quotation marks.`;

    try {
        console.log('[MazeMaster] Generating LLM message for battlebar:', battlebarName);

        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,  // v1.2.0: Disable lorebooks during maze generation
            max_length: 80,
        });

        if (response && response.trim()) {
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            console.log('[MazeMaster] Generated battlebar message:', cleaned);
            return cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] Battlebar LLM generation failed:', error);
    }

    return stageMessage;
}

/**
 * Generate a chest message using the LLM
 * @param {object} options - Generation options
 * @param {string} options.chestType - Type of chest ('normal' or 'locked')
 * @param {string} options.baseMessage - Base message to expand
 * @param {string} options.mainStory - Main story context (optional)
 * @param {boolean} options.hasKey - Whether player has a key (for locked chests)
 * @returns {Promise<string>} Generated message or fallback to baseMessage
 */
async function generateChestMessage(options) {
    const { chestType, baseMessage, mainStory, hasKey } = options;

    if (!baseMessage) return '';

    if (extensionSettings.llmEnabled === false) {
        return baseMessage;
    }

    if (typeof generateQuietPrompt !== 'function') {
        return baseMessage;
    }

    const chestDesc = chestType === 'locked'
        ? (hasKey ? 'a locked treasure chest - the player has a key to open it' : 'a locked treasure chest - the player lacks the key')
        : 'a treasure chest waiting to be opened';
    const playerName = getCurrentPersonaName();

    const prompt = `The player ${playerName} has discovered ${chestDesc} in a maze.

${mainStory ? `Story Setting: ${mainStory}\n\n` : ''}Based on this chest discovery message: "${baseMessage}"

Write a short, atmospheric description of finding the chest (1-2 sentences, under 100 characters). Make it feel rewarding and mysterious. You may reference the player by name. Do not use quotation marks.`;

    try {
        console.log('[MazeMaster] Generating LLM message for chest');

        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,  // v1.2.0: Disable lorebooks during maze generation
            max_length: 80,
        });

        if (response && response.trim()) {
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            console.log('[MazeMaster] Generated chest message:', cleaned);
            return cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] Chest LLM generation failed:', error);
    }

    return baseMessage;
}

/**
 * Generate LLM-enhanced room description
 * @param {Object} options - Room context for LLM generation
 * @returns {Promise<string>} Enhanced description or original
 */
async function generateEnhancedRoomDescription(options) {
    const { roomName, roomType, baseDescription, theme, sessionNotes } = options;

    // Check if LLM generation is available
    if (typeof generateQuietPrompt !== 'function') {
        console.log('[MazeMaster] generateQuietPrompt not available');
        return baseDescription;
    }

    // Check if LLM is globally enabled
    if (extensionSettings.llmEnabled === false) {
        return baseDescription;
    }

    // Get additional context
    const profile = currentMaze?.profile || {};
    const mainStory = profile.storyConfig?.mainStory || '';
    const currentFloor = (currentMaze?.currentFloor || 0) + 1;
    const totalFloors = currentMaze?.totalFloors || 1;
    const playerName = getCurrentPersonaName();

    // Truncate session notes to last ~500 chars for context
    const recentNotes = sessionNotes
        ? sessionNotes.slice(-500).split('\n').slice(-5).join('\n')
        : '';

    // v1.4.9: Include custom theme context if available
    const customTheme = getCustomTheme(theme);
    let themeContext = theme;
    if (customTheme) {
        themeContext = customTheme.displayName || theme;
        if (customTheme.tags?.length) {
            themeContext += ` (${customTheme.tags.join(', ')})`;
        }
    }
    const atmosphereNote = customTheme?.atmosphere || '';

    const prompt = `You are the narrator for a ${themeContext} dungeon crawler game.
Player: ${playerName}
Floor: ${currentFloor}/${totalFloors}
${atmosphereNote ? `Atmosphere: ${atmosphereNote}\n` : ''}${mainStory ? `Story: ${mainStory}\n` : ''}
${recentNotes ? `Recent events:\n${recentNotes}\n` : ''}
The player enters "${roomName}" (a ${roomType || 'standard'} room).
Base description: "${baseDescription}"

Write a vivid, atmospheric description (2-3 sentences max). Reference recent events if relevant. Stay in theme. Do not use quotation marks.`;

    try {
        console.log('[MazeMaster] Generating enhanced room description for:', roomName);

        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,
            max_length: 150,
        });

        if (response && response.trim()) {
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            console.log('[MazeMaster] Enhanced description:', cleaned);
            return cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] Room description LLM failed:', error);
    }

    return baseDescription;
}

/**
 * v2.0.2: Generate LLM-enhanced minion alias (3-4 words max)
 * @param {string} originalName - Original minion name (e.g., "The Butcher")
 * @param {string} theme - Theme name (e.g., "horror")
 * @returns {Promise<string>} Enhanced alias or original name on failure
 */
async function generateMinionAlias(originalName, theme) {
    if (!originalName) return originalName;

    // Check if LLM generation is available
    if (typeof generateQuietPrompt !== 'function') {
        console.log('[MazeMaster] generateQuietPrompt not available for minion alias');
        return originalName;
    }

    // Check if LLM is globally enabled
    if (extensionSettings.llmEnabled === false) {
        return originalName;
    }

    // Get custom theme context if available
    const customTheme = getCustomTheme(theme);
    const themeContext = customTheme?.displayName || theme || 'fantasy';
    const atmosphereNote = customTheme?.atmosphere || '';

    const prompt = `Generate a dramatic 3-4 word alias for a ${themeContext} villain named "${originalName}".
${atmosphereNote ? `Atmosphere: ${atmosphereNote}\n` : ''}
Examples of good aliases: "The Crimson Reaper", "The Shadow Stalker", "The Demon Necrophagist", "The Flayed One"
Reply with ONLY the new name (3-4 words max). No quotes, no explanation.`;

    try {
        console.log('[MazeMaster] Generating LLM minion alias for:', originalName);

        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,
            max_length: 40,
        });

        if (response && response.trim()) {
            // Clean and validate: extract 3-4 words max
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');

            const words = cleaned.split(/\s+/).slice(0, 4);
            if (words.length >= 2) {
                const alias = words.join(' ');
                console.log('[MazeMaster] Minion alias generated:', originalName, '->', alias);
                return alias;
            }
        }
    } catch (error) {
        console.error('[MazeMaster] Minion alias LLM failed:', error);
    }

    return originalName;
}

/**
 * v2.0.2: Generate LLM-enhanced story intro
 * @param {string} originalStory - Original story text
 * @param {string} theme - Theme name
 * @param {string} minionName - Main antagonist name (already aliased)
 * @returns {Promise<string>} Enhanced story or original on failure
 */
async function generateEnhancedStoryIntro(originalStory, theme, minionName) {
    if (!originalStory) return originalStory;

    // Check if LLM generation is available
    if (typeof generateQuietPrompt !== 'function') {
        console.log('[MazeMaster] generateQuietPrompt not available for story intro');
        return originalStory;
    }

    // Check if LLM is globally enabled
    if (extensionSettings.llmEnabled === false) {
        return originalStory;
    }

    // Get custom theme context if available
    const customTheme = getCustomTheme(theme);
    const themeContext = customTheme?.displayName || theme || 'fantasy';
    const atmosphereNote = customTheme?.atmosphere || '';

    const prompt = `You are the narrator for a ${themeContext} dungeon crawler game.
${atmosphereNote ? `Atmosphere: ${atmosphereNote}\n` : ''}
The main antagonist is "${minionName}".

Original maze introduction: "${originalStory}"

Rewrite this introduction in 2-3 vivid, atmospheric sentences. Keep the same meaning and tone but make it more immersive and dramatic. Do not use quotation marks.`;

    try {
        console.log('[MazeMaster] Generating LLM-enhanced story intro');

        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,
            max_length: 250,
        });

        if (response && response.trim()) {
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            console.log('[MazeMaster] Story intro enhanced');
            return cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] Story intro LLM failed:', error);
    }

    return originalStory;
}

/**
 * v2.0.2: Replace main minion original name with alias in text
 * @param {string} text - Text to process
 * @returns {string} Text with alias replacements
 */
function applyMinionAlias(text) {
    if (!text || typeof text !== 'string') return text;
    if (!currentMaze?.mainMinionOriginalName || !currentMaze?.mainMinionAlias) return text;
    if (currentMaze.mainMinionOriginalName === currentMaze.mainMinionAlias) return text;

    // Case-insensitive replacement
    const escaped = currentMaze.mainMinionOriginalName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(escaped, 'gi');
    return text.replace(regex, currentMaze.mainMinionAlias);
}

// =============================================================================
// v2.1.0: AVATAR GENERATION FUNCTIONS
// =============================================================================

/**
 * v2.1.0: Check if image generation (SD extension) is available
 * @returns {Promise<boolean>} True if image generation is available
 */
async function isImageGenerationAvailable() {
    try {
        // Check if executeSlashCommandsWithOptions is available
        if (typeof executeSlashCommandsWithOptions !== 'function') {
            console.log('[MazeMaster] executeSlashCommandsWithOptions not available');
            return false;
        }

        // Check if SD extension is loaded by looking for its UI elements
        const sdPanel = document.querySelector('#sd_settings, [id*="sd_"]');
        if (sdPanel) {
            return true;
        }

        // Alternative: check SillyTavern context for SD extension
        const context = SillyTavern.getContext();
        if (context.extensionSettings?.sd) {
            return true;
        }

        return false;
    } catch (e) {
        console.warn('[MazeMaster] Could not detect image generation:', e);
        return false;
    }
}

/**
 * v2.1.0: Build image generation prompt for minion avatar
 * @param {Object} minion - Minion data object
 * @param {string} theme - Theme name
 * @param {Object} customTheme - Custom theme data (optional)
 * @returns {string} Prompt for image generation
 */
function buildMinionAvatarPrompt(minion, theme, customTheme) {
    const themeContext = customTheme?.displayName || theme || 'fantasy';
    const atmosphere = customTheme?.atmosphere || '';

    // Type-specific keywords for better prompts
    const typeKeywords = {
        messenger: 'mysterious messenger, hooded figure, enigmatic',
        battlebar: 'fierce warrior, armored combatant, battle-ready',
        prizewheel: 'fortune teller, mystical oracle, magical aura',
        merchant: 'cunning trader, merchant, carrying wares',
        turnbased: 'powerful boss, imposing figure, commanding presence',
        stealth: 'shadow assassin, stealthy hunter, dark cloak',
        puzzle: 'ancient riddler, wise sage, mysterious',
        negotiation: 'shrewd diplomat, persuasive speaker, elegant',
        qte: 'quick challenger, agile fighter, nimble',
        dice: 'gambler, risk-taker, fortune seeker',
    };

    let prompt = `portrait of ${minion.name}`;

    // Add description if available (truncate to keep prompt reasonable)
    if (minion.description) {
        const shortDesc = minion.description.substring(0, 80).trim();
        prompt += `, ${shortDesc}`;
    }

    // Add type-specific keywords
    const typeKey = typeKeywords[minion.type] || 'mysterious figure';
    prompt += `, ${typeKey}`;

    // Add theme context
    prompt += `, ${themeContext} theme`;

    // Add atmosphere if available
    if (atmosphere) {
        prompt += `, ${atmosphere} atmosphere`;
    }

    // Standard quality tags for portrait
    prompt += ', character portrait, detailed, high quality, 1:1 aspect ratio, centered composition';

    return prompt;
}

/**
 * v2.1.0: Generate and save avatar for a minion using SD extension
 * @param {string} minionId - Minion identifier
 * @param {Object} minion - Minion data object
 * @param {string} theme - Theme name
 * @returns {Promise<string|null>} Generated image path or null on failure
 */
async function generateMinionAvatar(minionId, minion, theme) {
    if (!minion) {
        console.log('[MazeMaster] generateMinionAvatar: No minion provided');
        return null;
    }

    // Skip if minion already has an image
    if (minion.imagePath) {
        console.log('[MazeMaster] Minion already has avatar:', minionId, minion.imagePath);
        return minion.imagePath;
    }

    const customTheme = getCustomTheme(theme);
    const prompt = buildMinionAvatarPrompt(minion, theme, customTheme);
    const timeout = extensionSettings.avatarGenerationTimeout || 60000;

    console.log('[MazeMaster] Generating avatar for:', minionId);
    console.log('[MazeMaster] Avatar prompt:', prompt);

    try {
        // Execute /imagine command with quiet mode (no chat posting)
        const result = await Promise.race([
            executeSlashCommandsWithOptions(`/imagine quiet=true ${prompt}`),
            new Promise((_, reject) =>
                setTimeout(() => reject(new Error('Avatar generation timed out')), timeout)
            )
        ]);

        // The /imagine command returns the image path in result.pipe
        let imagePath = result?.pipe;

        if (imagePath && typeof imagePath === 'string' && imagePath.trim()) {
            imagePath = imagePath.trim();

            // Update minion with new image path and save
            const updatedMinion = { ...minion, imagePath };
            saveMinion(minionId, updatedMinion);

            console.log('[MazeMaster] Avatar generated for:', minionId, imagePath);
            return imagePath;
        }

        console.warn('[MazeMaster] No image path returned for:', minionId);
        return null;

    } catch (error) {
        console.error('[MazeMaster] Avatar generation failed for:', minionId, error.message);
        return null;
    }
}

/**
 * v2.1.0: Get list of minions that need avatar generation for a maze profile
 * @param {Object} profile - Maze profile object
 * @returns {Array<{id: string, minion: Object}>} Array of minions needing avatars
 */
function getMinionsNeedingAvatars(profile) {
    const results = [];
    const selectedMinions = profile.avatarGenerationMinions || [];

    // If specific minions are selected, use those
    if (selectedMinions.length > 0) {
        for (const minionId of selectedMinions) {
            const minion = getMinion(minionId);
            if (minion && !minion.imagePath) {
                results.push({ id: minionId, minion });
            }
        }
    } else {
        // Default: just the main minion
        if (profile.mainMinion) {
            const mainMinion = getMinion(profile.mainMinion);
            if (mainMinion && !mainMinion.imagePath) {
                results.push({ id: profile.mainMinion, minion: mainMinion });
            }
        }
    }

    return results;
}

/**
 * Enhance room description on first entry and cache it
 * @param {number} x - Room X coordinate
 * @param {number} y - Room Y coordinate
 */
async function enhanceRoomOnEntry(x, y) {
    console.log('[MazeMaster] enhanceRoomOnEntry called:', { x, y });

    if (!currentMaze?.isOpen || !currentMaze.profile) {
        console.log('[MazeMaster] Enhancement skipped: maze not open or no profile');
        return;
    }

    // Check if LLM enhancement is enabled for this maze
    if (!currentMaze.profile.llmEnhanceRooms) {
        console.log('[MazeMaster] Enhancement skipped: llmEnhanceRooms disabled in profile', currentMaze.profile.llmEnhanceRooms);
        return;
    }

    const floor = currentMaze.currentFloor || 0;
    const roomKey = `${floor}:${x},${y}`;

    // Check if already enhanced
    if (currentMaze.enhancedRooms?.[roomKey]) {
        console.log('[MazeMaster] Room already enhanced:', roomKey);
        return;
    }

    const cell = currentMaze.grid[y]?.[x];
    if (!cell || !cell.roomInfo) {
        console.log('[MazeMaster] Enhancement skipped: no cell or roomInfo at', { x, y, hasCell: !!cell, hasRoomInfo: !!cell?.roomInfo });
        return;
    }

    console.log('[MazeMaster] Proceeding with room enhancement for:', roomKey);

    const baseDescription = cell.roomInfo.description || '...';
    const roomName = cell.roomInfo.name || 'Unknown Room';
    const roomType = cell.roomInfo.type || 'standard';
    const theme = currentMaze.profile.theme || 'fantasy';

    // Show generating indicator
    showGeneratingIndicator(true);

    try {
        const enhanced = await generateEnhancedRoomDescription({
            roomName,
            roomType,
            baseDescription,
            theme,
            sessionNotes: currentMaze.sessionNotes || '',
        });

        // Store enhanced description
        if (!currentMaze.enhancedRooms) currentMaze.enhancedRooms = {};
        currentMaze.enhancedRooms[roomKey] = enhanced;

        // Update cell's roomInfo for immediate display
        cell.roomInfo.enhancedDescription = enhanced;

        // Add to session notes (include enhanced description for future LLM context)
        addSessionNote(`${roomName}: ${enhanced}`, 'Explore');

        // Update room info display
        updateRoomInfoBox();

        console.log('[MazeMaster] Room enhanced and cached:', roomKey);
    } catch (error) {
        console.error('[MazeMaster] Room enhancement failed:', error);
    } finally {
        showGeneratingIndicator(false);
    }
}

/**
 * Get current story milestone based on maze progress
 * @returns {string|null} Current milestone text or null
 */
function getCurrentMilestone() {
    if (!currentMaze.isOpen || !currentMaze.profile) return null;

    const storyConfig = currentMaze.profile.storyConfig;
    if (!storyConfig || !storyConfig.milestones || storyConfig.milestones.length === 0) return null;

    // Calculate maze progress percentage
    const totalCells = currentMaze.size * currentMaze.size;
    const visitedCount = currentMaze.visited?.size || 0;
    const progressPercent = (visitedCount / totalCells) * 100;

    // Find the highest milestone that has been reached
    let currentMilestoneText = null;
    for (const milestone of storyConfig.milestones) {
        if (progressPercent >= milestone.percent) {
            currentMilestoneText = milestone.storyUpdate;
        }
    }

    return currentMilestoneText;
}

/**
 * Get the main story from the current maze profile
 * @returns {string|null} Main story text or null
 */
function getMainStory() {
    if (!currentMaze.isOpen || !currentMaze.profile) return null;
    return currentMaze.profile.storyConfig?.mainStory || null;
}

// =============================================================================
// SETTINGS
// =============================================================================

/**
 * Force-update all factory default assets (traps, minions, profiles, etc.)
 * This overwrites saved versions with the latest code defaults
 */
function resetFactoryDefaults() {
    console.log('[MazeMaster] Resetting all factory defaults to version', FACTORY_DEFAULTS_VERSION);

    // Reset factory traps (clear old, add new)
    extensionSettings.traps = {};
    for (const [id, trap] of Object.entries(DEFAULT_TRAPS)) {
        extensionSettings.traps[id] = JSON.parse(JSON.stringify(trap));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_TRAPS).length, 'factory traps');

    // Reset factory minions (clear old, add new)
    extensionSettings.minions = {};
    for (const [id, minion] of Object.entries(DEFAULT_MINIONS)) {
        extensionSettings.minions[id] = JSON.parse(JSON.stringify(minion));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_MINIONS).length, 'factory minions');

    // Reset factory wheel profiles (clear old, add new)
    extensionSettings.profiles = {};
    for (const [name, profile] of Object.entries(DEFAULT_WHEEL_PROFILES)) {
        extensionSettings.profiles[name] = JSON.parse(JSON.stringify(profile));
    }
    extensionSettings.currentProfile = 'Tutorial - Learn the Wheel';
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_WHEEL_PROFILES).length, 'factory wheel profiles');

    // Reset factory battlebar profiles (clear old, add new)
    extensionSettings.battlebarProfiles = {};
    for (const [name, profile] of Object.entries(DEFAULT_BATTLEBAR_PROFILES)) {
        extensionSettings.battlebarProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    extensionSettings.currentBattlebarProfile = 'Tutorial - Learn Combat';
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_BATTLEBAR_PROFILES).length, 'factory battlebar profiles');

    // Reset factory turn-based profiles (clear old, add new)
    extensionSettings.turnbasedProfiles = {};
    for (const [name, profile] of Object.entries(DEFAULT_TURNBASED_PROFILES)) {
        extensionSettings.turnbasedProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    extensionSettings.currentTurnbasedProfile = 'Tutorial - Learn Turn-Based';
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_TURNBASED_PROFILES).length, 'factory turn-based profiles');

    // Reset factory QTE profiles (clear old, add new)
    extensionSettings.qteProfiles = {};
    for (const [name, profile] of Object.entries(DEFAULT_QTE_PROFILES)) {
        extensionSettings.qteProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    extensionSettings.currentQteProfile = 'Tutorial - First Steps';
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_QTE_PROFILES).length, 'factory QTE profiles');

    // Reset factory Dice profiles (clear old, add new)
    extensionSettings.diceProfiles = {};
    for (const [name, profile] of Object.entries(DEFAULT_DICE_PROFILES)) {
        extensionSettings.diceProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    extensionSettings.currentDiceProfile = 'Tutorial - Luck Practice';
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_DICE_PROFILES).length, 'factory Dice profiles');

    // Reset factory Stealth profiles (clear old, add new)
    extensionSettings.stealthProfiles = {};
    for (const [name, profile] of Object.entries(DEFAULT_STEALTH_PROFILES)) {
        extensionSettings.stealthProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    extensionSettings.currentStealthProfile = 'Tutorial - Stealth Basics';
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_STEALTH_PROFILES).length, 'factory Stealth profiles');

    // Reset factory Puzzle profiles (clear old, add new)
    extensionSettings.puzzleProfiles = {};
    for (const [name, profile] of Object.entries(DEFAULT_PUZZLE_PROFILES)) {
        extensionSettings.puzzleProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    extensionSettings.currentPuzzleProfile = 'Tutorial - Mind Training';
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_PUZZLE_PROFILES).length, 'factory Puzzle profiles');

    // Reset factory Negotiation profiles (clear old, add new)
    extensionSettings.negotiationProfiles = {};
    for (const [name, profile] of Object.entries(DEFAULT_NEGOTIATION_PROFILES)) {
        extensionSettings.negotiationProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    extensionSettings.currentNegotiationProfile = 'Tutorial - Social Training';
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_NEGOTIATION_PROFILES).length, 'factory Negotiation profiles');

    // Reset factory maze profiles (clear old, add new)
    extensionSettings.mazeProfiles = {};
    for (const [name, profile] of Object.entries(DEFAULT_MAZE_PROFILE)) {
        extensionSettings.mazeProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    extensionSettings.currentMazeProfile = 'Tutorial - Learn the Basics';
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_MAZE_PROFILE).length, 'factory maze profiles');

    // Reset factory minion profiles/packs (clear old, add new)
    extensionSettings.minionProfiles = {};
    for (const [name, profile] of Object.entries(DEFAULT_MINION_PROFILES)) {
        extensionSettings.minionProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_MINION_PROFILES).length, 'factory minion profiles');

    // Reset factory trap profiles/packs (clear old, add new)
    extensionSettings.trapProfiles = {};
    for (const [name, profile] of Object.entries(DEFAULT_TRAP_PROFILES)) {
        extensionSettings.trapProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_TRAP_PROFILES).length, 'factory trap profiles');

    // v2.0.1: Reset factory quest profiles (clear old, add new)
    extensionSettings.questProfiles = {};
    for (const [name, profile] of Object.entries(DEFAULT_QUEST_PROFILES)) {
        extensionSettings.questProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_QUEST_PROFILES).length, 'factory quest profiles');

    // v2.0.1: Clear custom themes (defaults are accessed via DEFAULT_THEME_PROFILES)
    extensionSettings.customThemes = {};
    console.log('[MazeMaster] Cleared custom themes - factory defaults available via dropdown');

    // v2.0.1: Clear custom styles (defaults are accessed via DEFAULT_STYLE_PROFILES)
    extensionSettings.customStyles = {};
    console.log('[MazeMaster] Cleared custom styles - factory defaults available via dropdown');

    // Update the stored version
    extensionSettings.factoryDefaultsVersion = FACTORY_DEFAULTS_VERSION;

    console.log('[MazeMaster] Factory defaults reset complete - all old profiles removed, v2.0.4 profiles installed');
}

function loadSettings() {
    const context = SillyTavern.getContext();

    // Initialize settings if they don't exist
    if (!context.extensionSettings[MODULE_NAME]) {
        context.extensionSettings[MODULE_NAME] = JSON.parse(JSON.stringify(defaultSettings));
    }

    // Get reference to stored settings
    extensionSettings = context.extensionSettings[MODULE_NAME];

    // Check if factory defaults need to be reset (version changed)
    const storedVersion = extensionSettings.factoryDefaultsVersion || 0;
    if (storedVersion < FACTORY_DEFAULTS_VERSION) {
        console.log(`[MazeMaster] Factory defaults version changed: ${storedVersion} -> ${FACTORY_DEFAULTS_VERSION}`);
        // Ensure storage objects exist before reset
        if (!extensionSettings.traps) extensionSettings.traps = {};
        if (!extensionSettings.minions) extensionSettings.minions = {};
        if (!extensionSettings.profiles) extensionSettings.profiles = {};
        if (!extensionSettings.battlebarProfiles) extensionSettings.battlebarProfiles = {};
        if (!extensionSettings.turnbasedProfiles) extensionSettings.turnbasedProfiles = {};
        if (!extensionSettings.qteProfiles) extensionSettings.qteProfiles = {};
        if (!extensionSettings.diceProfiles) extensionSettings.diceProfiles = {};
        if (!extensionSettings.stealthProfiles) extensionSettings.stealthProfiles = {};
        if (!extensionSettings.puzzleProfiles) extensionSettings.puzzleProfiles = {};
        if (!extensionSettings.negotiationProfiles) extensionSettings.negotiationProfiles = {};
        if (!extensionSettings.mazeProfiles) extensionSettings.mazeProfiles = {};
        if (!extensionSettings.minionProfiles) extensionSettings.minionProfiles = {};
        if (!extensionSettings.trapProfiles) extensionSettings.trapProfiles = {};
        resetFactoryDefaults();
        saveSettingsDebounced();
    }

    // v2.0.3: Repair corrupted bspConfig values in saved maze profiles
    // This fixes profiles that were corrupted by earlier mutation bugs
    let profilesRepaired = 0;
    if (extensionSettings.mazeProfiles) {
        for (const [name, profile] of Object.entries(extensionSettings.mazeProfiles)) {
            if (profile?.bspConfig?.secretDensity > 0.2) {
                console.warn(`[MazeMaster] Repairing corrupted secretDensity in profile "${name}": ${profile.bspConfig.secretDensity} -> 0.05`);
                profile.bspConfig.secretDensity = 0.05;
                profilesRepaired++;
            }
            if (profile?.bspConfig?.maxDepth > 20) {
                console.warn(`[MazeMaster] Repairing corrupted maxDepth in profile "${name}": ${profile.bspConfig.maxDepth} -> 6`);
                profile.bspConfig.maxDepth = 6;
                profilesRepaired++;
            }
        }
        if (profilesRepaired > 0) {
            console.log(`[MazeMaster] Repaired ${profilesRepaired} corrupted profile value(s)`);
            saveSettingsDebounced();
        }
    }

    // Fill in any missing defaults
    for (const key in defaultSettings) {
        if (extensionSettings[key] === undefined) {
            extensionSettings[key] = JSON.parse(JSON.stringify(defaultSettings[key]));
        }
    }

    // Ensure profiles objects exist
    if (!extensionSettings.profiles) {
        extensionSettings.profiles = {};
    }
    if (!extensionSettings.battlebarProfiles) {
        extensionSettings.battlebarProfiles = {};
    }
    if (!extensionSettings.mazeProfiles) {
        extensionSettings.mazeProfiles = {};
    }
    if (!extensionSettings.minions) {
        extensionSettings.minions = {};
    }
    if (!extensionSettings.traps) {
        extensionSettings.traps = {};
    }
    if (!extensionSettings.savedMazes) {
        extensionSettings.savedMazes = {};
    }
    if (!extensionSettings.minionProfiles) {
        extensionSettings.minionProfiles = {};
    }
    if (!extensionSettings.trapProfiles) {
        extensionSettings.trapProfiles = {};
    }

    // Always merge in default example data (won't overwrite existing profiles with same name)
    let needsSave = false;

    // Merge default wheel profiles
    for (const [name, profile] of Object.entries(DEFAULT_WHEEL_PROFILES)) {
        if (!extensionSettings.profiles[name]) {
            extensionSettings.profiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default wheel profile: ${name}`);
        }
    }

    // Migration: Fix broken wheel profiles with duplicate/empty triggers
    for (const [name, defaultProfile] of Object.entries(DEFAULT_WHEEL_PROFILES)) {
        const savedProfile = extensionSettings.profiles[name];
        if (savedProfile?.segments?.length > 0) {
            const triggers = savedProfile.segments.map(s => s.trigger);
            const uniqueTriggers = new Set(triggers);
            // If all triggers are the same (broken), or any are empty, replace with default
            if (uniqueTriggers.size === 1 || triggers.some(t => !t || t === '')) {
                extensionSettings.profiles[name] = JSON.parse(JSON.stringify(defaultProfile));
                needsSave = true;
                console.log(`[MazeMaster] Fixed broken wheel profile: ${name}`);
            }
        }
    }

    if (!extensionSettings.currentProfile) {
        extensionSettings.currentProfile = 'Blessing Wheel';
    }

    // Merge default battlebar profiles
    for (const [name, profile] of Object.entries(DEFAULT_BATTLEBAR_PROFILES)) {
        if (!extensionSettings.battlebarProfiles[name]) {
            extensionSettings.battlebarProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default battlebar profile: ${name}`);
        }
    }
    if (!extensionSettings.currentBattlebarProfile) {
        extensionSettings.currentBattlebarProfile = 'Tutorial - Learn Combat';
    }

    // Update existing battlebar profiles with any missing fields from defaults
    const defaultBbTemplate = DEFAULT_BATTLEBAR_PROFILES['Tutorial - Learn Combat'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.battlebarProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultBbTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to battlebar profile: ${name}`);
            }
        }
    }

    // Initialize turn-based profiles storage
    if (!extensionSettings.turnbasedProfiles) {
        extensionSettings.turnbasedProfiles = {};
        needsSave = true;
    }

    // Merge default turn-based profiles
    for (const [name, profile] of Object.entries(DEFAULT_TURNBASED_PROFILES)) {
        if (!extensionSettings.turnbasedProfiles[name]) {
            extensionSettings.turnbasedProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default turn-based profile: ${name}`);
        }
    }
    if (!extensionSettings.currentTurnbasedProfile) {
        extensionSettings.currentTurnbasedProfile = 'Tutorial - Learn Turn-Based';
    }

    // Update existing turn-based profiles with any missing fields from defaults
    const defaultTbTemplate = DEFAULT_TURNBASED_PROFILES['Tutorial - Learn Turn-Based'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.turnbasedProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultTbTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to turn-based profile: ${name}`);
            }
        }
    }

    // Initialize QTE profiles storage
    if (!extensionSettings.qteProfiles) {
        extensionSettings.qteProfiles = {};
        needsSave = true;
    }

    // Merge default QTE profiles
    for (const [name, profile] of Object.entries(DEFAULT_QTE_PROFILES)) {
        if (!extensionSettings.qteProfiles[name]) {
            extensionSettings.qteProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default QTE profile: ${name}`);
        }
    }
    if (!extensionSettings.currentQteProfile) {
        extensionSettings.currentQteProfile = 'Tutorial - First Steps';
    }

    // Update existing QTE profiles with any missing fields from defaults
    const defaultQteTemplate = DEFAULT_QTE_PROFILES['Tutorial - First Steps'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.qteProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultQteTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to QTE profile: ${name}`);
            }
        }
    }

    // Initialize Dice profiles storage
    if (!extensionSettings.diceProfiles) {
        extensionSettings.diceProfiles = {};
        needsSave = true;
    }

    // Merge default Dice profiles
    for (const [name, profile] of Object.entries(DEFAULT_DICE_PROFILES)) {
        if (!extensionSettings.diceProfiles[name]) {
            extensionSettings.diceProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default Dice profile: ${name}`);
        }
    }
    if (!extensionSettings.currentDiceProfile) {
        extensionSettings.currentDiceProfile = 'Tutorial - Luck Practice';
    }

    // Update existing Dice profiles with any missing fields from defaults
    const defaultDiceTemplate = DEFAULT_DICE_PROFILES['Tutorial - Luck Practice'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.diceProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultDiceTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to Dice profile: ${name}`);
            }
        }
    }

    // Initialize Stealth profiles storage
    if (!extensionSettings.stealthProfiles) {
        extensionSettings.stealthProfiles = {};
        needsSave = true;
    }

    // Merge default Stealth profiles
    for (const [name, profile] of Object.entries(DEFAULT_STEALTH_PROFILES)) {
        if (!extensionSettings.stealthProfiles[name]) {
            extensionSettings.stealthProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default Stealth profile: ${name}`);
        }
    }
    if (!extensionSettings.currentStealthProfile) {
        extensionSettings.currentStealthProfile = 'Tutorial - Stealth Basics';
    }

    // Update existing Stealth profiles with any missing fields from defaults
    const defaultStealthTemplate = DEFAULT_STEALTH_PROFILES['Tutorial - Stealth Basics'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.stealthProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultStealthTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to Stealth profile: ${name}`);
            }
        }
    }

    // Initialize Puzzle profiles storage
    if (!extensionSettings.puzzleProfiles) {
        extensionSettings.puzzleProfiles = {};
        needsSave = true;
    }

    // Merge default Puzzle profiles
    for (const [name, profile] of Object.entries(DEFAULT_PUZZLE_PROFILES)) {
        if (!extensionSettings.puzzleProfiles[name]) {
            extensionSettings.puzzleProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default Puzzle profile: ${name}`);
        }
    }
    if (!extensionSettings.currentPuzzleProfile) {
        extensionSettings.currentPuzzleProfile = 'Tutorial - Mind Training';
    }

    // Update existing Puzzle profiles with any missing fields from defaults
    const defaultPuzzleTemplate = DEFAULT_PUZZLE_PROFILES['Tutorial - Mind Training'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.puzzleProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultPuzzleTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to Puzzle profile: ${name}`);
            }
        }
    }

    // Initialize Negotiation profiles storage
    if (!extensionSettings.negotiationProfiles) {
        extensionSettings.negotiationProfiles = {};
        needsSave = true;
    }

    // Merge default Negotiation profiles
    for (const [name, profile] of Object.entries(DEFAULT_NEGOTIATION_PROFILES)) {
        if (!extensionSettings.negotiationProfiles[name]) {
            extensionSettings.negotiationProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default Negotiation profile: ${name}`);
        }
    }
    if (!extensionSettings.currentNegotiationProfile) {
        extensionSettings.currentNegotiationProfile = 'Tutorial - Social Training';
    }

    // Update existing Negotiation profiles with any missing fields from defaults
    const defaultNegotiationTemplate = DEFAULT_NEGOTIATION_PROFILES['Tutorial - Social Training'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.negotiationProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultNegotiationTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to Negotiation profile: ${name}`);
            }
        }
    }

    // Initialize Merchant Item Pools storage
    if (!extensionSettings.merchantItemPools) {
        extensionSettings.merchantItemPools = {};
        needsSave = true;
    }

    // Merge default Merchant Item Pools
    for (const [name, pool] of Object.entries(DEFAULT_MERCHANT_ITEM_POOLS)) {
        if (!extensionSettings.merchantItemPools[name]) {
            extensionSettings.merchantItemPools[name] = JSON.parse(JSON.stringify(pool));
            needsSave = true;
            console.log(`[MazeMaster] Added default Merchant Item Pool: ${name}`);
        }
    }

    // Merge default minions
    for (const [id, minion] of Object.entries(DEFAULT_MINIONS)) {
        if (!extensionSettings.minions[id]) {
            extensionSettings.minions[id] = JSON.parse(JSON.stringify(minion));
            needsSave = true;
            console.log(`[MazeMaster] Added default minion: ${id}`);
        }
    }

    // Merge default traps
    for (const [id, trap] of Object.entries(DEFAULT_TRAPS)) {
        if (!extensionSettings.traps[id]) {
            extensionSettings.traps[id] = JSON.parse(JSON.stringify(trap));
            needsSave = true;
            console.log(`[MazeMaster] Added default trap: ${id}`);
        }
    }

    // Merge default minion profiles (saved sets of minions)
    for (const [name, profile] of Object.entries(DEFAULT_MINION_PROFILES)) {
        if (!extensionSettings.minionProfiles[name]) {
            extensionSettings.minionProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default minion profile: ${name}`);
        }
    }

    // Merge default trap profiles (saved sets of traps)
    for (const [name, profile] of Object.entries(DEFAULT_TRAP_PROFILES)) {
        if (!extensionSettings.trapProfiles[name]) {
            extensionSettings.trapProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default trap profile: ${name}`);
        }
    }

    // Merge default maze profile (and update existing with missing or empty fields)
    for (const [name, defaultProfile] of Object.entries(DEFAULT_MAZE_PROFILE)) {
        if (!extensionSettings.mazeProfiles[name]) {
            extensionSettings.mazeProfiles[name] = JSON.parse(JSON.stringify(defaultProfile));
            needsSave = true;
            console.log(`[MazeMaster] Added default maze profile: ${name}`);
        } else {
            // Update existing profile with any missing or empty fields from default
            const existing = extensionSettings.mazeProfiles[name];
            for (const [key, value] of Object.entries(defaultProfile)) {
                // Check if the existing value is empty/missing
                const isEmptyArray = Array.isArray(existing[key]) && existing[key].length === 0;
                const isEmptyObject = typeof existing[key] === 'object' && existing[key] !== null &&
                    !Array.isArray(existing[key]) && Object.keys(existing[key]).length === 0;
                // gridSize specifically must be a positive number
                const isInvalidGridSize = key === 'gridSize' && (!existing[key] || existing[key] < 5);
                const isEmpty = existing[key] === undefined || isEmptyArray || isEmptyObject || isInvalidGridSize;

                // Also check if startingInventory has all zero values (treat as empty)
                const isZeroInventory = key === 'startingInventory' && existing[key] &&
                    typeof existing[key] === 'object' &&
                    (existing[key].key || 0) === 0 &&
                    (existing[key].stealth || 0) === 0 &&
                    (existing[key].strike || 0) === 0 &&
                    (existing[key].execute || 0) === 0;

                if ((isEmpty || isZeroInventory) && value && (Array.isArray(value) ? value.length > 0 : true)) {
                    existing[key] = JSON.parse(JSON.stringify(value));
                    needsSave = true;
                    console.log(`[MazeMaster] Added missing/empty field '${key}' to maze profile: ${name}`);
                }
            }
        }
    }
    if (!extensionSettings.currentMazeProfile) {
        extensionSettings.currentMazeProfile = 'Tutorial - Learn the Basics';
    }

    // Save to ensure structure is persisted
    if (needsSave) {
        saveSettingsDebounced();
    }

    console.log('[MazeMaster] Loaded settings:', extensionSettings);
}

function getProfileNames() {
    return Object.keys(extensionSettings.profiles || {});
}

function getProfile(name) {
    return extensionSettings.profiles[name];
}

function saveProfile(name, segments, randomize = false, difficulty = 1) {
    extensionSettings.profiles[name] = { segments, randomize, difficulty };
    saveSettingsDebounced();
    console.log('[MazeMaster] Profile saved:', name, extensionSettings.profiles[name]);
}

function deleteProfile(name) {
    delete extensionSettings.profiles[name];
    if (extensionSettings.currentProfile === name) {
        const remaining = getProfileNames();
        extensionSettings.currentProfile = remaining[0] || 'Tutorial - Learn the Wheel';
    }
    saveSettingsDebounced();
}

// Battlebar profile functions
function getBattlebarProfileNames() {
    return Object.keys(extensionSettings.battlebarProfiles || {});
}

function getBattlebarProfile(name) {
    return extensionSettings.battlebarProfiles[name];
}

function saveBattlebarProfile(name, profileData) {
    extensionSettings.battlebarProfiles[name] = {
        mainTitle: profileData.mainTitle || '',
        description: profileData.description || '',
        difficulty: profileData.difficulty || 3,
        hitsToWin: profileData.hitsToWin || 5,
        missesToLose: profileData.missesToLose || 3,
        hitCommand: profileData.hitCommand || '',
        missCommand: profileData.missCommand || '',
        winCommand: profileData.winCommand || '',
        loseCommand: profileData.loseCommand || '',
        images: profileData.images || [],
        // Item drop chances (maze only)
        keyDropChance: profileData.keyDropChance ?? 40,
        strikeDropChance: profileData.strikeDropChance ?? 20,
        stealthDropChance: profileData.stealthDropChance ?? 10,
    };
    saveSettingsDebounced();
    console.log('[MazeMaster] Battlebar profile saved:', name, extensionSettings.battlebarProfiles[name]);
}

function deleteBattlebarProfile(name) {
    delete extensionSettings.battlebarProfiles[name];
    if (extensionSettings.currentBattlebarProfile === name) {
        const remaining = getBattlebarProfileNames();
        extensionSettings.currentBattlebarProfile = remaining[0] || 'Tutorial - Learn Combat';
    }
    saveSettingsDebounced();
}

// Turn-Based profile functions (stub for now)
function getTurnbasedProfileNames() {
    return Object.keys(extensionSettings.turnbasedProfiles || {});
}

function getTurnbasedProfile(name) {
    return extensionSettings.turnbasedProfiles?.[name];
}

function saveTurnbasedProfile(name, profileData) {
    if (!extensionSettings.turnbasedProfiles) {
        extensionSettings.turnbasedProfiles = {};
    }
    extensionSettings.turnbasedProfiles[name] = { ...profileData };
    saveSettingsDebounced();
}

function deleteTurnbasedProfile(name) {
    delete extensionSettings.turnbasedProfiles?.[name];
    if (extensionSettings.currentTurnbasedProfile === name) {
        const remaining = getTurnbasedProfileNames();
        extensionSettings.currentTurnbasedProfile = remaining[0] || '';
    }
    saveSettingsDebounced();
}

// QTE profile functions
function getQteProfileNames() {
    return Object.keys(extensionSettings.qteProfiles || {});
}

function getQteProfile(name) {
    return extensionSettings.qteProfiles?.[name];
}

function saveQteProfile(name, profileData) {
    if (!extensionSettings.qteProfiles) {
        extensionSettings.qteProfiles = {};
    }
    extensionSettings.qteProfiles[name] = { ...profileData };
    saveSettingsDebounced();
}

function deleteQteProfile(name) {
    delete extensionSettings.qteProfiles?.[name];
    if (extensionSettings.currentQteProfile === name) {
        const remaining = getQteProfileNames();
        extensionSettings.currentQteProfile = remaining[0] || '';
    }
    saveSettingsDebounced();
}

// Dice profile functions
function getDiceProfileNames() {
    return Object.keys(extensionSettings.diceProfiles || {});
}

function getDiceProfile(name) {
    return extensionSettings.diceProfiles?.[name];
}

function saveDiceProfile(name, profileData) {
    if (!extensionSettings.diceProfiles) {
        extensionSettings.diceProfiles = {};
    }
    extensionSettings.diceProfiles[name] = { ...profileData };
    saveSettingsDebounced();
}

function deleteDiceProfile(name) {
    delete extensionSettings.diceProfiles?.[name];
    if (extensionSettings.currentDiceProfile === name) {
        const remaining = getDiceProfileNames();
        extensionSettings.currentDiceProfile = remaining[0] || '';
    }
    saveSettingsDebounced();
}

// Stealth profile functions
function getStealthProfileNames() {
    return Object.keys(extensionSettings.stealthProfiles || {});
}

function getStealthProfile(name) {
    return extensionSettings.stealthProfiles?.[name];
}

function saveStealthProfile(name, profileData) {
    if (!extensionSettings.stealthProfiles) {
        extensionSettings.stealthProfiles = {};
    }
    extensionSettings.stealthProfiles[name] = { ...profileData };
    saveSettingsDebounced();
}

function deleteStealthProfile(name) {
    delete extensionSettings.stealthProfiles?.[name];
    if (extensionSettings.currentStealthProfile === name) {
        const remaining = getStealthProfileNames();
        extensionSettings.currentStealthProfile = remaining[0] || '';
    }
    saveSettingsDebounced();
}

// Puzzle profile functions
function getPuzzleProfileNames() {
    return Object.keys(extensionSettings.puzzleProfiles || {});
}

function getPuzzleProfile(name) {
    return extensionSettings.puzzleProfiles?.[name];
}

function savePuzzleProfile(name, profileData) {
    if (!extensionSettings.puzzleProfiles) {
        extensionSettings.puzzleProfiles = {};
    }
    extensionSettings.puzzleProfiles[name] = { ...profileData };
    saveSettingsDebounced();
}

function deletePuzzleProfile(name) {
    delete extensionSettings.puzzleProfiles?.[name];
    if (extensionSettings.currentPuzzleProfile === name) {
        const remaining = getPuzzleProfileNames();
        extensionSettings.currentPuzzleProfile = remaining[0] || '';
    }
    saveSettingsDebounced();
}

// Negotiation profile functions
function getNegotiationProfileNames() {
    return Object.keys(extensionSettings.negotiationProfiles || {});
}

function getNegotiationProfile(name) {
    return extensionSettings.negotiationProfiles?.[name];
}

function saveNegotiationProfile(name, profileData) {
    if (!extensionSettings.negotiationProfiles) {
        extensionSettings.negotiationProfiles = {};
    }
    extensionSettings.negotiationProfiles[name] = { ...profileData };
    saveSettingsDebounced();
}

function deleteNegotiationProfile(name) {
    delete extensionSettings.negotiationProfiles?.[name];
    if (extensionSettings.currentNegotiationProfile === name) {
        const remaining = getNegotiationProfileNames();
        extensionSettings.currentNegotiationProfile = remaining[0] || '';
    }
    saveSettingsDebounced();
}

// v1.6.0: Combat Mechanics profile functions
function getCombatMechanicsProfileNames() {
    const profiles = extensionSettings.combatMechanicsProfiles || {};
    const names = Object.keys(profiles);
    // Always include defaults
    return [...new Set(['default', 'aggressive', 'defensive', 'classic', ...names])];
}

function getCombatMechanicsProfileData(name) {
    if (DEFAULT_COMBAT_MECHANICS_PROFILES[name]) {
        // Merge saved profile with defaults
        const saved = extensionSettings.combatMechanicsProfiles?.[name] || {};
        return { ...DEFAULT_COMBAT_MECHANICS_PROFILES[name], ...saved };
    }
    return extensionSettings.combatMechanicsProfiles?.[name] || DEFAULT_COMBAT_MECHANICS_PROFILES.default;
}

function saveCombatMechanicsProfile(name, profileData) {
    if (!extensionSettings.combatMechanicsProfiles) {
        extensionSettings.combatMechanicsProfiles = {};
    }
    extensionSettings.combatMechanicsProfiles[name] = {
        name: profileData.name || name,
        description: profileData.description || '',
        // Combo
        comboEnabled: profileData.comboEnabled ?? true,
        comboBonusPerHit: profileData.comboBonusPerHit ?? 5,
        maxComboBonus: profileData.maxComboBonus ?? 50,
        comboDecayTurns: profileData.comboDecayTurns ?? 2,
        comboResetOnMiss: profileData.comboResetOnMiss ?? true,
        comboResetOnDamage: profileData.comboResetOnDamage ?? false,
        // Block
        blockEnabled: profileData.blockEnabled ?? true,
        blockDamageReduction: profileData.blockDamageReduction ?? 0.5,
        blockBreakThreshold: profileData.blockBreakThreshold ?? 0,
        perfectBlockWindow: profileData.perfectBlockWindow ?? 0.3,
        perfectBlockReduction: profileData.perfectBlockReduction ?? 0.8,
        // Parry
        parryEnabled: profileData.parryEnabled ?? true,
        parryWindow: profileData.parryWindow ?? 0.5,
        parryDamageMultiplier: profileData.parryDamageMultiplier ?? 1.5,
        parryStunDuration: profileData.parryStunDuration ?? 1,
        parryDifficulty: profileData.parryDifficulty ?? 'normal',
        // Counter
        counterEnabled: profileData.counterEnabled ?? true,
        counterDamageBonus: profileData.counterDamageBonus ?? 25,
        counterCritBonus: profileData.counterCritBonus ?? 15,
        // Hooks
        onComboStart: profileData.onComboStart || '',
        onComboIncrease: profileData.onComboIncrease || '',
        onComboBreak: profileData.onComboBreak || '',
        onBlockAttempt: profileData.onBlockAttempt || '',
        onBlockSuccess: profileData.onBlockSuccess || '',
        onBlockBreak: profileData.onBlockBreak || '',
        onParryAttempt: profileData.onParryAttempt || '',
        onParrySuccess: profileData.onParrySuccess || '',
        onParryFail: profileData.onParryFail || '',
        onCounterAttack: profileData.onCounterAttack || '',
    };
    saveSettingsDebounced();
    console.log('[MazeMaster] Combat Mechanics profile saved:', name);
}

function deleteCombatMechanicsProfile(name) {
    // Don't delete default profiles
    if (DEFAULT_COMBAT_MECHANICS_PROFILES[name]) {
        console.log('[MazeMaster] Cannot delete default profile:', name);
        return false;
    }
    delete extensionSettings.combatMechanicsProfiles?.[name];
    if (extensionSettings.currentCombatMechanicsProfile === name) {
        extensionSettings.currentCombatMechanicsProfile = 'default';
    }
    saveSettingsDebounced();
    return true;
}

// v1.6.0: Custom Item Builder functions
function generateItemId() {
    return 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

function getCustomItemNames() {
    return Object.keys(extensionSettings.customItems || {});
}

function getCustomItem(id) {
    return extensionSettings.customItems?.[id];
}

function createCustomItem(data) {
    if (!extensionSettings.customItems) {
        extensionSettings.customItems = {};
    }
    const id = data.id || generateItemId();
    extensionSettings.customItems[id] = {
        id,
        name: data.name || 'New Item',
        type: data.type || 'consumable',
        subtype: data.subtype || null,
        rarity: data.rarity || 'common',
        icon: data.icon || 'fa-box',
        description: data.description || '',
        effects: data.effects || [],
        // Equipment stats
        attack: data.attack || 0,
        defense: data.defense || 0,
        critBonus: data.critBonus || 0,
        special: data.special || null,
        // Loot config
        lootWeight: data.lootWeight ?? 20,
        lootSources: data.lootSources || ['chest'],
        // STScript hooks
        onUse: data.onUse || '',
        onEquip: data.onEquip || '',
        onDrop: data.onDrop || '',
    };
    saveSettingsDebounced();
    console.log('[MazeMaster] Custom item created:', id, extensionSettings.customItems[id]);
    return id;
}

function updateCustomItem(id, data) {
    if (!extensionSettings.customItems?.[id]) return false;
    extensionSettings.customItems[id] = {
        ...extensionSettings.customItems[id],
        ...data,
        id, // Ensure ID doesn't change
    };
    saveSettingsDebounced();
    return true;
}

function deleteCustomItem(id) {
    if (!extensionSettings.customItems?.[id]) return false;
    delete extensionSettings.customItems[id];
    saveSettingsDebounced();
    return true;
}

/**
 * Process a single item effect
 * @param {object} effect - Effect definition
 * @param {object} context - { player, enemy, combat }
 * @returns {object} Result of the effect
 */
function processItemEffect(effect, context = {}) {
    const result = { success: true, messages: [] };

    switch (effect.type) {
        case 'damage':
            const damage = effect.value || 0;
            if (effect.target === 'enemy' && context.enemy) {
                context.enemy.hp = Math.max(0, (context.enemy.hp || 0) - damage);
                result.messages.push(`Dealt ${damage} ${effect.element || ''} damage!`.trim());
            } else if (effect.target === 'self' && context.player) {
                context.player.hp = Math.max(0, (context.player.hp || 0) - damage);
                result.messages.push(`Took ${damage} damage!`);
            }
            break;

        case 'heal':
            const healAmount = effect.value || 0;
            if (effect.target === 'self' && context.player) {
                context.player.hp = Math.min(context.player.maxHp || 100, (context.player.hp || 0) + healAmount);
                result.messages.push(`Healed for ${healAmount} HP!`);
            }
            break;

        case 'status':
            if (effect.target === 'enemy' && context.enemy && effect.status) {
                if (typeof applyStatusEffect === 'function') {
                    applyStatusEffect('enemy', effect.status, effect.duration || 3);
                }
                result.messages.push(`Applied ${effect.status} for ${effect.duration || 3} turns!`);
            } else if (effect.target === 'self' && context.player && effect.status) {
                if (typeof applyStatusEffect === 'function') {
                    applyStatusEffect('player', effect.status, effect.duration || 3);
                }
                result.messages.push(`Gained ${effect.status} for ${effect.duration || 3} turns!`);
            }
            break;

        case 'buff':
            if (effect.stat && effect.value) {
                result.messages.push(`+${effect.value} ${effect.stat} for ${effect.duration || 3} turns!`);
            }
            break;

        case 'teleport':
            result.messages.push(`Teleported!`);
            break;

        case 'reveal':
            result.messages.push(`Map revealed!`);
            break;

        default:
            result.messages.push(`Effect: ${effect.type}`);
    }

    return result;
}

/**
 * Use a custom item from inventory
 * @param {string} id - Item ID
 * @returns {object} { success, messages, itemRemoved }
 */
async function useCustomItem(id) {
    const item = getCustomItem(id);
    if (!item) return { success: false, messages: ['Item not found'] };

    const result = { success: true, messages: [], itemRemoved: false };

    // Check if item is in inventory
    if (!currentMaze?.customInventory?.[id] || currentMaze.customInventory[id] <= 0) {
        return { success: false, messages: ['You do not have this item'] };
    }

    // Process effects
    const context = {
        player: currentMaze?.character ? {
            hp: currentMaze.hp,
            maxHp: currentMaze.maxHP,
        } : null,
        enemy: currentTurnBased?.enemyHP ? {
            hp: currentTurnBased.enemyHP,
        } : null,
    };

    for (const effect of (item.effects || [])) {
        const effectResult = processItemEffect(effect, context);
        result.messages.push(...effectResult.messages);
    }

    // Update HP values
    if (context.player && currentMaze) {
        currentMaze.hp = context.player.hp;
    }
    if (context.enemy && currentTurnBased) {
        currentTurnBased.enemyHP = context.enemy.hp;
    }

    // Remove item from inventory if consumable
    if (item.type === 'consumable') {
        currentMaze.customInventory[id]--;
        if (currentMaze.customInventory[id] <= 0) {
            delete currentMaze.customInventory[id];
        }
        result.itemRemoved = true;
    }

    // Execute onUse hook
    if (item.onUse) {
        await executeWithTimeout(item.onUse, {
            itemId: id,
            itemName: item.name,
        });
    }

    return result;
}

/**
 * Export custom items to JSON
 * @returns {string} JSON string
 */
function exportCustomItems() {
    return JSON.stringify(extensionSettings.customItems || {}, null, 2);
}

/**
 * Import custom items from JSON
 * @param {string} json - JSON string
 * @returns {number} Number of items imported
 */
function importCustomItems(json) {
    try {
        const items = JSON.parse(json);
        if (!extensionSettings.customItems) {
            extensionSettings.customItems = {};
        }
        let count = 0;
        for (const [id, item] of Object.entries(items)) {
            if (item.name && item.type) {
                extensionSettings.customItems[id] = item;
                count++;
            }
        }
        saveSettingsDebounced();
        return count;
    } catch (e) {
        console.error('[MazeMaster] Failed to import custom items:', e);
        return 0;
    }
}

// =============================================================================
// v1.6.0: MINIMAP SYSTEM
// =============================================================================

/**
 * Get minimap settings
 * @returns {object} Minimap settings
 */
function getMinimapSettings() {
    return extensionSettings.minimapSettings || {
        enabled: true,
        size: 150,
        opacity: 0.85,
        position: 'top-right',
        showMarkers: true,
        showMinions: true,
        showChests: true,
        showPlayer: true,
        showExit: true,
    };
}

/**
 * Generate unique marker ID
 * @returns {string} Marker ID
 */
function generateMarkerId() {
    return 'marker_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
}

/**
 * Add a marker to the minimap
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 * @param {string} type - Marker type (waypoint, danger, note, treasure)
 * @param {string} label - Marker label
 * @returns {string} Marker ID
 */
async function addMinimapMarker(x, y, type = 'waypoint', label = '') {
    if (!currentMaze?.minimap) return null;

    const settings = getMinimapSettings();
    const markerType = settings.markerTypes?.find(t => t.id === type) || settings.markerTypes?.[0];

    const marker = {
        id: generateMarkerId(),
        x,
        y,
        type,
        label,
        icon: markerType?.icon || 'fa-location-dot',
        color: markerType?.color || '#3498db',
    };

    currentMaze.minimap.markers.push(marker);

    // Execute STScript hook
    if (settings.onMarkerAdd) {
        await executeWithTimeout(settings.onMarkerAdd, {
            x,
            y,
            type,
            label,
            markerId: marker.id,
        });
    }

    renderMinimap();
    return marker.id;
}

/**
 * Remove a marker from the minimap
 * @param {string} markerId - Marker ID to remove
 * @returns {boolean} Whether marker was found and removed
 */
async function removeMinimapMarker(markerId) {
    if (!currentMaze?.minimap?.markers) return false;

    const index = currentMaze.minimap.markers.findIndex(m => m.id === markerId);
    if (index === -1) return false;

    const marker = currentMaze.minimap.markers[index];
    currentMaze.minimap.markers.splice(index, 1);

    // Execute STScript hook
    const settings = getMinimapSettings();
    if (settings.onMarkerRemove) {
        await executeWithTimeout(settings.onMarkerRemove, {
            markerId,
            x: marker.x,
            y: marker.y,
            type: marker.type,
        });
    }

    renderMinimap();
    return true;
}

/**
 * Clear all markers from the minimap
 */
function clearMinimapMarkers() {
    if (!currentMaze?.minimap) return;
    currentMaze.minimap.markers = [];
    renderMinimap();
}

/**
 * Toggle minimap visibility
 */
function toggleMinimap() {
    if (!currentMaze?.minimap) return;
    currentMaze.minimap.enabled = !currentMaze.minimap.enabled;
    const container = document.getElementById('mazemaster_minimap_container');
    if (container) {
        container.style.display = currentMaze.minimap.enabled ? 'block' : 'none';
    }
}

/**
 * Render the minimap canvas
 */
function renderMinimap() {
    const container = document.getElementById('mazemaster_minimap_container');
    const canvas = document.getElementById('mazemaster_minimap_canvas');
    if (!container || !canvas || !currentMaze?.grid) return;

    const settings = getMinimapSettings();
    if (!settings.enabled || !currentMaze.minimap?.enabled) {
        container.style.display = 'none';
        return;
    }

    container.style.display = 'block';

    const ctx = canvas.getContext('2d');
    const size = settings.size || 150;
    const gridSize = currentMaze.grid.length;
    const cellSize = Math.floor(size / gridSize);

    canvas.width = cellSize * gridSize;
    canvas.height = cellSize * gridSize;
    container.style.width = `${canvas.width}px`;
    container.style.height = `${canvas.height + 30}px`; // +30 for header
    container.style.opacity = settings.opacity || 0.85;

    // Position the minimap
    const positions = {
        'top-right': { top: '10px', right: '10px', bottom: 'auto', left: 'auto' },
        'top-left': { top: '10px', left: '10px', bottom: 'auto', right: 'auto' },
        'bottom-right': { bottom: '10px', right: '10px', top: 'auto', left: 'auto' },
        'bottom-left': { bottom: '10px', left: '10px', top: 'auto', right: 'auto' },
    };
    const pos = positions[settings.position] || positions['top-right'];
    Object.assign(container.style, pos);

    // Clear canvas
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw grid cells
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = currentMaze.grid[y]?.[x];
            if (!cell) continue;

            const px = x * cellSize;
            const py = y * cellSize;

            // Determine cell color based on visibility and type
            let cellColor = '#1a1a2e'; // Default unexplored
            if (cell.explored || cell.visible) {
                if (cell.type === 'wall') {
                    cellColor = '#333';
                } else if (cell.type === 'exit') {
                    cellColor = settings.showExit ? '#2ecc71' : '#2a2a4a';
                } else if (cell.type === 'chest') {
                    cellColor = settings.showChests ? '#f1c40f' : '#2a2a4a';
                } else if (cell.type === 'saferoom') {
                    cellColor = '#27ae60';
                } else {
                    cellColor = '#2a2a4a';
                }
            }

            ctx.fillStyle = cellColor;
            ctx.fillRect(px, py, cellSize - 1, cellSize - 1);

            // Draw minions
            if (settings.showMinions && cell.minion && (cell.explored || cell.visible)) {
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(px + cellSize / 2, py + cellSize / 2, cellSize / 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    // Draw player position
    if (settings.showPlayer && currentMaze.x !== undefined && currentMaze.y !== undefined) {
        const px = currentMaze.x * cellSize + cellSize / 2;
        const py = currentMaze.y * cellSize + cellSize / 2;

        ctx.fillStyle = '#3498db';
        ctx.beginPath();
        ctx.arc(px, py, cellSize / 2.5, 0, Math.PI * 2);
        ctx.fill();

        // White dot in center
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(px, py, cellSize / 6, 0, Math.PI * 2);
        ctx.fill();
    }

    // Draw markers
    if (settings.showMarkers && currentMaze.minimap?.markers) {
        for (const marker of currentMaze.minimap.markers) {
            const px = marker.x * cellSize + cellSize / 2;
            const py = marker.y * cellSize + cellSize / 2;

            // Draw marker circle
            ctx.fillStyle = marker.color || '#f39c12';
            ctx.beginPath();
            ctx.arc(px, py, cellSize / 3, 0, Math.PI * 2);
            ctx.fill();

            // Draw marker border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }
}

/**
 * Update minimap when player position changes
 */
function updateMinimapPosition() {
    renderMinimap();
}

/**
 * Create minimap HTML container
 * @returns {string} HTML string
 */
function getMinimapHTML() {
    const settings = getMinimapSettings();
    return `
        <div id="mazemaster_minimap_container" class="mazemaster-minimap" style="display: ${settings.enabled ? 'block' : 'none'};">
            <div class="mazemaster-minimap-header">
                <span><i class="fa-solid fa-map"></i> Minimap</span>
                <button id="mazemaster_minimap_toggle" class="mazemaster-minimap-btn" title="Toggle Minimap">
                    <i class="fa-solid fa-eye"></i>
                </button>
            </div>
            <canvas id="mazemaster_minimap_canvas"></canvas>
        </div>
    `;
}

// Maze profile functions
function getMazeProfileNames() {
    // Combine user's saved profiles with built-in defaults (no duplicates)
    const savedNames = Object.keys(extensionSettings.mazeProfiles || {});
    const defaultNames = Object.keys(DEFAULT_MAZE_PROFILE || {});
    return [...new Set([...savedNames, ...defaultNames])];
}

function getMazeProfile(name) {
    // Check user's saved profiles first, then fall back to built-in defaults
    return extensionSettings.mazeProfiles?.[name] || DEFAULT_MAZE_PROFILE[name];
}

function saveMazeProfile(name, profileData) {
    extensionSettings.mazeProfiles[name] = {
        gridSize: profileData.gridSize || 10,
        difficulty: profileData.difficulty || 'normal',
        theme: profileData.theme || 'fantasy',
        mapStyle: profileData.mapStyle || 'maze',
        floors: profileData.floors || 1,
        mapVisibility: profileData.mapVisibility || 'fogOfWar',
        winCommand: profileData.winCommand || '',
        winImage: profileData.winImage || '',
        winMessage: profileData.winMessage || '',
        // Main minion settings
        mainMinion: profileData.mainMinion || '',
        mainMinionIntroMessage: profileData.mainMinionIntroMessage || '',
        mainMinionRandomChance: profileData.mainMinionRandomChance || 15,
        mainMinionRandomMessages: profileData.mainMinionRandomMessages || [],
        mainMinionExitType: profileData.mainMinionExitType || 'messenger',
        mainMinionExitProfile: profileData.mainMinionExitProfile || '',
        // Encounter settings (percent-based)
        minionEncounters: profileData.minionEncounters || [], // { minionId, percent }
        onBattlebarLoss: profileData.onBattlebarLoss || 'continue',
        loseCommand: profileData.loseCommand || '',
        // Chest tile settings
        chestImage: profileData.chestImage || '',
        chestTilePercent: profileData.chestTilePercent || 10,
        chestLockedPercent: profileData.chestLockedPercent || 30,
        chestLockedBonusPercent: profileData.chestLockedBonusPercent || 50,
        chestMimicPercent: profileData.chestMimicPercent || 15,
        // Chest loot settings
        chestLootMin: profileData.chestLootMin || 1,
        chestLootMax: profileData.chestLootMax || 2,
        // Regular chest loot chances
        chestKeyChance: profileData.chestKeyChance || 30,
        chestStrikeChance: profileData.chestStrikeChance || 50,
        chestStealthChance: profileData.chestStealthChance || 0,
        // Locked chest loot chances
        lockedChestKeyChance: profileData.lockedChestKeyChance || 40,
        lockedChestStrikeChance: profileData.lockedChestStrikeChance || 60,
        lockedChestStealthChance: profileData.lockedChestStealthChance || 30,
        // Execute chances (rare)
        chestExecuteChance: profileData.chestExecuteChance || 0,
        lockedChestExecuteChance: profileData.lockedChestExecuteChance || 5,
        // Starting inventory (combat + HP items)
        startingInventory: profileData.startingInventory || {
            key: 0, stealth: 0, strike: 0, execute: 0,
            healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0
        },
        // Trap encounters
        trapEncounters: profileData.trapEncounters || [],
        // Story milestones
        storyConfig: profileData.storyConfig || { mainStory: '', milestones: [] },
        // HP System settings (v1.3.0)
        hpEnabled: profileData.hpEnabled !== false,
        maxHP: profileData.maxHP || 100,
        battlebarDamageMultiplier: profileData.battlebarDamageMultiplier ?? 1.0,
        battlebarDifficultyMultiplier: profileData.battlebarDifficultyMultiplier ?? 1.0,
        onDeath: profileData.onDeath || 'respawn',
        respawnHPPercent: profileData.respawnHPPercent || 50,
        // Safe room settings
        safeRoomCount: profileData.safeRoomCount ?? 3,
        safeRoomHealPercent: profileData.safeRoomHealPercent ?? 100,
        safeRoomUseLLM: profileData.safeRoomUseLLM || false,
        // Rest mechanic settings
        restEnabled: profileData.restEnabled !== false,
        restHealPercent: profileData.restHealPercent ?? 20,
        restCooldown: profileData.restCooldown ?? 3,
        restInterruptChance: profileData.restInterruptChance ?? 0,
        restInterruptScript: profileData.restInterruptScript || '',
        // v2.1.0: Avatar generation settings
        avatarGenerationMinions: profileData.avatarGenerationMinions || [], // Array of minion IDs to generate avatars for
    };
    saveSettingsDebounced();
    console.log('[MazeMaster] Maze profile saved:', name, extensionSettings.mazeProfiles[name]);
}

function deleteMazeProfile(name) {
    delete extensionSettings.mazeProfiles[name];
    if (extensionSettings.currentMazeProfile === name) {
        const remaining = getMazeProfileNames();
        extensionSettings.currentMazeProfile = remaining[0] || 'Tutorial - Learn the Basics';
    }
    saveSettingsDebounced();
}

// =============================================================================
// CUSTOM THEME FUNCTIONS
// =============================================================================

function getCustomThemeNames() {
    // v2.0.0: Include both custom themes and default themes
    const customNames = Object.keys(extensionSettings.customThemes || {});
    const defaultNames = Object.keys(DEFAULT_THEME_PROFILES);
    // Combine, with custom themes first, avoiding duplicates
    return [...customNames, ...defaultNames.filter(n => !customNames.includes(n))];
}

function getCustomTheme(name) {
    // v2.0.0: Check custom themes first, then fall back to default themes
    if (extensionSettings.customThemes?.[name]) {
        return extensionSettings.customThemes[name];
    }
    // Return default theme if exists
    if (DEFAULT_THEME_PROFILES[name]) {
        return DEFAULT_THEME_PROFILES[name];
    }
    return undefined;
}

function saveCustomTheme(name, themeData) {
    if (!extensionSettings.customThemes) extensionSettings.customThemes = {};
    extensionSettings.customThemes[name] = {
        ...CUSTOM_THEME_DEFAULTS,
        name: themeData.name || name,
        displayName: themeData.displayName || name,
        tags: themeData.tags || [],
        atmosphere: themeData.atmosphere || '',
        adjectives: themeData.adjectives || [],
        roomTypes: {
            small: themeData.roomTypes?.small || [],
            medium: themeData.roomTypes?.medium || [],
            large: themeData.roomTypes?.large || [],
            special: themeData.roomTypes?.special || [],
        },
        flavorMessages: {
            chestFind: themeData.flavorMessages?.chestFind || '',
            trapTrigger: themeData.flavorMessages?.trapTrigger || '',
            victory: themeData.flavorMessages?.victory || '',
            defeat: themeData.flavorMessages?.defeat || '',
        },
        colors: {
            primary: themeData.colors?.primary || '#8b0000',
            secondary: themeData.colors?.secondary || '#2d1f1f',
            accent: themeData.colors?.accent || '#ff4444',
        }
    };
    saveSettingsDebounced();
    console.log('[MazeMaster] Custom theme saved:', name);
}

function deleteCustomTheme(name) {
    if (extensionSettings.customThemes?.[name]) {
        delete extensionSettings.customThemes[name];
        saveSettingsDebounced();
        console.log('[MazeMaster] Custom theme deleted:', name);
    }
}

/**
 * Get theme modifiers (adjectives) - checks custom themes first
 */
function getThemeModifiers(theme) {
    if (extensionSettings.customThemes?.[theme]) {
        return { adjectives: extensionSettings.customThemes[theme].adjectives || [] };
    }
    return THEME_MODIFIERS[theme] || THEME_MODIFIERS.fantasy;
}

/**
 * Get themed room types - checks custom themes first
 */
function getThemedRoomTypes(theme) {
    if (extensionSettings.customThemes?.[theme]) {
        return extensionSettings.customThemes[theme].roomTypes;
    }
    return THEMED_ROOM_TYPES[theme] || THEMED_ROOM_TYPES.fantasy;
}

// =============================================================================
// CUSTOM STYLE FUNCTIONS
// =============================================================================

function getCustomStyleNames() {
    // v2.0.0: Include both custom styles and default styles
    const customNames = Object.keys(extensionSettings.customStyles || {});
    const defaultNames = Object.keys(DEFAULT_STYLE_PROFILES);
    // Combine, with custom styles first, avoiding duplicates
    return [...customNames, ...defaultNames.filter(n => !customNames.includes(n))];
}

function getCustomStyle(name) {
    // v2.0.0: Check custom styles first, then fall back to default styles
    if (extensionSettings.customStyles?.[name]) {
        return extensionSettings.customStyles[name];
    }
    // Return default style if exists
    if (DEFAULT_STYLE_PROFILES[name]) {
        return DEFAULT_STYLE_PROFILES[name];
    }
    return undefined;
}

function saveCustomStyle(name, styleData) {
    if (!extensionSettings.customStyles) extensionSettings.customStyles = {};
    extensionSettings.customStyles[name] = {
        ...CUSTOM_STYLE_DEFAULTS,
        name: styleData.name || name,
        displayName: styleData.displayName || name,
        roomNames: {
            common: {
                prefixes: styleData.roomNames?.common?.prefixes || [],
                nouns: styleData.roomNames?.common?.nouns || [],
                descriptions: styleData.roomNames?.common?.descriptions || [],
            },
            junction: {
                prefixes: styleData.roomNames?.junction?.prefixes || [],
                nouns: styleData.roomNames?.junction?.nouns || [],
                descriptions: styleData.roomNames?.junction?.descriptions || [],
            },
            deadend: {
                prefixes: styleData.roomNames?.deadend?.prefixes || [],
                nouns: styleData.roomNames?.deadend?.nouns || [],
                descriptions: styleData.roomNames?.deadend?.descriptions || [],
            },
            staircase: {
                names: styleData.roomNames?.staircase?.names || [],
                descriptions: styleData.roomNames?.staircase?.descriptions || [],
            },
            portal: {
                names: styleData.roomNames?.portal?.names || [],
                descriptions: styleData.roomNames?.portal?.descriptions || [],
            },
            chest: {
                names: styleData.roomNames?.chest?.names || [],
                descriptions: styleData.roomNames?.chest?.descriptions || [],
            },
            minion: {
                names: styleData.roomNames?.minion?.names || [],
                descriptions: styleData.roomNames?.minion?.descriptions || [],
            },
            trap: {
                names: styleData.roomNames?.trap?.names || [],
                descriptions: styleData.roomNames?.trap?.descriptions || [],
            },
            exit: {
                names: styleData.roomNames?.exit?.names || [],
                descriptions: styleData.roomNames?.exit?.descriptions || [],
            },
            start: {
                names: styleData.roomNames?.start?.names || [],
                descriptions: styleData.roomNames?.start?.descriptions || [],
            },
        },
        bspConfig: {
            minRoomSize: styleData.bspConfig?.minRoomSize ?? 2,
            maxRoomSize: styleData.bspConfig?.maxRoomSize ?? 5,
            minSplitSize: styleData.bspConfig?.minSplitSize ?? 4,
            splitVariance: styleData.bspConfig?.splitVariance ?? 0.3,
            corridorWidth: styleData.bspConfig?.corridorWidth ?? 1,
            roomPadding: styleData.bspConfig?.roomPadding ?? 1,
            extraConnections: styleData.bspConfig?.extraConnections ?? 0.1,
            branchChance: styleData.bspConfig?.branchChance ?? 0.3,
            preferSquareRooms: styleData.bspConfig?.preferSquareRooms ?? false,
            gridAlign: styleData.bspConfig?.gridAlign ?? false,
            windingCorridors: styleData.bspConfig?.windingCorridors ?? false,
            modularRooms: styleData.bspConfig?.modularRooms ?? false,
        }
    };
    saveSettingsDebounced();
    console.log('[MazeMaster] Custom style saved:', name);
}

function deleteCustomStyle(name) {
    if (extensionSettings.customStyles?.[name]) {
        delete extensionSettings.customStyles[name];
        saveSettingsDebounced();
        console.log('[MazeMaster] Custom style deleted:', name);
    }
}

// =============================================================================
// QUEST PROFILE FUNCTIONS (v1.5.0)
// =============================================================================

// v1.7.0: Old quest profile functions removed - see Quest Profile System section above

/**
 * Render quest templates in config panel
 */
function renderQuestTemplateList() {
    const container = document.getElementById('mazemaster_quest_list');
    if (!container) return;

    const allQuests = getAllQuests();
    const questIds = Object.keys(allQuests);

    if (questIds.length === 0) {
        container.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No quest templates defined</div>';
        return;
    }

    let html = '';
    for (const questId of questIds) {
        const quest = allQuests[questId];
        const questType = getQuestType(quest.type);
        const isDefault = DEFAULT_QUESTS[questId] !== undefined;

        html += `
            <div class="mazemaster-quest-template-card" data-quest-id="${questId}">
                <div class="quest-template-header">
                    <div class="quest-template-title">
                        <i class="fa-solid ${questType.icon}"></i>
                        <span>${escapeHtml(quest.name)}</span>
                        ${isDefault ? '<span class="quest-default-badge">Default</span>' : ''}
                    </div>
                    <div class="quest-template-actions">
                        <button class="menu_button menu_button_icon quest-edit-btn" data-quest="${questId}" title="Edit">
                            <i class="fa-solid fa-pen"></i>
                        </button>
                        ${!isDefault ? `
                        <button class="menu_button menu_button_icon quest-delete-btn" data-quest="${questId}" title="Delete">
                            <i class="fa-solid fa-trash"></i>
                        </button>
                        ` : ''}
                    </div>
                </div>
                <div class="quest-template-info">
                    <span class="quest-template-type">${questType.name}</span>
                    <span class="quest-template-objective">${quest.objective?.count || 1} ${quest.objective?.target || 'target'}</span>
                    <span class="quest-template-reward"><i class="fa-solid fa-star"></i> ${quest.rewards?.xp || 0} XP</span>
                </div>
                <div class="quest-template-description">${escapeHtml(quest.description)}</div>
            </div>
        `;
    }

    container.innerHTML = html;
}

/**
 * Show quest editor dialog
 */
function showQuestEditor(questId = null) {
    const quest = questId ? getQuest(questId) : null;
    const isNew = !quest;
    const isDefault = questId && DEFAULT_QUESTS[questId] !== undefined;

    const dialog = document.createElement('div');
    dialog.className = 'mazemaster-quest-editor-dialog';
    dialog.innerHTML = `
        <div class="mazemaster-quest-editor-backdrop"></div>
        <div class="mazemaster-quest-editor-content">
            <div class="mazemaster-quest-editor-header">
                <h3>${isNew ? 'New Quest' : (isDefault ? 'View Quest (Default)' : 'Edit Quest')}</h3>
                <button class="quest-editor-close">&times;</button>
            </div>
            <div class="mazemaster-quest-editor-body">
                <div class="mazemaster-row">
                    <label style="width: 100px;">Quest ID</label>
                    <input type="text" id="quest_edit_id" class="mazemaster-input"
                        value="${questId || ''}"
                        placeholder="quest_my_quest"
                        ${!isNew ? 'readonly' : ''}
                        style="flex: 1;">
                </div>
                <div class="mazemaster-row">
                    <label style="width: 100px;">Name</label>
                    <input type="text" id="quest_edit_name" class="mazemaster-input"
                        value="${quest?.name || ''}"
                        placeholder="Quest Name"
                        ${isDefault ? 'readonly' : ''}
                        style="flex: 1;">
                </div>
                <div class="mazemaster-row">
                    <label style="width: 100px;">Type</label>
                    <select id="quest_edit_type" class="mazemaster-select" ${isDefault ? 'disabled' : ''}>
                        ${Object.values(QUEST_TYPES).map(t => `
                            <option value="${t.id}" ${quest?.type === t.id ? 'selected' : ''}>${t.name}</option>
                        `).join('')}
                    </select>
                </div>
                <div class="mazemaster-row">
                    <label style="width: 100px;">Target</label>
                    <input type="text" id="quest_edit_target" class="mazemaster-input"
                        value="${quest?.objective?.target || ''}"
                        placeholder="any, key, chest, boss..."
                        ${isDefault ? 'readonly' : ''}
                        style="flex: 1;">
                </div>
                <div class="mazemaster-row">
                    <label style="width: 100px;">Count</label>
                    <input type="number" id="quest_edit_count" class="mazemaster-input"
                        value="${quest?.objective?.count || 1}"
                        min="1"
                        ${isDefault ? 'readonly' : ''}
                        style="width: 80px;">
                </div>
                <div class="mazemaster-row">
                    <label style="width: 100px;">XP Reward</label>
                    <input type="number" id="quest_edit_xp" class="mazemaster-input"
                        value="${quest?.rewards?.xp || 50}"
                        min="0"
                        ${isDefault ? 'readonly' : ''}
                        style="width: 80px;">
                </div>
                <div class="mazemaster-row">
                    <label style="width: 100px;">Description</label>
                    <textarea id="quest_edit_desc" class="mazemaster-textarea"
                        rows="3"
                        placeholder="Quest description..."
                        ${isDefault ? 'readonly' : ''}
                        style="flex: 1;">${quest?.description || ''}</textarea>
                </div>
                <div class="mazemaster-row">
                    <label class="mazemaster-checkbox-label">
                        <input type="checkbox" id="quest_edit_llm" ${quest?.useLLM ? 'checked' : ''} ${isDefault ? 'disabled' : ''}>
                        Generate name/description with LLM
                    </label>
                </div>
            </div>
            <div class="mazemaster-quest-editor-footer">
                ${!isDefault ? `
                <button id="quest_editor_save" class="menu_button">
                    <i class="fa-solid fa-floppy-disk"></i> ${isNew ? 'Create' : 'Save'}
                </button>
                ` : ''}
                <button id="quest_editor_cancel" class="menu_button">
                    ${isDefault ? 'Close' : 'Cancel'}
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(dialog);

    // Event handlers
    dialog.querySelector('.mazemaster-quest-editor-backdrop').addEventListener('click', () => dialog.remove());
    dialog.querySelector('.quest-editor-close').addEventListener('click', () => dialog.remove());
    dialog.querySelector('#quest_editor_cancel').addEventListener('click', () => dialog.remove());

    const saveBtn = dialog.querySelector('#quest_editor_save');
    if (saveBtn) {
        saveBtn.addEventListener('click', () => {
            const newId = document.getElementById('quest_edit_id').value.trim();
            if (!newId) {
                toastr.error('Quest ID is required');
                return;
            }

            const questData = {
                id: newId,
                name: document.getElementById('quest_edit_name').value.trim() || 'Unnamed Quest',
                type: document.getElementById('quest_edit_type').value,
                description: document.getElementById('quest_edit_desc').value.trim(),
                objective: {
                    target: document.getElementById('quest_edit_target').value.trim() || 'any',
                    count: parseInt(document.getElementById('quest_edit_count').value) || 1,
                },
                rewards: {
                    xp: parseInt(document.getElementById('quest_edit_xp').value) || 0,
                    items: [],
                },
                useLLM: document.getElementById('quest_edit_llm').checked,
            };

            saveQuest(newId, questData);
            toastr.success(`Quest ${isNew ? 'created' : 'saved'}: ${questData.name}`);
            dialog.remove();
            renderQuestTemplateList();
        });
    }
}

// =========================================================================
// v1.6.0: CUSTOM ITEMS CONFIG TAB
// =========================================================================

/**
 * Render the custom items list in the Items config tab
 */
function renderCustomItemsList() {
    const container = document.getElementById('mazemaster_items_list');
    if (!container) return;

    const customItems = extensionSettings.customItems || {};
    const itemIds = Object.keys(customItems);

    if (itemIds.length === 0) {
        container.innerHTML = '<p style="color: #888; text-align: center;">No custom items defined. Click "Add Item" to create one.</p>';
        return;
    }

    container.innerHTML = itemIds.map(id => {
        const item = customItems[id];
        const rarityColors = {
            common: '#9e9e9e',
            uncommon: '#4caf50',
            rare: '#2196f3',
            epic: '#9c27b0',
            legendary: '#ff9800',
        };
        const color = rarityColors[item.rarity] || '#9e9e9e';
        return `
            <div class="mazemaster-item-card" data-id="${id}" style="border-left: 3px solid ${color};">
                <div class="mazemaster-item-header">
                    <i class="fa-solid ${item.icon || 'fa-box'}"></i>
                    <span class="mazemaster-item-name">${escapeHtml(item.name)}</span>
                    <span class="mazemaster-item-type">(${item.type})</span>
                </div>
                <div class="mazemaster-item-desc">${escapeHtml(item.description || '')}</div>
                <div class="mazemaster-item-actions">
                    <button class="menu_button menu_button_icon mazemaster-item-edit-btn" title="Edit">
                        <i class="fa-solid fa-pen"></i>
                    </button>
                    <button class="menu_button menu_button_icon mazemaster-item-delete-btn" title="Delete">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

/**
 * Render custom items in the item pool section
 * This allows custom items to be included/excluded from loot drops
 */
function renderCustomItemsInItemPool() {
    const container = document.getElementById('mazemaster_itempool_custom');
    if (!container) return;

    const customItems = extensionSettings.customItems || {};
    const itemIds = Object.keys(customItems);

    if (itemIds.length === 0) {
        container.innerHTML = '';
        return;
    }

    const currentMazeData = getCurrentMazeProfile();
    const poolItems = currentMazeData.itemPool?.items || [];

    container.innerHTML = `
        <label class="mazemaster-label" style="font-size: 0.8em; color: var(--SmartThemeEmColor);">Custom Items</label>
        <div class="mazemaster-grid-4col" style="gap: 4px;">
            ${itemIds.map(id => {
                const item = customItems[id];
                const checked = poolItems.includes(id) ? 'checked' : '';
                const icon = item.icon || 'fa-box';
                const color = {
                    common: '#9e9e9e',
                    uncommon: '#4caf50',
                    rare: '#2196f3',
                    epic: '#9c27b0',
                    legendary: '#ff9800'
                }[item.rarity] || '#9e9e9e';
                return `<label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="${id}" ${checked}><i class="fa-solid ${icon}" style="color:${color};"></i> ${escapeHtml(item.name)}</label>`;
            }).join('')}
        </div>
    `;

    // Attach event listeners to new checkboxes
    container.querySelectorAll('input[data-pool-item]').forEach(cb => {
        cb.addEventListener('change', () => {
            updateItemPoolFromCheckboxes();
        });
    });
}

// =========================================================================
// v1.6.0: FACTIONS CONFIG TAB
// =========================================================================

/**
 * Render the factions list in the Factions config tab
 */
function renderFactionsList() {
    const container = document.getElementById('mazemaster_factions_list');
    if (!container) return;

    const profile = extensionSettings.factionProfiles?.[extensionSettings.currentFactionProfile];
    const factions = profile?.factions || [];

    if (factions.length === 0) {
        container.innerHTML = '<p style="color: #888; text-align: center;">No factions defined. Click "Add Faction" to create one.</p>';
        return;
    }

    container.innerHTML = factions.map((faction, index) => `
        <div class="mazemaster-faction-card" data-index="${index}" style="border-left: 3px solid ${faction.color || '#888'};">
            <div class="mazemaster-faction-header">
                <i class="fa-solid ${faction.icon || 'fa-users'}"></i>
                <span class="mazemaster-faction-name">${escapeHtml(faction.name)}</span>
            </div>
            <div class="mazemaster-faction-desc">${escapeHtml(faction.description || '')}</div>
            <div class="mazemaster-faction-actions">
                <button class="menu_button menu_button_icon mazemaster-faction-edit-btn" title="Edit">
                    <i class="fa-solid fa-pen"></i>
                </button>
                <button class="menu_button menu_button_icon mazemaster-faction-delete-btn" title="Delete">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
        </div>
    `).join('');
}

// =========================================================================
// v1.6.0: VISION CONFIG TAB
// =========================================================================

/**
 * Render the vision settings in the Vision config tab
 */
function renderVisionSettings() {
    const profile = extensionSettings.visionProfiles?.[extensionSettings.currentVisionProfile] || {};

    // Populate form fields with current profile values
    const baseInput = document.getElementById('mazemaster_vision_base');
    const torchInput = document.getElementById('mazemaster_vision_torch');
    const torchDurationInput = document.getElementById('mazemaster_vision_torch_duration');
    const lanternInput = document.getElementById('mazemaster_vision_lantern');
    const darkInput = document.getElementById('mazemaster_vision_dark');
    const dimInput = document.getElementById('mazemaster_vision_dim');
    const brightInput = document.getElementById('mazemaster_vision_bright');

    if (baseInput) baseInput.value = profile.baseVisibility ?? 1;
    if (torchInput) torchInput.value = profile.torchBonus ?? 2;
    if (torchDurationInput) torchDurationInput.value = profile.torchDuration ?? 3;
    if (lanternInput) lanternInput.value = profile.lanternBonus ?? 1;
    if (darkInput) darkInput.value = profile.ambientLevels?.dark ?? -1;
    if (dimInput) dimInput.value = profile.ambientLevels?.dim ?? 0;
    if (brightInput) brightInput.value = profile.ambientLevels?.bright ?? 1;
}

/**
 * Get the current vision profile
 * @returns {Object} Vision profile settings
 */
function getVisionProfile() {
    // v2.0.0: Prioritize maze profile setting over global setting
    const profileName = currentMaze?.profile?.visionProfile || extensionSettings.currentVisionProfile || 'default';
    const profile = extensionSettings.visionProfiles?.[profileName];
    if (profile) return profile;
    return DEFAULT_VISION_PROFILES[profileName] || DEFAULT_VISION_PROFILES.default;
}

/**
 * Initialize lighting state for a new maze based on map style
 * @param {string} mapStyle - The map style being used
 */
function initLighting(mapStyle) {
    if (!currentMaze.lighting) {
        currentMaze.lighting = {
            ambientLevel: 'normal',
            activeLight: null,
            lightRadius: 1,
            torchMovesLeft: 0,
            sightPotionMovesLeft: 0,
        };
    }

    const profile = getVisionProfile();
    const roomDarkness = profile.roomDarkness || {};
    currentMaze.lighting.ambientLevel = roomDarkness[mapStyle] || 'normal';

    // Calculate initial light radius
    calculateLightRadius();
}

/**
 * Set ambient lighting level for the current room
 * @param {string} level - 'dark', 'dim', 'normal', or 'bright'
 */
async function setAmbientLight(level) {
    if (!currentMaze.lighting) return;

    const validLevels = ['dark', 'dim', 'normal', 'bright'];
    if (!validLevels.includes(level)) {
        console.warn(`[MazeMaster] Invalid ambient level: ${level}`);
        return;
    }

    const previousLevel = currentMaze.lighting.ambientLevel;
    currentMaze.lighting.ambientLevel = level;

    // Recalculate visibility
    const previousRadius = currentMaze.lighting.lightRadius;
    calculateLightRadius();

    // Fire hook if radius changed
    if (currentMaze.lighting.lightRadius !== previousRadius) {
        const profile = getVisionProfile();
        if (profile.onDarknessEnter) {
            await executeWithTimeout(substituteParams(profile.onDarknessEnter, {
                roomType: currentMaze.profile?.mapStyle || 'unknown',
                ambientLevel: level,
                effectiveRadius: currentMaze.lighting.lightRadius,
                previousLevel,
            }), 'onDarknessEnter');
        }
    }

    // Update fog of war display
    if (currentMaze.isOpen) {
        renderMazeGrid();
    }
}

/**
 * Calculate effective light radius based on profile and active lights
 */
function calculateLightRadius() {
    if (!currentMaze.lighting) return 1;

    const profile = getVisionProfile();
    let radius = profile.baseVisibility || 1;

    // Add ambient modifier
    const ambientMod = profile.ambientLevels?.[currentMaze.lighting.ambientLevel] ?? 0;
    radius += ambientMod;

    // Add torch bonus if active
    if (currentMaze.lighting.torchMovesLeft > 0) {
        radius += profile.torchBonus || 2;
    }

    // Add lantern bonus if in inventory
    if (currentMaze.inventory?.lantern > 0) {
        radius += profile.lanternBonus || 1;
    }

    // Add sight potion bonus if active
    if (currentMaze.lighting.sightPotionMovesLeft > 0) {
        radius += profile.sightPotionBonus || 2;
    }

    // Add permanent visibility bonus from consumed potions
    if (currentMaze.visibility?.permBonus > 0) {
        radius += currentMaze.visibility.permBonus;
    }

    // Ensure minimum radius of 1
    radius = Math.max(1, radius);

    currentMaze.lighting.lightRadius = radius;
    return radius;
}

/**
 * Activate a torch - provides temporary visibility bonus
 */
async function activateTorch() {
    if (!currentMaze.isOpen || !currentMaze.lighting) return false;

    if (!currentMaze.inventory?.torch || currentMaze.inventory.torch <= 0) {
        addMazeMessage('No Torch', 'You have no torches to light.');
        return false;
    }

    const profile = getVisionProfile();
    const previousRadius = currentMaze.lighting.lightRadius;

    // Consume torch
    currentMaze.inventory.torch--;
    currentMaze.lighting.torchMovesLeft = profile.torchDuration || 3;
    currentMaze.lighting.activeLight = 'torch';

    // Recalculate visibility
    calculateLightRadius();

    // Fire hook
    if (profile.onLightChange) {
        await executeWithTimeout(substituteParams(profile.onLightChange, {
            lightType: 'torch',
            remaining: currentMaze.lighting.torchMovesLeft,
            action: 'activate',
        }), 'onLightChange');
    }

    // Fire vision change hook if radius changed
    if (currentMaze.lighting.lightRadius !== previousRadius && profile.onVisionChange) {
        await executeWithTimeout(substituteParams(profile.onVisionChange, {
            newRadius: currentMaze.lighting.lightRadius,
            previousRadius,
            source: 'torch',
        }), 'onVisionChange');
    }

    addMazeMessage('Torch Lit', `Your torch burns brightly. (+${profile.torchBonus || 2} visibility for ${currentMaze.lighting.torchMovesLeft} moves)`);
    updateStatsDisplay();
    renderMazeGrid();

    return true;
}

/**
 * Consume a sight potion for temporary enhanced vision
 */
async function useSightPotion() {
    if (!currentMaze.isOpen || !currentMaze.lighting) return false;

    if (!currentMaze.inventory?.sightPotion || currentMaze.inventory.sightPotion <= 0) {
        addMazeMessage('No Potion', 'You have no sight potions.');
        return false;
    }

    const profile = getVisionProfile();
    const previousRadius = currentMaze.lighting.lightRadius;

    // Consume potion
    currentMaze.inventory.sightPotion--;
    currentMaze.lighting.sightPotionMovesLeft = profile.sightPotionDuration || 5;

    // Recalculate visibility
    calculateLightRadius();

    // Fire hook
    if (profile.onLightChange) {
        await executeWithTimeout(substituteParams(profile.onLightChange, {
            lightType: 'sightPotion',
            remaining: currentMaze.lighting.sightPotionMovesLeft,
            action: 'activate',
        }), 'onLightChange');
    }

    // Fire vision change hook
    if (currentMaze.lighting.lightRadius !== previousRadius && profile.onVisionChange) {
        await executeWithTimeout(substituteParams(profile.onVisionChange, {
            newRadius: currentMaze.lighting.lightRadius,
            previousRadius,
            source: 'sightPotion',
        }), 'onVisionChange');
    }

    addMazeMessage('Sight Enhanced', `Your vision sharpens. (+${profile.sightPotionBonus || 2} visibility for ${currentMaze.lighting.sightPotionMovesLeft} moves)`);
    updateStatsDisplay();
    renderMazeGrid();

    return true;
}

/**
 * Update light sources on player movement (decrement durations)
 * Called after each move
 */
async function updateLightingOnMove() {
    if (!currentMaze.isOpen || !currentMaze.lighting) return;

    const profile = getVisionProfile();
    const previousRadius = currentMaze.lighting.lightRadius;
    let lightExpired = null;

    // Decrement torch
    if (currentMaze.lighting.torchMovesLeft > 0) {
        currentMaze.lighting.torchMovesLeft--;
        if (currentMaze.lighting.torchMovesLeft <= 0) {
            currentMaze.lighting.activeLight = null;
            lightExpired = 'torch';
            addMazeMessage('Torch Burned Out', 'Your torch has burned out.');
        }
    }

    // Decrement sight potion
    if (currentMaze.lighting.sightPotionMovesLeft > 0) {
        currentMaze.lighting.sightPotionMovesLeft--;
        if (currentMaze.lighting.sightPotionMovesLeft <= 0) {
            if (!lightExpired) lightExpired = 'sightPotion';
            addMazeMessage('Vision Fading', 'Your enhanced sight fades away.');
        }
    }

    // Recalculate visibility
    calculateLightRadius();

    // Fire expired hook
    if (lightExpired && profile.onLightSourceExpire) {
        await executeWithTimeout(substituteParams(profile.onLightSourceExpire, {
            lightType: lightExpired,
        }), 'onLightSourceExpire');
    }

    // Fire vision change hook if radius changed
    if (currentMaze.lighting.lightRadius !== previousRadius && profile.onVisionChange) {
        await executeWithTimeout(substituteParams(profile.onVisionChange, {
            newRadius: currentMaze.lighting.lightRadius,
            previousRadius,
            source: 'movement',
        }), 'onVisionChange');
    }
}

/**
 * Get the names of all vision profiles
 * @returns {string[]} Array of profile names
 */
function getVisionProfileNames() {
    const defaultNames = Object.keys(DEFAULT_VISION_PROFILES);
    const customNames = Object.keys(extensionSettings.visionProfiles || {});
    return [...new Set([...defaultNames, ...customNames])];
}

/**
 * Save a vision profile
 * @param {string} name - Profile name
 * @param {Object} data - Profile data
 */
function saveVisionProfile(name, data) {
    if (!extensionSettings.visionProfiles) {
        extensionSettings.visionProfiles = {};
    }
    extensionSettings.visionProfiles[name] = data;
    saveSettingsDebounced();
}

/**
 * Delete a vision profile (only custom ones)
 * @param {string} name - Profile name to delete
 */
function deleteVisionProfile(name) {
    if (DEFAULT_VISION_PROFILES[name]) {
        toastr.warning('Cannot delete built-in profiles');
        return false;
    }
    if (extensionSettings.visionProfiles?.[name]) {
        delete extensionSettings.visionProfiles[name];
        if (extensionSettings.currentVisionProfile === name) {
            extensionSettings.currentVisionProfile = 'default';
        }
        saveSettingsDebounced();
        return true;
    }
    return false;
}

// =========================================================================
// v1.6.0: LOCKED DOORS SYSTEM
// =========================================================================

/**
 * Generate a unique door ID
 * @returns {string} UUID for door
 */
function generateDoorId() {
    return 'door_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
}

/**
 * Get door settings from the current maze profile
 * @returns {Object} Door settings
 */
function getDoorSettings() {
    return currentMaze.profile?.doorSettings || {
        enabled: true,
        lockTypes: ['key', 'puzzle', 'boss', 'switch'],
        onDoorLocked: '',
        onDoorUnlock: '',
        onDoorOpen: '',
    };
}

/**
 * Place a door in the maze at a specific position and direction
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 * @param {string} direction - Direction of door ('north', 'south', 'east', 'west')
 * @param {Object} config - Door configuration
 * @returns {Object|null} The created door or null
 */
function placeDoor(x, y, direction, config = {}) {
    if (!currentMaze.isOpen || !currentMaze.grid) return null;

    const cell = currentMaze.grid[y]?.[x];
    if (!cell) return null;

    const doorId = config.id || generateDoorId();

    const door = {
        id: doorId,
        x,
        y,
        direction,
        locked: config.locked !== false,
        lockType: config.lockType || 'key',
        keyRequired: config.keyRequired || null,
        opened: false,
        label: config.label || null,
    };

    // Initialize doors array on cell if not present
    if (!cell.doors) {
        cell.doors = [];
    }

    // Remove existing door in same direction if any
    cell.doors = cell.doors.filter(d => d.direction !== direction);

    // Add new door
    cell.doors.push(door);

    console.log(`[MazeMaster] Placed ${door.lockType} door at (${x}, ${y}) facing ${direction}`);
    return door;
}

/**
 * Get a door at a specific position and direction
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 * @param {string} direction - Direction to check
 * @returns {Object|null} Door object or null
 */
function getDoorAtPosition(x, y, direction) {
    if (!currentMaze.isOpen || !currentMaze.grid) return null;

    const cell = currentMaze.grid[y]?.[x];
    if (!cell || !cell.doors) return null;

    return cell.doors.find(d => d.direction === direction) || null;
}

/**
 * Check if a door blocks movement in a direction
 * @param {number} x - Current X
 * @param {number} y - Current Y
 * @param {string} direction - Movement direction ('north', 'south', 'east', 'west')
 * @returns {Object|null} The blocking door or null if passage is clear
 */
function checkDoorBlocking(x, y, direction) {
    const door = getDoorAtPosition(x, y, direction);

    if (!door) return null;
    if (door.opened) return null;
    if (!door.locked) return null;

    return door;
}

/**
 * Attempt to unlock a door
 * @param {Object} door - The door object
 * @returns {Promise<Object>} Result { success, message, method }
 */
async function attemptUnlockDoor(door) {
    if (!door || !door.locked) {
        return { success: true, message: 'Door is not locked', method: 'none' };
    }

    const settings = getDoorSettings();
    let success = false;
    let method = 'none';
    let message = '';

    switch (door.lockType) {
        case 'key':
            // Check for specific key or any key
            if (door.keyRequired) {
                // Specific key required (could be a custom item)
                if (currentMaze.customInventory?.[door.keyRequired] > 0) {
                    currentMaze.customInventory[door.keyRequired]--;
                    success = true;
                    method = 'specific_key';
                    message = `Used ${door.keyRequired} to unlock the door.`;
                } else {
                    message = `This door requires a ${door.keyRequired} to open.`;
                }
            } else {
                // Any key works
                if (currentMaze.inventory?.key > 0) {
                    currentMaze.inventory.key--;
                    success = true;
                    method = 'key';
                    message = 'Used a key to unlock the door.';
                } else {
                    message = 'This door is locked. You need a key.';
                }
            }
            break;

        case 'puzzle':
            // Puzzle doors require solving a puzzle (stub - could trigger puzzle encounter)
            message = 'This door requires solving a puzzle.';
            // Could trigger a puzzle minigame here
            break;

        case 'boss':
            // Boss doors require defeating a boss
            if (currentMaze.exitEncounterDone) {
                success = true;
                method = 'boss_defeated';
                message = 'The boss is defeated. The door opens.';
            } else {
                message = 'A powerful presence guards this door. Defeat the boss to proceed.';
            }
            break;

        case 'switch':
            // Switch doors require activating a switch elsewhere
            // Check if associated switch is activated
            const switchId = door.keyRequired; // Use keyRequired for switch ID
            if (currentMaze.activatedSwitches?.has(switchId)) {
                success = true;
                method = 'switch';
                message = 'The switch has been activated. The door opens.';
            } else {
                message = 'This door is controlled by a switch somewhere in the maze.';
            }
            break;

        default:
            message = 'This door cannot be opened.';
    }

    // Fire hooks
    if (success) {
        door.locked = false;
        door.opened = true;

        if (settings.onDoorUnlock) {
            await executeWithTimeout(substituteParams(settings.onDoorUnlock, {
                doorId: door.id,
                method,
                lockType: door.lockType,
            }), 'onDoorUnlock');
        }

        if (settings.onDoorOpen) {
            await executeWithTimeout(substituteParams(settings.onDoorOpen, {
                doorId: door.id,
            }), 'onDoorOpen');
        }

        updateInventoryDisplay();
        renderMazeGrid();
    } else {
        if (settings.onDoorLocked) {
            await executeWithTimeout(substituteParams(settings.onDoorLocked, {
                doorId: door.id,
                lockType: door.lockType,
                keyRequired: door.keyRequired || 'any',
            }), 'onDoorLocked');
        }
    }

    return { success, message, method };
}

/**
 * Force unlock a door by ID
 * @param {string} doorId - The door ID to unlock
 * @returns {boolean} Success
 */
function unlockDoor(doorId) {
    if (!currentMaze.isOpen || !currentMaze.grid) return false;

    // Search all cells for the door
    for (let y = 0; y < currentMaze.grid.length; y++) {
        for (let x = 0; x < currentMaze.grid[y].length; x++) {
            const cell = currentMaze.grid[y][x];
            if (cell.doors) {
                const door = cell.doors.find(d => d.id === doorId);
                if (door) {
                    door.locked = false;
                    door.opened = true;
                    console.log(`[MazeMaster] Force unlocked door ${doorId}`);
                    renderMazeGrid();
                    return true;
                }
            }
        }
    }

    console.warn(`[MazeMaster] Door ${doorId} not found`);
    return false;
}

/**
 * Lock a door by ID
 * @param {string} doorId - The door ID to lock
 * @returns {boolean} Success
 */
function lockDoor(doorId) {
    if (!currentMaze.isOpen || !currentMaze.grid) return false;

    for (let y = 0; y < currentMaze.grid.length; y++) {
        for (let x = 0; x < currentMaze.grid[y].length; x++) {
            const cell = currentMaze.grid[y][x];
            if (cell.doors) {
                const door = cell.doors.find(d => d.id === doorId);
                if (door) {
                    door.locked = true;
                    door.opened = false;
                    console.log(`[MazeMaster] Locked door ${doorId}`);
                    renderMazeGrid();
                    return true;
                }
            }
        }
    }

    return false;
}

/**
 * Activate a switch (for switch-controlled doors)
 * @param {string} switchId - The switch ID
 */
function activateSwitch(switchId) {
    if (!currentMaze.activatedSwitches) {
        currentMaze.activatedSwitches = new Set();
    }

    currentMaze.activatedSwitches.add(switchId);
    console.log(`[MazeMaster] Switch ${switchId} activated`);

    // Check if any doors should now open
    if (currentMaze.grid) {
        for (let y = 0; y < currentMaze.grid.length; y++) {
            for (let x = 0; x < currentMaze.grid[y].length; x++) {
                const cell = currentMaze.grid[y][x];
                if (cell.doors) {
                    cell.doors.forEach(door => {
                        if (door.lockType === 'switch' && door.keyRequired === switchId && door.locked) {
                            door.locked = false;
                            door.opened = true;
                            addMazeMessage('Door Opened', 'A door has been unlocked by the switch!');
                        }
                    });
                }
            }
        }
        renderMazeGrid();
    }
}

/**
 * Handle interaction with a locked door during movement
 * @param {Object} door - The blocking door
 * @returns {Promise<boolean>} True if door was opened and player can pass
 */
async function handleLockedDoorInteraction(door) {
    const result = await attemptUnlockDoor(door);

    if (result.success) {
        addMazeMessage('Door Unlocked', result.message);
        return true;
    } else {
        addMazeMessage('Locked Door', result.message);
        return false;
    }
}

// =========================================================================
// v1.6.0: FACTION REPUTATION SYSTEM
// =========================================================================

/**
 * Get the current faction profile
 * @returns {Object} Faction profile settings
 */
function getFactionProfile() {
    // v2.0.0: Prioritize maze profile setting over global setting
    const profileName = currentMaze?.profile?.factionProfile || extensionSettings.currentFactionProfile || 'default';
    const profile = extensionSettings.factionProfiles?.[profileName];
    if (profile) return profile;
    return DEFAULT_FACTION_PROFILES[profileName] || DEFAULT_FACTION_PROFILES.default;
}

/**
 * Initialize factions state for a new maze
 */
function initFactions() {
    const profile = getFactionProfile();

    if (!profile.factions || profile.factions.length === 0) {
        currentMaze.factions = {};
        return;
    }

    currentMaze.factions = {};

    for (const faction of profile.factions) {
        currentMaze.factions[faction.id] = {
            id: faction.id,
            name: faction.name,
            standing: faction.initialStanding || 0,
            tier: 'neutral',
            lastChange: null,
        };

        // Calculate initial tier
        currentMaze.factions[faction.id].tier = calculateFactionTier(
            currentMaze.factions[faction.id].standing
        );
    }

    console.log(`[MazeMaster] Initialized ${Object.keys(currentMaze.factions).length} factions`);
}

/**
 * Get reputation standing with a faction
 * @param {string} factionId - The faction ID
 * @returns {number} Standing value (-100 to 100)
 */
function getReputation(factionId) {
    return currentMaze.factions?.[factionId]?.standing ?? 0;
}

/**
 * Calculate faction tier from standing value
 * @param {number} standing - The standing value
 * @returns {string} Tier name
 */
function calculateFactionTier(standing) {
    const profile = getFactionProfile();
    const tiers = profile.tiers || DEFAULT_FACTION_PROFILES.default.tiers;

    for (const [tierName, tierData] of Object.entries(tiers)) {
        if (standing >= tierData.min && standing <= tierData.max) {
            return tierName;
        }
    }

    return 'neutral';
}

/**
 * Get the tier name for a faction
 * @param {string} factionId - The faction ID
 * @returns {string} Tier name
 */
function getFactionTier(factionId) {
    return currentMaze.factions?.[factionId]?.tier || 'neutral';
}

/**
 * Get faction behavior based on tier
 * @param {string} factionId - The faction ID
 * @returns {string} Behavior type ('attack', 'refuse', 'wary', 'help', 'loyal')
 */
function checkFactionReaction(factionId) {
    const tier = getFactionTier(factionId);
    const profile = getFactionProfile();
    const tiers = profile.tiers || DEFAULT_FACTION_PROFILES.default.tiers;

    return tiers[tier]?.behavior || 'wary';
}

/**
 * Get faction data by ID
 * @param {string} factionId - The faction ID
 * @returns {Object|null} Faction definition from profile
 */
function getFactionDefinition(factionId) {
    const profile = getFactionProfile();
    return profile.factions?.find(f => f.id === factionId) || null;
}

/**
 * Modify reputation with a faction
 * @param {string} factionId - The faction ID
 * @param {number} amount - Amount to change (positive or negative)
 * @param {string} reason - Reason for the change
 * @returns {Promise<Object>} Result with previous/new tier info
 */
async function modifyReputation(factionId, amount, reason = '') {
    if (!currentMaze.factions?.[factionId]) {
        console.warn(`[MazeMaster] Faction ${factionId} not found`);
        return { success: false, message: 'Faction not found' };
    }

    const faction = currentMaze.factions[factionId];
    const previousStanding = faction.standing;
    const previousTier = faction.tier;

    // Apply change (clamped to -100 to 100)
    faction.standing = Math.max(-100, Math.min(100, faction.standing + amount));
    faction.lastChange = { amount, reason, timestamp: Date.now() };

    // Calculate new tier
    const newTier = calculateFactionTier(faction.standing);
    const tierChanged = previousTier !== newTier;
    faction.tier = newTier;

    const profile = getFactionProfile();
    const factionDef = getFactionDefinition(factionId);

    // Fire reputation change hook
    if (profile.onReputationChange) {
        await executeWithTimeout(substituteParams(profile.onReputationChange, {
            factionId,
            factionName: factionDef?.name || factionId,
            amount,
            reason,
            previousStanding,
            newStanding: faction.standing,
            previousTier,
            newTier,
        }), 'onReputationChange');
    }

    // Fire tier change hook if tier changed
    if (tierChanged) {
        if (profile.onTierChange) {
            await executeWithTimeout(substituteParams(profile.onTierChange, {
                factionId,
                factionName: factionDef?.name || factionId,
                previousTier,
                newTier,
                standing: faction.standing,
            }), 'onTierChange');
        }

        // Check for hostile/friendly transitions
        if (newTier === 'hostile' && previousTier !== 'hostile' && profile.onFactionHostile) {
            await executeWithTimeout(substituteParams(profile.onFactionHostile, {
                factionId,
                factionName: factionDef?.name || factionId,
                standing: faction.standing,
            }), 'onFactionHostile');
        }

        if ((newTier === 'friendly' || newTier === 'allied') &&
            previousTier !== 'friendly' && previousTier !== 'allied' &&
            profile.onFactionFriendly) {
            await executeWithTimeout(substituteParams(profile.onFactionFriendly, {
                factionId,
                factionName: factionDef?.name || factionId,
                standing: faction.standing,
            }), 'onFactionFriendly');
        }
    }

    // Apply spillover to related factions
    await applyReputationSpillover(factionId, amount);

    // Update display
    updateFactionDisplay();

    console.log(`[MazeMaster] Faction ${factionId}: ${previousStanding} -> ${faction.standing} (${amount > 0 ? '+' : ''}${amount}) [${reason}]`);

    return {
        success: true,
        factionId,
        previousStanding,
        newStanding: faction.standing,
        previousTier,
        newTier,
        tierChanged,
    };
}

/**
 * Apply reputation spillover to related factions
 * @param {string} sourceFactionId - The faction that changed
 * @param {number} amount - Original amount changed
 */
async function applyReputationSpillover(sourceFactionId, amount) {
    const profile = getFactionProfile();
    const relationships = profile.relationships || {};
    const spilloverMult = profile.spilloverMultiplier || 0.25;

    // Get relationships where this faction affects others
    const factionRelations = relationships[sourceFactionId];
    if (!factionRelations) return;

    for (const [targetFactionId, multiplier] of Object.entries(factionRelations)) {
        if (!currentMaze.factions?.[targetFactionId]) continue;

        // Calculate spillover amount
        const spillover = Math.round(amount * multiplier * spilloverMult);
        if (spillover === 0) continue;

        const faction = currentMaze.factions[targetFactionId];
        const previousTier = faction.tier;

        faction.standing = Math.max(-100, Math.min(100, faction.standing + spillover));
        faction.tier = calculateFactionTier(faction.standing);

        console.log(`[MazeMaster] Spillover: ${targetFactionId} ${spillover > 0 ? '+' : ''}${spillover} (from ${sourceFactionId})`);
    }
}

/**
 * Update the faction display in the UI
 */
function updateFactionDisplay() {
    const container = document.getElementById('maze_faction_display');
    if (!container) return;

    const profile = getFactionProfile();
    const factions = currentMaze.factions || {};

    if (Object.keys(factions).length === 0) {
        container.innerHTML = '';
        container.style.display = 'none';
        return;
    }

    container.style.display = 'block';
    const tiers = profile.tiers || DEFAULT_FACTION_PROFILES.default.tiers;

    container.innerHTML = Object.values(factions).map(faction => {
        const def = getFactionDefinition(faction.id);
        const tierData = tiers[faction.tier] || { label: faction.tier };
        const tierColor = getTierColor(faction.tier);
        const percentage = ((faction.standing + 100) / 200) * 100;

        return `
            <div class="maze-faction-item" data-faction="${faction.id}">
                <div class="faction-header">
                    <i class="fa-solid ${def?.icon || 'fa-users'}" style="color: ${def?.color || '#888'}"></i>
                    <span class="faction-name">${escapeHtml(def?.name || faction.id)}</span>
                    <span class="faction-tier" style="color: ${tierColor}">${tierData.label || faction.tier}</span>
                </div>
                <div class="faction-bar">
                    <div class="faction-bar-fill" style="width: ${percentage}%; background: ${tierColor}"></div>
                    <span class="faction-standing">${faction.standing > 0 ? '+' : ''}${faction.standing}</span>
                </div>
            </div>
        `;
    }).join('');
}

/**
 * Get color for a faction tier
 * @param {string} tier - The tier name
 * @returns {string} Color hex code
 */
function getTierColor(tier) {
    const colors = {
        hostile: '#e74c3c',
        unfriendly: '#e67e22',
        neutral: '#95a5a6',
        friendly: '#2ecc71',
        allied: '#3498db',
    };
    return colors[tier] || '#95a5a6';
}

/**
 * Get all faction profile names
 * @returns {string[]} Array of profile names
 */
function getFactionProfileNames() {
    const defaultNames = Object.keys(DEFAULT_FACTION_PROFILES);
    const customNames = Object.keys(extensionSettings.factionProfiles || {});
    return [...new Set([...defaultNames, ...customNames])];
}

/**
 * Save a faction profile
 * @param {string} name - Profile name
 * @param {Object} data - Profile data
 */
function saveFactionProfile(name, data) {
    if (!extensionSettings.factionProfiles) {
        extensionSettings.factionProfiles = {};
    }
    extensionSettings.factionProfiles[name] = data;
    saveSettingsDebounced();
}

/**
 * Delete a faction profile
 * @param {string} name - Profile name to delete
 */
function deleteFactionProfile(name) {
    if (DEFAULT_FACTION_PROFILES[name]) {
        toastr.warning('Cannot delete built-in profiles');
        return false;
    }
    if (extensionSettings.factionProfiles?.[name]) {
        delete extensionSettings.factionProfiles[name];
        if (extensionSettings.currentFactionProfile === name) {
            extensionSettings.currentFactionProfile = 'default';
        }
        saveSettingsDebounced();
        return true;
    }
    return false;
}

/**
 * Get HTML for faction display panel (in-game)
 * @returns {string} HTML string
 */
function getFactionDisplayHTML() {
    return `
        <div id="maze_faction_display" class="maze-faction-display" style="display: none;"></div>
    `;
}

// =========================================================================
// v1.6.0: PERMADEATH CAMPAIGN SYSTEM
// =========================================================================

/**
 * Check if current maze has permadeath enabled
 * @returns {boolean}
 */
function isPermadeathEnabled() {
    return currentMaze.profile?.permadeathEnabled === true;
}

/**
 * Initialize a permadeath campaign run
 * Called when starting a new maze with permadeath enabled
 */
function initPermadeathCampaign() {
    if (!isPermadeathEnabled()) return;

    currentMaze.campaign = {
        isPermadeath: true,
        startTime: Date.now(),
        endTime: null,
        deathCause: null,
        finalStats: null,
    };

    console.log('[MazeMaster] Permadeath campaign started');
}

/**
 * Calculate final score for a permadeath run
 * @returns {number} Final score
 */
function calculatePermadeathScore() {
    const stats = currentMaze.stats || {};
    const character = currentMaze.character || { level: 1 };

    // Base score from exploration and combat
    let score = 0;

    // Exploration points: 10 per room visited
    score += (stats.roomsExplored || 0) * 10;

    // Floor clearing: 500 per floor cleared
    score += (currentMaze.currentFloor || 0) * 500;

    // Enemies defeated: 50 per enemy
    score += (stats.minionsDefeated || 0) * 50;

    // Chests opened: 25 per chest
    score += (stats.chestsOpened || 0) * 25;

    // Level bonus: 100 per level
    score += (character.level - 1) * 100;

    // Survival time bonus: 1 point per second (up to 30 minutes = 1800 points)
    const survivalTime = (Date.now() - (currentMaze.campaign?.startTime || Date.now())) / 1000;
    score += Math.min(1800, Math.floor(survivalTime));

    // Victory bonus
    if (currentMaze.isVictory) {
        score += 2000;
    }

    return score;
}

/**
 * Handle permadeath - player has died permanently
 * @param {string} cause - The cause of death
 */
async function handlePermadeath(cause) {
    if (!isPermadeathEnabled() || !currentMaze.campaign) return;

    currentMaze.campaign.endTime = Date.now();
    currentMaze.campaign.deathCause = cause;

    const score = calculatePermadeathScore();
    const survivalTime = currentMaze.campaign.endTime - currentMaze.campaign.startTime;

    const finalStats = {
        profileName: currentMaze.profileName,
        date: new Date().toISOString().split('T')[0],
        floorsCleared: currentMaze.currentFloor || 0,
        roomsExplored: currentMaze.stats?.roomsExplored || 0,
        enemiesDefeated: currentMaze.stats?.minionsDefeated || 0,
        chestsOpened: currentMaze.stats?.chestsOpened || 0,
        survivalTime,
        deathCause: cause,
        finalLevel: currentMaze.character?.level || 1,
        score,
        isVictory: currentMaze.isVictory || false,
    };

    currentMaze.campaign.finalStats = finalStats;

    // Add to leaderboard
    const leaderboardResult = addLeaderboardEntry(finalStats);

    // Fire hook
    const profile = currentMaze.profile;
    if (profile?.onPermadeath) {
        await executeWithTimeout(substituteParams(profile.onPermadeath, {
            deathCause: cause,
            floorsCleared: finalStats.floorsCleared,
            score,
            survivalTime: Math.floor(survivalTime / 1000),
            rank: leaderboardResult.rank,
            isNewRecord: leaderboardResult.isNewRecord,
        }), 'onPermadeath');
    }

    // Show death screen
    showPermadeathScreen(finalStats, leaderboardResult);

    console.log(`[MazeMaster] Permadeath: ${cause}, Score: ${score}, Rank: ${leaderboardResult.rank}`);
}

/**
 * Add an entry to the leaderboard
 * @param {Object} stats - Final stats object
 * @returns {Object} { rank, isNewRecord }
 */
function addLeaderboardEntry(stats) {
    if (!extensionSettings.leaderboard) {
        extensionSettings.leaderboard = { entries: [], maxEntries: 50 };
    }

    const entry = {
        id: 'lb_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
        ...stats,
    };

    const entries = extensionSettings.leaderboard.entries;
    entries.push(entry);

    // Sort by score descending
    entries.sort((a, b) => b.score - a.score);

    // Find rank
    const rank = entries.findIndex(e => e.id === entry.id) + 1;

    // Check if new record
    const isNewRecord = rank === 1 && entries.length > 1;

    // Trim to max entries
    const maxEntries = extensionSettings.leaderboard.maxEntries || 50;
    if (entries.length > maxEntries) {
        entries.splice(maxEntries);
    }

    saveSettingsDebounced();

    // Fire leaderboard entry hook if applicable
    if (currentMaze.profile?.onLeaderboardEntry) {
        executeWithTimeout(substituteParams(currentMaze.profile.onLeaderboardEntry, {
            rank,
            score: stats.score,
            isNewRecord,
            profileName: stats.profileName,
        }), 'onLeaderboardEntry');
    }

    return { rank, isNewRecord };
}

/**
 * Get the leaderboard entries
 * @param {string} [profileName] - Filter by profile name
 * @returns {Array} Sorted leaderboard entries
 */
function getLeaderboard(profileName = null) {
    const entries = extensionSettings.leaderboard?.entries || [];

    if (profileName) {
        return entries.filter(e => e.profileName === profileName);
    }

    return entries;
}

/**
 * Clear the leaderboard (or entries for a specific profile)
 * @param {string} [profileName] - Profile to clear, or null for all
 */
function clearLeaderboard(profileName = null) {
    if (!extensionSettings.leaderboard) return;

    if (profileName) {
        extensionSettings.leaderboard.entries = extensionSettings.leaderboard.entries.filter(
            e => e.profileName !== profileName
        );
    } else {
        extensionSettings.leaderboard.entries = [];
    }

    saveSettingsDebounced();
}

/**
 * Show the permadeath death screen
 * @param {Object} stats - Final stats
 * @param {Object} leaderboardResult - Rank info
 */
function showPermadeathScreen(stats, leaderboardResult) {
    const modal = document.getElementById('mazemaster_maze_modal');
    if (!modal) return;

    const survivalMinutes = Math.floor(stats.survivalTime / 60000);
    const survivalSeconds = Math.floor((stats.survivalTime % 60000) / 1000);

    const dialog = document.createElement('div');
    dialog.className = 'maze-permadeath-screen';
    dialog.innerHTML = `
        <div class="permadeath-backdrop"></div>
        <div class="permadeath-content">
            <h2 class="permadeath-title">${stats.isVictory ? 'VICTORY!' : 'GAME OVER'}</h2>
            <div class="permadeath-cause">${stats.isVictory ? 'You escaped the maze!' : stats.deathCause}</div>

            <div class="permadeath-stats">
                <div class="stat-row">
                    <span class="stat-label">Final Score</span>
                    <span class="stat-value score">${stats.score.toLocaleString()}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Rank</span>
                    <span class="stat-value">#${leaderboardResult.rank}${leaderboardResult.isNewRecord ? ' NEW RECORD!' : ''}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Floors Cleared</span>
                    <span class="stat-value">${stats.floorsCleared}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Rooms Explored</span>
                    <span class="stat-value">${stats.roomsExplored}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Enemies Defeated</span>
                    <span class="stat-value">${stats.enemiesDefeated}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Survival Time</span>
                    <span class="stat-value">${survivalMinutes}m ${survivalSeconds}s</span>
                </div>
            </div>

            <div class="permadeath-actions">
                <button id="permadeath_leaderboard_btn" class="menu_button">
                    <i class="fa-solid fa-trophy"></i> Leaderboard
                </button>
                <button id="permadeath_restart_btn" class="menu_button">
                    <i class="fa-solid fa-redo"></i> Try Again
                </button>
                <button id="permadeath_close_btn" class="menu_button">
                    <i class="fa-solid fa-door-open"></i> Exit
                </button>
            </div>
        </div>
    `;

    modal.appendChild(dialog);

    // Event handlers
    dialog.querySelector('#permadeath_leaderboard_btn')?.addEventListener('click', () => {
        showLeaderboardPopup(stats.profileName);
    });

    dialog.querySelector('#permadeath_restart_btn')?.addEventListener('click', () => {
        dialog.remove();
        closeMaze();
        startMaze(stats.profileName);
    });

    dialog.querySelector('#permadeath_close_btn')?.addEventListener('click', () => {
        dialog.remove();
        closeMaze();
    });
}

/**
 * Show leaderboard popup
 * @param {string} [profileName] - Filter by profile
 */
function showLeaderboardPopup(profileName = null) {
    const entries = getLeaderboard(profileName);

    const dialog = document.createElement('div');
    dialog.className = 'maze-leaderboard-popup';
    dialog.innerHTML = `
        <div class="leaderboard-backdrop"></div>
        <div class="leaderboard-content">
            <div class="leaderboard-header">
                <h3><i class="fa-solid fa-trophy"></i> Leaderboard${profileName ? ` - ${profileName}` : ''}</h3>
                <button class="leaderboard-close-btn"><i class="fa-solid fa-times"></i></button>
            </div>
            <div class="leaderboard-list">
                ${entries.length === 0 ? '<div class="leaderboard-empty">No entries yet. Play in permadeath mode to compete!</div>' : ''}
                ${entries.slice(0, 20).map((entry, idx) => `
                    <div class="leaderboard-entry ${idx < 3 ? 'top-' + (idx + 1) : ''}">
                        <span class="lb-rank">#${idx + 1}</span>
                        <span class="lb-profile">${escapeHtml(entry.profileName)}</span>
                        <span class="lb-score">${entry.score.toLocaleString()}</span>
                        <span class="lb-floors">F${entry.floorsCleared + 1}</span>
                        <span class="lb-date">${entry.date}</span>
                    </div>
                `).join('')}
            </div>
            <div class="leaderboard-actions">
                <button id="leaderboard_clear_btn" class="menu_button" style="font-size: 0.8em;">
                    <i class="fa-solid fa-trash"></i> Clear
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(dialog);

    dialog.querySelector('.leaderboard-close-btn')?.addEventListener('click', () => dialog.remove());
    dialog.querySelector('.leaderboard-backdrop')?.addEventListener('click', () => dialog.remove());
    dialog.querySelector('#leaderboard_clear_btn')?.addEventListener('click', () => {
        if (confirm('Clear all leaderboard entries?')) {
            clearLeaderboard(profileName);
            dialog.remove();
        }
    });
}

// =========================================================================
// v1.6.0: SOUND CONFIG TAB
// =========================================================================

/**
 * Render the sound settings in the Sound config tab
 */
function renderSoundSettings() {
    const profile = extensionSettings.soundProfiles?.[extensionSettings.currentSoundProfile] || {};

    // Update master volume display
    const masterSlider = document.getElementById('mazemaster_sound_master');
    const masterValue = document.getElementById('mazemaster_sound_master_value');
    if (masterSlider && masterValue) {
        const vol = Math.round((profile.masterVolume ?? 0.8) * 100);
        masterSlider.value = vol;
        masterValue.textContent = `${vol}%`;
    }

    // Update category volumes
    const categories = ['combat', 'ui', 'ambient'];
    categories.forEach(cat => {
        const slider = document.getElementById(`mazemaster_sound_${cat}`);
        const value = document.getElementById(`mazemaster_sound_${cat}_value`);
        if (slider && value) {
            const vol = Math.round((profile.categoryVolumes?.[cat] ?? 0.5) * 100);
            slider.value = vol;
            value.textContent = `${vol}%`;
        }
    });

    // Update enabled checkbox
    const enabledCheckbox = document.getElementById('mazemaster_sound_enabled');
    if (enabledCheckbox) {
        enabledCheckbox.checked = profile.enabled !== false;
    }
}

// =========================================================================
// v1.6.0: SOUND EFFECTS SYSTEM
// =========================================================================

// Audio context and cache
let audioContext = null;
let audioBufferCache = {};
let isMuted = false;

/**
 * Get the current sound profile
 * @returns {Object} Sound profile settings
 */
function getSoundProfile() {
    // v2.0.0: Prioritize maze profile setting over global setting
    const profileName = currentMaze?.profile?.soundProfile || extensionSettings.currentSoundProfile || 'default';
    const profile = extensionSettings.soundProfiles?.[profileName];
    if (profile) return profile;

    // Default profile
    return {
        enabled: true,
        masterVolume: 0.8,
        categoryVolumes: {
            combat: 0.8,
            ui: 0.6,
            ambient: 0.4,
            music: 0.5,
        },
        sounds: {
            'attack_hit': { category: 'combat', volume: 1.0 },
            'attack_miss': { category: 'combat', volume: 0.8 },
            'critical_hit': { category: 'combat', volume: 1.0 },
            'block': { category: 'combat', volume: 0.9 },
            'parry': { category: 'combat', volume: 1.0 },
            'enemy_attack': { category: 'combat', volume: 0.8 },
            'enemy_hit': { category: 'combat', volume: 0.9 },
            'enemy_critical': { category: 'combat', volume: 1.0 },
            'heal': { category: 'ui', volume: 0.8 },
            'chest_open': { category: 'ui', volume: 0.7 },
            'chest_unlock': { category: 'ui', volume: 0.8 },
            'chest_locked': { category: 'ui', volume: 0.5 },
            'item_pickup': { category: 'ui', volume: 0.6 },
            'level_up': { category: 'ui', volume: 1.0 },
            'door_unlock': { category: 'ui', volume: 0.7 },
            'door_locked': { category: 'ui', volume: 0.5 },
            'footstep': { category: 'ambient', volume: 0.3 },
            'trap_trigger': { category: 'combat', volume: 0.9 },
            'victory': { category: 'ui', volume: 1.0 },
            'defeat': { category: 'ui', volume: 0.9 },
        },
        onSoundPlay: '',
    };
}

/**
 * Initialize the audio system
 */
function initAudioSystem() {
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        console.log('[MazeMaster] Audio system initialized');
    } catch (e) {
        console.warn('[MazeMaster] Could not initialize audio context:', e);
    }
}

/**
 * Play a sound effect
 * @param {string} soundId - The sound ID from profile
 * @param {number} [volumeMod=1] - Volume modifier (0-1)
 */
async function playSound(soundId, volumeMod = 1) {
    const profile = getSoundProfile();

    // Check if sounds are enabled
    if (profile.enabled === false || isMuted) return;

    const soundDef = profile.sounds?.[soundId];
    if (!soundDef) {
        console.log(`[MazeMaster] Sound not found: ${soundId}`);
        return;
    }

    // Calculate volume
    const category = soundDef.category || 'ui';
    const masterVol = profile.masterVolume ?? 0.8;
    const categoryVol = profile.categoryVolumes?.[category] ?? 0.5;
    const soundVol = soundDef.volume ?? 1.0;
    const finalVolume = masterVol * categoryVol * soundVol * volumeMod;

    // Fire hook
    if (profile.onSoundPlay) {
        await executeWithTimeout(substituteParams(profile.onSoundPlay, {
            soundId,
            category,
            volume: finalVolume,
        }), 'onSoundPlay');
    }

    // Play using Web Audio or HTMLAudioElement
    if (soundDef.path) {
        await playSoundFile(soundDef.path, finalVolume);
    } else {
        // Generate synthetic beep for missing sounds
        playSyntheticSound(soundId, finalVolume);
    }
}

/**
 * Play a sound file from path
 * @param {string} path - Path to sound file
 * @param {number} volume - Volume (0-1)
 */
async function playSoundFile(path, volume) {
    try {
        const audio = new Audio(path);
        audio.volume = Math.max(0, Math.min(1, volume));
        await audio.play();
    } catch (e) {
        console.warn(`[MazeMaster] Could not play sound: ${path}`, e);
    }
}

/**
 * Play a synthetic sound (beep) when no file is available
 * @param {string} soundId - Sound type for frequency selection
 * @param {number} volume - Volume (0-1)
 */
function playSyntheticSound(soundId, volume) {
    if (!audioContext) return;

    try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        // Different frequencies for different sounds
        const frequencies = {
            'attack_hit': 400,
            'attack_miss': 200,
            'critical_hit': 600,
            'block': 300,
            'parry': 500,
            'chest_open': 523,
            'item_pickup': 659,
            'level_up': 880,
            'door_unlock': 440,
            'footstep': 100,
            'trap_trigger': 220,
            'victory': 698,
            'defeat': 147,
        };

        oscillator.frequency.value = frequencies[soundId] || 440;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
    } catch (e) {
        // Ignore errors for synthetic sounds
    }
}

/**
 * Play a custom sound from URL
 * @param {string} url - URL or path to sound
 * @param {number} volume - Volume (0-1)
 */
async function playSoundCustom(url, volume = 1.0) {
    const profile = getSoundProfile();
    if (profile.enabled === false || isMuted) return;

    const masterVol = profile.masterVolume ?? 0.8;
    await playSoundFile(url, volume * masterVol);
}

/**
 * Set master volume
 * @param {number} volume - Volume (0-1)
 */
function setMasterVolume(volume) {
    const profileName = extensionSettings.currentSoundProfile || 'default';
    if (!extensionSettings.soundProfiles) {
        extensionSettings.soundProfiles = {};
    }
    if (!extensionSettings.soundProfiles[profileName]) {
        extensionSettings.soundProfiles[profileName] = getSoundProfile();
    }
    extensionSettings.soundProfiles[profileName].masterVolume = Math.max(0, Math.min(1, volume));
    saveSettingsDebounced();
}

/**
 * Set category volume
 * @param {string} category - Category name
 * @param {number} volume - Volume (0-1)
 */
function setCategoryVolume(category, volume) {
    const profileName = extensionSettings.currentSoundProfile || 'default';
    if (!extensionSettings.soundProfiles) {
        extensionSettings.soundProfiles = {};
    }
    if (!extensionSettings.soundProfiles[profileName]) {
        extensionSettings.soundProfiles[profileName] = getSoundProfile();
    }
    if (!extensionSettings.soundProfiles[profileName].categoryVolumes) {
        extensionSettings.soundProfiles[profileName].categoryVolumes = {};
    }
    extensionSettings.soundProfiles[profileName].categoryVolumes[category] = Math.max(0, Math.min(1, volume));
    saveSettingsDebounced();
}

/**
 * Toggle mute state
 * @returns {boolean} New mute state
 */
function toggleMute() {
    isMuted = !isMuted;
    console.log(`[MazeMaster] Sound ${isMuted ? 'muted' : 'unmuted'}`);
    return isMuted;
}

/**
 * Get mute state
 * @returns {boolean}
 */
function isSoundMuted() {
    return isMuted;
}

/**
 * Preload sound files for better performance
 * @param {Array} soundIds - Array of sound IDs to preload
 */
async function preloadSounds(soundIds = null) {
    const profile = getSoundProfile();
    const sounds = profile.sounds || {};

    const toPreload = soundIds || Object.keys(sounds);

    for (const id of toPreload) {
        const sound = sounds[id];
        if (sound?.path) {
            try {
                const audio = new Audio();
                audio.preload = 'auto';
                audio.src = sound.path;
                // Just trigger loading, don't play
            } catch (e) {
                // Ignore preload errors
            }
        }
    }

    console.log(`[MazeMaster] Preloaded ${toPreload.length} sounds`);
}

/**
 * Get all sound profile names
 * @returns {string[]}
 */
function getSoundProfileNames() {
    const customNames = Object.keys(extensionSettings.soundProfiles || {});
    return customNames.length > 0 ? customNames : ['default'];
}

/**
 * Save a sound profile
 * @param {string} name - Profile name
 * @param {Object} data - Profile data
 */
function saveSoundProfile(name, data) {
    if (!extensionSettings.soundProfiles) {
        extensionSettings.soundProfiles = {};
    }
    extensionSettings.soundProfiles[name] = data;
    saveSettingsDebounced();
}

// =========================================================================
// v1.6.0: VISUAL EFFECTS SYSTEM
// =========================================================================

/**
 * Get VFX settings
 * @returns {Object} VFX settings
 */
function getVFXSettings() {
    // v2.0.0: Check maze profile vfxEnabled setting first
    const mazeVfxEnabled = currentMaze?.profile?.vfxEnabled;
    const baseSettings = extensionSettings.vfxSettings || {
        enabled: true,
        screenShake: true,
        particles: true,
        skillVFX: {
            // Combat VFX
            'attack_hit': { particleType: 'sparks', color: '#fff', shake: { intensity: 3, duration: 100 } },
            'critical_hit': { particleType: 'sparks', color: '#e74c3c', shake: { intensity: 10, duration: 250 } },
            'enemy_attack': { particleType: 'sparks', color: '#c0392b', shake: { intensity: 4, duration: 150 } },
            'enemy_critical': { particleType: 'flames', color: '#e74c3c', shake: { intensity: 12, duration: 300 } },
            'block': { particleType: 'sparks', color: '#7f8c8d', shake: { intensity: 4, duration: 100 } },
            'parry': { particleType: 'sparks', color: '#f1c40f', shake: { intensity: 6, duration: 150 } },
            // Skills
            'combat_power_strike': { particleType: 'sparks', color: '#f39c12', shake: { intensity: 5, duration: 200 } },
            'magic_fireball': { particleType: 'flames', color: '#e74c3c', shake: { intensity: 8, duration: 300 } },
            'magic_frost': { particleType: 'frost', color: '#3498db', shake: { intensity: 3, duration: 150 } },
            'magic_lightning': { particleType: 'lightning', color: '#f1c40f', shake: { intensity: 7, duration: 200 } },
            // Utility VFX
            'heal': { particleType: 'heal', color: '#2ecc71', shake: null },
            'level_up': { particleType: 'sparks', color: '#f39c12', shake: null },
        },
    };

    // v2.0.0: Override enabled state from maze profile if specified
    if (typeof mazeVfxEnabled === 'boolean') {
        return { ...baseSettings, enabled: mazeVfxEnabled };
    }
    return baseSettings;
}

/**
 * Trigger a visual effect
 * @param {string} effectId - The effect ID
 * @param {HTMLElement} [targetElement] - Target element (defaults to maze container)
 */
async function triggerVFX(effectId, targetElement = null) {
    const settings = getVFXSettings();

    if (!settings.enabled) return;

    const effectDef = settings.skillVFX?.[effectId];
    if (!effectDef) {
        console.log(`[MazeMaster] VFX not found: ${effectId}`);
        return;
    }

    const container = targetElement || document.getElementById('maze_grid_container') || document.getElementById('mazemaster_maze_modal');
    if (!container) return;

    // Screen shake
    if (settings.screenShake && effectDef.shake) {
        screenShake(container, effectDef.shake.intensity, effectDef.shake.duration);
    }

    // Particles
    if (settings.particles && effectDef.particleType) {
        const rect = container.getBoundingClientRect();
        const origin = {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2,
        };
        spawnParticles(effectDef.particleType, 10, origin, effectDef.color);
    }
}

/**
 * Apply screen shake effect
 * @param {HTMLElement} element - Element to shake
 * @param {number} intensity - Shake intensity (pixels)
 * @param {number} duration - Shake duration (ms)
 */
function screenShake(element, intensity = 5, duration = 200) {
    if (!element) return;

    const originalTransform = element.style.transform;
    const startTime = performance.now();

    function shake(currentTime) {
        const elapsed = currentTime - startTime;
        if (elapsed >= duration) {
            element.style.transform = originalTransform;
            return;
        }

        const progress = elapsed / duration;
        const decay = 1 - progress;
        const offsetX = (Math.random() - 0.5) * 2 * intensity * decay;
        const offsetY = (Math.random() - 0.5) * 2 * intensity * decay;

        element.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        requestAnimationFrame(shake);
    }

    requestAnimationFrame(shake);
}

/**
 * Spawn particle effects
 * @param {string} type - Particle type ('sparks', 'flames', 'frost', 'glow', 'stars')
 * @param {number} count - Number of particles
 * @param {Object} origin - { x, y } origin point
 * @param {string} color - Particle color
 */
function spawnParticles(type, count, origin, color = '#fff') {
    const container = document.createElement('div');
    container.className = 'mazemaster-particle-container';
    container.style.cssText = `position: fixed; pointer-events: none; z-index: 9999;`;
    document.body.appendChild(container);

    for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = `mazemaster-particle particle-${type}`;

        // Random direction
        const angle = Math.random() * Math.PI * 2;
        const speed = 50 + Math.random() * 100;
        const dx = Math.cos(angle) * speed;
        const dy = Math.sin(angle) * speed;

        particle.style.cssText = `
            position: absolute;
            left: ${origin.x}px;
            top: ${origin.y}px;
            width: 8px;
            height: 8px;
            background: ${color};
            border-radius: 50%;
            opacity: 1;
            --dx: ${dx}px;
            --dy: ${dy}px;
            animation: particle-fly 0.5s ease-out forwards;
        `;

        container.appendChild(particle);
    }

    // Cleanup after animation
    setTimeout(() => container.remove(), 600);
}

/**
 * Clean up any lingering particle elements
 */
function cleanupParticles() {
    document.querySelectorAll('.mazemaster-particle-container').forEach(el => el.remove());
}

// =========================================================================
// v1.6.0: SPRITE ANIMATION SYSTEM
// =========================================================================

// Active animations registry
let activeAnimations = {};
let animationFrame = null;

/**
 * Get animation settings
 * @returns {Object} Animation settings
 */
function getAnimationSettings() {
    return extensionSettings.animationSettings || {
        enabled: true,
        animations: {
            'player_idle': { frames: ['idle_1', 'idle_2'], frameTime: 500, loop: true },
            'player_walk': { frames: ['walk_1', 'walk_2', 'walk_3', 'walk_4'], frameTime: 150, loop: true },
            'player_attack': { frames: ['attack_1', 'attack_2', 'attack_3'], frameTime: 100, loop: false },
            'minion_idle': { frames: ['minion_idle_1', 'minion_idle_2'], frameTime: 400, loop: true },
            'minion_attack': { frames: ['minion_attack_1', 'minion_attack_2'], frameTime: 120, loop: false },
            'chest_open': { frames: ['chest_closed', 'chest_opening', 'chest_open'], frameTime: 150, loop: false },
        },
        // Frame to sprite path mapping - users can customize this
        frameSprites: {
            // Player frames
            'idle_1': { sprite: null },  // null means use default
            'idle_2': { sprite: null },
            'walk_1': { sprite: null },
            'walk_2': { sprite: null },
            'walk_3': { sprite: null },
            'walk_4': { sprite: null },
            'attack_1': { sprite: null },
            'attack_2': { sprite: null },
            'attack_3': { sprite: null },
            // Minion frames
            'minion_idle_1': { sprite: null },
            'minion_idle_2': { sprite: null },
            'minion_attack_1': { sprite: null },
            'minion_attack_2': { sprite: null },
            // Chest frames
            'chest_closed': { sprite: null },
            'chest_opening': { sprite: null },
            'chest_open': { sprite: null },
        },
    };
}

/**
 * Start an animation for an entity
 * @param {string} entityId - Entity identifier (e.g., 'player', 'minion_1')
 * @param {string} animationName - Animation name
 * @param {Function} [onComplete] - Callback when non-looping animation completes
 */
function startAnimation(entityId, animationName, onComplete = null) {
    const settings = getAnimationSettings();
    if (!settings.enabled) return;

    const animDef = settings.animations?.[animationName];
    if (!animDef) {
        console.log(`[MazeMaster] Animation not found: ${animationName}`);
        return;
    }

    activeAnimations[entityId] = {
        animation: animationName,
        frames: animDef.frames,
        frameTime: animDef.frameTime || 200,
        loop: animDef.loop !== false,
        currentFrame: 0,
        lastUpdate: performance.now(),
        onComplete,
    };

    // Start animation loop if not running
    if (!animationFrame) {
        animationLoop();
    }
}

/**
 * Stop animation for an entity
 * @param {string} entityId - Entity identifier
 */
function stopAnimation(entityId) {
    delete activeAnimations[entityId];

    // Stop loop if no active animations
    if (Object.keys(activeAnimations).length === 0 && animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
    }
}

/**
 * Get current frame for an entity
 * @param {string} entityId - Entity identifier
 * @returns {string|null} Current frame name or null
 */
function getCurrentFrame(entityId) {
    const anim = activeAnimations[entityId];
    if (!anim) return null;
    return anim.frames[anim.currentFrame] || null;
}

/**
 * Main animation loop
 */
function animationLoop() {
    const now = performance.now();
    let anyActive = false;

    for (const [entityId, anim] of Object.entries(activeAnimations)) {
        anyActive = true;
        const elapsed = now - anim.lastUpdate;

        if (elapsed >= anim.frameTime) {
            anim.currentFrame++;
            anim.lastUpdate = now;

            if (anim.currentFrame >= anim.frames.length) {
                if (anim.loop) {
                    anim.currentFrame = 0;
                } else {
                    // Non-looping animation finished
                    if (anim.onComplete) anim.onComplete();
                    delete activeAnimations[entityId];
                    continue;
                }
            }

            // Update sprite display if applicable
            updateEntitySprite(entityId, anim.frames[anim.currentFrame]);
        }
    }

    if (anyActive || Object.keys(activeAnimations).length > 0) {
        animationFrame = requestAnimationFrame(animationLoop);
    } else {
        animationFrame = null;
    }
}

/**
 * Update an entity's sprite display
 * @param {string} entityId - Entity identifier
 * @param {string} frameName - Frame name to display
 */
function updateEntitySprite(entityId, frameName) {
    // Get sprite mapping from settings
    const settings = getAnimationSettings();
    const frameMapping = settings.frameSprites?.[frameName];

    // Try to find and update the entity element
    if (entityId === 'player') {
        // Update player overlay
        const playerOverlay = document.getElementById('maze_player_overlay');
        if (playerOverlay) {
            playerOverlay.dataset.animFrame = frameName;
            if (frameMapping?.sprite) {
                playerOverlay.style.backgroundImage = `url('${frameMapping.sprite}')`;
            }
        }
    } else if (entityId.startsWith('minion_')) {
        // Update minion image in maze grid
        const minionIdx = entityId.replace('minion_', '');
        const minionImg = document.getElementById('maze_minion_img');
        if (minionImg && frameMapping?.sprite) {
            minionImg.src = frameMapping.sprite;
        }
    } else {
        // Generic entity update via data attribute
        const el = document.querySelector(`[data-entity="${entityId}"]`);
        if (el) {
            el.dataset.animFrame = frameName;
            if (frameMapping?.sprite) {
                if (el.tagName === 'IMG') {
                    el.src = frameMapping.sprite;
                } else {
                    el.style.backgroundImage = `url('${frameMapping.sprite}')`;
                }
            }
        }
    }
}

/**
 * Stop all active animations
 */
function stopAllAnimations() {
    activeAnimations = {};
    if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
    }
}

/**
 * Check if an entity has an active animation
 * @param {string} entityId - Entity identifier
 * @returns {boolean}
 */
function hasAnimation(entityId) {
    return entityId in activeAnimations;
}

/**
 * Get room name data - checks custom styles first
 */
function getRoomNameData(mapStyle) {
    if (extensionSettings.customStyles?.[mapStyle]) {
        return extensionSettings.customStyles[mapStyle].roomNames;
    }
    return ROOM_NAME_DATA[mapStyle] || ROOM_NAME_DATA.maze;
}

/**
 * Get BSP config - checks custom styles first
 */
function getCustomBSPConfig(mapStyle) {
    if (extensionSettings.customStyles?.[mapStyle]) {
        return extensionSettings.customStyles[mapStyle].bspConfig;
    }
    const mapped = STYLE_TO_BSP_CONFIG[mapStyle] || mapStyle;
    return BSP_STYLE_CONFIGS[mapped] || BSP_STYLE_CONFIGS.dungeon;
}

/**
 * Populate theme profile selector dropdown
 */
function populateThemeProfileSelect() {
    const select = document.getElementById('mazemaster_theme_profile_select');
    if (!select) return;

    const names = getCustomThemeNames();
    // v2.0.0: Use getCustomTheme to get display names (works for both custom and default themes)
    const customThemes = extensionSettings.customThemes || {};
    select.innerHTML = '<option value="">-- Select Theme --</option>' +
        names.map(n => {
            const theme = getCustomTheme(n);
            const displayName = (theme && theme.displayName) ? theme.displayName : n;
            const isDefault = DEFAULT_THEME_PROFILES[n] && !customThemes[n];
            const label = isDefault ? `${displayName} (Default)` : displayName;
            return `<option value="${escapeHtml(n)}">${escapeHtml(label)}</option>`;
        }).join('');
}

/**
 * Populate style profile selector dropdown
 */
function populateStyleProfileSelect() {
    const select = document.getElementById('mazemaster_style_profile_select');
    if (!select) return;

    const names = getCustomStyleNames();
    // v2.0.0: Use getCustomStyle to get display names (works for both custom and default styles)
    const customStyles = extensionSettings.customStyles || {};
    select.innerHTML = '<option value="">-- Select Style --</option>' +
        names.map(n => {
            const style = getCustomStyle(n);
            const displayName = (style && style.displayName) ? style.displayName : n;
            const isDefault = DEFAULT_STYLE_PROFILES[n] && !customStyles[n];
            const label = isDefault ? `${displayName} (Default)` : displayName;
            return `<option value="${escapeHtml(n)}">${escapeHtml(label)}</option>`;
        }).join('');
}

/**
 * Load theme data into UI form
 */
function loadThemeToUI(themeName) {
    const theme = getCustomTheme(themeName);
    if (!theme) return;

    const setVal = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.value = val || '';
    };
    const setChecked = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.checked = !!val;
    };

    setVal('mazemaster_theme_name', theme.name);
    setVal('mazemaster_theme_display', theme.displayName);
    setVal('mazemaster_theme_tags', (theme.tags || []).join(', '));
    setVal('mazemaster_theme_atmosphere', theme.atmosphere);
    setVal('mazemaster_theme_adjectives', (theme.adjectives || []).join(', '));
    setVal('mazemaster_theme_rooms_small', (theme.roomTypes?.small || []).join(', '));
    setVal('mazemaster_theme_rooms_medium', (theme.roomTypes?.medium || []).join(', '));
    setVal('mazemaster_theme_rooms_large', (theme.roomTypes?.large || []).join(', '));
    setVal('mazemaster_theme_rooms_special', (theme.roomTypes?.special || []).join(', '));
    setVal('mazemaster_theme_flavor_chest', theme.flavorMessages?.chestFind);
    setVal('mazemaster_theme_flavor_trap', theme.flavorMessages?.trapTrigger);
    setVal('mazemaster_theme_flavor_victory', theme.flavorMessages?.victory);
    setVal('mazemaster_theme_flavor_defeat', theme.flavorMessages?.defeat);
    setVal('mazemaster_theme_color_primary', theme.colors?.primary || '#8b0000');
    setVal('mazemaster_theme_color_secondary', theme.colors?.secondary || '#2d1f1f');
    setVal('mazemaster_theme_color_accent', theme.colors?.accent || '#ff4444');
}

/**
 * Collect theme data from UI form
 */
function collectThemeFromUI() {
    const getVal = (id) => document.getElementById(id)?.value || '';
    const parseList = (id) => getVal(id).split(',').map(s => s.trim()).filter(Boolean);

    return {
        name: getVal('mazemaster_theme_name'),
        displayName: getVal('mazemaster_theme_display'),
        tags: parseList('mazemaster_theme_tags'),
        atmosphere: getVal('mazemaster_theme_atmosphere'),
        adjectives: parseList('mazemaster_theme_adjectives'),
        roomTypes: {
            small: parseList('mazemaster_theme_rooms_small'),
            medium: parseList('mazemaster_theme_rooms_medium'),
            large: parseList('mazemaster_theme_rooms_large'),
            special: parseList('mazemaster_theme_rooms_special'),
        },
        flavorMessages: {
            chestFind: getVal('mazemaster_theme_flavor_chest'),
            trapTrigger: getVal('mazemaster_theme_flavor_trap'),
            victory: getVal('mazemaster_theme_flavor_victory'),
            defeat: getVal('mazemaster_theme_flavor_defeat'),
        },
        colors: {
            primary: getVal('mazemaster_theme_color_primary'),
            secondary: getVal('mazemaster_theme_color_secondary'),
            accent: getVal('mazemaster_theme_color_accent'),
        }
    };
}

/**
 * Clear theme form
 */
function clearThemeForm() {
    const fields = [
        'mazemaster_theme_name', 'mazemaster_theme_display', 'mazemaster_theme_tags',
        'mazemaster_theme_atmosphere', 'mazemaster_theme_adjectives',
        'mazemaster_theme_rooms_small', 'mazemaster_theme_rooms_medium',
        'mazemaster_theme_rooms_large', 'mazemaster_theme_rooms_special',
        'mazemaster_theme_flavor_chest', 'mazemaster_theme_flavor_trap',
        'mazemaster_theme_flavor_victory', 'mazemaster_theme_flavor_defeat'
    ];
    fields.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '';
    });
    const colorPrimary = document.getElementById('mazemaster_theme_color_primary');
    const colorSecondary = document.getElementById('mazemaster_theme_color_secondary');
    const colorAccent = document.getElementById('mazemaster_theme_color_accent');
    if (colorPrimary) colorPrimary.value = '#8b0000';
    if (colorSecondary) colorSecondary.value = '#2d1f1f';
    if (colorAccent) colorAccent.value = '#ff4444';
}

/**
 * Load style data into UI form
 */
function loadStyleToUI(styleName) {
    const style = getCustomStyle(styleName);
    if (!style) return;

    const setVal = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.value = val || '';
    };
    const setChecked = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.checked = !!val;
    };

    setVal('mazemaster_style_name', style.name);
    setVal('mazemaster_style_display', style.displayName);

    // BSP config
    setVal('mazemaster_style_bsp_minroom', style.bspConfig?.minRoomSize ?? 2);
    setVal('mazemaster_style_bsp_maxroom', style.bspConfig?.maxRoomSize ?? 5);
    setVal('mazemaster_style_bsp_corridor', style.bspConfig?.corridorWidth ?? 1);
    setVal('mazemaster_style_bsp_padding', style.bspConfig?.roomPadding ?? 1);
    setVal('mazemaster_style_bsp_minsplit', style.bspConfig?.minSplitSize ?? 4);
    setVal('mazemaster_style_bsp_variance', style.bspConfig?.splitVariance ?? 0.3);
    setVal('mazemaster_style_bsp_connections', style.bspConfig?.extraConnections ?? 0.1);
    setVal('mazemaster_style_bsp_branch', style.bspConfig?.branchChance ?? 0.3);
    setChecked('mazemaster_style_bsp_grid', style.bspConfig?.gridAlign);
    setChecked('mazemaster_style_bsp_winding', style.bspConfig?.windingCorridors);
    setChecked('mazemaster_style_bsp_modular', style.bspConfig?.modularRooms);
    setChecked('mazemaster_style_bsp_square', style.bspConfig?.preferSquareRooms);

    // Room names
    setVal('mazemaster_style_common_prefixes', (style.roomNames?.common?.prefixes || []).join(', '));
    setVal('mazemaster_style_common_nouns', (style.roomNames?.common?.nouns || []).join(', '));
    setVal('mazemaster_style_common_desc', (style.roomNames?.common?.descriptions || []).join('\n'));
    setVal('mazemaster_style_junction_prefixes', (style.roomNames?.junction?.prefixes || []).join(', '));
    setVal('mazemaster_style_junction_nouns', (style.roomNames?.junction?.nouns || []).join(', '));
    setVal('mazemaster_style_junction_desc', (style.roomNames?.junction?.descriptions || []).join('\n'));
    setVal('mazemaster_style_deadend_prefixes', (style.roomNames?.deadend?.prefixes || []).join(', '));
    setVal('mazemaster_style_deadend_nouns', (style.roomNames?.deadend?.nouns || []).join(', '));
    setVal('mazemaster_style_deadend_desc', (style.roomNames?.deadend?.descriptions || []).join('\n'));
    setVal('mazemaster_style_start_names', (style.roomNames?.start?.names || []).join(', '));
    setVal('mazemaster_style_staircase_names', (style.roomNames?.staircase?.names || []).join(', '));
    setVal('mazemaster_style_portal_names', (style.roomNames?.portal?.names || []).join(', '));
    setVal('mazemaster_style_chest_names', (style.roomNames?.chest?.names || []).join(', '));
    setVal('mazemaster_style_minion_names', (style.roomNames?.minion?.names || []).join(', '));
    setVal('mazemaster_style_trap_names', (style.roomNames?.trap?.names || []).join(', '));
    setVal('mazemaster_style_exit_names', (style.roomNames?.exit?.names || []).join(', '));
}

/**
 * Collect style data from UI form
 */
function collectStyleFromUI() {
    const getVal = (id) => document.getElementById(id)?.value || '';
    const getNum = (id, def) => parseFloat(document.getElementById(id)?.value) || def;
    const getInt = (id, def) => parseInt(document.getElementById(id)?.value) || def;
    const getChecked = (id) => document.getElementById(id)?.checked || false;
    const parseList = (id) => getVal(id).split(',').map(s => s.trim()).filter(Boolean);
    const parseLines = (id) => getVal(id).split('\n').map(s => s.trim()).filter(Boolean);

    return {
        name: getVal('mazemaster_style_name'),
        displayName: getVal('mazemaster_style_display'),
        bspConfig: {
            minRoomSize: getInt('mazemaster_style_bsp_minroom', 2),
            maxRoomSize: getInt('mazemaster_style_bsp_maxroom', 5),
            corridorWidth: getInt('mazemaster_style_bsp_corridor', 1),
            roomPadding: getInt('mazemaster_style_bsp_padding', 1),
            minSplitSize: getInt('mazemaster_style_bsp_minsplit', 4),
            splitVariance: getNum('mazemaster_style_bsp_variance', 0.3),
            extraConnections: getNum('mazemaster_style_bsp_connections', 0.1),
            branchChance: getNum('mazemaster_style_bsp_branch', 0.3),
            gridAlign: getChecked('mazemaster_style_bsp_grid'),
            windingCorridors: getChecked('mazemaster_style_bsp_winding'),
            modularRooms: getChecked('mazemaster_style_bsp_modular'),
            preferSquareRooms: getChecked('mazemaster_style_bsp_square'),
        },
        roomNames: {
            common: {
                prefixes: parseList('mazemaster_style_common_prefixes'),
                nouns: parseList('mazemaster_style_common_nouns'),
                descriptions: parseLines('mazemaster_style_common_desc'),
            },
            junction: {
                prefixes: parseList('mazemaster_style_junction_prefixes'),
                nouns: parseList('mazemaster_style_junction_nouns'),
                descriptions: parseLines('mazemaster_style_junction_desc'),
            },
            deadend: {
                prefixes: parseList('mazemaster_style_deadend_prefixes'),
                nouns: parseList('mazemaster_style_deadend_nouns'),
                descriptions: parseLines('mazemaster_style_deadend_desc'),
            },
            start: {
                names: parseList('mazemaster_style_start_names'),
                descriptions: [],
            },
            staircase: {
                names: parseList('mazemaster_style_staircase_names'),
                descriptions: [],
            },
            portal: {
                names: parseList('mazemaster_style_portal_names'),
                descriptions: [],
            },
            chest: {
                names: parseList('mazemaster_style_chest_names'),
                descriptions: [],
            },
            minion: {
                names: parseList('mazemaster_style_minion_names'),
                descriptions: [],
            },
            trap: {
                names: parseList('mazemaster_style_trap_names'),
                descriptions: [],
            },
            exit: {
                names: parseList('mazemaster_style_exit_names'),
                descriptions: [],
            },
        }
    };
}

/**
 * Clear style form
 */
function clearStyleForm() {
    const fields = [
        'mazemaster_style_name', 'mazemaster_style_display',
        'mazemaster_style_common_prefixes', 'mazemaster_style_common_nouns', 'mazemaster_style_common_desc',
        'mazemaster_style_junction_prefixes', 'mazemaster_style_junction_nouns', 'mazemaster_style_junction_desc',
        'mazemaster_style_deadend_prefixes', 'mazemaster_style_deadend_nouns', 'mazemaster_style_deadend_desc',
        'mazemaster_style_start_names', 'mazemaster_style_staircase_names', 'mazemaster_style_portal_names',
        'mazemaster_style_chest_names', 'mazemaster_style_minion_names', 'mazemaster_style_trap_names',
        'mazemaster_style_exit_names'
    ];
    fields.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '';
    });
    // Reset BSP defaults
    const setVal = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.value = val;
    };
    const setChecked = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.checked = val;
    };
    setVal('mazemaster_style_bsp_minroom', '2');
    setVal('mazemaster_style_bsp_maxroom', '5');
    setVal('mazemaster_style_bsp_corridor', '1');
    setVal('mazemaster_style_bsp_padding', '1');
    setVal('mazemaster_style_bsp_minsplit', '4');
    setVal('mazemaster_style_bsp_variance', '0.3');
    setVal('mazemaster_style_bsp_connections', '0.1');
    setVal('mazemaster_style_bsp_branch', '0.3');
    setChecked('mazemaster_style_bsp_grid', false);
    setChecked('mazemaster_style_bsp_winding', false);
    setChecked('mazemaster_style_bsp_modular', false);
    setChecked('mazemaster_style_bsp_square', false);
}

// =============================================================================
// MINION FUNCTIONS
// =============================================================================

// Minion functions
function getMinionNames() {
    return Object.keys(extensionSettings.minions || {});
}

function getMinion(name) {
    return extensionSettings.minions[name];
}

function saveMinion(id, minionData) {
    extensionSettings.minions[id] = {
        name: minionData.name || 'Unknown',
        imagePath: minionData.imagePath || '',
        description: minionData.description || '', // For LLM generation
        type: minionData.type || 'messenger', // 'messenger' | 'battlebar' | 'prizewheel' | 'merchant' | 'turnbased' | 'qte' | 'dice' | 'stealth' | 'puzzle' | 'negotiation'
        battlebarProfiles: minionData.battlebarProfiles || [], // For battlebar type
        wheelProfiles: minionData.wheelProfiles || [], // For prizewheel type
        messages: minionData.messages || [], // For messenger type
        encounterScript: minionData.encounterScript || '', // Optional STScript to run on encounter
        merchantItemCount: minionData.merchantItemCount || { min: 1, max: 3 }, // For merchant type
        // Movement settings for maze encounters
        movement: minionData.movement || {
            type: 'stationary', // 'stationary' | 'patrol' | 'chase'
            patrolRadius: 3,
            chaseRange: 5,
            speed: 1, // moves per player move (1 = every move, 2 = every other move)
        },
    };
    saveSettingsDebounced();
    console.log('[MazeMaster] Minion saved:', id, extensionSettings.minions[id]);
}

function deleteMinion(id) {
    delete extensionSettings.minions[id];
    saveSettingsDebounced();
}

function getDefaultMinion() {
    return {
        name: 'The Maze',
        imagePath: '',
        message: 'Find your way to the exit...',
    };
}

// =============================================================================
// TRAP FUNCTIONS
// =============================================================================

function getTrapNames() {
    return Object.keys(extensionSettings.traps || {});
}

function getTrap(id) {
    return extensionSettings.traps?.[id];
}

function saveTrap(id, trapData) {
    if (!extensionSettings.traps) extensionSettings.traps = {};
    extensionSettings.traps[id] = {
        name: trapData.name || 'Unknown Trap',
        imagePath: trapData.imagePath || '',
        message: trapData.message || 'You triggered a trap!',
        script: trapData.script || '', // STScript to execute when triggered
        avoidChance: trapData.avoidChance ?? 0, // % chance to avoid (0-100)
        avoidMessage: trapData.avoidMessage || '', // Message when avoided
        avoidScript: trapData.avoidScript || '', // STScript to execute when avoided
    };
    saveSettingsDebounced();
    console.log('[MazeMaster] Trap saved:', id, extensionSettings.traps[id]);
}

function deleteTrap(id) {
    delete extensionSettings.traps[id];
    saveSettingsDebounced();
}

// =============================================================================
// WHEEL LOGIC
// =============================================================================

function loadWheelFromProfile(profileName) {
    const profile = getProfile(profileName);
    if (!profile || !profile.segments || profile.segments.length === 0) {
        return { error: `Profile "${profileName}" not found or empty` };
    }

    currentWheel.segments = profile.segments.map((seg, i) => ({
        ...seg,
        units: SIZE_UNITS[seg.size] || 1,
        color: WHEEL_COLORS[i % WHEEL_COLORS.length],
    }));
    currentWheel.isOpen = false;
    currentWheel.isSpinning = false;
    currentWheel.pendingRespin = false;
    currentWheel.hasRespun = false;

    return { success: true, count: currentWheel.segments.length };
}

function validateWheelBalance() {
    const halfCount = currentWheel.segments.filter(s => s.size === 'halfseg').length;
    const doubleCount = currentWheel.segments.filter(s => s.size === 'doubleseg').length;

    if (halfCount !== doubleCount) {
        console.error(`[MazeMaster] Wheel balance error: ${halfCount} halfseg(s) but ${doubleCount} doubleseg(s). They must be equal.`);
        return { valid: false, error: `Wheel unbalanced: ${halfCount} halfseg(s) ≠ ${doubleCount} doubleseg(s)` };
    }
    return { valid: true };
}

function getTotalUnits() {
    return currentWheel.segments.reduce((sum, s) => sum + s.units, 0);
}

function selectWinner() {
    const totalUnits = getTotalUnits();
    let random = Math.random() * totalUnits;

    for (const segment of currentWheel.segments) {
        random -= segment.units;
        if (random <= 0) {
            return segment;
        }
    }
    return currentWheel.segments[currentWheel.segments.length - 1];
}

function clearWheel() {
    currentWheel.segments = [];
    currentWheel.isOpen = false;
    currentWheel.isSpinning = false;
    currentWheel.pendingRespin = false;
    currentWheel.hasRespun = false;
}

// =============================================================================
// WHEEL MODAL & CANVAS
// =============================================================================

function getWheelModalHtml() {
    // Show cancel button for maze encounters only (emergency escape)
    const showCancel = currentMaze.isOpen && currentMaze.pendingEncounter;
    return `
        <div id="mazemaster_wheel_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.95);">
            <div class="mazemaster-wheel-container">
                ${showCancel ? `<button id="mazemaster_wheel_cancel_btn" class="mazemaster-wheel-cancel-btn" title="Cancel wheel (skip encounter)"><i class="fa-solid fa-xmark"></i></button>` : ''}
                <div class="mazemaster-wheel-pointer"></div>
                <canvas id="mazemaster_wheel_canvas" width="400" height="400"></canvas>
                <button id="mazemaster_spin_btn" class="mazemaster-spin-btn">
                    <i class="fa-solid fa-play"></i> SPIN
                </button>
            </div>
        </div>
    `;
}

function getWheelStyles() {
    return `
        .mazemaster-wheel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: flex-start;
            justify-content: center;
            z-index: 10002;
            overflow-y: auto;
            padding: 10px 0;
            -webkit-overflow-scrolling: touch;
        }

        .mazemaster-wheel-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 25px;
            margin: auto;
            background: #1a1a2e;
            border-radius: 15px;
            border: 2px solid #333;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .mazemaster-wheel-pointer {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 30px solid #fff;
            z-index: 10;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        #mazemaster_wheel_canvas {
            border-radius: 50%;
            box-shadow: 0 0 30px rgba(0,0,0,0.5), inset 0 0 20px rgba(255,255,255,0.1);
            transition: transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99);
        }

        .mazemaster-spin-btn {
            padding: 15px 40px;
            font-size: 1.2em;
            font-weight: bold;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .mazemaster-spin-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.6);
        }

        .mazemaster-spin-btn:disabled {
            background: #555;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .mazemaster-spin-btn.respin {
            background: linear-gradient(135deg, #f39c12, #d68910);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
        }

        .mazemaster-spin-btn.respin:hover {
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.6);
        }

        .mazemaster-wheel-cancel-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(100, 100, 100, 0.8);
            color: #ccc;
            border: 1px solid #555;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            z-index: 100;
            transition: background 0.2s, color 0.2s;
        }

        .mazemaster-wheel-cancel-btn:hover {
            background: rgba(180, 60, 60, 0.9);
            color: white;
            border-color: #a33;
        }
    `;
}

function drawWheel(canvas) {
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(centerX, centerY) - 10;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const totalUnits = getTotalUnits();
    let currentAngle = -Math.PI / 2;

    for (const segment of currentWheel.segments) {
        const segmentAngle = (segment.units / totalUnits) * 2 * Math.PI;

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + segmentAngle);
        ctx.closePath();
        ctx.fillStyle = segment.color;
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 2;
        ctx.stroke();

        const textAngle = currentAngle + segmentAngle / 2;
        const textRadius = radius * 0.55;
        const textX = centerX + Math.cos(textAngle) * textRadius;
        const textY = centerY + Math.sin(textAngle) * textRadius;

        ctx.save();
        ctx.translate(textX, textY);
        // Rotate text to be radial (pointing outward from center)
        ctx.rotate(textAngle);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 3;

        let displayText = segment.text || segment.trigger;
        if (displayText.length > 12) {
            displayText = displayText.substring(0, 10) + '...';
        }
        ctx.fillText(displayText, 0, 0);
        ctx.restore();

        currentAngle += segmentAngle;
    }

    ctx.beginPath();
    ctx.arc(centerX, centerY, 20, 0, 2 * Math.PI);
    ctx.fillStyle = '#333';
    ctx.fill();
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 3;
    ctx.stroke();
}

function showWheelModal() {
    const existing = document.getElementById('mazemaster_wheel_modal');
    if (existing) existing.remove();

    if (!document.getElementById('mazemaster_wheel_styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_wheel_styles';
        styleEl.textContent = getWheelStyles();
        document.head.appendChild(styleEl);
    }

    const modalContainer = document.createElement('div');
    modalContainer.innerHTML = getWheelModalHtml();
    document.body.appendChild(modalContainer.firstElementChild);

    const canvas = document.getElementById('mazemaster_wheel_canvas');
    if (canvas) {
        drawWheel(canvas);
    }

    const spinBtn = document.getElementById('mazemaster_spin_btn');
    if (spinBtn) {
        spinBtn.addEventListener('click', handleSpinClick);
    }

    // Cancel button (only shown during maze encounters as emergency escape)
    const cancelBtn = document.getElementById('mazemaster_wheel_cancel_btn');
    if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
            if (currentWheel.isSpinning) return; // Don't cancel while spinning
            console.log('[MazeMaster] Wheel cancelled by user');

            // Close modal
            const modal = document.getElementById('mazemaster_wheel_modal');
            if (modal) modal.remove();
            currentWheel.isOpen = false;
            currentWheel.isSpinning = false;
            clearWheel();

            // Handle maze state
            if (currentMaze.isOpen) {
                const encounterType = currentMaze.pendingEncounter?.type;
                currentMaze.pendingEncounter = null;

                if (encounterType === 'exit_wheel') {
                    // Exit was cancelled - player stays at exit, can try again
                    currentMaze.isPaused = false;
                } else {
                    // Regular wheel encounter cancelled - resume maze
                    resumeMaze();
                }
            }
        });
    }

    currentWheel.isOpen = true;
}

function closeWheelModal() {
    const modal = document.getElementById('mazemaster_wheel_modal');
    if (modal) modal.remove();
    currentWheel.isOpen = false;

    // Handle maze integration if this was a maze encounter
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (encounterType === 'exit_wheel') {
                    // Exit wheel completed - win the maze
                    currentMaze.exitEncounterDone = true;
                    currentMaze.isPaused = false;
                    handleMazeWin();
                    return;
                } else if (encounterType === 'wheel') {
                    // Regular wheel encounter - resume maze
                    resumeMaze();
                    return;
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeWheelModal:', err);
        }

        // Fallback: ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

async function handleSpinClick() {
    const spinBtn = document.getElementById('mazemaster_spin_btn');
    if (!spinBtn || currentWheel.isSpinning) return;

    spinBtn.disabled = true;
    spinBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Spinning...';

    currentWheel.isSpinning = true;
    currentWheel.pendingRespin = false;

    const winner = selectWinner();
    const canvas = document.getElementById('mazemaster_wheel_canvas');

    if (!canvas) {
        currentWheel.isSpinning = false;
        return;
    }

    // Calculate winning angle
    const totalUnits = getTotalUnits();
    let winnerStartAngle = 0;
    for (const segment of currentWheel.segments) {
        if (segment === winner) break;
        winnerStartAngle += (segment.units / totalUnits) * 360;
    }
    const winnerMidAngle = winnerStartAngle + ((winner.units / totalUnits) * 360) / 2;

    const fullRotations = 5 + Math.floor(Math.random() * 3);
    const currentRotation = parseFloat(canvas.style.transform?.match(/rotate\((\d+\.?\d*)deg\)/)?.[1] || 0);
    const finalAngle = currentRotation + fullRotations * 360 + (360 - winnerMidAngle);

    canvas.style.transition = 'transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99)';
    canvas.style.transform = `rotate(${finalAngle}deg)`;

    await new Promise(resolve => setTimeout(resolve, 4200));

    currentWheel.isSpinning = false;

    // Execute command - use winner.command directly since it was copied from profile during loadWheelFromProfile
    // This fixes issues where exit wheels wouldn't execute commands because extensionSettings.currentProfile wasn't set
    if (winner.command) {
        console.log(`[MazeMaster] Executing command for "${winner.text}": ${winner.command}`);
        await executeWithTimeout(winner.command);
    }

    // Store result for macros - use the loaded profile name from pendingEncounter if available
    const wheelProfileName = currentMaze.isOpen && currentMaze.pendingEncounter?.profile
        ? currentMaze.pendingEncounter.profile
        : extensionSettings.currentProfile;
    lastResults.wheel[wheelProfileName || 'unknown'] = {
        segmentName: winner.text,
        command: winner.command || '',
        timestamp: Date.now(),
    };

    // Check for respin (only one respin allowed per wheel session)
    if (winner.respin && !currentWheel.hasRespun) {
        currentWheel.pendingRespin = true;
        currentWheel.hasRespun = true; // Mark that we've used our one respin
        spinBtn.disabled = false;
        spinBtn.className = 'mazemaster-spin-btn respin';
        spinBtn.innerHTML = '<i class="fa-solid fa-rotate"></i> RESPIN';
    } else {
        closeWheelModal();
        clearWheel();
    }
}

// =============================================================================
// SLASH COMMANDS
// =============================================================================

function registerSlashCommands() {
    console.log('[MazeMaster] registerSlashCommands() starting...');
    try {
    // Wheel command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'wheel',
        callback: async (args) => {
            // Try specified profile, then current, then first available, then default
            let profileName = args.profile;
            if (!profileName) {
                // Check if current profile exists
                const current = extensionSettings.currentProfile;
                if (current && getProfile(current)) {
                    profileName = current;
                } else {
                    // Use first available profile or fallback
                    const available = getProfileNames();
                    profileName = available.length > 0 ? available[0] : 'Blessing Wheel';
                }
            }

            console.log('[MazeMaster] /wheel command - loading profile:', profileName);
            const result = loadWheelFromProfile(profileName);
            if (result.error) {
                console.error('[MazeMaster] /wheel error:', result.error);
                return `Error: ${result.error}`;
            }

            const validation = validateWheelBalance();
            if (!validation.valid) {
                return `Error: ${validation.error}`;
            }

            extensionSettings.currentProfile = profileName;
            showWheelModal();
            return `Wheel "${profileName}" opened with ${result.count} segments. Click SPIN!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the wheel profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
                defaultValue: 'default',
            }),
        ],
        helpString: 'Open a wheel by profile name. Example: /wheel profile="mywheel"',
    }));

    // Battlebar command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'battlebar',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentBattlebarProfile || 'Tutorial - Learn Combat';
            const result = startBattlebar(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Battlebar "${profileName}" started! Press SPACE when the arrow is in the green zone.`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the battlebar profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
                defaultValue: 'default',
            }),
        ],
        helpString: 'Start a battlebar challenge. Example: /battlebar profile="boss1"',
    }));

    // Maze command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'maze',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentMazeProfile || 'Tutorial - Learn the Basics';
            const result = startMaze(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Maze "${profileName}" started! Use arrow keys to navigate.`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the maze profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a maze game. Example: /maze profile="dungeon1"',
    }));

    // Mazeminion command - sets the current minion display in an active maze
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazeminion',
        callback: async (args) => {
            if (!currentMaze.isOpen) {
                return 'No maze is currently open.';
            }

            const minionName = args.name;
            const message = args.message || '';

            // Check if this is a configured minion
            const minion = getMinion(minionName);
            if (minion) {
                currentMaze.currentMinion = {
                    name: minion.name,
                    imagePath: minion.imagePath,
                    message: message,
                };
            } else {
                // Custom minion name
                currentMaze.currentMinion = {
                    name: minionName || 'Unknown',
                    imagePath: '',
                    message: message,
                };
            }

            updateMazeHero();
            return '';
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'name',
                description: 'Minion name (from config) or custom name',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'message',
                description: 'Message to display',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Set the minion display in an active maze. Example: /mazeminion name="Goblin" message="You shall not pass!"',
    }));

    // Mazestats command - get current session stats as JSON
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazestats',
        callback: async () => {
            if (!currentMaze.isOpen) {
                return JSON.stringify({ error: 'No maze is currently open.' });
            }

            const stats = {
                moves: currentMaze.stats?.moves || 0,
                encountersTotal: currentMaze.stats?.encountersTotal || 0,
                encountersWon: currentMaze.stats?.encountersWon || 0,
                chestsOpened: currentMaze.stats?.chestsOpened || 0,
                trapsTriggered: currentMaze.stats?.trapsTriggered || 0,
                teleportsUsed: currentMaze.stats?.teleportsUsed || 0,
                itemsCollected: currentMaze.stats?.itemsCollected || {},
                exploration: getExplorationPercent(),
                elapsedTime: getElapsedTime(),
                difficulty: currentMaze.profile?.difficulty || 'normal',
            };

            return JSON.stringify(stats);
        },
        helpString: 'Get current maze session statistics as JSON. Example: /mazestats',
    }));

    // Mazeexplore command - get exploration percentage
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazeexplore',
        callback: async () => {
            if (!currentMaze.isOpen) {
                return 'No maze is currently open.';
            }

            const percent = getExplorationPercent();
            return String(percent);
        },
        helpString: 'Get current maze exploration percentage (0-100). Example: /mazeexplore',
    }));

    // Mazeobjective command - get objective progress
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazeobjective',
        callback: async (args) => {
            if (!currentMaze.isOpen) {
                return JSON.stringify({ error: 'No maze is currently open.' });
            }

            const objectives = currentMaze.profile?.objectives || [];
            const progress = currentMaze.objectiveProgress || {};

            if (args.id) {
                // Get specific objective
                const obj = objectives.find(o => o.id === args.id);
                if (!obj) {
                    return JSON.stringify({ error: `Objective "${args.id}" not found.` });
                }
                const prog = progress[args.id] || { current: 0, completed: false };
                return JSON.stringify({
                    id: obj.id,
                    type: obj.type,
                    target: obj.target,
                    description: obj.description,
                    current: prog.current,
                    required: obj.count,
                    completed: prog.completed,
                    isRequired: obj.required,
                });
            } else {
                // Get all objectives
                const allProgress = objectives.map(obj => {
                    const prog = progress[obj.id] || { current: 0, completed: false };
                    return {
                        id: obj.id,
                        type: obj.type,
                        description: obj.description,
                        current: prog.current,
                        required: obj.count,
                        completed: prog.completed,
                        isRequired: obj.required,
                    };
                });
                return JSON.stringify(allProgress);
            }
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'id',
                description: 'Specific objective ID to get (optional, returns all if omitted)',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Get maze objective progress. Example: /mazeobjective id="collect_keys" or /mazeobjective (for all)',
    }));

    // Mazedifficulty command - set difficulty for next maze
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazedifficulty',
        callback: async (args) => {
            const tier = args.tier?.toLowerCase();
            const validTiers = getAvailableDifficulties(); // v1.9.0: Dynamic from DIFFICULTY_TIERS

            if (!tier) {
                // Return current difficulty setting
                const currentProfile = extensionSettings.mazeProfiles?.[extensionSettings.currentMazeProfile || 'Tutorial - Learn the Basics'];
                return currentProfile?.difficulty || 'normal';
            }

            if (!validTiers.includes(tier)) {
                return `Error: Invalid difficulty tier. Valid options: ${validTiers.join(', ')}`;
            }

            // Update the current maze profile's difficulty
            const profileName = extensionSettings.currentMazeProfile || 'Tutorial - Learn the Basics';
            if (extensionSettings.mazeProfiles?.[profileName]) {
                extensionSettings.mazeProfiles[profileName].difficulty = tier;
                saveSettings();
                return `Difficulty set to "${tier}" for profile "${profileName}".`;
            } else {
                return `Error: Profile "${profileName}" not found.`;
            }
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'tier',
                description: 'Difficulty tier: easy, normal, hard, or nightmare',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Get or set maze difficulty. Example: /mazedifficulty tier="hard" or /mazedifficulty (to get current)',
    }));

    // v1.2.0: Persona stats command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazepersonastats',
        callback: async (args) => {
            const personaName = args.persona || getCurrentPersonaName();
            const stats = extensionSettings.mazeStats?.personas?.[personaName];

            if (!stats) {
                return JSON.stringify({ error: `No stats found for persona "${personaName}".` });
            }

            return JSON.stringify({
                persona: personaName,
                totalGames: stats.totalGames || 0,
                wins: stats.wins || 0,
                losses: stats.losses || 0,
                totalMoves: stats.totalMoves || 0,
                bestTime: stats.bestTime,
                profileStats: stats.profileStats || {},
            });
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'persona',
                description: 'Name of the persona to get stats for (default: current persona)',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Get maze stats for a specific persona. Example: /mazepersonastats persona="Alice"',
    }));

    // v1.2.0: Floor command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazefloor',
        callback: async () => {
            if (!currentMaze.isOpen) {
                return JSON.stringify({ error: 'No maze is currently open.' });
            }

            return JSON.stringify({
                current: (currentMaze.currentFloor || 0) + 1,
                total: currentMaze.totalFloors || 1,
            });
        },
        helpString: 'Get current floor information in an active maze. Example: /mazefloor',
    }));

    // v1.2.0: Theme command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazetheme',
        callback: async (args) => {
            const theme = args.theme?.toLowerCase();
            const validThemes = getAvailableThemes(); // v1.9.0: Dynamic from DEFAULT_FACTION_PROFILES

            if (!theme) {
                // Return current theme
                const profileName = extensionSettings.currentMazeProfile || 'Tutorial - Learn the Basics';
                const currentProfile = extensionSettings.mazeProfiles?.[profileName];
                return currentProfile?.theme || 'fantasy';
            }

            if (!validThemes.includes(theme)) {
                return `Error: Invalid theme. Valid options: ${validThemes.join(', ')}`;
            }

            const profileName = extensionSettings.currentMazeProfile || 'Tutorial - Learn the Basics';
            if (extensionSettings.mazeProfiles?.[profileName]) {
                extensionSettings.mazeProfiles[profileName].theme = theme;
                saveSettings();
                return `Theme set to "${theme}" for profile "${profileName}".`;
            } else {
                return `Error: Profile "${profileName}" not found.`;
            }
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'theme',
                description: 'Theme: fantasy, horror, scifi, or action',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Get or set maze theme. Example: /mazetheme theme="horror" or /mazetheme (to get current)',
    }));

    // v1.2.0: Map style command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazemapstyle',
        callback: async (args) => {
            const style = args.style?.toLowerCase();
            const validStyles = getAvailableMapStyles(); // v1.9.0: Dynamic from STYLE_TO_BSP_CONFIG

            if (!style) {
                // Return current map style
                const profileName = extensionSettings.currentMazeProfile || 'Tutorial - Learn the Basics';
                const currentProfile = extensionSettings.mazeProfiles?.[profileName];
                return currentProfile?.mapStyle || 'maze';
            }

            if (!validStyles.includes(style)) {
                return `Error: Invalid map style. Valid options: ${validStyles.join(', ')}`;
            }

            const profileName = extensionSettings.currentMazeProfile || 'Tutorial - Learn the Basics';
            if (extensionSettings.mazeProfiles?.[profileName]) {
                extensionSettings.mazeProfiles[profileName].mapStyle = style;
                saveSettings();
                return `Map style set to "${style}" for profile "${profileName}".`;
            } else {
                return `Error: Profile "${profileName}" not found.`;
            }
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'style',
                description: 'Map style: maze, dungeon, city, forest, or spaceship',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Get or set maze map style. Example: /mazemapstyle style="dungeon" or /mazemapstyle (to get current)',
    }));

    // v1.3.0: Item management commands
    const ITEM_INDEX = {
        // Core items (1-4)
        1: 'key', 2: 'stealth', 3: 'strike', 4: 'execute',
        // Special items (5-10)
        5: 'floorKey', 6: 'portalStone', 7: 'minionBane', 8: 'mapFragment', 9: 'timeShard', 10: 'voidWalk',
        // HP items (11-15)
        11: 'healingPotion', 12: 'greaterHealing', 13: 'elixir', 14: 'revivalCharm', 15: 'heartCrystal',
        // Visibility items (16-20)
        16: 'torch', 17: 'lantern', 18: 'revealScroll', 19: 'sightPotion', 20: 'crystalBall',
        // Name aliases
        'key': 'key', 'stealth': 'stealth', 'strike': 'strike', 'execute': 'execute',
        'floorkey': 'floorKey', 'portalstone': 'portalStone', 'minionbane': 'minionBane',
        'mapfragment': 'mapFragment', 'timeshard': 'timeShard', 'voidwalk': 'voidWalk',
        'healingpotion': 'healingPotion', 'greaterhealing': 'greaterHealing', 'elixir': 'elixir',
        'revivalcharm': 'revivalCharm', 'heartcrystal': 'heartCrystal',
        'torch': 'torch', 'lantern': 'lantern', 'revealscroll': 'revealScroll',
        'sightpotion': 'sightPotion', 'crystalball': 'crystalBall',
        // Short aliases
        'hp': 'healingPotion', 'ghp': 'greaterHealing', 'potion': 'healingPotion',
        'light': 'torch', 'scroll': 'revealScroll', 'sight': 'sightPotion', 'ball': 'crystalBall',
    };

    console.log('[MazeMaster] Registering /mazeitem command...');
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazeitem',
        aliases: ['mitem', 'mazeinv'],
        callback: async (args) => {
            console.log('[MazeMaster] /mazeitem callback invoked with args:', args);
            if (!currentMaze.isOpen) {
                return 'Error: No maze is currently open.';
            }

            const action = args.action?.toLowerCase();
            const itemInput = args.item?.toString().toLowerCase();
            const amount = parseInt(args.amount) || 1;

            if (!action || !['add', 'remove', 'list'].includes(action)) {
                return 'Error: action must be "add", "remove", or "list". Example: /mazeitem action="add" item="key" amount=1';
            }

            if (action === 'list') {
                const items = [
                    '1=key, 2=stealth, 3=strike, 4=execute',
                    '5=floorKey, 6=portalStone, 7=minionBane, 8=mapFragment, 9=timeShard, 10=voidWalk',
                    '11=healingPotion, 12=greaterHealing, 13=elixir, 14=revivalCharm, 15=heartCrystal',
                    '16=torch, 17=lantern, 18=revealScroll, 19=sightPotion, 20=crystalBall',
                ];
                return `Available items:\n${items.join('\n')}`;
            }

            if (!itemInput) {
                return 'Error: item is required. Use item number (1-15) or name. Use /mazeitem action="list" to see all items.';
            }

            const itemName = ITEM_INDEX[itemInput];
            if (!itemName) {
                return `Error: Unknown item "${itemInput}". Use /mazeitem action="list" to see available items.`;
            }

            if (action === 'add') {
                await addToInventory(itemName, amount);
                return `Added ${amount}x ${itemName} to inventory.`;
            } else if (action === 'remove') {
                const current = currentMaze.inventory[itemName] || 0;
                const toRemove = Math.min(amount, current);
                if (toRemove > 0) {
                    await removeFromInventory(itemName, toRemove);
                    return `Removed ${toRemove}x ${itemName} from inventory.`;
                } else {
                    return `No ${itemName} in inventory to remove.`;
                }
            }
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'action',
                description: 'Action: add, remove, or list',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: true,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'item',
                description: 'Item number (1-15) or name',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'amount',
                description: 'Amount to add/remove (default: 1)',
                typeList: [ARGUMENT_TYPE.NUMBER],
                isRequired: false,
            }),
        ],
        helpString: 'Manage maze inventory. Examples: /mazeitem action="add" item="key" amount=3, /mazeitem action="remove" item="11", /mazeitem action="list"',
    }));
    console.log('[MazeMaster] /mazeitem command registered successfully');

    // v1.3.0: HP commands
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazehp',
        callback: async (args) => {
            if (!currentMaze.isOpen) {
                return JSON.stringify({ error: 'No maze is currently open.' });
            }

            if (!currentMaze.hpEnabled || !currentMaze.hp) {
                return JSON.stringify({ error: 'HP system is not enabled for this maze.' });
            }

            // If set argument provided, set HP
            if (args.set !== undefined) {
                const newHP = parseInt(args.set);
                if (isNaN(newHP) || newHP < 0) {
                    return 'Error: set must be a positive number.';
                }
                const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;
                currentMaze.hp.current = Math.min(newHP, maxTotal);
                updateHPDisplay();
                return `HP set to ${currentMaze.hp.current}/${maxTotal}`;
            }

            // Return current HP status
            const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;
            return JSON.stringify({
                current: currentMaze.hp.current,
                max: maxTotal,
                percent: Math.round((currentMaze.hp.current / maxTotal) * 100),
                reviveCharges: currentMaze.hp.reviveCharges,
            });
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'set',
                description: 'Set HP to this value',
                typeList: [ARGUMENT_TYPE.NUMBER],
                isRequired: false,
            }),
        ],
        helpString: 'Get or set player HP. Examples: /mazehp (get status), /mazehp set=50',
    }));

    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazeheal',
        callback: async (args) => {
            if (!currentMaze.isOpen) {
                return 'Error: No maze is currently open.';
            }

            if (!currentMaze.hpEnabled || !currentMaze.hp) {
                return 'Error: HP system is not enabled for this maze.';
            }

            const amount = parseInt(args.amount) || 25;
            const isPercent = args.percent === 'true' || args.percent === true;

            await healPlayer(amount, isPercent, 'command');
            return `Healed ${amount}${isPercent ? '%' : ''} HP.`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'amount',
                description: 'Amount to heal (default: 25)',
                typeList: [ARGUMENT_TYPE.NUMBER],
                isRequired: false,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'percent',
                description: 'If true, amount is percentage of max HP',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Heal the player. Examples: /mazeheal amount=50, /mazeheal amount=25 percent=true',
    }));

    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazedamage',
        callback: async (args) => {
            if (!currentMaze.isOpen) {
                return 'Error: No maze is currently open.';
            }

            if (!currentMaze.hpEnabled || !currentMaze.hp) {
                return 'Error: HP system is not enabled for this maze.';
            }

            const amount = parseInt(args.amount) || 10;
            const source = args.source || 'command';

            await applyDamage(amount, source);
            return `Dealt ${amount} damage (source: ${source}).`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'amount',
                description: 'Amount of damage (default: 10)',
                typeList: [ARGUMENT_TYPE.NUMBER],
                isRequired: false,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'source',
                description: 'Damage source for hooks (default: command)',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Deal damage to the player. Examples: /mazedamage amount=25, /mazedamage amount=10 source="trap"',
    }));

    // Turn-Based combat command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'turnbased',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentTurnbasedProfile || 'Tutorial - Learn Turn-Based';
            const result = startTurnBased(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Turn-based combat "${profileName}" started!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the turn-based combat profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a turn-based combat encounter. Example: /turnbased profile="Dungeon Skirmish"',
    }));

    // QTE combat command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'qte',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentQteProfile || 'Tutorial - First Steps';
            const result = startQTE(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `QTE "${profileName}" started! Press the keys as they appear!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the QTE profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a Quick-Time Event challenge. Example: /qte profile="Combat Flurry"',
    }));

    // Dice combat command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'dice',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentDiceProfile || 'Tutorial - Luck Practice';
            const result = startDice(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Dice challenge "${profileName}" started! Click to roll!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the dice profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a dice roll challenge. Example: /dice profile="Skill Check"',
    }));

    // Stealth encounter command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'stealth',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentStealthProfile || 'Tutorial - Stealth Basics';
            const result = startStealth(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Stealth encounter "${profileName}" started! Sneak past the guards!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the stealth profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a stealth encounter. Example: /stealth profile="Guard Patrol"',
    }));

    // Puzzle encounter command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'puzzle',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentPuzzleProfile || 'Tutorial - Mind Training';
            const result = startPuzzle(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Puzzle "${profileName}" started! Solve the sequence!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the puzzle profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a puzzle encounter. Example: /puzzle profile="Memory Trial"',
    }));

    // Negotiation encounter command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'negotiate',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentNegotiationProfile || 'Tutorial - Social Training';
            const result = startNegotiation(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Negotiation "${profileName}" started! Convince them to help!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the negotiation profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a negotiation encounter. Example: /negotiate profile="Merchant Haggle"',
    }));

    console.log('[MazeMaster] Slash commands registered');
    } catch (err) {
        console.error('[MazeMaster] ERROR registering slash commands:', err);
    }
}

// =============================================================================
// TURN-BASED COMBAT MODAL & GAME LOGIC
// =============================================================================

function getTurnBasedModalHtml() {
    return `
        <div id="mazemaster_turnbased_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-tb-container">
                <div id="tb_main_title" class="mazemaster-tb-main-title">Combat!</div>

                <div class="mazemaster-tb-combatants">
                    <div class="mazemaster-tb-combatant tb-player">
                        <div class="tb-combatant-name">You</div>
                        <div class="tb-hp-bar-container">
                            <div class="tb-hp-bar tb-hp-player" id="tb_player_hp_bar"></div>
                        </div>
                        <div class="tb-hp-text"><span id="tb_player_hp">100</span>/<span id="tb_player_max_hp">100</span> HP</div>
                        <div class="tb-status-effects" id="tb_player_status_effects"></div>
                    </div>
                    <div class="mazemaster-tb-vs">VS</div>
                    <div class="mazemaster-tb-combatant tb-enemy">
                        <div class="tb-combatant-name" id="tb_enemy_name">Enemy</div>
                        <div class="tb-hp-bar-container">
                            <div class="tb-hp-bar tb-hp-enemy" id="tb_enemy_hp_bar"></div>
                        </div>
                        <div class="tb-hp-text"><span id="tb_enemy_hp">100</span>/<span id="tb_enemy_max_hp">100</span> HP</div>
                        <div class="tb-status-effects" id="tb_enemy_status_effects"></div>
                    </div>
                </div>

                <div class="mazemaster-tb-turn-indicator">
                    <span id="tb_turn_text">Your Turn</span> - Turn <span id="tb_turn_count">1</span>
                    <div id="tb_combo_display" class="tb-combo-display" style="display: none;"></div>
                </div>

                <div class="mazemaster-tb-log" id="tb_combat_log">
                    <div class="tb-log-entry">Combat begins!</div>
                </div>

                <div class="mazemaster-tb-actions" id="tb_action_buttons">
                    <button id="tb_attack_btn" class="mazemaster-tb-btn tb-btn-attack">
                        <i class="fa-solid fa-sword"></i> Attack
                    </button>
                    <button id="tb_defend_btn" class="mazemaster-tb-btn tb-btn-defend">
                        <i class="fa-solid fa-shield"></i> Defend
                    </button>
                    <button id="tb_block_btn" class="mazemaster-tb-btn tb-btn-block">
                        <i class="fa-solid fa-shield-halved"></i> Block
                    </button>
                    <button id="tb_parry_btn" class="mazemaster-tb-btn tb-btn-parry">
                        <i class="fa-solid fa-rotate-left"></i> Parry
                    </button>
                    <button id="tb_item_btn" class="mazemaster-tb-btn tb-btn-item">
                        <i class="fa-solid fa-flask"></i> Item
                    </button>
                    <button id="tb_skill_btn" class="mazemaster-tb-btn tb-btn-skill">
                        <i class="fa-solid fa-fire"></i> Skills
                    </button>
                    <button id="tb_flee_btn" class="mazemaster-tb-btn tb-btn-flee">
                        <i class="fa-solid fa-person-running"></i> Flee
                    </button>
                </div>

                <div class="mazemaster-tb-result" id="tb_result_panel" style="display: none;">
                    <div id="tb_result_text" class="tb-result-text"></div>
                    <button id="tb_close_btn" class="mazemaster-tb-btn tb-btn-close">
                        <i class="fa-solid fa-check"></i> Close
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getTurnBasedStyles() {
    return `
        .mazemaster-tb-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 25px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            border: 2px solid #4a7c59;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(74, 124, 89, 0.3);
            width: 500px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .mazemaster-tb-main-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .mazemaster-tb-combatants {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            gap: 20px;
        }

        .mazemaster-tb-combatant {
            flex: 1;
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .tb-combatant-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
        }

        .tb-hp-bar-container {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .tb-hp-bar {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .tb-hp-player {
            background: linear-gradient(90deg, #2ecc71 0%, #27ae60 100%);
        }

        .tb-hp-enemy {
            background: linear-gradient(90deg, #e74c3c 0%, #c0392b 100%);
        }

        .tb-hp-text {
            font-size: 0.9em;
            color: #aaa;
        }

        .tb-status-effects {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: center;
            margin-top: 8px;
            min-height: 24px;
        }

        .tb-status-icon {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            position: relative;
            cursor: help;
            animation: status-pulse 2s ease-in-out infinite;
        }

        .tb-status-icon .status-duration {
            position: absolute;
            bottom: -4px;
            right: -4px;
            background: #333;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #555;
        }

        @keyframes status-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .tb-status-dot { animation: status-pulse 1s ease-in-out infinite; }
        .tb-status-cc { animation: status-shake 0.5s ease-in-out infinite; }

        @keyframes status-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        .tb-log-status { color: #9b59b6; }
        .tb-log-burn { color: #e74c3c; }
        .tb-log-poison { color: #2ecc71; }
        .tb-log-freeze { color: #3498db; }
        .tb-log-stun { color: #f1c40f; }
        .tb-log-ability { color: #e67e22; font-style: italic; }

        /* v1.6.0: Combo/Block/Parry log styles */
        .tb-log-combo { color: #f39c12; font-weight: bold; }
        .tb-log-block { color: #3498db; font-weight: bold; }
        .tb-log-block-break { color: #e74c3c; font-weight: bold; font-style: italic; }
        .tb-log-parry { color: #9b59b6; font-style: italic; }
        .tb-log-parry-success { color: #2ecc71; font-weight: bold; }
        .tb-log-info { color: #95a5a6; font-style: italic; }

        /* v1.6.0: Combo display */
        .tb-combo-display {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 8px;
            padding: 5px 15px;
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.3) 0%, rgba(231, 76, 60, 0.3) 100%);
            border-radius: 15px;
            border: 2px solid #f39c12;
            animation: combo-glow 0.5s ease-in-out infinite alternate;
        }

        .tb-combo-display.combo-active {
            display: flex;
        }

        .combo-counter {
            font-size: 1.4em;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.8);
        }

        .combo-bonus {
            font-size: 1.1em;
            color: #2ecc71;
            font-weight: bold;
        }

        @keyframes combo-glow {
            0% { box-shadow: 0 0 5px rgba(243, 156, 18, 0.5); }
            100% { box-shadow: 0 0 15px rgba(243, 156, 18, 0.8); }
        }

        /* v1.6.0: Block/Parry button styles */
        .tb-btn-block {
            background: linear-gradient(135deg, #2980b9 0%, #1abc9c 100%) !important;
        }

        .tb-btn-block:hover {
            background: linear-gradient(135deg, #3498db 0%, #1abc9c 100%) !important;
        }

        .tb-btn-parry {
            background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%) !important;
        }

        .tb-btn-parry:hover {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%) !important;
        }

        .mazemaster-tb-vs {
            font-size: 1.5em;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .mazemaster-tb-turn-indicator {
            font-size: 1.1em;
            color: #3498db;
            padding: 8px 20px;
            background: rgba(52, 152, 219, 0.2);
            border-radius: 20px;
            border: 1px solid rgba(52, 152, 219, 0.5);
        }

        .mazemaster-tb-log {
            width: 100%;
            height: 120px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.9em;
            color: #ccc;
        }

        .tb-log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .tb-log-entry:last-child {
            border-bottom: none;
        }

        .tb-log-damage { color: #e74c3c; }
        .tb-log-heal { color: #2ecc71; }
        .tb-log-defend { color: #3498db; }
        .tb-log-crit { color: #f39c12; font-weight: bold; }
        .tb-log-flee { color: #9b59b6; }

        .mazemaster-tb-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .mazemaster-tb-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mazemaster-tb-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .mazemaster-tb-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .tb-btn-attack {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .tb-btn-defend {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .tb-btn-item {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        .tb-btn-flee {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }

        .tb-btn-skill {
            background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
            color: white;
        }

        .tb-btn-skill:hover {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .tb-btn-close {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 15px 40px;
        }

        .mazemaster-tb-result {
            text-align: center;
        }

        .tb-result-text {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .tb-result-victory { color: #2ecc71; }
        .tb-result-defeat { color: #e74c3c; }
        .tb-result-fled { color: #9b59b6; }

        .tb-combatant.defending {
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.6);
        }

        .tb-hp-bar.flash-damage {
            animation: tb-flash-damage 0.3s ease;
        }

        .tb-hp-bar.flash-heal {
            animation: tb-flash-heal 0.3s ease;
        }

        @keyframes tb-flash-damage {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5) saturate(2); }
        }

        @keyframes tb-flash-heal {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5) hue-rotate(60deg); }
        }
    `;
}

function startTurnBased(profileName, enemyNameOverride = null) {
    console.log('[MazeMaster] startTurnBased called with profile:', profileName);
    const profile = getTurnbasedProfile(profileName);
    console.log('[MazeMaster] Retrieved profile:', profile);
    if (!profile) {
        console.error(`[MazeMaster] Turn-based profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    // Determine player HP - use maze HP if in a maze with HP enabled, otherwise use profile defaults
    let playerHP = profile.playerHP || 100;
    let playerMaxHP = profile.playerHP || 100;
    let isMazeEncounter = false;

    if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
        isMazeEncounter = true;
        playerHP = currentMaze.hp.current;
        playerMaxHP = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
        console.log('[MazeMaster] Using maze HP for combat:', playerHP, '/', playerMaxHP);
    } else {
        console.log('[MazeMaster] Using profile HP for combat:', playerHP, '/', playerMaxHP);
    }

    // v1.5.0: Select random enemy type based on context
    const enemyTypes = Object.keys(ENEMY_TYPES);
    const randomEnemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];

    // Initialize combat state
    console.log('[MazeMaster] Initializing turn-based combat state');
    currentTurnBased = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        playerHP: playerHP,
        playerMaxHP: playerMaxHP,
        enemyHP: profile.enemyHP || 100,
        enemyMaxHP: profile.enemyHP || 100,
        currentTurn: profile.turnOrder === 'enemy_first' ? 'enemy' : 'player',
        turnCount: 1,
        isDefending: false,
        isVictory: false,
        isDefeat: false,
        isMazeEncounter: isMazeEncounter,
        combatLog: ['Combat begins!'],
        // v1.3.1: Enemy name override from minion encounter
        enemyNameOverride: enemyNameOverride,
        // v1.5.0: Advanced combat state
        playerStatusEffects: [],
        enemyStatusEffects: [],
        enemyType: randomEnemyType,
        isFirstStrike: true,
        difficulty: profile.difficulty || 1,
    };

    // Pause maze if active
    if (currentMaze.isOpen) {
        currentMaze.isPaused = true;
    }

    showTurnBasedModal();
    updateTurnBasedDisplay();
    updateStatusEffectsDisplay(); // v1.5.0: Initialize status effect display

    // If enemy goes first, process their turn after a short delay
    if (currentTurnBased.currentTurn === 'enemy') {
        setTimeout(() => processEnemyTurn(), 1000);
    }

    console.log(`[MazeMaster] Turn-based combat started: ${profileName} (enemy type: ${randomEnemyType})`);
    return { success: true };
}

function showTurnBasedModal() {
    console.log('[MazeMaster] showTurnBasedModal called');
    // Remove existing modal if any
    const existing = document.getElementById('mazemaster_turnbased_modal');
    if (existing) {
        console.log('[MazeMaster] Removing existing turn-based modal');
        existing.remove();
    }

    // Add styles if not present
    if (!document.getElementById('mazemaster_tb_styles')) {
        console.log('[MazeMaster] Adding turn-based styles');
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_tb_styles';
        styleEl.textContent = getTurnBasedStyles();
        document.head.appendChild(styleEl);
    }

    // Add modal
    console.log('[MazeMaster] Inserting turn-based modal HTML');
    document.body.insertAdjacentHTML('beforeend', getTurnBasedModalHtml());

    // Verify modal was added
    const modalCheck = document.getElementById('mazemaster_turnbased_modal');
    console.log('[MazeMaster] Modal element exists:', !!modalCheck);

    // Update enemy name and title - use enemyNameOverride for both if available
    const titleEl = document.getElementById('tb_main_title');
    const enemyNameEl = document.getElementById('tb_enemy_name');
    console.log('[MazeMaster] Title element:', titleEl, 'Enemy name element:', enemyNameEl);
    const displayName = currentTurnBased.enemyNameOverride || currentTurnBased.profile.mainTitle || 'Combat!';
    if (titleEl) titleEl.textContent = displayName;
    if (enemyNameEl) enemyNameEl.textContent = currentTurnBased.enemyNameOverride || currentTurnBased.profile.enemyName || 'Enemy';

    // Attach event handlers
    console.log('[MazeMaster] Attaching turn-based event handlers');
    const attackBtn = document.getElementById('tb_attack_btn');
    const defendBtn = document.getElementById('tb_defend_btn');
    const blockBtn = document.getElementById('tb_block_btn');
    const parryBtn = document.getElementById('tb_parry_btn');
    const itemBtn = document.getElementById('tb_item_btn');
    const skillBtn = document.getElementById('tb_skill_btn');
    const fleeBtn = document.getElementById('tb_flee_btn');
    const closeBtn = document.getElementById('tb_close_btn');

    console.log('[MazeMaster] Button elements found:', {
        attack: !!attackBtn, defend: !!defendBtn, block: !!blockBtn,
        parry: !!parryBtn, item: !!itemBtn, skill: !!skillBtn, flee: !!fleeBtn, close: !!closeBtn
    });

    if (attackBtn) {
        attackBtn.onclick = (e) => {
            console.log('[MazeMaster] Attack button clicked!', e);
            handleTBAttack();
        };
    }
    if (defendBtn) {
        defendBtn.onclick = (e) => {
            console.log('[MazeMaster] Defend button clicked!', e);
            handleTBDefend();
        };
    }
    if (blockBtn) {
        blockBtn.onclick = (e) => {
            console.log('[MazeMaster] Block button clicked!', e);
            handleTBBlock();
        };
    }
    if (parryBtn) {
        parryBtn.onclick = (e) => {
            console.log('[MazeMaster] Parry button clicked!', e);
            handleTBParry();
        };
    }
    if (itemBtn) {
        itemBtn.onclick = (e) => {
            console.log('[MazeMaster] Item button clicked!', e);
            handleTBItem();
        };
    }
    if (skillBtn) {
        skillBtn.onclick = (e) => {
            console.log('[MazeMaster] Skills button clicked!', e);
            handleTBSkills();
        };
    }
    if (fleeBtn) {
        fleeBtn.onclick = (e) => {
            console.log('[MazeMaster] Flee button clicked!', e);
            handleTBFlee();
        };
    }
    if (closeBtn) {
        closeBtn.onclick = (e) => {
            console.log('[MazeMaster] Close button clicked!', e);
            closeTurnBasedModal();
        };
    }

    // v1.6.0: Show/hide block and parry buttons based on profile
    const cmProfile = getCombatMechanicsProfile();
    if (blockBtn) blockBtn.style.display = cmProfile.blockEnabled ? 'flex' : 'none';
    if (parryBtn) parryBtn.style.display = cmProfile.parryEnabled ? 'flex' : 'none';

    console.log('[MazeMaster] Turn-based modal setup complete');
}

function updateTurnBasedDisplay() {
    // Update HP bars
    const playerHPPercent = (currentTurnBased.playerHP / currentTurnBased.playerMaxHP) * 100;
    const enemyHPPercent = (currentTurnBased.enemyHP / currentTurnBased.enemyMaxHP) * 100;

    const playerHPBar = document.getElementById('tb_player_hp_bar');
    const enemyHPBar = document.getElementById('tb_enemy_hp_bar');
    if (playerHPBar) playerHPBar.style.width = `${playerHPPercent}%`;
    if (enemyHPBar) enemyHPBar.style.width = `${enemyHPPercent}%`;

    // Update HP text
    const playerHPEl = document.getElementById('tb_player_hp');
    const playerMaxHPEl = document.getElementById('tb_player_max_hp');
    const enemyHPEl = document.getElementById('tb_enemy_hp');
    const enemyMaxHPEl = document.getElementById('tb_enemy_max_hp');
    if (playerHPEl) playerHPEl.textContent = Math.max(0, currentTurnBased.playerHP);
    if (playerMaxHPEl) playerMaxHPEl.textContent = currentTurnBased.playerMaxHP;
    if (enemyHPEl) enemyHPEl.textContent = Math.max(0, currentTurnBased.enemyHP);
    if (enemyMaxHPEl) enemyMaxHPEl.textContent = currentTurnBased.enemyMaxHP;

    // Update turn indicator
    const turnTextEl = document.getElementById('tb_turn_text');
    const turnCountEl = document.getElementById('tb_turn_count');
    if (turnTextEl) turnTextEl.textContent = currentTurnBased.currentTurn === 'player' ? 'Your Turn' : 'Enemy Turn';
    if (turnCountEl) turnCountEl.textContent = currentTurnBased.turnCount;

    // Update combat log
    const logEl = document.getElementById('tb_combat_log');
    if (logEl) {
        logEl.innerHTML = currentTurnBased.combatLog.map(entry => {
            let className = 'tb-log-entry';
            if (entry.includes('damage') || entry.includes('hit')) className += ' tb-log-damage';
            if (entry.includes('heal') || entry.includes('restored')) className += ' tb-log-heal';
            if (entry.includes('defend') || entry.includes('block')) className += ' tb-log-defend';
            if (entry.includes('CRITICAL')) className += ' tb-log-crit';
            if (entry.includes('flee') || entry.includes('escape')) className += ' tb-log-flee';
            return `<div class="${className}">${entry}</div>`;
        }).join('');
        logEl.scrollTop = logEl.scrollHeight;
    }

    // Update defending visual
    const playerCombatant = document.querySelector('.tb-player');
    if (playerCombatant) {
        playerCombatant.classList.toggle('defending', currentTurnBased.isDefending);
    }

    // Enable/disable action buttons based on turn
    const actionBtns = document.querySelectorAll('.mazemaster-tb-btn');
    actionBtns.forEach(btn => {
        if (btn.id !== 'tb_close_btn') {
            btn.disabled = currentTurnBased.currentTurn !== 'player' || currentTurnBased.isVictory || currentTurnBased.isDefeat;
        }
    });
}

function addTBLogEntry(message) {
    currentTurnBased.combatLog.push(message);
    // Keep log at reasonable size
    if (currentTurnBased.combatLog.length > 50) {
        currentTurnBased.combatLog.shift();
    }
    updateTurnBasedDisplay();
}

function flashHPBar(isPlayer, isDamage) {
    const barId = isPlayer ? 'tb_player_hp_bar' : 'tb_enemy_hp_bar';
    const bar = document.getElementById(barId);
    if (bar) {
        bar.classList.remove('flash-damage', 'flash-heal');
        void bar.offsetWidth; // Trigger reflow
        bar.classList.add(isDamage ? 'flash-damage' : 'flash-heal');
    }
}

// =============================================================================
// v1.6.0: COMBO/BLOCK/PARRY COMBAT MECHANICS
// =============================================================================

/**
 * Get the current combat mechanics profile settings
 * @returns {object} The current profile or default
 */
function getCombatMechanicsProfile() {
    // v2.0.0: Prioritize maze profile setting over global setting
    const profileName = currentMaze?.profile?.combatMechanicsProfile || extensionSettings.currentCombatMechanicsProfile || 'default';
    const profiles = extensionSettings.combatMechanicsProfiles || {};
    return profiles[profileName] || DEFAULT_COMBAT_MECHANICS_PROFILES[profileName] || DEFAULT_COMBAT_MECHANICS_PROFILES.default;
}

/**
 * Initialize combat mechanics state for a new combat
 */
function initCombatMechanics() {
    if (!currentMaze?.combatMechanics) return;
    currentMaze.combatMechanics = {
        comboCounter: 0,
        maxCombo: 0,
        comboDecayTimer: 0,
        isBlocking: false,
        parryWindow: false,
        parrySuccess: false,
        lastAction: null,
    };
}

/**
 * Increment combo counter on successful hit
 * @returns {object} { comboCount, bonusDamage, totalBonus }
 */
async function incrementCombo() {
    if (!currentMaze?.combatMechanics) return { comboCount: 0, bonusDamage: 0, totalBonus: 0 };
    const profile = getCombatMechanicsProfile();

    if (!profile.comboEnabled) return { comboCount: 0, bonusDamage: 0, totalBonus: 0 };

    const cm = currentMaze.combatMechanics;
    const wasZero = cm.comboCounter === 0;

    cm.comboCounter++;
    cm.comboDecayTimer = profile.comboDecayTurns;
    if (cm.comboCounter > cm.maxCombo) {
        cm.maxCombo = cm.comboCounter;
    }

    const bonusDamage = Math.min(cm.comboCounter * profile.comboBonusPerHit, profile.maxComboBonus);

    // Execute STScript hooks
    if (wasZero && profile.onComboStart) {
        await executeWithTimeout(profile.onComboStart, {
            comboCount: cm.comboCounter,
        });
    }
    if (profile.onComboIncrease) {
        await executeWithTimeout(profile.onComboIncrease, {
            comboCount: cm.comboCounter,
            bonusDamage: profile.comboBonusPerHit,
            totalBonus: bonusDamage,
        });
    }

    return { comboCount: cm.comboCounter, bonusDamage: profile.comboBonusPerHit, totalBonus: bonusDamage };
}

/**
 * Reset combo counter
 * @param {string} reason - Why combo was reset ('miss', 'damage', 'turn_end', 'combat_end')
 */
async function resetCombo(reason = 'combat_end') {
    if (!currentMaze?.combatMechanics) return;
    const profile = getCombatMechanicsProfile();

    if (!profile.comboEnabled) return;

    const cm = currentMaze.combatMechanics;
    const finalCombo = cm.comboCounter;
    const maxCombo = cm.maxCombo;

    if (finalCombo > 0 && profile.onComboBreak) {
        await executeWithTimeout(profile.onComboBreak, {
            finalCombo,
            maxCombo,
            reason,
        });
    }

    cm.comboCounter = 0;
    cm.comboDecayTimer = 0;
}

/**
 * Get current combo damage bonus percentage
 * @returns {number} Bonus damage percentage (0-maxComboBonus)
 */
function getComboBonus() {
    if (!currentMaze?.combatMechanics) return 0;
    const profile = getCombatMechanicsProfile();

    if (!profile.comboEnabled) return 0;

    const cm = currentMaze.combatMechanics;
    return Math.min(cm.comboCounter * profile.comboBonusPerHit, profile.maxComboBonus);
}

/**
 * Decay combo counter at end of player turn
 */
async function decayCombo() {
    if (!currentMaze?.combatMechanics) return;
    const profile = getCombatMechanicsProfile();

    if (!profile.comboEnabled) return;

    const cm = currentMaze.combatMechanics;
    if (cm.comboDecayTimer > 0) {
        cm.comboDecayTimer--;
        if (cm.comboDecayTimer === 0 && cm.comboCounter > 0) {
            await resetCombo('turn_end');
        }
    }
}

/**
 * Execute block action - sets blocking state for this turn
 * @param {number} incomingDamage - Optional predicted incoming damage
 * @returns {object} { isBlocking, damageReduction }
 */
async function executeBlock(incomingDamage = 0) {
    if (!currentMaze?.combatMechanics) return { isBlocking: false, damageReduction: 0 };
    const profile = getCombatMechanicsProfile();

    if (!profile.blockEnabled) return { isBlocking: false, damageReduction: 0 };

    const cm = currentMaze.combatMechanics;
    cm.isBlocking = true;
    cm.lastAction = 'block';

    if (profile.onBlockAttempt) {
        await executeWithTimeout(profile.onBlockAttempt, {
            damageIncoming: incomingDamage,
        });
    }

    return { isBlocking: true, damageReduction: profile.blockDamageReduction };
}

/**
 * Process damage when player is blocking
 * @param {number} originalDamage - Incoming damage before block
 * @returns {object} { damageTaken, damageBlocked, blockBroken }
 */
async function processBlockedDamage(originalDamage) {
    if (!currentMaze?.combatMechanics) return { damageTaken: originalDamage, damageBlocked: 0, blockBroken: false };
    const profile = getCombatMechanicsProfile();
    const cm = currentMaze.combatMechanics;

    if (!cm.isBlocking || !profile.blockEnabled) {
        return { damageTaken: originalDamage, damageBlocked: 0, blockBroken: false };
    }

    // Check for block break
    if (profile.blockBreakThreshold > 0 && originalDamage >= profile.blockBreakThreshold) {
        cm.isBlocking = false;
        if (profile.onBlockBreak) {
            await executeWithTimeout(profile.onBlockBreak, {
                damage: originalDamage,
                threshold: profile.blockBreakThreshold,
            });
        }
        return { damageTaken: originalDamage, damageBlocked: 0, blockBroken: true };
    }

    // Apply block reduction
    const damageBlocked = Math.floor(originalDamage * profile.blockDamageReduction);
    const damageTaken = originalDamage - damageBlocked;

    if (profile.onBlockSuccess) {
        await executeWithTimeout(profile.onBlockSuccess, {
            damageBlocked,
            damageTaken,
            originalDamage,
        });
    }

    // Reset blocking after use
    cm.isBlocking = false;

    return { damageTaken, damageBlocked, blockBroken: false };
}

/**
 * Start parry timing window
 * @param {string} enemyName - Name of attacking enemy
 * @param {number} attackDamage - Predicted attack damage
 */
async function startParryWindow(enemyName, attackDamage) {
    if (!currentMaze?.combatMechanics) return;
    const profile = getCombatMechanicsProfile();

    if (!profile.parryEnabled) return;

    const cm = currentMaze.combatMechanics;
    cm.parryWindow = true;
    cm.parrySuccess = false;
    cm.lastAction = 'parry_attempt';

    if (profile.onParryAttempt) {
        await executeWithTimeout(profile.onParryAttempt, {
            enemyName,
            attackDamage,
        });
    }

    // Parry window duration based on difficulty
    const windowMultipliers = { easy: 1.5, normal: 1.0, hard: 0.6 };
    const windowTime = profile.parryWindow * 1000 * (windowMultipliers[profile.parryDifficulty] || 1);

    setTimeout(() => {
        if (currentMaze?.combatMechanics) {
            currentMaze.combatMechanics.parryWindow = false;
        }
    }, windowTime);
}

/**
 * Attempt to parry during the parry window
 * @returns {boolean} Whether parry was successful
 */
async function attemptParry() {
    if (!currentMaze?.combatMechanics) return false;
    const profile = getCombatMechanicsProfile();
    const cm = currentMaze.combatMechanics;

    if (!profile.parryEnabled || !cm.parryWindow) return false;

    cm.parrySuccess = true;
    cm.parryWindow = false;
    cm.lastAction = 'parry';

    return true;
}

/**
 * Process parry result after enemy attack
 * @param {number} baseDamage - Base damage that would be dealt
 * @param {string} enemyName - Name of enemy
 * @returns {object} { parried, counterDamage, stunDuration, damageTaken }
 */
async function processParryResult(baseDamage, enemyName) {
    if (!currentMaze?.combatMechanics) return { parried: false, counterDamage: 0, stunDuration: 0, damageTaken: baseDamage };
    const profile = getCombatMechanicsProfile();
    const cm = currentMaze.combatMechanics;

    if (!profile.parryEnabled) {
        return { parried: false, counterDamage: 0, stunDuration: 0, damageTaken: baseDamage };
    }

    if (cm.parrySuccess) {
        const counterDamage = Math.floor(baseDamage * profile.parryDamageMultiplier);

        if (profile.onParrySuccess) {
            await executeWithTimeout(profile.onParrySuccess, {
                enemyName,
                counterDamage,
                stunDuration: profile.parryStunDuration,
            });
        }

        cm.parrySuccess = false;
        return {
            parried: true,
            counterDamage,
            stunDuration: profile.parryStunDuration,
            damageTaken: 0,
        };
    }

    // Parry failed or wasn't attempted
    if (cm.lastAction === 'parry_attempt' && profile.onParryFail) {
        await executeWithTimeout(profile.onParryFail, {
            enemyName,
            damageTaken: baseDamage,
        });
    }

    return { parried: false, counterDamage: 0, stunDuration: 0, damageTaken: baseDamage };
}

/**
 * Execute counter-attack after successful parry
 * @param {number} baseDamage - Base counter damage
 * @param {string} enemyName - Enemy being countered
 * @returns {object} { damage, isCrit }
 */
async function processCounterAttack(baseDamage, enemyName) {
    if (!currentMaze?.combatMechanics) return { damage: baseDamage, isCrit: false };
    const profile = getCombatMechanicsProfile();

    if (!profile.counterEnabled) return { damage: baseDamage, isCrit: false };

    // Apply counter damage bonus
    let damage = Math.floor(baseDamage * (1 + profile.counterDamageBonus / 100));
    let isCrit = false;

    // Check for counter critical hit
    const critChance = profile.counterCritBonus;
    if (Math.random() * 100 < critChance) {
        damage = Math.floor(damage * 1.5);
        isCrit = true;
    }

    if (profile.onCounterAttack) {
        await executeWithTimeout(profile.onCounterAttack, {
            damage,
            enemyName,
            isCrit,
        });
    }

    return { damage, isCrit };
}

/**
 * Reset combat mechanics state at end of combat
 */
function resetCombatMechanics() {
    if (!currentMaze?.combatMechanics) return;
    currentMaze.combatMechanics = {
        comboCounter: 0,
        maxCombo: 0,
        comboDecayTimer: 0,
        isBlocking: false,
        parryWindow: false,
        parrySuccess: false,
        lastAction: null,
    };
}

/**
 * Update combo display in combat UI
 */
function updateComboDisplay() {
    const comboEl = document.getElementById('tb_combo_display');
    if (!comboEl || !currentMaze?.combatMechanics) return;

    const profile = getCombatMechanicsProfile();
    if (!profile.comboEnabled) {
        comboEl.style.display = 'none';
        return;
    }

    const cm = currentMaze.combatMechanics;
    if (cm.comboCounter > 0) {
        const bonus = getComboBonus();
        comboEl.innerHTML = `<span class="combo-counter">${cm.comboCounter}x</span> <span class="combo-bonus">+${bonus}%</span>`;
        comboEl.style.display = 'flex';
        comboEl.classList.add('combo-active');
    } else {
        comboEl.style.display = 'none';
        comboEl.classList.remove('combo-active');
    }
}

/**
 * Calculate damage with equipment bonuses
 * @param {number} attack - Base attack value
 * @param {number} defense - Base defense value
 * @param {number} critChance - Base critical hit chance (%)
 * @param {number} critMultiplier - Critical hit damage multiplier
 * @param {boolean} isPlayerAttack - Whether this is player attacking (applies equipment bonuses)
 * @param {boolean} isPlayerDefending - Whether player is defending (applies equipment defense)
 * @returns {object} { damage, isCrit, equipBonuses }
 */
function calculateDamage(attack, defense, critChance, critMultiplier, isPlayerAttack = true, isPlayerDefending = false, isFirstStrike = false) {
    // v1.5.0: Apply equipment and level bonuses if in a maze
    const equipStats = currentMaze?.isOpen ? getEquippedStats() : { attack: 0, defense: 0, critBonus: 0, specials: [] };
    const levelStats = currentMaze?.isOpen && currentMaze.character
        ? getLevelStats(currentMaze.character.level)
        : { attackBonus: 0, defenseBonus: 0 };
    // v1.5.0: Skill bonuses
    const passiveSkills = currentMaze?.isOpen ? getPassiveSkillBonuses() : { critBonus: 0, lifestealPercent: 0, firstStrikeBonus: 0 };
    const activeSkills = currentMaze?.isOpen ? getActiveSkillEffects() : { damageBonus: 0, damageReduction: 0, guaranteedCrit: false };

    // Apply equipment, level, and skill attack bonus for player attacks
    if (isPlayerAttack) {
        attack += equipStats.attack + levelStats.attackBonus;
        critChance += equipStats.critBonus + passiveSkills.critBonus;
    }

    // Apply equipment and level defense bonus when player is defending
    if (isPlayerDefending) {
        defense += equipStats.defense + levelStats.defenseBonus;
    }

    let baseDamage = Math.max(1, attack - defense);
    // Add some variance (+/- 20%)
    baseDamage = Math.round(baseDamage * (0.8 + Math.random() * 0.4));

    // Apply first strike bonus (Backstab skill)
    if (isPlayerAttack && isFirstStrike && passiveSkills.firstStrikeBonus > 0) {
        baseDamage = Math.round(baseDamage * (1 + passiveSkills.firstStrikeBonus / 100));
    }

    // Apply active skill damage bonuses (e.g., Berserker)
    if (isPlayerAttack && activeSkills.damageBonus > 0) {
        baseDamage = Math.round(baseDamage * (1 + activeSkills.damageBonus / 100));
    }

    // v1.6.0: Apply combo damage bonus for player attacks
    const comboBonus = isPlayerAttack ? getComboBonus() : 0;
    if (comboBonus > 0) {
        baseDamage = Math.round(baseDamage * (1 + comboBonus / 100));
    }

    // Apply active skill damage reduction (e.g., Ice Shield)
    if (isPlayerDefending && activeSkills.damageReduction > 0) {
        baseDamage = Math.round(baseDamage * (1 - activeSkills.damageReduction / 100));
    }

    let isCrit = false;
    if (activeSkills.guaranteedCrit || Math.random() * 100 < critChance) {
        baseDamage = Math.round(baseDamage * critMultiplier);
        isCrit = true;
    }

    // v2.0.4: Calculate total lifesteal from skills AND equipment specials
    let totalLifesteal = passiveSkills.lifestealPercent;
    if (isPlayerAttack && equipStats.specials) {
        for (const special of equipStats.specials) {
            if (special.type === 'lifesteal') {
                totalLifesteal += special.value;
            }
        }
    }

    return {
        damage: baseDamage,
        isCrit,
        equipBonuses: equipStats,
        levelBonuses: levelStats,
        skillBonuses: { passive: passiveSkills, active: activeSkills },
        lifestealPercent: totalLifesteal,
        comboBonus,
    };
}

async function handleTBAttack() {
    if (currentTurnBased.currentTurn !== 'player') return;

    // v1.5.0: Check if player is CC'd
    if (shouldSkipTurn('player')) {
        addTBLogEntry(`<span class="tb-log-stun">You are unable to act!</span>`);

        // Process and tick player status effects
        const dotResult = processStatusEffects('player');
        if (dotResult.damage > 0) {
            currentTurnBased.playerHP = Math.max(0, currentTurnBased.playerHP - dotResult.damage);
            flashHPBar(true, true);
        }
        updateStatusEffectsDisplay();

        if (currentTurnBased.playerHP <= 0) {
            await handleTurnBasedLoss();
            return;
        }

        currentTurnBased.currentTurn = 'enemy';
        updateTurnBasedDisplay();
        setTimeout(() => processEnemyTurn(), 1000);
        return;
    }

    const profile = currentTurnBased.profile;
    currentTurnBased.isDefending = false;

    // v1.5.0: Apply damage modifiers from status effects
    const statusMods = getStatusDamageModifiers('player');

    // Calculate damage with first strike tracking
    const isFirstStrike = currentTurnBased.isFirstStrike === true;
    const { damage: baseDamage, isCrit, lifestealPercent } = calculateDamage(
        profile.playerAttack || 15,
        profile.enemyDefense || 5,
        profile.critChance || 10,
        profile.critMultiplier || 2.0,
        true,   // isPlayerAttack
        false,  // isPlayerDefending
        isFirstStrike
    );

    // Apply status damage modifier (damageBonus increases damage dealt)
    const damage = Math.round(baseDamage * (1 + (statusMods.damageBonus || 0) / 100));

    currentTurnBased.isFirstStrike = false; // No longer first strike after first attack

    currentTurnBased.enemyHP = Math.max(0, currentTurnBased.enemyHP - damage);
    flashHPBar(false, true);

    // v1.6.0: Play attack sound, VFX, and animation
    const combatContainer = document.querySelector('.turn-based-container');
    startAnimation('player', 'player_attack');
    if (isCrit) {
        playSound('critical_hit');
        triggerVFX('critical_hit', combatContainer);
    } else {
        playSound('attack_hit');
        triggerVFX('attack_hit', combatContainer);
    }

    // v1.6.0: Increment combo on successful hit
    const comboResult = await incrementCombo();
    updateComboDisplay();

    if (isCrit) {
        if (comboResult.comboCount > 1) {
            addTBLogEntry(`<span class="tb-log-crit">CRITICAL HIT! ${comboResult.comboCount}x COMBO! You deal ${damage} damage!</span>`);
        } else {
            addTBLogEntry(`<span class="tb-log-crit">CRITICAL HIT! You deal ${damage} damage!</span>`);
        }
    } else {
        if (comboResult.comboCount > 1) {
            addTBLogEntry(`<span class="tb-log-combo">${comboResult.comboCount}x COMBO!</span> You attack for ${damage} damage!`);
        } else {
            addTBLogEntry(`You attack for ${damage} damage!`);
        }
    }

    // v1.5.0: Apply lifesteal
    if (lifestealPercent > 0 && damage > 0) {
        const healAmount = Math.round(damage * lifestealPercent / 100);
        if (healAmount > 0) {
            currentTurnBased.playerHP = Math.min(currentTurnBased.playerMaxHP, currentTurnBased.playerHP + healAmount);
            flashHPBar(true, false);
            playSound('heal');
            triggerVFX('heal', combatContainer);
            addTBLogEntry(`<span class="tb-log-heal">Lifesteal heals you for ${healAmount} HP!</span>`);
        }
    }

    // v2.0.0: Reduce weapon durability on attack
    if (currentMaze?.equipment?.weapon) {
        reduceEquipmentDurability('weapon', 1);
    }

    // Execute STScript hook
    if (profile.onAttack) {
        await executeWithTimeout(profile.onAttack);
    }

    // Check for victory
    if (currentTurnBased.enemyHP <= 0) {
        await handleTurnBasedWin();
        return;
    }

    // Switch to enemy turn
    currentTurnBased.currentTurn = 'enemy';
    updateTurnBasedDisplay();
    setTimeout(() => processEnemyTurn(), 1000);
}

async function handleTBDefend() {
    if (currentTurnBased.currentTurn !== 'player') return;

    currentTurnBased.isDefending = true;
    addTBLogEntry('You take a defensive stance.');

    // Execute STScript hook
    if (currentTurnBased.profile.onDefend) {
        await executeWithTimeout(currentTurnBased.profile.onDefend);
    }

    // Switch to enemy turn
    currentTurnBased.currentTurn = 'enemy';
    updateTurnBasedDisplay();
    setTimeout(() => processEnemyTurn(), 1000);
}

/**
 * v1.6.0: Handle block action in turn-based combat
 * Block reduces incoming damage on enemy's next attack
 */
async function handleTBBlock() {
    if (currentTurnBased.currentTurn !== 'player') return;

    const profile = getCombatMechanicsProfile();
    if (!profile.blockEnabled) {
        addTBLogEntry(`<span class="tb-log-info">Blocking is not available.</span>`);
        return;
    }

    // v1.5.0: Check if player is CC'd
    if (shouldSkipTurn('player')) {
        addTBLogEntry(`<span class="tb-log-stun">You are unable to act!</span>`);
        currentTurnBased.currentTurn = 'enemy';
        updateTurnBasedDisplay();
        setTimeout(() => processEnemyTurn(), 1000);
        return;
    }

    // Execute block
    const blockResult = await executeBlock();
    if (blockResult.isBlocking) {
        const reductionPercent = Math.round(profile.blockDamageReduction * 100);
        addTBLogEntry(`<span class="tb-log-block">You raise your guard! (${reductionPercent}% damage reduction)</span>`);
        currentTurnBased.isDefending = true;  // Also triggers existing defend logic
    }

    // v1.6.0: Decay combo when blocking instead of attacking
    await decayCombo();
    updateComboDisplay();

    // Switch to enemy turn
    currentTurnBased.currentTurn = 'enemy';
    updateTurnBasedDisplay();
    setTimeout(() => processEnemyTurn(), 1000);
}

/**
 * v1.6.0: Handle parry attempt in turn-based combat
 * Parry has a timing window - if successful, counter-attacks the enemy
 */
async function handleTBParry() {
    if (currentTurnBased.currentTurn !== 'player') return;

    const profile = getCombatMechanicsProfile();
    if (!profile.parryEnabled) {
        addTBLogEntry(`<span class="tb-log-info">Parrying is not available.</span>`);
        return;
    }

    // v1.5.0: Check if player is CC'd
    if (shouldSkipTurn('player')) {
        addTBLogEntry(`<span class="tb-log-stun">You are unable to act!</span>`);
        currentTurnBased.currentTurn = 'enemy';
        updateTurnBasedDisplay();
        setTimeout(() => processEnemyTurn(), 1000);
        return;
    }

    // Start parry window
    await startParryWindow(
        currentTurnBased.enemyName || 'Enemy',
        currentTurnBased.profile.enemyAttack || 10
    );

    addTBLogEntry(`<span class="tb-log-parry">You prepare to parry! Time your defense...</span>`);
    currentTurnBased.isDefending = false;

    // v1.6.0: Decay combo when parrying instead of attacking
    await decayCombo();
    updateComboDisplay();

    // Switch to enemy turn - parry success is checked in processEnemyTurn
    currentTurnBased.currentTurn = 'enemy';
    updateTurnBasedDisplay();
    setTimeout(() => processEnemyTurn(), 800);  // Slightly faster to match parry timing
}

/**
 * v1.6.0: Handle parry button click during parry window
 * Called when player clicks parry during the active parry window
 */
async function handleParryTiming() {
    const success = await attemptParry();
    if (success) {
        addTBLogEntry(`<span class="tb-log-parry-success">Perfect timing!</span>`);
    }
}

async function handleTBItem() {
    if (currentTurnBased.currentTurn !== 'player') return;

    // Check if we have healing potions in maze inventory
    if (currentMaze.isOpen && currentMaze.inventory && currentMaze.inventory.healingPotion > 0) {
        const healAmount = Math.round(currentTurnBased.playerMaxHP * 0.25);
        currentTurnBased.playerHP = Math.min(currentTurnBased.playerMaxHP, currentTurnBased.playerHP + healAmount);
        currentMaze.inventory.healingPotion--;
        flashHPBar(true, false);
        addTBLogEntry(`You use a Healing Potion and restore ${healAmount} HP!`);

        // Execute STScript hook
        if (currentTurnBased.profile.onItem) {
            await executeWithTimeout(currentTurnBased.profile.onItem);
        }

        currentTurnBased.isDefending = false;
        currentTurnBased.currentTurn = 'enemy';
        updateTurnBasedDisplay();
        setTimeout(() => processEnemyTurn(), 1000);
    } else {
        addTBLogEntry('No items available!');
    }
}

/**
 * Handle skills button click - show available combat skills
 */
async function handleTBSkills() {
    if (currentTurnBased.currentTurn !== 'player') return;

    console.log('[MazeMaster] handleTBSkills called');

    // Get learned skills
    const learnedSkills = currentMaze.skills?.learned || {};
    const cooldowns = currentMaze.skills?.cooldowns || {};

    console.log('[MazeMaster] Learned skills:', learnedSkills);
    console.log('[MazeMaster] Cooldowns:', cooldowns);

    // Filter to skills with combat use and not on cooldown
    const availableSkills = [];
    for (const [skillId, rank] of Object.entries(learnedSkills)) {
        if (rank < 1) continue;
        const skill = getSkill(skillId);
        if (!skill) continue;

        // Check if skill is usable in combat (has combat-relevant effects)
        const effect = getSkillEffect(skillId, rank);
        const isCombatSkill = skill.tree === 'combat' ||
                              skill.tree === 'magic' ||
                              effect?.damage > 0 ||
                              effect?.heal > 0 ||
                              effect?.damageBonus > 0 ||
                              effect?.stun ||
                              effect?.burn ||
                              effect?.burnChance;

        if (!isCombatSkill) continue;

        // Check cooldown
        const onCooldown = (cooldowns[skillId] || 0) > 0;

        availableSkills.push({
            id: skillId,
            skill,
            rank,
            effect,
            cooldown: cooldowns[skillId] || 0,
            onCooldown,
        });
    }

    console.log('[MazeMaster] Available combat skills:', availableSkills);

    if (availableSkills.length === 0) {
        addTBLogEntry('No combat skills available!');
        return;
    }

    // Show skill selection popup
    showSkillSelectionPopup(availableSkills);
}

/**
 * Show a popup for selecting skills during combat
 */
function showSkillSelectionPopup(skills) {
    // Remove existing popup if any
    const existing = document.getElementById('tb_skill_popup');
    if (existing) existing.remove();

    // Build skill buttons
    let skillsHtml = '';
    for (const s of skills) {
        const tree = SKILL_TREES[s.skill.tree] || { color: '#666' };
        const cooldownText = s.onCooldown ? ` (${s.cooldown} turns)` : '';
        const disabledClass = s.onCooldown ? 'disabled' : '';
        const effectDesc = s.effect.damage ? `${s.effect.damage} dmg` :
                          s.effect.heal ? `${s.effect.heal} heal` :
                          s.effect.damageBonus ? `+${s.effect.damageBonus}% dmg` : 'Use';

        skillsHtml += `
            <button class="tb-skill-option ${disabledClass}" data-skill="${s.id}" ${s.onCooldown ? 'disabled' : ''}
                    style="border-color: ${tree.color};">
                <span class="skill-name">${s.skill.name}</span>
                <span class="skill-effect">${effectDesc}${cooldownText}</span>
            </button>
        `;
    }

    const popupHtml = `
        <div id="tb_skill_popup" class="tb-skill-popup">
            <div class="tb-skill-popup-title">Select Skill</div>
            <div class="tb-skill-popup-skills">
                ${skillsHtml}
            </div>
            <button id="tb_skill_cancel" class="tb-skill-cancel">Cancel</button>
        </div>
    `;

    // Add popup styles if not present
    if (!document.getElementById('tb_skill_popup_styles')) {
        const style = document.createElement('style');
        style.id = 'tb_skill_popup_styles';
        style.textContent = `
            .tb-skill-popup {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                border: 2px solid #e67e22;
                border-radius: 12px;
                padding: 20px;
                z-index: 1000000;
                min-width: 250px;
                max-width: 400px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            }
            .tb-skill-popup-title {
                font-size: 1.3em;
                font-weight: bold;
                color: #e67e22;
                text-align: center;
                margin-bottom: 15px;
            }
            .tb-skill-popup-skills {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }
            .tb-skill-option {
                padding: 12px 15px;
                background: rgba(0, 0, 0, 0.4);
                border: 2px solid #444;
                border-radius: 8px;
                color: #fff;
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition: all 0.2s ease;
            }
            .tb-skill-option:hover:not(.disabled) {
                background: rgba(230, 126, 34, 0.3);
                transform: translateX(5px);
            }
            .tb-skill-option.disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }
            .skill-name {
                font-weight: bold;
            }
            .skill-effect {
                font-size: 0.85em;
                color: #aaa;
            }
            .tb-skill-cancel {
                width: 100%;
                margin-top: 15px;
                padding: 10px;
                background: rgba(149, 165, 166, 0.3);
                border: 1px solid #95a5a6;
                border-radius: 6px;
                color: #fff;
                cursor: pointer;
                transition: background 0.2s;
            }
            .tb-skill-cancel:hover {
                background: rgba(149, 165, 166, 0.5);
            }
        `;
        document.head.appendChild(style);
    }

    // Insert popup
    const modal = document.getElementById('mazemaster_turnbased_modal');
    if (modal) {
        modal.insertAdjacentHTML('beforeend', popupHtml);

        // Attach event handlers
        const popup = document.getElementById('tb_skill_popup');

        // Cancel button
        document.getElementById('tb_skill_cancel')?.addEventListener('click', () => {
            popup?.remove();
        });

        // Skill buttons
        popup?.querySelectorAll('.tb-skill-option:not(.disabled)').forEach(btn => {
            btn.addEventListener('click', async () => {
                const skillId = btn.dataset.skill;
                popup.remove();
                await useCombatSkill(skillId);
            });
        });
    }
}

/**
 * Use a skill during turn-based combat
 */
async function useCombatSkill(skillId) {
    console.log('[MazeMaster] Using combat skill:', skillId);

    // Execute the skill
    const result = await executePlayerCombatSkill(skillId);

    if (!result.success) {
        addTBLogEntry(`Skill failed: ${result.message}`);
        return;
    }

    // Check for victory
    if (currentTurnBased.enemyHP <= 0) {
        await handleTurnBasedWin();
        return;
    }

    // Switch to enemy turn
    currentTurnBased.isDefending = false;
    currentTurnBased.currentTurn = 'enemy';
    updateTurnBasedDisplay();
    setTimeout(() => processEnemyTurn(), 1000);
}

async function handleTBFlee() {
    if (currentTurnBased.currentTurn !== 'player') return;

    const fleeChance = currentTurnBased.profile.fleeChance || 30;
    const roll = Math.random() * 100;

    if (roll < fleeChance) {
        addTBLogEntry('You successfully flee from combat!');

        // Execute STScript hook
        if (currentTurnBased.profile.onFlee) {
            await executeWithTimeout(currentTurnBased.profile.onFlee);
        }

        currentTurnBased.isVictory = false;
        currentTurnBased.isDefeat = false;
        showTurnBasedResult('fled');
    } else {
        addTBLogEntry(`Failed to escape! (${Math.round(roll)} vs ${fleeChance})`);
        currentTurnBased.isDefending = false;
        currentTurnBased.currentTurn = 'enemy';
        updateTurnBasedDisplay();
        setTimeout(() => processEnemyTurn(), 1000);
    }
}

async function processEnemyTurn() {
    if (currentTurnBased.currentTurn !== 'enemy') return;
    if (currentTurnBased.isVictory || currentTurnBased.isDefeat) return;

    const profile = currentTurnBased.profile;
    const enemyName = currentTurnBased.enemyNameOverride || profile.enemyName || 'Enemy';

    // Execute turn start hook
    if (profile.onTurnStart) {
        await executeWithTimeout(profile.onTurnStart);
    }

    // v1.5.0: Process enemy status effects (DoT damage, tick durations)
    const enemyDotResult = processStatusEffects('enemy');
    if (enemyDotResult.damage > 0) {
        currentTurnBased.enemyHP = Math.max(0, currentTurnBased.enemyHP - enemyDotResult.damage);
        flashHPBar(false, true);
    }
    updateStatusEffectsDisplay();

    // Check if enemy died from DoT
    if (currentTurnBased.enemyHP <= 0) {
        await handleTurnBasedWin();
        return;
    }

    // v1.5.0: Check if enemy is CC'd
    if (shouldSkipTurn('enemy')) {
        addTBLogEntry(`<span class="tb-log-stun">${enemyName} is unable to act!</span>`);

        currentTurnBased.currentTurn = 'player';
        currentTurnBased.turnCount++;
        currentTurnBased.isDefending = false;

        // v1.5.0: Update survive quest progress
        updateQuestProgress('survive', 'turn', 1);

        updateTurnBasedDisplay();
        return;
    }

    // v1.5.0: Select enemy ability based on enemy type
    const enemyType = currentTurnBased.enemyType || 'warrior';
    const enemyTypeData = ENEMY_TYPES[enemyType];
    let selectedAbility = null;

    if (enemyTypeData && enemyTypeData.abilities && enemyTypeData.abilities.length > 0) {
        // Weighted random selection
        const totalWeight = enemyTypeData.abilities.reduce((sum, a) => sum + (a.weight || 10), 0);
        let roll = Math.random() * totalWeight;
        for (const ability of enemyTypeData.abilities) {
            roll -= (ability.weight || 10);
            if (roll <= 0) {
                selectedAbility = ability;
                break;
            }
        }
    }

    // Calculate base damage
    const baseAttack = enemyTypeData?.baseAttack || profile.enemyAttack || 12;
    const baseDefense = profile.playerDefense || 5;

    // v1.5.0: Apply enemy status damage modifiers
    const enemyDmgMod = getStatusDamageModifiers('enemy');
    const playerDefMod = getStatusDefenseModifiers('player');

    let { damage: baseDamage, isCrit } = calculateDamage(
        baseAttack,
        baseDefense,
        profile.critChance || 10,
        profile.critMultiplier || 2.0,
        false,  // isPlayerAttack = false (enemy is attacking)
        true    // isPlayerDefending = true (apply player's equipment defense)
    );

    // Apply status modifiers (enemy damage bonus, player damage reduction)
    baseDamage = Math.round(baseDamage * (1 + (enemyDmgMod.damageBonus || 0) / 100) * (1 - (playerDefMod.damageReduction || 0) / 100));

    // Apply ability damage multiplier
    if (selectedAbility && selectedAbility.damageMultiplier) {
        baseDamage = Math.round(baseDamage * selectedAbility.damageMultiplier);
    }

    // Reduce damage if defending
    let damage = baseDamage;
    let wasBlocked = false;
    let wasParried = false;

    // v1.6.0: Check for parry first (higher priority)
    const parryResult = await processParryResult(damage, enemyName);
    if (parryResult.parried) {
        wasParried = true;
        damage = 0;

        // Execute counter-attack
        const counterResult = await processCounterAttack(parryResult.counterDamage, enemyName);
        currentTurnBased.enemyHP = Math.max(0, currentTurnBased.enemyHP - counterResult.damage);
        flashHPBar(false, true);

        // v1.6.0: Play parry sound and VFX
        const combatContainerParry = document.querySelector('.turn-based-container');
        playSound('parry');
        triggerVFX('parry', combatContainerParry);

        if (counterResult.isCrit) {
            addTBLogEntry(`<span class="tb-log-parry-success">PARRY! CRITICAL COUNTER for ${counterResult.damage} damage!</span>`);
        } else {
            addTBLogEntry(`<span class="tb-log-parry-success">PARRY! Counter-attack for ${counterResult.damage} damage!</span>`);
        }

        // Apply stun to enemy if parry stuns
        if (parryResult.stunDuration > 0) {
            applyStatusEffect('enemy', 'stunned', parryResult.stunDuration);
            addTBLogEntry(`<span class="tb-log-stun">${enemyName} is stunned!</span>`);
        }

        // Check if counter killed enemy
        if (currentTurnBased.enemyHP <= 0) {
            await handleTurnBasedWin();
            return;
        }
    } else {
        // v1.6.0: Check for block
        const blockResult = await processBlockedDamage(damage);
        if (blockResult.damageBlocked > 0) {
            wasBlocked = true;
            damage = blockResult.damageTaken;
            if (blockResult.blockBroken) {
                addTBLogEntry(`<span class="tb-log-block-break">Your guard is broken!</span>`);
            } else {
                addTBLogEntry(`<span class="tb-log-block">You block ${blockResult.damageBlocked} damage!</span>`);
            }
        } else if (currentTurnBased.isDefending) {
            // Fallback to standard defend if no block mechanics
            damage = Math.round(damage * 0.5);
            addTBLogEntry(`Your defense reduces the damage!`);
        }
    }

    // v1.5.0: Execute ability (may apply status effects)
    if (selectedAbility) {
        executeEnemyAbility(selectedAbility);
        addTBLogEntry(`<span class="tb-log-ability">${enemyName} uses ${selectedAbility.name}!</span>`);
    }

    // Apply damage (may be 0 if parried)
    const combatContainer = document.querySelector('.turn-based-container');

    // v1.6.0: Play enemy attack animation
    startAnimation('minion_0', 'minion_attack');

    if (damage > 0) {
        currentTurnBased.playerHP = Math.max(0, currentTurnBased.playerHP - damage);
        flashHPBar(true, true);

        // v1.6.0: Play enemy attack sound and VFX
        if (isCrit && !wasBlocked) {
            playSound('critical_hit');
            triggerVFX('enemy_critical', combatContainer);
            addTBLogEntry(`<span class="tb-log-crit">CRITICAL! ${enemyName} deals ${damage} damage!</span>`);
        } else if (!wasBlocked && !wasParried) {
            playSound('enemy_hit');
            triggerVFX('enemy_attack', combatContainer);
            addTBLogEntry(`${enemyName} attacks for ${damage} damage!`);
        } else if (wasBlocked) {
            playSound('block');
            triggerVFX('block', combatContainer);
            addTBLogEntry(`${enemyName} attacks! You take ${damage} damage through your guard.`);
        }

        // v1.6.0: Check if combo should reset on taking damage
        const cmProfile = getCombatMechanicsProfile();
        if (cmProfile.comboResetOnDamage && damage > 0) {
            await resetCombo('damage');
            updateComboDisplay();
        }

        // v2.0.0: Reduce armor durability when taking damage
        if (currentMaze?.equipment?.armor) {
            reduceEquipmentDurability('armor', 1);
        }
    } else if (!wasParried) {
        addTBLogEntry(`${enemyName} attacks but deals no damage!`);
    }

    // v1.5.0: Check for Ice Shield freeze retaliation
    const iceShieldActive = currentMaze?.skills?.activeEffects?.find(e => e.skillId === 'magic_ice_shield');
    if (iceShieldActive) {
        const freezeChance = iceShieldActive.effect?.freezeChance || 15;
        if (Math.random() * 100 < freezeChance) {
            applyStatusEffect('enemy', 'frozen');
            addTBLogEntry(`<span class="tb-log-freeze">Ice Shield freezes ${enemyName}!</span>`);
        }
    }

    updateStatusEffectsDisplay();

    // Execute STScript hook
    if (profile.onPlayerHit) {
        await executeWithTimeout(profile.onPlayerHit);
    }

    // Check for defeat
    if (currentTurnBased.playerHP <= 0) {
        await handleTurnBasedLoss();
        return;
    }

    // v1.5.0: Process player status effects at end of enemy turn (tick durations for player)
    const playerDotResult = processStatusEffects('player');
    if (playerDotResult.damage > 0) {
        currentTurnBased.playerHP = Math.max(0, currentTurnBased.playerHP - playerDotResult.damage);
        flashHPBar(true, true);

        if (currentTurnBased.playerHP <= 0) {
            await handleTurnBasedLoss();
            return;
        }
    }
    updateStatusEffectsDisplay();

    // Next turn
    currentTurnBased.currentTurn = 'player';
    currentTurnBased.turnCount++;
    currentTurnBased.isDefending = false;

    // v1.5.0: Update survive quest progress
    updateQuestProgress('survive', 'turn', 1);

    // v1.5.0: Tick skill cooldowns at end of each full round
    tickSkillCooldowns();

    updateTurnBasedDisplay();
}

async function handleTurnBasedWin() {
    currentTurnBased.isVictory = true;
    currentTurnBased.currentTurn = 'none';

    // v1.5.0: Clear all status effects on combat end
    clearAllStatusEffects();
    updateStatusEffectsDisplay();

    // v1.6.0: Play victory sound
    playSound('victory');

    const profile = currentTurnBased.profile;
    addTBLogEntry('Victory! The enemy is defeated!');

    try {
        // Execute STScript hook
        if (profile.onWin) {
            await executeWithTimeout(profile.onWin);
        }

        // Handle item drops if in maze (v1.8.0: filtered by item pool)
        if (currentMaze.isOpen && currentMaze.pendingEncounter) {
            if (isItemInPool('key') && Math.random() * 100 < (profile.keyDropChance || 40)) {
                addToInventory('key');
                addTBLogEntry('You found a Key!');
            }
            if (isItemInPool('strike') && Math.random() * 100 < (profile.strikeDropChance || 20)) {
                addToInventory('strike');
                addTBLogEntry('You found a Strike!');
            }
            if (isItemInPool('healingPotion') && Math.random() * 100 < (profile.healingPotionDropChance || 20)) {
                addToInventory('healingPotion');
                addTBLogEntry('You found a Healing Potion!');
            }

            // v1.5.0: Equipment drop chance
            try {
                const equipDropChance = profile.equipmentDropChance ?? 15;
                const equipment = await triggerEquipmentDrop(equipDropChance);
                if (equipment) {
                    addTBLogEntry(`You found ${equipment.name}!`);
                }
            } catch (e) {
                console.error('[MazeMaster] Equipment drop error:', e);
            }

            // v1.5.0: Grant XP for combat victory
            try {
                const difficulty = currentTurnBased.difficulty || 1;
                const xpAmount = getXpReward('combatVictory') + (difficulty * getXpReward('combatDifficultyBonus'));
                const xpResult = await grantXp(xpAmount, 'combat');
                addTBLogEntry(`+${xpAmount} XP`);
                if (xpResult?.leveledUp) {
                    addTBLogEntry(`LEVEL UP! Now level ${xpResult.newLevel}!`);
                }
            } catch (e) {
                console.error('[MazeMaster] XP grant error:', e);
            }

            // v1.5.0: Update defeat quest progress
            try {
                const enemyType = currentTurnBased.enemyType || 'enemy';
                await updateQuestProgress('defeat', enemyType, 1);
            } catch (e) {
                console.error('[MazeMaster] Quest progress error:', e);
            }
        }
    } catch (e) {
        console.error('[MazeMaster] Victory handler error:', e);
    }

    // Store result
    lastResults.turnbased = lastResults.turnbased || {};
    lastResults.turnbased[currentTurnBased.profileName] = {
        result: 'win',
        turnsPlayed: currentTurnBased.turnCount,
        timestamp: Date.now(),
    };

    showTurnBasedResult('victory');
}

async function handleTurnBasedLoss() {
    currentTurnBased.isDefeat = true;
    currentTurnBased.currentTurn = 'none';

    // v1.5.0: Clear all status effects on combat end
    clearAllStatusEffects();
    updateStatusEffectsDisplay();

    // v1.6.0: Play defeat sound
    playSound('defeat');

    const profile = currentTurnBased.profile;
    addTBLogEntry('Defeat... You have fallen.');

    // Execute STScript hook
    if (profile.onLose) {
        await executeWithTimeout(profile.onLose);
    }

    // Apply maze HP damage
    let playerDied = false;
    if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
        const damage = profile.damage || 25;
        const mazeMultiplier = currentMaze.profile?.battlebarDamageMultiplier ?? 1.0;
        const actualDamage = Math.round(damage * mazeMultiplier);
        const survived = await applyDamage(actualDamage, 'turnbased');
        playerDied = !survived;
    }

    // Store result
    lastResults.turnbased = lastResults.turnbased || {};
    lastResults.turnbased[currentTurnBased.profileName] = {
        result: 'lose',
        turnsPlayed: currentTurnBased.turnCount,
        timestamp: Date.now(),
    };

    // If player died, close modal and let death handling take over
    if (playerDied) {
        closeTurnBasedModal();
        return;
    }

    showTurnBasedResult('defeat');
}

function showTurnBasedResult(result) {
    const actionsEl = document.getElementById('tb_action_buttons');
    const resultPanel = document.getElementById('tb_result_panel');
    const resultText = document.getElementById('tb_result_text');

    if (actionsEl) actionsEl.style.display = 'none';
    if (resultPanel) resultPanel.style.display = 'block';

    if (resultText) {
        if (result === 'victory') {
            resultText.textContent = 'Victory!';
            resultText.className = 'tb-result-text tb-result-victory';
        } else if (result === 'defeat') {
            resultText.textContent = 'Defeat...';
            resultText.className = 'tb-result-text tb-result-defeat';
        } else if (result === 'fled') {
            resultText.textContent = 'Escaped!';
            resultText.className = 'tb-result-text tb-result-fled';
        }
    }

    updateTurnBasedDisplay();
}

async function closeTurnBasedModal() {
    const modal = document.getElementById('mazemaster_turnbased_modal');
    if (modal) modal.remove();

    const wasVictory = currentTurnBased.isVictory;
    const wasDefeat = currentTurnBased.isDefeat;
    const isMazeEncounter = currentTurnBased.isMazeEncounter;

    // Persist HP back to maze if this was a maze encounter
    if (isMazeEncounter && currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
        const previousHP = currentMaze.hp.current;
        currentMaze.hp.current = Math.max(0, currentTurnBased.playerHP);
        console.log('[MazeMaster] Persisting combat HP to maze:', previousHP, '->', currentMaze.hp.current);

        // Update maze HP display
        updateHPDisplay();

        // Check if player died in combat (defeat case)
        if (wasDefeat && currentMaze.hp.current <= 0) {
            console.log('[MazeMaster] Player died in turn-based combat');
            // The maze loss will be handled below or by existing defeat logic
        }
    }

    currentTurnBased.isOpen = false;

    // Handle maze integration
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasVictory) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);
                    if (encounterType === 'exit_turnbased') {
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    }
                } else if (wasDefeat) {
                    // Player was defeated - handle maze loss if HP depleted
                    if (isMazeEncounter && currentMaze.hp && currentMaze.hp.current <= 0) {
                        currentMaze.pendingEncounter = null;
                        handleMazeLoss();
                        return; // handleMazeLoss takes over
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeTurnBasedModal:', err);
        }

        // Always ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

// =============================================================================
// QTE MODAL & GAME LOGIC
// =============================================================================

// Key display mapping for visual prompts
const QTE_KEY_DISPLAY = {
    'W': { label: 'W', icon: 'fa-arrow-up', color: '#3498db' },
    'A': { label: 'A', icon: 'fa-arrow-left', color: '#e74c3c' },
    'S': { label: 'S', icon: 'fa-arrow-down', color: '#2ecc71' },
    'D': { label: 'D', icon: 'fa-arrow-right', color: '#f39c12' },
    'SPACE': { label: 'SPACE', icon: 'fa-square', color: '#9b59b6' },
    'E': { label: 'E', icon: 'fa-hand', color: '#1abc9c' },
    'Q': { label: 'Q', icon: 'fa-shield', color: '#e67e22' },
};

function getQTEModalHtml() {
    return `
        <div id="mazemaster_qte_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-qte-container">
                <div id="qte_main_title" class="mazemaster-qte-main-title">QTE!</div>

                <div class="mazemaster-qte-progress">
                    <div class="qte-progress-bar" id="qte_progress_bar"></div>
                    <div class="qte-progress-text"><span id="qte_current_index">0</span>/<span id="qte_total_count">0</span></div>
                </div>

                <div class="mazemaster-qte-prompt-area">
                    <div class="qte-timer-ring" id="qte_timer_ring">
                        <svg viewBox="0 0 100 100">
                            <circle class="qte-timer-bg" cx="50" cy="50" r="45"/>
                            <circle class="qte-timer-fill" id="qte_timer_circle" cx="50" cy="50" r="45"/>
                        </svg>
                        <div class="qte-key-prompt" id="qte_key_prompt">
                            <i class="fa-solid fa-hourglass-start"></i>
                            <span>GET READY</span>
                        </div>
                    </div>
                </div>

                <div class="mazemaster-qte-stats">
                    <span class="qte-stat qte-stat-combo">
                        Combo: <span id="qte_combo">0</span>x
                    </span>
                    <span class="qte-stat qte-stat-perfects">
                        Perfect: <span id="qte_perfects">0</span>
                    </span>
                    <span class="qte-stat qte-stat-misses">
                        Miss: <span id="qte_misses">0</span>
                    </span>
                </div>

                <div class="mazemaster-qte-log" id="qte_combat_log">
                    <div class="qte-log-entry">Prepare yourself...</div>
                </div>

                <div class="mazemaster-qte-result" id="qte_result_panel" style="display: none;">
                    <div id="qte_result_text" class="qte-result-text"></div>
                    <div id="qte_result_stats" class="qte-result-stats"></div>
                    <button id="qte_close_btn" class="mazemaster-qte-btn qte-btn-close">
                        <i class="fa-solid fa-check"></i> Close
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getQTEStyles() {
    return `
        .mazemaster-qte-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 25px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            border: 2px solid #9b59b6;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(155, 89, 182, 0.3);
            width: 450px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .mazemaster-qte-main-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .mazemaster-qte-progress {
            width: 100%;
            position: relative;
        }

        .qte-progress-bar {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .qte-progress-bar::after {
            content: '';
            display: block;
            height: 100%;
            width: var(--progress, 0%);
            background: linear-gradient(90deg, #9b59b6, #3498db);
            transition: width 0.3s ease;
        }

        .qte-progress-text {
            position: absolute;
            right: 0;
            top: -20px;
            font-size: 0.9em;
            color: #aaa;
        }

        .mazemaster-qte-prompt-area {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 180px;
            width: 100%;
        }

        .qte-timer-ring {
            position: relative;
            width: 160px;
            height: 160px;
        }

        .qte-timer-ring svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        .qte-timer-bg {
            fill: none;
            stroke: #333;
            stroke-width: 8;
        }

        .qte-timer-fill {
            fill: none;
            stroke: #9b59b6;
            stroke-width: 8;
            stroke-linecap: round;
            stroke-dasharray: 283;
            stroke-dashoffset: 0;
            transition: stroke-dashoffset 0.1s linear;
        }

        .qte-timer-fill.warning {
            stroke: #f39c12;
        }

        .qte-timer-fill.critical {
            stroke: #e74c3c;
        }

        .qte-key-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .qte-key-prompt i {
            font-size: 2.5em;
            color: #fff;
        }

        .qte-key-prompt span {
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .qte-key-prompt.success {
            animation: qte-success-pulse 0.3s ease;
        }

        .qte-key-prompt.fail {
            animation: qte-fail-shake 0.3s ease;
        }

        .qte-key-prompt.perfect {
            animation: qte-perfect-glow 0.4s ease;
        }

        @keyframes qte-success-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        @keyframes qte-fail-shake {
            0%, 100% { transform: translate(-50%, -50%); }
            25% { transform: translate(calc(-50% - 10px), -50%); }
            75% { transform: translate(calc(-50% + 10px), -50%); }
        }

        @keyframes qte-perfect-glow {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5) drop-shadow(0 0 20px gold); }
            100% { filter: brightness(1); }
        }

        .mazemaster-qte-stats {
            display: flex;
            gap: 20px;
            font-size: 1em;
            font-weight: bold;
        }

        .qte-stat-combo { color: #f39c12; }
        .qte-stat-perfects { color: #2ecc71; }
        .qte-stat-misses { color: #e74c3c; }

        .mazemaster-qte-log {
            width: 100%;
            height: 80px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.85em;
            color: #ccc;
        }

        .qte-log-entry {
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .qte-log-entry:last-child { border-bottom: none; }
        .qte-log-success { color: #2ecc71; }
        .qte-log-perfect { color: #f1c40f; font-weight: bold; }
        .qte-log-miss { color: #e74c3c; }
        .qte-log-combo { color: #3498db; }

        .mazemaster-qte-result {
            text-align: center;
            padding: 15px;
        }

        .qte-result-text {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .qte-result-text.success { color: #2ecc71; }
        .qte-result-text.fail { color: #e74c3c; }

        .qte-result-stats {
            font-size: 0.95em;
            color: #aaa;
            margin-bottom: 15px;
        }

        .mazemaster-qte-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mazemaster-qte-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .qte-btn-close {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 15px 40px;
            margin: 0 auto;
        }
    `;
}

function startQTE(profileName) {
    console.log('[MazeMaster] startQTE called with profile:', profileName);
    const profile = getQteProfile(profileName);
    console.log('[MazeMaster] QTE profile retrieved:', profile);
    if (!profile) {
        console.error(`[MazeMaster] QTE profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    // Generate sequence
    const sequenceLength = Math.floor(
        Math.random() * (profile.sequenceLengthMax - profile.sequenceLengthMin + 1) + profile.sequenceLengthMin
    );
    const sequence = [];
    for (let i = 0; i < sequenceLength; i++) {
        const randomKey = profile.allowedKeys[Math.floor(Math.random() * profile.allowedKeys.length)];
        sequence.push(randomKey);
    }

    // Initialize QTE state
    currentQTE = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        sequence: sequence,
        currentIndex: 0,
        currentTimeWindow: profile.timeWindowBase,
        promptStartTime: 0,
        timeoutId: null,
        successes: 0,
        perfects: 0,
        misses: 0,
        combo: 0,
        maxCombo: 0,
        isComplete: false,
        isSuccess: false,
        combatLog: ['Prepare yourself...'],
    };

    // Pause maze if active
    if (currentMaze.isOpen) {
        currentMaze.isPaused = true;
    }

    showQTEModal();

    // Execute start hook
    if (profile.onStart) {
        executeWithTimeout(profile.onStart);
    }

    // Start after a brief countdown
    setTimeout(() => {
        addQTELogEntry('GO!');
        showNextQTEPrompt();
    }, 1000);

    console.log(`[MazeMaster] QTE started: ${profileName}, sequence length: ${sequenceLength}`);
    return { success: true };
}

function showQTEModal() {
    const existing = document.getElementById('mazemaster_qte_modal');
    if (existing) existing.remove();

    if (!document.getElementById('mazemaster_qte_styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_qte_styles';
        styleEl.textContent = getQTEStyles();
        document.head.appendChild(styleEl);
    }

    document.body.insertAdjacentHTML('beforeend', getQTEModalHtml());

    // Update title
    const titleEl = document.getElementById('qte_main_title');
    if (titleEl) titleEl.textContent = currentQTE.profile.mainTitle || 'QTE!';

    // Update total count
    const totalEl = document.getElementById('qte_total_count');
    if (totalEl) totalEl.textContent = currentQTE.sequence.length;

    // Attach close button handler
    document.getElementById('qte_close_btn')?.addEventListener('click', closeQTEModal);

    // Attach keyboard handler
    document.addEventListener('keydown', handleQTEKeydown);

    updateQTEDisplay();
}

function updateQTEDisplay() {
    // Update progress bar
    const progressBar = document.getElementById('qte_progress_bar');
    const progress = (currentQTE.currentIndex / currentQTE.sequence.length) * 100;
    if (progressBar) progressBar.style.setProperty('--progress', `${progress}%`);

    // Update current index
    const indexEl = document.getElementById('qte_current_index');
    if (indexEl) indexEl.textContent = currentQTE.currentIndex;

    // Update stats
    const comboEl = document.getElementById('qte_combo');
    const perfectsEl = document.getElementById('qte_perfects');
    const missesEl = document.getElementById('qte_misses');
    if (comboEl) comboEl.textContent = currentQTE.combo;
    if (perfectsEl) perfectsEl.textContent = currentQTE.perfects;
    if (missesEl) missesEl.textContent = currentQTE.misses;

    // Update combat log
    const logEl = document.getElementById('qte_combat_log');
    if (logEl) {
        logEl.innerHTML = currentQTE.combatLog.map(entry => {
            let className = 'qte-log-entry';
            if (entry.includes('Success') || entry.includes('Hit')) className += ' qte-log-success';
            if (entry.includes('PERFECT')) className += ' qte-log-perfect';
            if (entry.includes('Miss') || entry.includes('Too slow')) className += ' qte-log-miss';
            if (entry.includes('Combo')) className += ' qte-log-combo';
            return `<div class="${className}">${entry}</div>`;
        }).join('');
        logEl.scrollTop = logEl.scrollHeight;
    }
}

function addQTELogEntry(message) {
    currentQTE.combatLog.push(message);
    if (currentQTE.combatLog.length > 30) {
        currentQTE.combatLog.shift();
    }
    updateQTEDisplay();
}

function showNextQTEPrompt() {
    if (currentQTE.currentIndex >= currentQTE.sequence.length) {
        handleQTEComplete();
        return;
    }

    const key = currentQTE.sequence[currentQTE.currentIndex];
    const keyInfo = QTE_KEY_DISPLAY[key] || { label: key, icon: 'fa-keyboard', color: '#fff' };

    // Update the prompt display
    const promptEl = document.getElementById('qte_key_prompt');
    if (promptEl) {
        promptEl.innerHTML = `
            <i class="fa-solid ${keyInfo.icon}" style="color: ${keyInfo.color}"></i>
            <span>${keyInfo.label}</span>
        `;
        promptEl.classList.remove('success', 'fail', 'perfect');
    }

    // Reset and start timer animation
    const timerCircle = document.getElementById('qte_timer_circle');
    if (timerCircle) {
        timerCircle.style.strokeDashoffset = '0';
        timerCircle.classList.remove('warning', 'critical');
    }

    // Store prompt start time
    currentQTE.promptStartTime = performance.now();

    // Execute prompt hook
    if (currentQTE.profile.onPrompt) {
        executeWithTimeout(currentQTE.profile.onPrompt);
    }

    // Set timeout for this prompt
    if (currentQTE.timeoutId) clearTimeout(currentQTE.timeoutId);
    currentQTE.timeoutId = setTimeout(() => handleQTEMiss(), currentQTE.currentTimeWindow);

    // Animate timer
    animateQTETimer();
}

function animateQTETimer() {
    const timerCircle = document.getElementById('qte_timer_circle');
    if (!timerCircle || !currentQTE.isOpen || currentQTE.isComplete) return;

    const elapsed = performance.now() - currentQTE.promptStartTime;
    const progress = elapsed / currentQTE.currentTimeWindow;
    const dashOffset = 283 * progress; // 283 is the circumference (2 * PI * 45)

    timerCircle.style.strokeDashoffset = dashOffset;

    // Color changes based on time remaining
    if (progress > 0.75) {
        timerCircle.classList.add('critical');
        timerCircle.classList.remove('warning');
    } else if (progress > 0.5) {
        timerCircle.classList.add('warning');
        timerCircle.classList.remove('critical');
    }

    if (progress < 1 && currentQTE.isOpen && !currentQTE.isComplete) {
        requestAnimationFrame(animateQTETimer);
    }
}

function handleQTEKeydown(e) {
    if (!currentQTE.isOpen || currentQTE.isComplete) return;

    // Get the expected key
    const expectedKey = currentQTE.sequence[currentQTE.currentIndex];
    let pressedKey = e.key.toUpperCase();

    // Handle space key
    if (e.key === ' ') pressedKey = 'SPACE';

    // Check if this is an allowed key
    if (!currentQTE.profile.allowedKeys.includes(pressedKey)) {
        return; // Ignore keys not in the allowed set
    }

    e.preventDefault();

    if (pressedKey === expectedKey) {
        handleQTESuccess();
    } else {
        handleQTEMiss();
    }
}

async function handleQTESuccess() {
    // Clear timeout
    if (currentQTE.timeoutId) {
        clearTimeout(currentQTE.timeoutId);
        currentQTE.timeoutId = null;
    }

    // Calculate timing
    const reactionTime = performance.now() - currentQTE.promptStartTime;
    const perfectWindow = currentQTE.currentTimeWindow * (currentQTE.profile.perfectWindowPercent / 100);
    const isPerfect = reactionTime <= perfectWindow;

    // Update stats
    currentQTE.successes++;
    currentQTE.combo++;
    currentQTE.maxCombo = Math.max(currentQTE.maxCombo, currentQTE.combo);

    // Animate success
    const promptEl = document.getElementById('qte_key_prompt');

    if (isPerfect) {
        currentQTE.perfects++;
        promptEl?.classList.add('perfect');
        addQTELogEntry(`PERFECT! (${Math.round(reactionTime)}ms)`);

        // Execute perfect hook
        if (currentQTE.profile.onPerfect) {
            await executeWithTimeout(currentQTE.profile.onPerfect);
        }
    } else {
        promptEl?.classList.add('success');
        addQTELogEntry(`Success! (${Math.round(reactionTime)}ms)`);

        // Execute success hook
        if (currentQTE.profile.onSuccess) {
            await executeWithTimeout(currentQTE.profile.onSuccess);
        }
    }

    // Log combo milestones
    if (currentQTE.combo > 1 && currentQTE.combo % 3 === 0) {
        addQTELogEntry(`Combo x${currentQTE.combo}!`);
    }

    // Move to next prompt
    currentQTE.currentIndex++;
    updateQTEDisplay();

    // Scale time window for difficulty
    if (currentQTE.profile.difficultyScaling) {
        currentQTE.currentTimeWindow = Math.max(
            currentQTE.profile.timeWindowMin,
            currentQTE.currentTimeWindow * currentQTE.profile.difficultyScaling
        );
    }

    // Brief delay before next prompt
    setTimeout(() => showNextQTEPrompt(), 400);
}

async function handleQTEMiss() {
    // Clear timeout
    if (currentQTE.timeoutId) {
        clearTimeout(currentQTE.timeoutId);
        currentQTE.timeoutId = null;
    }

    // Update stats
    currentQTE.misses++;
    currentQTE.combo = 0;

    // Animate failure
    const promptEl = document.getElementById('qte_key_prompt');
    promptEl?.classList.add('fail');

    const expectedKey = currentQTE.sequence[currentQTE.currentIndex];
    addQTELogEntry(`Miss! Expected: ${expectedKey}`);

    // Execute miss hook
    if (currentQTE.profile.onMiss) {
        await executeWithTimeout(currentQTE.profile.onMiss);
    }

    // Move to next prompt
    currentQTE.currentIndex++;
    updateQTEDisplay();

    // Brief delay before next prompt
    setTimeout(() => showNextQTEPrompt(), 400);
}

async function handleQTEComplete() {
    currentQTE.isComplete = true;

    // Determine success based on success rate
    const successRate = currentQTE.successes / currentQTE.sequence.length;
    currentQTE.isSuccess = successRate >= 0.5; // Pass if 50% or more successful

    // Remove keyboard handler
    document.removeEventListener('keydown', handleQTEKeydown);

    const profile = currentQTE.profile;

    if (currentQTE.isSuccess) {
        addQTELogEntry('QTE Complete - Success!');

        // Execute complete hook
        if (profile.onComplete) {
            await executeWithTimeout(profile.onComplete);
        }

        // Handle item drops if in maze (v1.8.0: filtered by item pool)
        if (currentMaze.isOpen && currentMaze.pendingEncounter) {
            if (isItemInPool('key') && Math.random() * 100 < (profile.keyDropChance || 30)) {
                addToInventory('key');
                addQTELogEntry('You found a Key!');
            }
            if (isItemInPool('strike') && Math.random() * 100 < (profile.strikeDropChance || 15)) {
                addToInventory('strike');
                addQTELogEntry('You found a Strike!');
            }
            if (isItemInPool('healingPotion') && Math.random() * 100 < (profile.healingPotionDropChance || 15)) {
                addToInventory('healingPotion');
                addQTELogEntry('You found a Healing Potion!');
            }
        }

        // Store result
        lastResults.qte = lastResults.qte || {};
        lastResults.qte[currentQTE.profileName] = {
            result: 'success',
            successRate: successRate,
            perfects: currentQTE.perfects,
            maxCombo: currentQTE.maxCombo,
            timestamp: Date.now(),
        };
    } else {
        addQTELogEntry('QTE Failed...');

        // Execute fail hook
        if (profile.onFail) {
            await executeWithTimeout(profile.onFail);
        }

        // Apply maze HP damage
        let playerDied = false;
        if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
            const damage = profile.damage || 20;
            const mazeMultiplier = currentMaze.profile?.battlebarDamageMultiplier ?? 1.0;
            const actualDamage = Math.round(damage * mazeMultiplier);
            const survived = await applyDamage(actualDamage, 'qte');
            playerDied = !survived;
        }

        // Store result
        lastResults.qte = lastResults.qte || {};
        lastResults.qte[currentQTE.profileName] = {
            result: 'fail',
            successRate: successRate,
            perfects: currentQTE.perfects,
            maxCombo: currentQTE.maxCombo,
            timestamp: Date.now(),
        };

        // If player died, close modal and let death handling take over
        if (playerDied) {
            closeQTEModal();
            return;
        }
    }

    showQTEResult();
}

function showQTEResult() {
    const promptArea = document.querySelector('.mazemaster-qte-prompt-area');
    const statsArea = document.querySelector('.mazemaster-qte-stats');
    const logArea = document.querySelector('.mazemaster-qte-log');
    const resultPanel = document.getElementById('qte_result_panel');
    const resultText = document.getElementById('qte_result_text');
    const resultStats = document.getElementById('qte_result_stats');

    if (promptArea) promptArea.style.display = 'none';
    if (statsArea) statsArea.style.display = 'none';
    if (logArea) logArea.style.display = 'none';
    if (resultPanel) resultPanel.style.display = 'block';

    const successRate = Math.round((currentQTE.successes / currentQTE.sequence.length) * 100);

    if (resultText) {
        if (currentQTE.isSuccess) {
            resultText.textContent = currentQTE.perfects === currentQTE.sequence.length ? 'PERFECT!' : 'Success!';
            resultText.className = 'qte-result-text success';
        } else {
            resultText.textContent = 'Failed...';
            resultText.className = 'qte-result-text fail';
        }
    }

    if (resultStats) {
        resultStats.innerHTML = `
            <div>Hits: ${currentQTE.successes}/${currentQTE.sequence.length} (${successRate}%)</div>
            <div>Perfect: ${currentQTE.perfects} | Max Combo: ${currentQTE.maxCombo}x</div>
        `;
    }
}

async function closeQTEModal() {
    // Clear any pending timeout
    if (currentQTE.timeoutId) {
        clearTimeout(currentQTE.timeoutId);
        currentQTE.timeoutId = null;
    }

    // Remove keyboard handler
    document.removeEventListener('keydown', handleQTEKeydown);

    const modal = document.getElementById('mazemaster_qte_modal');
    if (modal) modal.remove();

    const wasSuccess = currentQTE.isSuccess;
    currentQTE.isOpen = false;

    // Handle maze integration
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasSuccess) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);

                    // v2.0.5: Grant XP for successful QTE encounter
                    const qteXp = getXpReward('combatVictory');
                    if (qteXp > 0) {
                        const xpResult = await grantXp(qteXp, 'qte');
                        if (xpResult.leveledUp) {
                            addMazeLogMessage(`Level Up! Now level ${xpResult.newLevel}!`, 'success');
                        }
                        addMazeLogMessage(`QTE success! +${qteXp} XP`, 'info');
                    }

                    // Heal player on successful QTE completion (skill reward)
                    if (currentMaze.hp && currentMaze.profile?.hpEnabled !== false) {
                        const healPercent = currentMaze.profile.skillEncounterHealPercent || 25;
                        const maxTotal = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
                        const healAmount = Math.floor(maxTotal * (healPercent / 100));
                        if (currentMaze.hp.current < maxTotal && healAmount > 0) {
                            await healPlayer(healAmount, false, 'QTE success');
                            addMazeLogMessage(`Quick reflexes! Recovered ${healAmount} HP.`, 'heal');
                        }
                    }

                    if (encounterType === 'exit_qte') {
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeQTEModal:', err);
        }

        // Always ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

// =============================================================================
// DICE COMBAT MODAL & GAME LOGIC
// =============================================================================

// Dice type configuration
const DICE_TYPES = {
    'd4': { sides: 4, icon: 'fa-dice-d4', color: '#e74c3c' },
    'd6': { sides: 6, icon: 'fa-dice-d6', color: '#3498db' },
    'd8': { sides: 8, icon: 'fa-dice', color: '#2ecc71' },
    'd10': { sides: 10, icon: 'fa-dice-d10', color: '#f39c12' },
    'd12': { sides: 12, icon: 'fa-dice-d12', color: '#9b59b6' },
    'd20': { sides: 20, icon: 'fa-dice-d20', color: '#e67e22' },
    'd100': { sides: 100, icon: 'fa-percent', color: '#1abc9c' },
};

function getDiceModalHtml() {
    return `
        <div id="mazemaster_dice_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-dice-container">
                <div id="dice_main_title" class="mazemaster-dice-main-title">Roll the Dice!</div>
                <div id="dice_description" class="mazemaster-dice-description"></div>

                <div class="mazemaster-dice-info">
                    <span class="dice-info-item">
                        <i class="fa-solid fa-bullseye"></i>
                        Target: <span id="dice_threshold">0</span>
                    </span>
                    <span class="dice-info-item">
                        <i class="fa-solid fa-plus-minus"></i>
                        Modifier: <span id="dice_modifier">+0</span>
                    </span>
                    <span class="dice-info-item">
                        <i class="fa-solid fa-rotate"></i>
                        Rerolls: <span id="dice_rerolls">0</span>
                    </span>
                </div>

                <div class="mazemaster-dice-roll-area" id="dice_roll_area">
                    <div class="dice-waiting">
                        <i class="fa-solid fa-dice fa-3x"></i>
                        <div>Click to Roll!</div>
                    </div>
                </div>

                <div class="mazemaster-dice-result" id="dice_result_display" style="display: none;">
                    <div class="dice-result-total">
                        <span id="dice_result_total">0</span>
                    </div>
                    <div class="dice-result-breakdown" id="dice_result_breakdown"></div>
                </div>

                <div class="mazemaster-dice-log" id="dice_combat_log">
                    <div class="dice-log-entry">Ready to roll...</div>
                </div>

                <div class="mazemaster-dice-actions" id="dice_actions">
                    <button id="dice_roll_btn" class="mazemaster-dice-btn dice-btn-roll">
                        <i class="fa-solid fa-dice"></i> Roll
                    </button>
                </div>

                <div class="mazemaster-dice-final" id="dice_final_panel" style="display: none;">
                    <div id="dice_final_text" class="dice-final-text"></div>
                    <button id="dice_close_btn" class="mazemaster-dice-btn dice-btn-close">
                        <i class="fa-solid fa-check"></i> Close
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getDiceStyles() {
    return `
        .mazemaster-dice-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 25px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            border: 2px solid #f39c12;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(243, 156, 18, 0.3);
            width: 420px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .mazemaster-dice-main-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .mazemaster-dice-description {
            font-size: 0.9em;
            color: #aaa;
            text-align: center;
            max-width: 350px;
        }

        .mazemaster-dice-info {
            display: flex;
            gap: 20px;
            font-size: 0.95em;
            color: #ddd;
        }

        .dice-info-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dice-info-item i {
            color: #f39c12;
        }

        .mazemaster-dice-roll-area {
            width: 100%;
            min-height: 120px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mazemaster-dice-roll-area:hover {
            background: rgba(243, 156, 18, 0.2);
        }

        .dice-waiting {
            text-align: center;
            color: #888;
        }

        .dice-waiting i {
            margin-bottom: 10px;
            animation: dice-pulse 2s ease-in-out infinite;
        }

        @keyframes dice-pulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        .dice-rolling {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .dice-single {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            animation: dice-roll 0.5s ease-out;
        }

        .dice-single.critical-success {
            background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%);
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.5);
        }

        .dice-single.critical-fail {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
        }

        @keyframes dice-roll {
            0% { transform: rotateX(0deg) rotateY(0deg) scale(0.5); opacity: 0; }
            50% { transform: rotateX(180deg) rotateY(180deg) scale(1.2); }
            100% { transform: rotateX(360deg) rotateY(360deg) scale(1); opacity: 1; }
        }

        .mazemaster-dice-result {
            text-align: center;
        }

        .dice-result-total {
            font-size: 3em;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .dice-result-total.success { color: #2ecc71; }
        .dice-result-total.fail { color: #e74c3c; }
        .dice-result-total.critical-success {
            color: #f1c40f;
            animation: critical-glow 1s ease-in-out infinite;
        }
        .dice-result-total.critical-fail {
            color: #c0392b;
            animation: critical-shake 0.5s ease-in-out;
        }

        @keyframes critical-glow {
            0%, 100% { text-shadow: 0 0 10px rgba(241, 196, 15, 0.5); }
            50% { text-shadow: 0 0 30px rgba(241, 196, 15, 1); }
        }

        @keyframes critical-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* v1.6.0: VFX Particle Animations */
        @keyframes particle-fly {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--dx, 50px), var(--dy, -50px)) scale(0.3);
                opacity: 0;
            }
        }

        @keyframes vfx-flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes vfx-expand {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        .mazemaster-vfx-flash {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, transparent 70%);
            animation: vfx-flash 0.3s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }

        .mazemaster-particle.particle-sparks {
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            box-shadow: 0 0 6px #f39c12;
        }

        .mazemaster-particle.particle-flames {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 0 8px #e74c3c;
            border-radius: 30% 70% 70% 30%;
        }

        .mazemaster-particle.particle-frost {
            background: linear-gradient(135deg, #3498db, #9b59b6);
            box-shadow: 0 0 6px #3498db;
        }

        .mazemaster-particle.particle-heal {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            box-shadow: 0 0 6px #2ecc71;
        }

        .mazemaster-particle.particle-lightning {
            background: linear-gradient(135deg, #f1c40f, #fff);
            box-shadow: 0 0 10px #f1c40f;
            width: 4px !important;
            height: 12px !important;
            border-radius: 2px;
        }

        .dice-result-breakdown {
            font-size: 0.9em;
            color: #888;
            margin-top: 5px;
        }

        .mazemaster-dice-log {
            width: 100%;
            height: 60px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.85em;
            color: #ccc;
        }

        .dice-log-entry { padding: 2px 0; }
        .dice-log-success { color: #2ecc71; }
        .dice-log-fail { color: #e74c3c; }
        .dice-log-critical { color: #f1c40f; font-weight: bold; }
        .dice-log-reroll { color: #3498db; }

        .mazemaster-dice-actions {
            display: flex;
            gap: 10px;
        }

        .mazemaster-dice-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mazemaster-dice-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .mazemaster-dice-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .dice-btn-roll {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
        }

        .dice-btn-reroll {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .dice-btn-close {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 15px 40px;
        }

        .mazemaster-dice-final {
            text-align: center;
            padding: 15px;
        }

        .dice-final-text {
            font-size: 1.6em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .dice-final-text.success { color: #2ecc71; }
        .dice-final-text.fail { color: #e74c3c; }
    `;
}

function rollDie(sides) {
    return Math.floor(Math.random() * sides) + 1;
}

function startDice(profileName) {
    console.log('[MazeMaster] startDice called with profile:', profileName);
    const profile = getDiceProfile(profileName);
    console.log('[MazeMaster] Dice profile retrieved:', profile);
    if (!profile) {
        console.error(`[MazeMaster] Dice profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    const diceConfig = DICE_TYPES[profile.diceType] || DICE_TYPES['d6'];

    // Initialize dice state
    currentDice = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        diceResults: [],
        total: 0,
        rawTotal: 0,
        threshold: profile.threshold,
        modifier: profile.modifier || 0,
        rerollsRemaining: profile.rerollsAllowed || 0,
        isCriticalSuccess: false,
        isCriticalFail: false,
        isSuccess: false,
        isComplete: false,
        combatLog: ['Ready to roll...'],
    };

    // Pause maze if active
    if (currentMaze.isOpen) {
        currentMaze.isPaused = true;
    }

    showDiceModal();

    // Execute start hook
    if (profile.onStart) {
        executeWithTimeout(profile.onStart);
    }

    console.log(`[MazeMaster] Dice started: ${profileName}`);
    return { success: true };
}

function showDiceModal() {
    const existing = document.getElementById('mazemaster_dice_modal');
    if (existing) existing.remove();

    if (!document.getElementById('mazemaster_dice_styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_dice_styles';
        styleEl.textContent = getDiceStyles();
        document.head.appendChild(styleEl);
    }

    document.body.insertAdjacentHTML('beforeend', getDiceModalHtml());

    const profile = currentDice.profile;

    // Update UI
    document.getElementById('dice_main_title').textContent = profile.mainTitle || 'Roll the Dice!';
    document.getElementById('dice_description').textContent = profile.description || '';

    const thresholdText = profile.thresholdType === 'beat' ? `> ${profile.threshold}` : `≥ ${profile.threshold}`;
    document.getElementById('dice_threshold').textContent = thresholdText;

    const modText = profile.modifier >= 0 ? `+${profile.modifier}` : `${profile.modifier}`;
    document.getElementById('dice_modifier').textContent = modText;
    document.getElementById('dice_rerolls').textContent = currentDice.rerollsRemaining;

    // Event handlers
    document.getElementById('dice_roll_area')?.addEventListener('click', performDiceRoll);
    document.getElementById('dice_roll_btn')?.addEventListener('click', performDiceRoll);
    document.getElementById('dice_close_btn')?.addEventListener('click', closeDiceModal);

    updateDiceDisplay();
}

function updateDiceDisplay() {
    document.getElementById('dice_rerolls').textContent = currentDice.rerollsRemaining;

    // Update combat log
    const logEl = document.getElementById('dice_combat_log');
    if (logEl) {
        logEl.innerHTML = currentDice.combatLog.map(entry => {
            let className = 'dice-log-entry';
            if (entry.includes('Success') || entry.includes('passed')) className += ' dice-log-success';
            if (entry.includes('Failed') || entry.includes('failed')) className += ' dice-log-fail';
            if (entry.includes('Critical') || entry.includes('CRITICAL')) className += ' dice-log-critical';
            if (entry.includes('Reroll')) className += ' dice-log-reroll';
            return `<div class="${className}">${entry}</div>`;
        }).join('');
        logEl.scrollTop = logEl.scrollHeight;
    }
}

function addDiceLogEntry(message) {
    currentDice.combatLog.push(message);
    if (currentDice.combatLog.length > 20) {
        currentDice.combatLog.shift();
    }
    updateDiceDisplay();
}

async function performDiceRoll() {
    if (currentDice.isComplete) return;

    const profile = currentDice.profile;
    const diceConfig = DICE_TYPES[profile.diceType] || DICE_TYPES['d6'];
    const diceCount = profile.diceCount || 1;

    // Roll the dice
    const results = [];
    for (let i = 0; i < diceCount; i++) {
        results.push(rollDie(diceConfig.sides));
    }

    currentDice.diceResults = results;
    currentDice.rawTotal = results.reduce((sum, val) => sum + val, 0);
    currentDice.total = currentDice.rawTotal + currentDice.modifier;

    // Animate dice roll
    const rollArea = document.getElementById('dice_roll_area');
    rollArea.innerHTML = `<div class="dice-rolling">${results.map(r => `<div class="dice-single">${r}</div>`).join('')}</div>`;

    // Log the roll
    const diceNotation = `${diceCount}${profile.diceType}`;
    const modStr = currentDice.modifier !== 0 ? (currentDice.modifier > 0 ? ` + ${currentDice.modifier}` : ` - ${Math.abs(currentDice.modifier)}`) : '';
    addDiceLogEntry(`Rolled ${diceNotation}: [${results.join(', ')}]${modStr} = ${currentDice.total}`);

    // Execute roll hook
    if (profile.onRoll) {
        await executeWithTimeout(profile.onRoll);
    }

    // Check for criticals
    currentDice.isCriticalSuccess = currentDice.rawTotal >= profile.criticalSuccess;
    currentDice.isCriticalFail = currentDice.rawTotal <= profile.criticalFail;

    // Check success/failure
    if (profile.thresholdType === 'beat') {
        currentDice.isSuccess = currentDice.total > currentDice.threshold;
    } else {
        currentDice.isSuccess = currentDice.total >= currentDice.threshold;
    }

    // Show result display
    setTimeout(() => {
        showDiceResult();
    }, 600);
}

async function showDiceResult() {
    const profile = currentDice.profile;
    const resultDisplay = document.getElementById('dice_result_display');
    const totalEl = document.getElementById('dice_result_total');
    const breakdownEl = document.getElementById('dice_result_breakdown');
    const actionsEl = document.getElementById('dice_actions');

    resultDisplay.style.display = 'block';
    totalEl.textContent = currentDice.total;

    // Style based on result
    let resultClass = currentDice.isSuccess ? 'success' : 'fail';
    if (currentDice.isCriticalSuccess) resultClass = 'critical-success';
    if (currentDice.isCriticalFail) resultClass = 'critical-fail';
    totalEl.className = 'dice-result-total ' + resultClass;

    // Update dice visuals for crits
    const diceEls = document.querySelectorAll('.dice-single');
    if (currentDice.isCriticalSuccess) {
        diceEls.forEach(el => el.classList.add('critical-success'));
    } else if (currentDice.isCriticalFail) {
        diceEls.forEach(el => el.classList.add('critical-fail'));
    }

    // Breakdown text
    const thresholdText = profile.thresholdType === 'beat' ? `needed > ${currentDice.threshold}` : `needed ≥ ${currentDice.threshold}`;
    breakdownEl.textContent = thresholdText;

    // Handle criticals
    if (currentDice.isCriticalSuccess) {
        addDiceLogEntry('CRITICAL SUCCESS!');
        if (profile.onCriticalSuccess) {
            await executeWithTimeout(profile.onCriticalSuccess);
        }
    } else if (currentDice.isCriticalFail) {
        addDiceLogEntry('CRITICAL FAILURE!');
        if (profile.onCriticalFail) {
            await executeWithTimeout(profile.onCriticalFail);
        }
    }

    // Handle success/fail hooks
    if (currentDice.isSuccess) {
        addDiceLogEntry('Roll passed!');
        if (profile.onSuccess) {
            await executeWithTimeout(profile.onSuccess);
        }
    } else {
        addDiceLogEntry('Roll failed...');
        if (profile.onFail) {
            await executeWithTimeout(profile.onFail);
        }
    }

    // Update actions - show reroll button if available
    if (currentDice.rerollsRemaining > 0 && !currentDice.isSuccess) {
        const rerollCostText = profile.rerollCost === 'none' ? '' : ` (costs 1 ${profile.rerollCost})`;
        actionsEl.innerHTML = `
            <button id="dice_reroll_btn" class="mazemaster-dice-btn dice-btn-reroll">
                <i class="fa-solid fa-rotate"></i> Reroll${rerollCostText}
            </button>
            <button id="dice_accept_btn" class="mazemaster-dice-btn dice-btn-close">
                <i class="fa-solid fa-check"></i> Accept
            </button>
        `;
        document.getElementById('dice_reroll_btn')?.addEventListener('click', handleDiceReroll);
        document.getElementById('dice_accept_btn')?.addEventListener('click', finalizeDiceResult);
    } else {
        // Auto-finalize if no rerolls or success
        setTimeout(() => finalizeDiceResult(), 1000);
    }
}

async function handleDiceReroll() {
    const profile = currentDice.profile;

    // Check reroll cost
    if (profile.rerollCost !== 'none') {
        const itemKey = profile.rerollCost; // 'strike', 'key', etc.
        if (currentMaze.isOpen && currentMaze.inventory) {
            if ((currentMaze.inventory[itemKey] || 0) <= 0) {
                addDiceLogEntry(`Not enough ${itemKey}s to reroll!`);
                return;
            }
            currentMaze.inventory[itemKey]--;
            addDiceLogEntry(`Spent 1 ${itemKey} to reroll`);
        }
    }

    currentDice.rerollsRemaining--;
    addDiceLogEntry(`Rerolling... (${currentDice.rerollsRemaining} left)`);

    // Execute reroll hook
    if (profile.onReroll) {
        await executeWithTimeout(profile.onReroll);
    }

    // Reset result display
    document.getElementById('dice_result_display').style.display = 'none';

    // Perform new roll
    await performDiceRoll();
}

async function finalizeDiceResult() {
    currentDice.isComplete = true;
    const profile = currentDice.profile;

    const actionsEl = document.getElementById('dice_actions');
    actionsEl.style.display = 'none';

    const finalPanel = document.getElementById('dice_final_panel');
    const finalText = document.getElementById('dice_final_text');

    if (currentDice.isSuccess) {
        if (currentDice.isCriticalSuccess) {
            finalText.textContent = 'CRITICAL SUCCESS!';
        } else {
            finalText.textContent = 'Success!';
        }
        finalText.className = 'dice-final-text success';

        // Execute complete hook
        if (profile.onComplete) {
            await executeWithTimeout(profile.onComplete);
        }

        // Handle item drops if in maze (v1.8.0: filtered by item pool)
        if (currentMaze.isOpen && currentMaze.pendingEncounter) {
            if (isItemInPool('key') && Math.random() * 100 < (profile.keyDropChance || 25)) {
                addToInventory('key');
                addDiceLogEntry('You found a Key!');
            }
            if (isItemInPool('strike') && Math.random() * 100 < (profile.strikeDropChance || 12)) {
                addToInventory('strike');
                addDiceLogEntry('You found a Strike!');
            }
            if (isItemInPool('healingPotion') && Math.random() * 100 < (profile.healingPotionDropChance || 15)) {
                addToInventory('healingPotion');
                addDiceLogEntry('You found a Healing Potion!');
            }
        }

        // Store result
        lastResults.dice = lastResults.dice || {};
        lastResults.dice[currentDice.profileName] = {
            result: 'success',
            total: currentDice.total,
            rawTotal: currentDice.rawTotal,
            isCritical: currentDice.isCriticalSuccess,
            timestamp: Date.now(),
        };
    } else {
        if (currentDice.isCriticalFail) {
            finalText.textContent = 'CRITICAL FAILURE!';
        } else {
            finalText.textContent = 'Failed...';
        }
        finalText.className = 'dice-final-text fail';

        // Execute lose hook
        if (profile.onLose) {
            await executeWithTimeout(profile.onLose);
        }

        // Apply maze HP damage
        let playerDied = false;
        if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
            let damage = profile.damage || 20;
            if (currentDice.isCriticalFail) {
                damage = Math.round(damage * 1.5); // Extra damage on crit fail
            }
            const mazeMultiplier = currentMaze.profile?.battlebarDamageMultiplier ?? 1.0;
            const actualDamage = Math.round(damage * mazeMultiplier);
            const survived = await applyDamage(actualDamage, 'dice');
            playerDied = !survived;
        }

        // Store result
        lastResults.dice = lastResults.dice || {};
        lastResults.dice[currentDice.profileName] = {
            result: 'fail',
            total: currentDice.total,
            rawTotal: currentDice.rawTotal,
            isCritical: currentDice.isCriticalFail,
            timestamp: Date.now(),
        };

        // If player died, close modal and let death handling take over
        if (playerDied) {
            closeDiceModal();
            return;
        }
    }

    finalPanel.style.display = 'block';
}

async function closeDiceModal() {
    const modal = document.getElementById('mazemaster_dice_modal');
    if (modal) modal.remove();

    const wasSuccess = currentDice.isSuccess;
    currentDice.isOpen = false;

    // Handle maze integration
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasSuccess) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);

                    // v2.0.5: Grant XP for successful dice encounter
                    const diceXp = getXpReward('combatVictory');
                    if (diceXp > 0) {
                        const xpResult = await grantXp(diceXp, 'dice');
                        if (xpResult.leveledUp) {
                            addMazeLogMessage(`Level Up! Now level ${xpResult.newLevel}!`, 'success');
                        }
                        addMazeLogMessage(`Dice victory! +${diceXp} XP`, 'info');
                    }

                    if (encounterType === 'exit_dice') {
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeDiceModal:', err);
        }

        // Always ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

// =============================================================================
// STEALTH ENCOUNTER MODAL & GAME LOGIC
// =============================================================================

function getStealthModalHtml() {
    return `
        <div id="mazemaster_stealth_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-stealth-container">
                <div id="stealth_main_title" class="mazemaster-stealth-main-title">Stealth</div>
                <div id="stealth_description" class="mazemaster-stealth-description"></div>

                <div class="mazemaster-stealth-progress">
                    <div class="stealth-sections">
                        <span>Progress: </span>
                        <span id="stealth_section_display"></span>
                    </div>
                </div>

                <div class="mazemaster-stealth-detection">
                    <div class="stealth-detection-label">
                        <i class="fa-solid fa-eye"></i>
                        <span>Detection</span>
                    </div>
                    <div class="stealth-detection-bar">
                        <div class="stealth-detection-fill" id="stealth_detection_bar"></div>
                    </div>
                    <div class="stealth-detection-text">
                        <span id="stealth_detection_value">0</span>/<span id="stealth_detection_max">100</span>
                    </div>
                </div>

                <div class="mazemaster-stealth-guard" id="stealth_guard_area">
                    <i class="fa-solid fa-user-shield fa-3x"></i>
                    <div id="stealth_guard_name">Guard</div>
                    <div id="stealth_guard_status">Unaware</div>
                </div>

                <div class="mazemaster-stealth-log" id="stealth_combat_log">
                    <div class="stealth-log-entry">You begin your infiltration...</div>
                </div>

                <div class="mazemaster-stealth-actions" id="stealth_actions">
                    <button id="stealth_advance_btn" class="mazemaster-stealth-btn stealth-btn-advance" title="Move forward - risky but progresses">
                        <i class="fa-solid fa-forward"></i> Advance
                    </button>
                    <button id="stealth_hide_btn" class="mazemaster-stealth-btn stealth-btn-hide" title="Stay hidden - reduces detection">
                        <i class="fa-solid fa-mask"></i> Hide
                    </button>
                    <button id="stealth_distract_btn" class="mazemaster-stealth-btn stealth-btn-distract" title="Create a distraction - may reduce detection significantly">
                        <i class="fa-solid fa-volume-high"></i> Distract
                    </button>
                    <button id="stealth_wait_btn" class="mazemaster-stealth-btn stealth-btn-wait" title="Wait patiently - small detection reduction">
                        <i class="fa-solid fa-hourglass-half"></i> Wait
                    </button>
                </div>

                <div class="mazemaster-stealth-result" id="stealth_result_panel" style="display: none;">
                    <div id="stealth_result_text" class="stealth-result-text"></div>
                    <button id="stealth_close_btn" class="mazemaster-stealth-btn stealth-btn-close">
                        <i class="fa-solid fa-check"></i> Close
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getStealthStyles() {
    return `
        .mazemaster-stealth-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 25px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1a 100%);
            border-radius: 15px;
            border: 2px solid #1abc9c;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(26, 188, 156, 0.3);
            width: 450px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .mazemaster-stealth-main-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .mazemaster-stealth-description {
            font-size: 0.9em;
            color: #aaa;
            text-align: center;
            max-width: 380px;
        }

        .mazemaster-stealth-progress {
            width: 100%;
            text-align: center;
        }

        .stealth-sections {
            font-size: 1.1em;
            color: #1abc9c;
        }

        #stealth_section_display {
            font-weight: bold;
        }

        .mazemaster-stealth-detection {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stealth-detection-label {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #e74c3c;
            min-width: 90px;
        }

        .stealth-detection-bar {
            flex: 1;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
        }

        .stealth-detection-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #27ae60, #f39c12, #e74c3c);
            transition: width 0.3s ease;
        }

        .stealth-detection-text {
            min-width: 60px;
            text-align: right;
            color: #ddd;
        }

        .mazemaster-stealth-guard {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            width: 100%;
        }

        .mazemaster-stealth-guard i {
            color: #7f8c8d;
            transition: all 0.3s ease;
        }

        .mazemaster-stealth-guard.alert i {
            color: #f39c12;
            animation: guard-alert 1s ease infinite;
        }

        .mazemaster-stealth-guard.detected i {
            color: #e74c3c;
            animation: guard-detected 0.5s ease infinite;
        }

        @keyframes guard-alert {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        @keyframes guard-detected {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        #stealth_guard_name {
            font-size: 1.1em;
            font-weight: bold;
            color: #ddd;
        }

        #stealth_guard_status {
            font-size: 0.9em;
            color: #888;
        }

        #stealth_guard_status.alert { color: #f39c12; }
        #stealth_guard_status.detected { color: #e74c3c; font-weight: bold; }

        .mazemaster-stealth-log {
            width: 100%;
            height: 80px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.85em;
            color: #ccc;
        }

        .stealth-log-entry { padding: 2px 0; }
        .stealth-log-success { color: #1abc9c; }
        .stealth-log-fail { color: #e74c3c; }
        .stealth-log-warning { color: #f39c12; }
        .stealth-log-action { color: #3498db; }

        .mazemaster-stealth-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 100%;
        }

        .mazemaster-stealth-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .mazemaster-stealth-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .mazemaster-stealth-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .stealth-btn-advance {
            background: linear-gradient(135deg, #1abc9c 0%, #16a085 100%);
            color: white;
        }

        .stealth-btn-hide {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }

        .stealth-btn-distract {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
        }

        .stealth-btn-wait {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .stealth-btn-close {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 15px 40px;
        }

        .mazemaster-stealth-result {
            text-align: center;
            padding: 15px;
        }

        .stealth-result-text {
            font-size: 1.6em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .stealth-result-text.success { color: #1abc9c; }
        .stealth-result-text.fail { color: #e74c3c; }
    `;
}

function startStealth(profileName) {
    console.log('[MazeMaster] startStealth called with profile:', profileName);
    const profile = getStealthProfile(profileName);
    console.log('[MazeMaster] Retrieved stealth profile:', profile);
    if (!profile) {
        console.error(`[MazeMaster] Stealth profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    console.log('[MazeMaster] Initializing stealth state with config:', {
        sectionsToPass: profile.sectionsToPass,
        detectionThreshold: profile.detectionThreshold
    });
    // Initialize stealth state
    currentStealth = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        currentSection: 0,
        sectionsToPass: profile.sectionsToPass,
        detection: 0,
        detectionThreshold: profile.detectionThreshold,
        isSuccess: false,
        isCaught: false,
        isComplete: false,
        actionsTaken: 0,
        combatLog: ['You begin your infiltration...'],
    };
    console.log('[MazeMaster] currentStealth initialized:', currentStealth);

    // Pause maze if active
    if (currentMaze.isOpen) {
        currentMaze.isPaused = true;
        console.log('[MazeMaster] Maze paused for stealth');
    }

    console.log('[MazeMaster] Calling showStealthModal...');
    showStealthModal();

    // Execute start hook
    if (profile.onStart) {
        executeWithTimeout(profile.onStart);
    }

    console.log(`[MazeMaster] Stealth started: ${profileName}`);
    return { success: true };
}

function showStealthModal() {
    console.log('[MazeMaster] showStealthModal called');
    const existing = document.getElementById('mazemaster_stealth_modal');
    if (existing) {
        console.log('[MazeMaster] Removing existing stealth modal');
        existing.remove();
    }

    if (!document.getElementById('mazemaster_stealth_styles')) {
        console.log('[MazeMaster] Adding stealth styles to document');
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_stealth_styles';
        styleEl.textContent = getStealthStyles();
        document.head.appendChild(styleEl);
    }

    console.log('[MazeMaster] Inserting stealth modal HTML');
    document.body.insertAdjacentHTML('beforeend', getStealthModalHtml());

    const modalEl = document.getElementById('mazemaster_stealth_modal');
    console.log('[MazeMaster] Stealth modal element after insert:', modalEl);

    const profile = currentStealth.profile;
    console.log('[MazeMaster] Updating stealth UI with profile:', profile?.name);

    // Update UI
    const titleEl = document.getElementById('stealth_main_title');
    const descEl = document.getElementById('stealth_description');
    console.log('[MazeMaster] Stealth UI elements - title:', titleEl, 'desc:', descEl);

    if (titleEl) titleEl.textContent = profile.mainTitle || 'Stealth';
    if (descEl) descEl.textContent = profile.description || '';
    document.getElementById('stealth_guard_name').textContent = profile.guardName || 'Guard';
    document.getElementById('stealth_detection_max').textContent = currentStealth.detectionThreshold;

    // Event handlers
    console.log('[MazeMaster] Attaching stealth event handlers');
    document.getElementById('stealth_advance_btn')?.addEventListener('click', () => handleStealthAction('advance'));
    document.getElementById('stealth_hide_btn')?.addEventListener('click', () => handleStealthAction('hide'));
    document.getElementById('stealth_distract_btn')?.addEventListener('click', () => handleStealthAction('distract'));
    document.getElementById('stealth_wait_btn')?.addEventListener('click', () => handleStealthAction('wait'));
    document.getElementById('stealth_close_btn')?.addEventListener('click', closeStealthModal);

    console.log('[MazeMaster] Calling updateStealthDisplay');
    updateStealthDisplay();
    console.log('[MazeMaster] showStealthModal complete');
}

function updateStealthDisplay() {
    // Update section progress
    const sectionDisplay = document.getElementById('stealth_section_display');
    if (sectionDisplay) {
        let sections = '';
        for (let i = 0; i < currentStealth.sectionsToPass; i++) {
            if (i < currentStealth.currentSection) {
                sections += '● ';
            } else {
                sections += '○ ';
            }
        }
        sectionDisplay.textContent = sections.trim();
    }

    // Update detection bar
    const detectionBar = document.getElementById('stealth_detection_bar');
    const detectionValue = document.getElementById('stealth_detection_value');
    const detectionPercent = (currentStealth.detection / currentStealth.detectionThreshold) * 100;
    if (detectionBar) detectionBar.style.width = `${Math.min(detectionPercent, 100)}%`;
    if (detectionValue) detectionValue.textContent = Math.round(currentStealth.detection);

    // Update guard status
    const guardArea = document.getElementById('stealth_guard_area');
    const guardStatus = document.getElementById('stealth_guard_status');
    if (guardArea && guardStatus) {
        guardArea.classList.remove('alert', 'detected');
        if (detectionPercent >= 80) {
            guardArea.classList.add('detected');
            guardStatus.textContent = 'ALERT!';
            guardStatus.className = 'detected';
        } else if (detectionPercent >= 50) {
            guardArea.classList.add('alert');
            guardStatus.textContent = 'Suspicious';
            guardStatus.className = 'alert';
        } else if (detectionPercent >= 25) {
            guardStatus.textContent = 'Cautious';
            guardStatus.className = '';
        } else {
            guardStatus.textContent = 'Unaware';
            guardStatus.className = '';
        }
    }

    // Update combat log
    const logEl = document.getElementById('stealth_combat_log');
    if (logEl) {
        logEl.innerHTML = currentStealth.combatLog.map(entry => {
            let className = 'stealth-log-entry';
            if (entry.includes('success') || entry.includes('passed') || entry.includes('clear')) className += ' stealth-log-success';
            if (entry.includes('spotted') || entry.includes('caught') || entry.includes('failed')) className += ' stealth-log-fail';
            if (entry.includes('suspicion') || entry.includes('alert') || entry.includes('detection')) className += ' stealth-log-warning';
            if (entry.includes('You ')) className += ' stealth-log-action';
            return `<div class="${className}">${entry}</div>`;
        }).join('');
        logEl.scrollTop = logEl.scrollHeight;
    }
}

function addStealthLogEntry(message) {
    currentStealth.combatLog.push(message);
    if (currentStealth.combatLog.length > 30) {
        currentStealth.combatLog.shift();
    }
    updateStealthDisplay();
}

async function handleStealthAction(action) {
    if (currentStealth.isComplete) return;

    const profile = currentStealth.profile;
    currentStealth.actionsTaken++;
    let success = false;
    let detectionChange = 0;

    switch (action) {
        case 'advance':
            success = Math.random() * 100 < profile.advanceSuccessChance;
            if (success) {
                currentStealth.currentSection++;
                addStealthLogEntry('You advance quietly... clear!');
                if (profile.onAdvance) await executeWithTimeout(profile.onAdvance);
            } else {
                detectionChange = profile.baseDetectionRate;
                addStealthLogEntry(`You made noise! (+${detectionChange} detection)`);
                if (profile.onDetectionIncrease) await executeWithTimeout(profile.onDetectionIncrease);
            }
            break;

        case 'hide':
            detectionChange = -profile.hideRecovery;
            addStealthLogEntry(`You hide in the shadows... (-${profile.hideRecovery} detection)`);
            if (profile.onHide) await executeWithTimeout(profile.onHide);
            success = true;
            break;

        case 'distract':
            success = Math.random() * 100 < profile.distractSuccessChance;
            if (success) {
                detectionChange = -profile.distractReduction;
                addStealthLogEntry(`Distraction worked! (-${profile.distractReduction} detection)`);
                if (profile.onDistract) await executeWithTimeout(profile.onDistract);
            } else {
                detectionChange = Math.round(profile.baseDetectionRate * 0.5);
                addStealthLogEntry(`Distraction failed! (+${detectionChange} detection)`);
                if (profile.onDetectionIncrease) await executeWithTimeout(profile.onDetectionIncrease);
            }
            break;

        case 'wait':
            detectionChange = -profile.waitRecovery;
            addStealthLogEntry(`You wait patiently... (-${profile.waitRecovery} detection)`);
            if (profile.onWait) await executeWithTimeout(profile.onWait);
            success = true;
            break;
    }

    // Apply detection change
    currentStealth.detection = Math.max(0, currentStealth.detection + detectionChange);

    updateStealthDisplay();

    // Check for caught
    if (currentStealth.detection >= currentStealth.detectionThreshold) {
        await handleStealthCaught();
        return;
    }

    // Check for success
    if (currentStealth.currentSection >= currentStealth.sectionsToPass) {
        await handleStealthSuccess();
    }
}

async function handleStealthSuccess() {
    currentStealth.isComplete = true;
    currentStealth.isSuccess = true;

    addStealthLogEntry('Infiltration successful!');

    const profile = currentStealth.profile;

    // Execute complete hook
    if (profile.onComplete) {
        await executeWithTimeout(profile.onComplete);
    }

    // Handle item drops if in maze (v1.8.0: filtered by item pool)
    if (currentMaze.isOpen && currentMaze.pendingEncounter) {
        if (isItemInPool('key') && Math.random() * 100 < (profile.keyDropChance || 20)) {
            addToInventory('key');
            addStealthLogEntry('You found a Key!');
        }
        if (isItemInPool('stealth') && Math.random() * 100 < (profile.stealthDropChance || 15)) {
            addToInventory('stealth');
            addStealthLogEntry('You found a Stealth item!');
        }
        if (isItemInPool('healingPotion') && Math.random() * 100 < (profile.healingPotionDropChance || 15)) {
            addToInventory('healingPotion');
            addStealthLogEntry('You found a Healing Potion!');
        }
    }

    // Store result
    lastResults.stealth = lastResults.stealth || {};
    lastResults.stealth[currentStealth.profileName] = {
        result: 'success',
        actionsTaken: currentStealth.actionsTaken,
        finalDetection: currentStealth.detection,
        timestamp: Date.now(),
    };

    showStealthResult();
}

async function handleStealthCaught() {
    currentStealth.isComplete = true;
    currentStealth.isCaught = true;

    addStealthLogEntry('You\'ve been caught!');

    const profile = currentStealth.profile;

    // Execute caught hook
    if (profile.onCaught) {
        await executeWithTimeout(profile.onCaught);
    }

    // Apply maze HP damage
    let playerDied = false;
    if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
        const damage = profile.damage || 25;
        const mazeMultiplier = currentMaze.profile?.battlebarDamageMultiplier ?? 1.0;
        const actualDamage = Math.round(damage * mazeMultiplier);
        const survived = await applyDamage(actualDamage, 'stealth');
        playerDied = !survived;
    }

    // Store result
    lastResults.stealth = lastResults.stealth || {};
    lastResults.stealth[currentStealth.profileName] = {
        result: 'caught',
        actionsTaken: currentStealth.actionsTaken,
        finalDetection: currentStealth.detection,
        timestamp: Date.now(),
    };

    // If player died, close stealth modal and let death handling take over
    if (playerDied) {
        closeStealthModal();
        return;
    }

    showStealthResult();
}

function showStealthResult() {
    const actionsEl = document.getElementById('stealth_actions');
    const resultPanel = document.getElementById('stealth_result_panel');
    const resultText = document.getElementById('stealth_result_text');

    if (actionsEl) actionsEl.style.display = 'none';
    if (resultPanel) resultPanel.style.display = 'block';

    if (resultText) {
        if (currentStealth.isSuccess) {
            resultText.textContent = 'Infiltration Successful!';
            resultText.className = 'stealth-result-text success';
        } else {
            resultText.textContent = 'Caught!';
            resultText.className = 'stealth-result-text fail';
        }
    }
}

async function closeStealthModal() {
    const modal = document.getElementById('mazemaster_stealth_modal');
    if (modal) modal.remove();

    const wasSuccess = currentStealth.isSuccess;
    currentStealth.isOpen = false;

    // Handle maze integration
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasSuccess) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);

                    // v2.0.5: Grant XP for successful stealth encounter
                    const stealthXp = getXpReward('combatVictory'); // Use combat XP as base
                    if (stealthXp > 0) {
                        const xpResult = await grantXp(stealthXp, 'stealth');
                        if (xpResult.leveledUp) {
                            addMazeLogMessage(`Level Up! Now level ${xpResult.newLevel}!`, 'success');
                        }
                        addMazeLogMessage(`Stealth success! +${stealthXp} XP`, 'info');
                    }

                    // Heal player on successful stealth completion (skill reward)
                    if (currentMaze.hp && currentMaze.profile?.hpEnabled !== false) {
                        const healPercent = currentMaze.profile.skillEncounterHealPercent || 25;
                        const maxTotal = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
                        const healAmount = Math.floor(maxTotal * (healPercent / 100));
                        if (currentMaze.hp.current < maxTotal && healAmount > 0) {
                            await healPlayer(healAmount, false, 'Stealth success');
                            addMazeLogMessage(`Silent and deadly! Recovered ${healAmount} HP.`, 'heal');
                        }
                    }

                    if (encounterType === 'exit_stealth') {
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeStealthModal:', err);
        }

        // Always ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

// =============================================================================
// PUZZLE MODAL & GAME LOGIC
// =============================================================================

function getPuzzleModalHtml() {
    return `
        <div id="mazemaster_puzzle_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-puzzle-container">
                <div id="puzzle_main_title" class="puzzle-main-title">Puzzle</div>
                <div id="puzzle_description" class="puzzle-description"></div>

                <div class="puzzle-stats-row">
                    <div class="puzzle-stat">
                        <span class="puzzle-stat-label">Progress:</span>
                        <span id="puzzle_progress">0/0</span>
                    </div>
                    <div class="puzzle-stat">
                        <span class="puzzle-stat-label">Time:</span>
                        <span id="puzzle_timer">--</span>
                    </div>
                    <div class="puzzle-stat">
                        <span class="puzzle-stat-label">Hints:</span>
                        <span id="puzzle_hints">0</span>
                    </div>
                    <div class="puzzle-stat">
                        <span class="puzzle-stat-label">Mistakes:</span>
                        <span id="puzzle_mistakes">0/0</span>
                    </div>
                </div>

                <div class="puzzle-instruction" id="puzzle_instruction">Watch the sequence...</div>

                <div id="puzzle_grid_container" class="puzzle-grid-container">
                    <!-- Grid will be generated here -->
                </div>

                <div id="puzzle_actions" class="puzzle-actions">
                    <button id="puzzle_hint_btn" class="puzzle-btn puzzle-hint-btn">
                        <i class="fa-solid fa-lightbulb"></i> Use Hint
                    </button>
                    <button id="puzzle_reset_btn" class="puzzle-btn puzzle-reset-btn">
                        <i class="fa-solid fa-redo"></i> Show Sequence
                    </button>
                </div>

                <div id="puzzle_result_panel" class="puzzle-result-panel" style="display:none;">
                    <div id="puzzle_result_text" class="puzzle-result-text"></div>
                    <button id="puzzle_close_btn" class="puzzle-btn puzzle-close-btn">
                        <i class="fa-solid fa-check"></i> Continue
                    </button>
                </div>

                <div id="puzzle_combat_log" class="puzzle-combat-log"></div>
            </div>
        </div>
    `;
}

function getPuzzleStyles() {
    return `
        .mazemaster-puzzle-container {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            border: 2px solid #3d5a80;
            border-radius: 15px;
            padding: 25px;
            min-width: 450px;
            max-width: 550px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(61, 90, 128, 0.4);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0e0;
        }

        .puzzle-main-title {
            text-align: center;
            font-size: 1.8em;
            font-weight: bold;
            color: #9b59b6;
            text-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
            margin-bottom: 8px;
        }

        .puzzle-description {
            text-align: center;
            font-size: 0.95em;
            color: #bbb;
            margin-bottom: 15px;
            font-style: italic;
        }

        .puzzle-stats-row {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .puzzle-stat {
            text-align: center;
        }

        .puzzle-stat-label {
            color: #888;
            font-size: 0.85em;
            display: block;
        }

        .puzzle-stat span:not(.puzzle-stat-label) {
            color: #9b59b6;
            font-weight: bold;
            font-size: 1.1em;
        }

        .puzzle-instruction {
            text-align: center;
            font-size: 1.1em;
            color: #f1c40f;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(241, 196, 15, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(241, 196, 15, 0.3);
        }

        .puzzle-grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .puzzle-grid {
            display: grid;
            gap: 8px;
            padding: 15px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            border: 2px solid #3d5a80;
        }

        .puzzle-cell {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
            border: 2px solid #3d5a80;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
        }

        .puzzle-cell:hover:not(.disabled) {
            background: linear-gradient(135deg, #3d5a80 0%, #2c3e50 100%);
            transform: scale(1.05);
        }

        .puzzle-cell.highlighted {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            border-color: #bb6bd9;
            box-shadow: 0 0 20px rgba(155, 89, 182, 0.6);
            animation: puzzle-pulse 0.5s ease;
        }

        .puzzle-cell.correct {
            background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            border-color: #2ecc71;
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.5);
        }

        .puzzle-cell.wrong {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            border-color: #e74c3c;
            animation: puzzle-shake 0.3s ease;
        }

        .puzzle-cell.hint {
            background: linear-gradient(135deg, #f39c12 0%, #d68910 100%);
            border-color: #f1c40f;
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.5);
        }

        .puzzle-cell.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        @keyframes puzzle-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes puzzle-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .puzzle-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .puzzle-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .puzzle-hint-btn {
            background: linear-gradient(135deg, #f39c12 0%, #d68910 100%);
            color: white;
        }

        .puzzle-hint-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.5);
        }

        .puzzle-hint-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .puzzle-reset-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .puzzle-reset-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.5);
        }

        .puzzle-close-btn {
            background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .puzzle-close-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(39, 174, 96, 0.5);
        }

        .puzzle-result-panel {
            text-align: center;
            padding: 20px;
        }

        .puzzle-result-text {
            font-size: 1.6em;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .puzzle-result-text.success { color: #2ecc71; }
        .puzzle-result-text.fail { color: #e74c3c; }

        .puzzle-combat-log {
            max-height: 100px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            font-size: 0.9em;
        }

        .puzzle-log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .puzzle-log-entry:last-child { border-bottom: none; }
        .puzzle-log-success { color: #2ecc71; }
        .puzzle-log-fail { color: #e74c3c; }
        .puzzle-log-warning { color: #f39c12; }
        .puzzle-log-info { color: #3498db; }
    `;
}

function startPuzzle(profileName) {
    console.log('[MazeMaster] startPuzzle called with profile:', profileName);
    const profile = getPuzzleProfile(profileName);
    console.log('[MazeMaster] Retrieved puzzle profile:', profile);
    if (!profile) {
        console.error(`[MazeMaster] Puzzle profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    // Generate the puzzle sequence
    const gridSize = profile.gridSize || 3;
    const sequenceLength = profile.sequenceLength || 4;
    const sequence = [];
    const totalCells = gridSize * gridSize;

    console.log('[MazeMaster] Generating puzzle with gridSize:', gridSize, 'sequenceLength:', sequenceLength);
    for (let i = 0; i < sequenceLength; i++) {
        sequence.push(Math.floor(Math.random() * totalCells));
    }
    console.log('[MazeMaster] Generated sequence:', sequence);

    // Initialize puzzle state
    currentPuzzle = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        puzzleType: profile.puzzleType || 'sequence',
        gridSize: gridSize,
        grid: [],
        sequence: sequence,
        playerSequence: [],
        currentStep: 0,
        timeLimit: profile.timeLimit || 0,
        timeRemaining: profile.timeLimit || 0,
        timerInterval: null,
        hintsRemaining: profile.hintsAllowed || 0,
        hintsUsed: 0,
        wrongGuesses: 0,
        wrongGuessesAllowed: profile.wrongGuessesAllowed || 3,
        score: 100,
        isShowingSequence: false,
        isSuccess: false,
        isFailed: false,
        isComplete: false,
        combatLog: ['The puzzle awaits...'],
    };
    console.log('[MazeMaster] currentPuzzle initialized:', currentPuzzle);

    // Pause maze if active
    if (currentMaze.isOpen) {
        currentMaze.isPaused = true;
        console.log('[MazeMaster] Maze paused for puzzle');
    }

    console.log('[MazeMaster] Calling showPuzzleModal...');
    showPuzzleModal();

    // Execute start hook
    if (profile.onStart) {
        executeWithTimeout(profile.onStart);
    }

    console.log(`[MazeMaster] Puzzle started: ${profileName}`);
    return { success: true };
}

function showPuzzleModal() {
    console.log('[MazeMaster] showPuzzleModal called');
    const existing = document.getElementById('mazemaster_puzzle_modal');
    if (existing) {
        console.log('[MazeMaster] Removing existing puzzle modal');
        existing.remove();
    }

    if (!document.getElementById('mazemaster_puzzle_styles')) {
        console.log('[MazeMaster] Adding puzzle styles to document');
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_puzzle_styles';
        styleEl.textContent = getPuzzleStyles();
        document.head.appendChild(styleEl);
    }

    console.log('[MazeMaster] Inserting puzzle modal HTML');
    document.body.insertAdjacentHTML('beforeend', getPuzzleModalHtml());

    const modalEl = document.getElementById('mazemaster_puzzle_modal');
    console.log('[MazeMaster] Puzzle modal element after insert:', modalEl);

    const profile = currentPuzzle.profile;
    console.log('[MazeMaster] Updating puzzle UI with profile:', profile?.name);

    // Update UI
    const titleEl = document.getElementById('puzzle_main_title');
    const descEl = document.getElementById('puzzle_description');
    console.log('[MazeMaster] Puzzle UI elements - title:', titleEl, 'desc:', descEl);

    if (titleEl) titleEl.textContent = profile.mainTitle || 'Puzzle';
    if (descEl) descEl.textContent = profile.description || '';
    document.getElementById('puzzle_hints').textContent = currentPuzzle.hintsRemaining;
    document.getElementById('puzzle_mistakes').textContent = `${currentPuzzle.wrongGuesses}/${currentPuzzle.wrongGuessesAllowed}`;
    document.getElementById('puzzle_progress').textContent = `${currentPuzzle.currentStep}/${currentPuzzle.sequence.length}`;

    // Generate grid
    console.log('[MazeMaster] Generating puzzle grid');
    generatePuzzleGrid();

    // Event handlers
    console.log('[MazeMaster] Attaching puzzle event handlers');
    document.getElementById('puzzle_hint_btn')?.addEventListener('click', usePuzzleHint);
    document.getElementById('puzzle_reset_btn')?.addEventListener('click', showPuzzleSequence);
    document.getElementById('puzzle_close_btn')?.addEventListener('click', closePuzzleModal);

    // Start timer if applicable
    if (currentPuzzle.timeLimit > 0) {
        console.log('[MazeMaster] Starting puzzle timer with limit:', currentPuzzle.timeLimit);
        startPuzzleTimer();
    } else {
        document.getElementById('puzzle_timer').textContent = '∞';
    }

    // Show sequence after a brief delay
    console.log('[MazeMaster] Scheduling sequence display in 500ms');
    setTimeout(() => showPuzzleSequence(), 500);
    console.log('[MazeMaster] showPuzzleModal complete');
}

function generatePuzzleGrid() {
    const container = document.getElementById('puzzle_grid_container');
    if (!container) return;

    const gridSize = currentPuzzle.gridSize;
    const grid = document.createElement('div');
    grid.className = 'puzzle-grid';
    grid.style.gridTemplateColumns = `repeat(${gridSize}, 60px)`;

    for (let i = 0; i < gridSize * gridSize; i++) {
        const cell = document.createElement('div');
        cell.className = 'puzzle-cell';
        cell.dataset.index = i;
        cell.textContent = i + 1;
        cell.addEventListener('click', () => handlePuzzleCellClick(i));
        grid.appendChild(cell);
        currentPuzzle.grid.push(cell);
    }

    container.innerHTML = '';
    container.appendChild(grid);
}

async function showPuzzleSequence() {
    if (currentPuzzle.isComplete) return;

    currentPuzzle.isShowingSequence = true;
    const instruction = document.getElementById('puzzle_instruction');
    if (instruction) instruction.textContent = 'Watch carefully...';

    // Disable cells during sequence
    currentPuzzle.grid.forEach(cell => cell.classList.add('disabled'));

    // Show each step in the sequence
    for (let i = 0; i < currentPuzzle.sequence.length; i++) {
        const cellIndex = currentPuzzle.sequence[i];
        const cell = currentPuzzle.grid[cellIndex];

        await new Promise(resolve => setTimeout(resolve, 600));
        cell.classList.add('highlighted');

        await new Promise(resolve => setTimeout(resolve, 400));
        cell.classList.remove('highlighted');
    }

    await new Promise(resolve => setTimeout(resolve, 300));

    currentPuzzle.isShowingSequence = false;
    if (instruction) instruction.textContent = 'Repeat the sequence!';

    // Enable cells
    currentPuzzle.grid.forEach(cell => cell.classList.remove('disabled'));

    addPuzzleLogEntry('Sequence shown. Your turn!');
}

function handlePuzzleCellClick(index) {
    if (currentPuzzle.isComplete || currentPuzzle.isShowingSequence) return;

    const cell = currentPuzzle.grid[index];
    const expectedIndex = currentPuzzle.sequence[currentPuzzle.currentStep];
    const profile = currentPuzzle.profile;

    if (index === expectedIndex) {
        // Correct!
        cell.classList.add('correct');
        setTimeout(() => cell.classList.remove('correct'), 300);

        currentPuzzle.currentStep++;
        currentPuzzle.playerSequence.push(index);

        document.getElementById('puzzle_progress').textContent =
            `${currentPuzzle.currentStep}/${currentPuzzle.sequence.length}`;

        addPuzzleLogEntry(`Step ${currentPuzzle.currentStep} correct!`);

        if (profile.onCorrectMove) {
            executeWithTimeout(profile.onCorrectMove);
        }

        // Check for win
        if (currentPuzzle.currentStep >= currentPuzzle.sequence.length) {
            handlePuzzleSuccess();
        }
    } else {
        // Wrong!
        cell.classList.add('wrong');
        setTimeout(() => cell.classList.remove('wrong'), 300);

        currentPuzzle.wrongGuesses++;
        currentPuzzle.score -= (profile.wrongGuessPenalty || 10);

        document.getElementById('puzzle_mistakes').textContent =
            `${currentPuzzle.wrongGuesses}/${currentPuzzle.wrongGuessesAllowed}`;

        addPuzzleLogEntry(`Wrong! Mistakes: ${currentPuzzle.wrongGuesses}/${currentPuzzle.wrongGuessesAllowed}`);

        if (profile.onWrongMove) {
            executeWithTimeout(profile.onWrongMove);
        }

        // Check for fail
        if (currentPuzzle.wrongGuesses >= currentPuzzle.wrongGuessesAllowed) {
            handlePuzzleFail();
        }
    }
}

function usePuzzleHint() {
    if (currentPuzzle.isComplete || currentPuzzle.hintsRemaining <= 0) return;

    currentPuzzle.hintsRemaining--;
    currentPuzzle.hintsUsed++;
    currentPuzzle.score -= (currentPuzzle.profile.hintPenalty || 10);

    document.getElementById('puzzle_hints').textContent = currentPuzzle.hintsRemaining;

    // Highlight the next correct cell briefly
    const nextIndex = currentPuzzle.sequence[currentPuzzle.currentStep];
    const cell = currentPuzzle.grid[nextIndex];
    cell.classList.add('hint');
    setTimeout(() => cell.classList.remove('hint'), 1000);

    addPuzzleLogEntry(`Hint used! ${currentPuzzle.hintsRemaining} remaining.`);

    if (currentPuzzle.profile.onHint) {
        executeWithTimeout(currentPuzzle.profile.onHint);
    }

    // Disable button if no hints left
    if (currentPuzzle.hintsRemaining <= 0) {
        const btn = document.getElementById('puzzle_hint_btn');
        if (btn) btn.disabled = true;
    }
}

function startPuzzleTimer() {
    const timerEl = document.getElementById('puzzle_timer');

    currentPuzzle.timerInterval = setInterval(() => {
        currentPuzzle.timeRemaining--;

        if (timerEl) {
            const mins = Math.floor(currentPuzzle.timeRemaining / 60);
            const secs = currentPuzzle.timeRemaining % 60;
            timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;

            if (currentPuzzle.timeRemaining <= 10) {
                timerEl.style.color = '#e74c3c';
            }
        }

        if (currentPuzzle.timeRemaining <= 0) {
            clearInterval(currentPuzzle.timerInterval);
            addPuzzleLogEntry('Time\'s up!');
            handlePuzzleFail();
        }
    }, 1000);
}

async function handlePuzzleSuccess() {
    currentPuzzle.isComplete = true;
    currentPuzzle.isSuccess = true;

    if (currentPuzzle.timerInterval) {
        clearInterval(currentPuzzle.timerInterval);
    }

    addPuzzleLogEntry('Puzzle solved!');

    const profile = currentPuzzle.profile;

    // Execute complete hook
    if (profile.onComplete) {
        await executeWithTimeout(profile.onComplete);
    }

    // Handle item drops if in maze (v1.8.0: filtered by item pool)
    if (currentMaze.isOpen && currentMaze.pendingEncounter) {
        if (isItemInPool('key') && Math.random() * 100 < (profile.keyDropChance || 20)) {
            addToInventory('key');
            addPuzzleLogEntry('You found a Key!');
        }
        if (isItemInPool('stealth') && Math.random() * 100 < (profile.stealthDropChance || 15)) {
            addToInventory('stealth');
            addPuzzleLogEntry('You found a Stealth item!');
        }
        if (isItemInPool('healingPotion') && Math.random() * 100 < (profile.healingPotionDropChance || 15)) {
            addToInventory('healingPotion');
            addPuzzleLogEntry('You found a Healing Potion!');
        }
    }

    // Store result
    lastResults.puzzle = lastResults.puzzle || {};
    lastResults.puzzle[currentPuzzle.profileName] = {
        result: 'success',
        score: currentPuzzle.score,
        hintsUsed: currentPuzzle.hintsUsed,
        wrongGuesses: currentPuzzle.wrongGuesses,
        timeRemaining: currentPuzzle.timeRemaining,
        timestamp: Date.now(),
    };

    showPuzzleResult();
}

async function handlePuzzleFail() {
    currentPuzzle.isComplete = true;
    currentPuzzle.isFailed = true;

    if (currentPuzzle.timerInterval) {
        clearInterval(currentPuzzle.timerInterval);
    }

    addPuzzleLogEntry('Puzzle failed!');

    const profile = currentPuzzle.profile;

    // Execute fail hook - STScript handles any damage/consequences
    if (profile.onFail) {
        await executeWithTimeout(profile.onFail);
    }

    // Store result
    lastResults.puzzle = lastResults.puzzle || {};
    lastResults.puzzle[currentPuzzle.profileName] = {
        result: 'fail',
        score: currentPuzzle.score,
        hintsUsed: currentPuzzle.hintsUsed,
        wrongGuesses: currentPuzzle.wrongGuesses,
        timestamp: Date.now(),
    };

    showPuzzleResult();
}

function showPuzzleResult() {
    const actionsEl = document.getElementById('puzzle_actions');
    const resultPanel = document.getElementById('puzzle_result_panel');
    const resultText = document.getElementById('puzzle_result_text');
    const instruction = document.getElementById('puzzle_instruction');

    if (actionsEl) actionsEl.style.display = 'none';
    if (instruction) instruction.style.display = 'none';
    if (resultPanel) resultPanel.style.display = 'block';

    // Disable all cells
    currentPuzzle.grid.forEach(cell => cell.classList.add('disabled'));

    if (resultText) {
        if (currentPuzzle.isSuccess) {
            resultText.textContent = currentPuzzle.profile.successMessage || 'Puzzle Solved!';
            resultText.className = 'puzzle-result-text success';
        } else {
            resultText.textContent = currentPuzzle.profile.failMessage || 'Puzzle Failed!';
            resultText.className = 'puzzle-result-text fail';
        }
    }
}

function addPuzzleLogEntry(message) {
    currentPuzzle.combatLog.push(message);
    if (currentPuzzle.combatLog.length > 20) {
        currentPuzzle.combatLog.shift();
    }

    const logEl = document.getElementById('puzzle_combat_log');
    if (logEl) {
        logEl.innerHTML = currentPuzzle.combatLog.map(entry => {
            let className = 'puzzle-log-entry';
            if (entry.includes('correct') || entry.includes('solved') || entry.includes('found')) className += ' puzzle-log-success';
            if (entry.includes('Wrong') || entry.includes('failed') || entry.includes('Time')) className += ' puzzle-log-fail';
            if (entry.includes('Hint')) className += ' puzzle-log-warning';
            if (entry.includes('turn') || entry.includes('shown')) className += ' puzzle-log-info';
            return `<div class="${className}">${entry}</div>`;
        }).join('');
        logEl.scrollTop = logEl.scrollHeight;
    }
}

async function closePuzzleModal() {
    if (currentPuzzle.timerInterval) {
        clearInterval(currentPuzzle.timerInterval);
    }

    const modal = document.getElementById('mazemaster_puzzle_modal');
    if (modal) modal.remove();

    const wasSuccess = currentPuzzle.isSuccess;
    currentPuzzle.isOpen = false;

    // v2.0.4: Debug logging for puzzle XP issues
    console.log('[MazeMaster] closePuzzleModal:', {
        wasSuccess,
        mazeIsOpen: currentMaze.isOpen,
        pendingEncounter: currentMaze.pendingEncounter,
    });

    // Handle maze integration
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasSuccess) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);

                    // v2.0.4: Award XP for solving puzzle (moved from v2.0.3)
                    try {
                        const puzzleXp = getXpReward('puzzleSolved');
                        console.log('[MazeMaster] Awarding puzzle XP:', puzzleXp);
                        const xpResult = await grantXp(puzzleXp, 'puzzle');
                        addMazeLogMessage(`Puzzle solved! +${puzzleXp} XP`, 'success');
                        if (xpResult?.leveledUp) {
                            addMazeLogMessage(`Level Up! Now level ${xpResult.newLevel}!`, 'success');
                        }
                    } catch (e) {
                        console.error('[MazeMaster] Puzzle XP grant error:', e);
                    }

                    // Heal player on successful puzzle completion (skill reward)
                    if (currentMaze.hp && currentMaze.profile?.hpEnabled !== false) {
                        const healPercent = currentMaze.profile.skillEncounterHealPercent || 25;
                        const maxTotal = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
                        const healAmount = Math.floor(maxTotal * (healPercent / 100));
                        if (currentMaze.hp.current < maxTotal && healAmount > 0) {
                            await healPlayer(healAmount, false, 'Puzzle success');
                            addMazeLogMessage(`Brilliant mind! Recovered ${healAmount} HP.`, 'heal');
                        }
                    }

                    if (encounterType === 'exit_puzzle') {
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closePuzzleModal:', err);
        }

        // Always ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;

        // v2.0.3: Reset minion display back to main minion or narrator
        const profile = currentMaze.profile;
        if (profile?.mainMinion) {
            const mainMinion = getMinion(profile.mainMinion);
            if (mainMinion) {
                currentMaze.currentMinion = {
                    name: currentMaze.mainMinionAlias || mainMinion.name,
                    imagePath: mainMinion.imagePath,
                    message: wasSuccess ? 'Well done! That puzzle was no match for you.' : 'The puzzle proved too difficult this time...',
                };
            }
        } else {
            // Fallback to narrator
            currentMaze.currentMinion = {
                name: 'Narrator',
                imagePath: '',
                message: wasSuccess ? 'The puzzle has been solved.' : 'The puzzle remains unsolved.',
            };
        }
        updateMazeHero();
    }
}

// =============================================================================
// NEGOTIATION MODAL & GAME LOGIC
// =============================================================================

function getNegotiationModalHtml() {
    return `
        <div id="mazemaster_negotiation_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-negotiate-container">
                <div id="negotiate_main_title" class="negotiate-main-title">Negotiation</div>
                <div id="negotiate_description" class="negotiate-description"></div>

                <div class="negotiate-npc-area">
                    <div class="negotiate-npc-name" id="negotiate_npc_name">NPC</div>
                    <div class="negotiate-disposition" id="negotiate_disposition">Neutral</div>
                </div>

                <div class="negotiate-stats-row">
                    <div class="negotiate-stat">
                        <span class="negotiate-stat-label">Favor:</span>
                        <div class="negotiate-favor-bar-container">
                            <div class="negotiate-favor-bar" id="negotiate_favor_bar"></div>
                        </div>
                        <span id="negotiate_favor_value">50</span>/<span id="negotiate_favor_max">75</span>
                    </div>
                    <div class="negotiate-stat">
                        <span class="negotiate-stat-label">Turns:</span>
                        <span id="negotiate_turns">0/0</span>
                    </div>
                </div>

                <div id="negotiate_actions" class="negotiate-actions">
                    <button id="negotiate_persuade_btn" class="negotiate-btn negotiate-persuade-btn">
                        <i class="fa-solid fa-comment"></i> Persuade
                    </button>
                    <button id="negotiate_intimidate_btn" class="negotiate-btn negotiate-intimidate-btn">
                        <i class="fa-solid fa-hand-fist"></i> Intimidate
                    </button>
                    <button id="negotiate_flatter_btn" class="negotiate-btn negotiate-flatter-btn">
                        <i class="fa-solid fa-heart"></i> Flatter
                    </button>
                    <button id="negotiate_bribe_btn" class="negotiate-btn negotiate-bribe-btn">
                        <i class="fa-solid fa-coins"></i> Bribe
                    </button>
                    <button id="negotiate_insult_btn" class="negotiate-btn negotiate-insult-btn" style="display:none;">
                        <i class="fa-solid fa-face-angry"></i> Insult
                    </button>
                </div>

                <div id="negotiate_result_panel" class="negotiate-result-panel" style="display:none;">
                    <div id="negotiate_result_text" class="negotiate-result-text"></div>
                    <button id="negotiate_close_btn" class="negotiate-btn negotiate-close-btn">
                        <i class="fa-solid fa-check"></i> Continue
                    </button>
                </div>

                <div id="negotiate_combat_log" class="negotiate-combat-log"></div>
            </div>
        </div>
    `;
}

function getNegotiationStyles() {
    return `
        .mazemaster-negotiate-container {
            background: linear-gradient(135deg, #2c1810 0%, #1a0f0a 50%, #0f0705 100%);
            border: 2px solid #8b4513;
            border-radius: 15px;
            padding: 25px;
            min-width: 450px;
            max-width: 550px;
            box-shadow: 0 0 40px rgba(139, 69, 19, 0.4);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0e0;
        }

        .negotiate-main-title {
            text-align: center;
            font-size: 1.8em;
            font-weight: bold;
            color: #daa520;
            text-shadow: 0 0 10px rgba(218, 165, 32, 0.5);
            margin-bottom: 8px;
        }

        .negotiate-description {
            text-align: center;
            font-size: 0.95em;
            color: #bbb;
            margin-bottom: 15px;
            font-style: italic;
        }

        .negotiate-npc-area {
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            margin-bottom: 15px;
            border: 1px solid #8b4513;
        }

        .negotiate-npc-name {
            font-size: 1.3em;
            font-weight: bold;
            color: #daa520;
            margin-bottom: 5px;
        }

        .negotiate-disposition {
            font-size: 1em;
            padding: 5px 15px;
            border-radius: 15px;
            display: inline-block;
        }

        .negotiate-disposition.hostile { background: #e74c3c; color: white; }
        .negotiate-disposition.unfriendly { background: #e67e22; color: white; }
        .negotiate-disposition.neutral { background: #7f8c8d; color: white; }
        .negotiate-disposition.friendly { background: #27ae60; color: white; }
        .negotiate-disposition.enthusiastic { background: #2ecc71; color: white; }

        .negotiate-stats-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .negotiate-stat {
            text-align: center;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .negotiate-stat-label {
            color: #888;
            font-size: 0.9em;
        }

        .negotiate-favor-bar-container {
            width: 150px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #555;
        }

        .negotiate-favor-bar {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c 0%, #f39c12 50%, #27ae60 100%);
            transition: width 0.3s ease;
            width: 50%;
        }

        .negotiate-actions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .negotiate-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .negotiate-persuade-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .negotiate-intimidate-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .negotiate-flatter-btn {
            background: linear-gradient(135deg, #e91e63 0%, #c2185b 100%);
            color: white;
        }

        .negotiate-bribe-btn {
            background: linear-gradient(135deg, #f39c12 0%, #d68910 100%);
            color: white;
        }

        .negotiate-insult-btn {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
            grid-column: span 2;
        }

        .negotiate-btn:hover:not(:disabled) {
            transform: scale(1.03);
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        .negotiate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .negotiate-close-btn {
            background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
            width: 100%;
        }

        .negotiate-result-panel {
            text-align: center;
            padding: 20px;
        }

        .negotiate-result-text {
            font-size: 1.6em;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .negotiate-result-text.success { color: #2ecc71; }
        .negotiate-result-text.fail { color: #e74c3c; }

        .negotiate-combat-log {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            font-size: 0.9em;
        }

        .negotiate-log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .negotiate-log-entry:last-child { border-bottom: none; }
        .negotiate-log-success { color: #2ecc71; }
        .negotiate-log-fail { color: #e74c3c; }
        .negotiate-log-warning { color: #f39c12; }
        .negotiate-log-info { color: #3498db; }
        .negotiate-log-action { color: #daa520; }
    `;
}

function startNegotiation(profileName) {
    console.log('[MazeMaster] startNegotiation called with profile:', profileName);
    const profile = getNegotiationProfile(profileName);
    console.log('[MazeMaster] Retrieved negotiation profile:', profile);
    if (!profile) {
        console.error(`[MazeMaster] Negotiation profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    console.log('[MazeMaster] Initializing negotiation state with config:', {
        startingFavor: profile.startingFavor,
        favorThreshold: profile.favorThreshold,
        turnsAllowed: profile.turnsAllowed
    });
    // Initialize negotiation state
    currentNegotiation = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        favor: profile.startingFavor || 50,
        favorThreshold: profile.favorThreshold || 75,
        turnsRemaining: profile.turnsAllowed || 5,
        turnsUsed: 0,
        lastAction: '',
        lastResult: '',
        isSuccess: false,
        isFailed: false,
        isComplete: false,
        combatLog: ['The negotiation begins...'],
    };
    console.log('[MazeMaster] currentNegotiation initialized:', currentNegotiation);

    // Pause maze if active
    if (currentMaze.isOpen) {
        currentMaze.isPaused = true;
        console.log('[MazeMaster] Maze paused for negotiation');
    }

    console.log('[MazeMaster] Calling showNegotiationModal...');
    showNegotiationModal();

    // Execute start hook
    if (profile.onStart) {
        executeWithTimeout(profile.onStart);
    }

    console.log(`[MazeMaster] Negotiation started: ${profileName}`);
    return { success: true };
}

function showNegotiationModal() {
    console.log('[MazeMaster] showNegotiationModal called');
    const existing = document.getElementById('mazemaster_negotiation_modal');
    if (existing) {
        console.log('[MazeMaster] Removing existing negotiation modal');
        existing.remove();
    }

    if (!document.getElementById('mazemaster_negotiation_styles')) {
        console.log('[MazeMaster] Adding negotiation styles to document');
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_negotiation_styles';
        styleEl.textContent = getNegotiationStyles();
        document.head.appendChild(styleEl);
    }

    console.log('[MazeMaster] Inserting negotiation modal HTML');
    document.body.insertAdjacentHTML('beforeend', getNegotiationModalHtml());

    const modalEl = document.getElementById('mazemaster_negotiation_modal');
    console.log('[MazeMaster] Negotiation modal element after insert:', modalEl);

    const profile = currentNegotiation.profile;
    console.log('[MazeMaster] Updating negotiation UI with profile:', profile?.name);

    // Update UI
    const titleEl = document.getElementById('negotiate_main_title');
    const descEl = document.getElementById('negotiate_description');
    console.log('[MazeMaster] Negotiation UI elements - title:', titleEl, 'desc:', descEl);

    if (titleEl) titleEl.textContent = profile.mainTitle || 'Negotiation';
    if (descEl) descEl.textContent = profile.description || '';
    document.getElementById('negotiate_npc_name').textContent = profile.npcName || 'NPC';
    document.getElementById('negotiate_favor_max').textContent = currentNegotiation.favorThreshold;
    document.getElementById('negotiate_turns').textContent =
        `${currentNegotiation.turnsUsed}/${profile.turnsAllowed}`;

    // Show/hide optional buttons
    if (!profile.flattery) {
        document.getElementById('negotiate_flatter_btn').style.display = 'none';
    }
    if (profile.insult) {
        document.getElementById('negotiate_insult_btn').style.display = 'flex';
    }

    // Event handlers
    console.log('[MazeMaster] Attaching negotiation event handlers');
    document.getElementById('negotiate_persuade_btn')?.addEventListener('click', () => handleNegotiationAction('persuade'));
    document.getElementById('negotiate_intimidate_btn')?.addEventListener('click', () => handleNegotiationAction('intimidate'));
    document.getElementById('negotiate_flatter_btn')?.addEventListener('click', () => handleNegotiationAction('flatter'));
    document.getElementById('negotiate_bribe_btn')?.addEventListener('click', () => handleNegotiationAction('bribe'));
    document.getElementById('negotiate_insult_btn')?.addEventListener('click', () => handleNegotiationAction('insult'));
    document.getElementById('negotiate_close_btn')?.addEventListener('click', closeNegotiationModal);

    console.log('[MazeMaster] Calling updateNegotiationDisplay');
    updateNegotiationDisplay();
    console.log('[MazeMaster] showNegotiationModal complete');
}

function updateNegotiationDisplay() {
    // Update favor bar
    const favorBar = document.getElementById('negotiate_favor_bar');
    const favorValue = document.getElementById('negotiate_favor_value');
    const favorPercent = (currentNegotiation.favor / 100) * 100;

    if (favorBar) favorBar.style.width = `${Math.min(favorPercent, 100)}%`;
    if (favorValue) favorValue.textContent = Math.round(currentNegotiation.favor);

    // Update disposition text
    const dispositionEl = document.getElementById('negotiate_disposition');
    if (dispositionEl) {
        dispositionEl.classList.remove('hostile', 'unfriendly', 'neutral', 'friendly', 'enthusiastic');

        if (currentNegotiation.favor >= 80) {
            dispositionEl.textContent = 'Enthusiastic';
            dispositionEl.classList.add('enthusiastic');
        } else if (currentNegotiation.favor >= 60) {
            dispositionEl.textContent = 'Friendly';
            dispositionEl.classList.add('friendly');
        } else if (currentNegotiation.favor >= 40) {
            dispositionEl.textContent = 'Neutral';
            dispositionEl.classList.add('neutral');
        } else if (currentNegotiation.favor >= 20) {
            dispositionEl.textContent = 'Unfriendly';
            dispositionEl.classList.add('unfriendly');
        } else {
            dispositionEl.textContent = 'Hostile';
            dispositionEl.classList.add('hostile');
        }
    }

    // Update turns
    const turnsEl = document.getElementById('negotiate_turns');
    if (turnsEl) {
        turnsEl.textContent = `${currentNegotiation.turnsUsed}/${currentNegotiation.profile.turnsAllowed}`;
    }

    // Update combat log
    const logEl = document.getElementById('negotiate_combat_log');
    if (logEl) {
        logEl.innerHTML = currentNegotiation.combatLog.map(entry => {
            let className = 'negotiate-log-entry';
            if (entry.includes('success') || entry.includes('agrees') || entry.includes('impressed')) className += ' negotiate-log-success';
            if (entry.includes('fail') || entry.includes('refuses') || entry.includes('angry')) className += ' negotiate-log-fail';
            if (entry.includes('suspicious') || entry.includes('wary')) className += ' negotiate-log-warning';
            if (entry.includes('You ')) className += ' negotiate-log-action';
            return `<div class="${className}">${entry}</div>`;
        }).join('');
        logEl.scrollTop = logEl.scrollHeight;
    }
}

function addNegotiationLogEntry(message) {
    currentNegotiation.combatLog.push(message);
    if (currentNegotiation.combatLog.length > 30) {
        currentNegotiation.combatLog.shift();
    }
    updateNegotiationDisplay();
}

async function handleNegotiationAction(action) {
    if (currentNegotiation.isComplete) return;

    const profile = currentNegotiation.profile;
    currentNegotiation.turnsUsed++;
    currentNegotiation.turnsRemaining--;
    currentNegotiation.lastAction = action;

    let favorChange = 0;
    let success = false;
    const roll = Math.random() * 100;

    switch (action) {
        case 'persuade':
            success = roll < (profile.persuadeBonus + currentNegotiation.favor * 0.3);
            if (success) {
                favorChange = 10 + Math.floor(Math.random() * 10);
                addNegotiationLogEntry(`You make a compelling argument. (+${favorChange} favor)`);
            } else {
                favorChange = -5;
                addNegotiationLogEntry(`Your words fall flat. (${favorChange} favor)`);
            }
            if (profile.onPersuade) await executeWithTimeout(profile.onPersuade);
            break;

        case 'intimidate':
            success = roll < (profile.intimidateBonus + (100 - currentNegotiation.favor) * 0.2);
            if (success) {
                favorChange = 15 + Math.floor(Math.random() * 10);
                addNegotiationLogEntry(`They seem... persuaded by your forcefulness. (+${favorChange} favor)`);
            } else {
                favorChange = -15;
                addNegotiationLogEntry(`They don't take kindly to threats. (${favorChange} favor)`);
            }
            if (profile.onIntimidate) await executeWithTimeout(profile.onIntimidate);
            break;

        case 'flatter':
            success = roll < (profile.flatterBonus + currentNegotiation.favor * 0.4);
            if (success) {
                favorChange = 8 + Math.floor(Math.random() * 8);
                addNegotiationLogEntry(`They're flattered by your words. (+${favorChange} favor)`);
            } else {
                favorChange = -3;
                addNegotiationLogEntry(`They see through your flattery. (${favorChange} favor)`);
            }
            if (profile.onFlatter) await executeWithTimeout(profile.onFlatter);
            break;

        case 'bribe':
            const bribeCost = profile.bribeCost || 'key';
            const hasItem = currentMaze.isOpen ? (currentMaze.inventory?.[bribeCost] || 0) > 0 : true;

            if (!hasItem) {
                addNegotiationLogEntry(`You don't have anything to offer...`);
                currentNegotiation.turnsUsed--;
                currentNegotiation.turnsRemaining++;
                updateNegotiationDisplay();
                return;
            }

            if (currentMaze.isOpen && currentMaze.inventory) {
                currentMaze.inventory[bribeCost]--;
            }

            success = roll < profile.bribeBonus;
            if (success) {
                favorChange = 20 + Math.floor(Math.random() * 15);
                addNegotiationLogEntry(`The bribe is accepted with a knowing smile. (+${favorChange} favor)`);
            } else {
                favorChange = -10;
                addNegotiationLogEntry(`They pocket the bribe but remain unmoved. (${favorChange} favor)`);
            }
            if (profile.onBribe) await executeWithTimeout(profile.onBribe);
            break;

        case 'insult':
            // Risky high-reward move
            success = roll < 25; // Low success chance
            if (success) {
                favorChange = 25 + Math.floor(Math.random() * 15);
                addNegotiationLogEntry(`Surprisingly, your insult earns their respect! (+${favorChange} favor)`);
            } else {
                favorChange = -(profile.insultPenalty || 20);
                addNegotiationLogEntry(`They're deeply offended! (${favorChange} favor)`);
            }
            if (profile.onInsult) await executeWithTimeout(profile.onInsult);
            break;
    }

    // Apply favor change
    currentNegotiation.favor = Math.max(0, Math.min(100, currentNegotiation.favor + favorChange));
    currentNegotiation.lastResult = success ? 'success' : 'fail';

    updateNegotiationDisplay();

    // Check for win
    if (currentNegotiation.favor >= currentNegotiation.favorThreshold) {
        handleNegotiationSuccess();
        return;
    }

    // Check for loss (out of turns or favor too low)
    if (currentNegotiation.turnsRemaining <= 0) {
        addNegotiationLogEntry('You\'ve run out of time...');
        handleNegotiationFail();
        return;
    }

    if (currentNegotiation.favor <= 0) {
        addNegotiationLogEntry('They refuse to speak with you any further!');
        handleNegotiationFail();
        return;
    }
}

async function handleNegotiationSuccess() {
    currentNegotiation.isComplete = true;
    currentNegotiation.isSuccess = true;

    addNegotiationLogEntry('Negotiation successful!');

    const profile = currentNegotiation.profile;

    // Execute complete hook
    if (profile.onComplete) {
        await executeWithTimeout(profile.onComplete);
    }

    // Handle item drops if in maze (v1.8.0: filtered by item pool)
    if (currentMaze.isOpen && currentMaze.pendingEncounter) {
        if (isItemInPool('key') && Math.random() * 100 < (profile.keyDropChance || 20)) {
            addToInventory('key');
            addNegotiationLogEntry('You received a Key!');
        }
        if (isItemInPool('stealth') && Math.random() * 100 < (profile.stealthDropChance || 15)) {
            addToInventory('stealth');
            addNegotiationLogEntry('You received a Stealth item!');
        }
        if (isItemInPool('healingPotion') && Math.random() * 100 < (profile.healingPotionDropChance || 15)) {
            addToInventory('healingPotion');
            addNegotiationLogEntry('You received a Healing Potion!');
        }
    }

    // Store result
    lastResults.negotiation = lastResults.negotiation || {};
    lastResults.negotiation[currentNegotiation.profileName] = {
        result: 'success',
        finalFavor: currentNegotiation.favor,
        turnsUsed: currentNegotiation.turnsUsed,
        timestamp: Date.now(),
    };

    showNegotiationResult();
}

async function handleNegotiationFail() {
    currentNegotiation.isComplete = true;
    currentNegotiation.isFailed = true;

    addNegotiationLogEntry('Negotiation failed!');

    const profile = currentNegotiation.profile;

    // Execute fail hook
    if (profile.onFail) {
        await executeWithTimeout(profile.onFail);
    }

    // Apply maze HP damage
    let playerDied = false;
    if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
        const damage = profile.damage || 25;
        const mazeMultiplier = currentMaze.profile?.battlebarDamageMultiplier ?? 1.0;
        const actualDamage = Math.round(damage * mazeMultiplier);
        const survived = await applyDamage(actualDamage, 'negotiation');
        playerDied = !survived;
    }

    // Store result
    lastResults.negotiation = lastResults.negotiation || {};
    lastResults.negotiation[currentNegotiation.profileName] = {
        result: 'fail',
        finalFavor: currentNegotiation.favor,
        turnsUsed: currentNegotiation.turnsUsed,
        timestamp: Date.now(),
    };

    // If player died, close modal and let death handling take over
    if (playerDied) {
        closeNegotiationModal();
        return;
    }

    showNegotiationResult();
}

function showNegotiationResult() {
    const actionsEl = document.getElementById('negotiate_actions');
    const resultPanel = document.getElementById('negotiate_result_panel');
    const resultText = document.getElementById('negotiate_result_text');

    if (actionsEl) actionsEl.style.display = 'none';
    if (resultPanel) resultPanel.style.display = 'block';

    if (resultText) {
        if (currentNegotiation.isSuccess) {
            resultText.textContent = currentNegotiation.profile.successMessage || 'Negotiation Successful!';
            resultText.className = 'negotiate-result-text success';
        } else {
            resultText.textContent = currentNegotiation.profile.failMessage || 'Negotiation Failed!';
            resultText.className = 'negotiate-result-text fail';
        }
    }
}

async function closeNegotiationModal() {
    const modal = document.getElementById('mazemaster_negotiation_modal');
    if (modal) modal.remove();

    const wasSuccess = currentNegotiation.isSuccess;
    currentNegotiation.isOpen = false;

    // Handle maze integration
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasSuccess) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);

                    // v2.0.5: Grant XP for successful negotiation encounter
                    const negotiateXp = getXpReward('combatVictory');
                    if (negotiateXp > 0) {
                        const xpResult = await grantXp(negotiateXp, 'negotiation');
                        if (xpResult.leveledUp) {
                            addMazeLogMessage(`Level Up! Now level ${xpResult.newLevel}!`, 'success');
                        }
                        addMazeLogMessage(`Negotiation success! +${negotiateXp} XP`, 'info');
                    }

                    // Heal player on successful negotiation completion (skill reward)
                    if (currentMaze.hp && currentMaze.profile?.hpEnabled !== false) {
                        const healPercent = currentMaze.profile.skillEncounterHealPercent || 25;
                        const maxTotal = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
                        const healAmount = Math.floor(maxTotal * (healPercent / 100));
                        if (currentMaze.hp.current < maxTotal && healAmount > 0) {
                            await healPlayer(healAmount, false, 'Negotiation success');
                            addMazeLogMessage(`Smooth talker! Recovered ${healAmount} HP.`, 'heal');
                        }
                    }

                    if (encounterType === 'exit_negotiation') {
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeNegotiationModal:', err);
        }

        // Always ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

// =============================================================================
// MERCHANT ITEM SELECTION MODAL
// =============================================================================

// Runtime state for merchant interaction
let currentMerchantOffer = {
    isOpen: false,
    minionId: null,
    minion: null,
    offeredItems: [],
    selectedItem: null,
};

function getMerchantItemPool(poolName) {
    return extensionSettings.merchantItemPools?.[poolName] || DEFAULT_MERCHANT_ITEM_POOLS[poolName] || DEFAULT_MERCHANT_ITEM_POOLS['Common Goods'];
}

function selectRandomMerchantItems(poolName, count) {
    const pool = getMerchantItemPool(poolName);
    if (!pool || !pool.items || pool.items.length === 0) {
        return [{ id: 'key', name: 'Key', description: 'Opens locked doors', icon: '🗝️' }];
    }

    const items = pool.items;
    const totalWeight = items.reduce((sum, item) => sum + (item.weight || 10), 0);
    const selected = [];
    const usedIds = new Set();

    // Weighted random selection without duplicates
    while (selected.length < count && selected.length < items.length) {
        let roll = Math.random() * totalWeight;
        for (const item of items) {
            if (usedIds.has(item.id)) continue;
            roll -= (item.weight || 10);
            if (roll <= 0) {
                selected.push({ ...item });
                usedIds.add(item.id);
                break;
            }
        }
        // Fallback if weighted selection fails
        if (selected.length < count && !usedIds.has(items[selected.length % items.length].id)) {
            const fallbackItem = items.find(i => !usedIds.has(i.id));
            if (fallbackItem) {
                selected.push({ ...fallbackItem });
                usedIds.add(fallbackItem.id);
            }
        }
    }

    return selected;
}

function getMerchantModalHtml() {
    return `
        <div id="mazemaster_merchant_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-merchant-container">
                <div class="merchant-header">
                    <div id="merchant_title" class="merchant-title">Merchant Wares</div>
                    <div id="merchant_subtitle" class="merchant-subtitle">Choose one item to take</div>
                </div>

                <div id="merchant_items" class="merchant-items-grid">
                    <!-- Items will be dynamically inserted here -->
                </div>

                <div class="merchant-footer">
                    <button id="merchant_take_btn" class="merchant-btn merchant-take-btn" disabled>
                        <i class="fa-solid fa-hand"></i> Take Selected Item
                    </button>
                    <button id="merchant_decline_btn" class="merchant-btn merchant-decline-btn">
                        <i class="fa-solid fa-xmark"></i> Leave Without Taking
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getMerchantStyles() {
    return `
        .mazemaster-merchant-container {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f1a 100%);
            border: 2px solid #d4af37;
            border-radius: 15px;
            padding: 25px;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.3);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0e0;
        }

        .merchant-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .merchant-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #d4af37;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            margin-bottom: 5px;
        }

        .merchant-subtitle {
            font-size: 1em;
            color: #aaa;
            font-style: italic;
        }

        .merchant-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }

        .merchant-item-card {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #444;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .merchant-item-card:hover {
            border-color: #d4af37;
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(212, 175, 55, 0.3);
        }

        .merchant-item-card.selected {
            border-color: #4ade80;
            background: rgba(74, 222, 128, 0.15);
            box-shadow: 0 0 25px rgba(74, 222, 128, 0.4);
        }

        .merchant-item-card.selected::after {
            content: '✓';
            position: absolute;
            top: 5px;
            right: 8px;
            font-size: 1.2em;
            color: #4ade80;
        }

        .merchant-item-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
            display: block;
        }

        .merchant-item-name {
            font-size: 1.1em;
            font-weight: bold;
            color: #d4af37;
            margin-bottom: 5px;
        }

        .merchant-item-description {
            font-size: 0.85em;
            color: #888;
            line-height: 1.3;
        }

        .merchant-footer {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .merchant-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .merchant-take-btn {
            background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            color: white;
        }

        .merchant-take-btn:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .merchant-take-btn:not(:disabled):hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(39, 174, 96, 0.5);
        }

        .merchant-decline-btn {
            background: linear-gradient(135deg, #7f8c8d 0%, #5a6c7d 100%);
            color: white;
        }

        .merchant-decline-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(127, 140, 141, 0.5);
        }
    `;
}

function showMerchantModal(minionId, offeredItems) {
    const minion = getMinion(minionId);
    if (!minion) return;

    // Initialize state
    currentMerchantOffer = {
        isOpen: true,
        minionId: minionId,
        minion: minion,
        offeredItems: offeredItems,
        selectedItem: null,
    };

    // Remove existing modal if any
    const existing = document.getElementById('mazemaster_merchant_modal');
    if (existing) existing.remove();

    // Add styles
    if (!document.getElementById('mazemaster_merchant_styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_merchant_styles';
        styleEl.textContent = getMerchantStyles();
        document.head.appendChild(styleEl);
    }

    // Add modal HTML
    document.body.insertAdjacentHTML('beforeend', getMerchantModalHtml());

    // Update title based on merchant
    document.getElementById('merchant_title').textContent = minion.name || 'Merchant Wares';

    // Render offered items
    const itemsContainer = document.getElementById('merchant_items');
    itemsContainer.innerHTML = offeredItems.map((item, index) => `
        <div class="merchant-item-card" data-item-index="${index}" data-item-id="${item.id}">
            <span class="merchant-item-icon">${item.icon || '📦'}</span>
            <div class="merchant-item-name">${item.name}</div>
            <div class="merchant-item-description">${item.description}</div>
        </div>
    `).join('');

    // Add click handlers for item selection
    itemsContainer.querySelectorAll('.merchant-item-card').forEach(card => {
        card.addEventListener('click', () => {
            // Deselect all
            itemsContainer.querySelectorAll('.merchant-item-card').forEach(c => c.classList.remove('selected'));
            // Select clicked
            card.classList.add('selected');
            currentMerchantOffer.selectedItem = offeredItems[parseInt(card.dataset.itemIndex)];
            // Enable take button
            document.getElementById('merchant_take_btn').disabled = false;
        });
    });

    // Button handlers
    document.getElementById('merchant_take_btn').addEventListener('click', handleMerchantTake);
    document.getElementById('merchant_decline_btn').addEventListener('click', handleMerchantLeave);
}

function handleMerchantTake() {
    if (!currentMerchantOffer.selectedItem) return;

    const item = currentMerchantOffer.selectedItem;

    // Add item to inventory
    addToInventory(item.id);

    // Update message
    if (currentMaze.currentMinion) {
        currentMaze.currentMinion.message = `Enjoy your ${item.name}! A pleasure doing business!`;
        updateMazeHero();
    }

    closeMerchantModal(true);
}

function handleMerchantLeave() {
    // Update message
    if (currentMaze.currentMinion) {
        currentMaze.currentMinion.message = "Perhaps another time, then...";
        updateMazeHero();
    }

    closeMerchantModal(false);
}

function closeMerchantModal(tookItem) {
    const modal = document.getElementById('mazemaster_merchant_modal');
    if (modal) modal.remove();

    currentMerchantOffer.isOpen = false;

    // Resume maze
    if (currentMaze.pendingConfirmation) {
        currentMaze.pendingConfirmation = null;
    }

    // Show OK to continue
    const confirmEl = document.getElementById('maze_encounter_confirm');
    if (confirmEl) {
        confirmEl.innerHTML = `<button id="maze_confirm_ok" class="menu_button maze-confirm-btn">OK</button>`;
        confirmEl.style.display = 'flex';
        document.getElementById('maze_confirm_ok')?.addEventListener('click', () => {
            hideActionPopup();
            resumeMaze();
        });
    } else {
        resumeMaze();
    }
}

// =============================================================================
// BATTLEBAR MODAL & GAME LOGIC
// =============================================================================

function getBattlebarModalHtml() {
    return `
        <div id="mazemaster_battlebar_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-bb-container">
                <div id="bb_main_title" class="mazemaster-bb-main-title"></div>
                <div class="mazemaster-bb-image-display">
                    <img id="mazemaster_bb_img" src="" alt="">
                </div>
                <div id="bb_stage_title" class="mazemaster-bb-stage-title"></div>
                <div class="mazemaster-bb-stats">
                    <span class="bb-stat bb-stat-hits">
                        Hits: <span id="bb_current_hits">0</span>/<span id="bb_needed_hits">5</span>
                    </span>
                    <span class="bb-stat bb-stat-misses">
                        Misses: <span id="bb_current_misses">0</span>/<span id="bb_max_misses">3</span>
                    </span>
                </div>
                <div class="mazemaster-bb-bar-container">
                    <div class="mazemaster-bb-bar">
                        <div class="mazemaster-bb-zone" id="bb_zone"></div>
                        <div class="mazemaster-bb-arrow" id="bb_arrow"></div>
                    </div>
                </div>
                <div class="mazemaster-bb-instructions">
                    Press <kbd>SPACE</kbd> when the arrow is in the green zone!
                </div>
                <div class="mazemaster-bb-action-buttons">
                    <button id="mazemaster_bb_hit_btn" class="mazemaster-bb-hit-btn">
                        <i class="fa-solid fa-bullseye"></i> HIT!
                    </button>
                    <button id="mazemaster_bb_strike_btn" class="mazemaster-bb-strike-btn" style="display: none;">
                        <i class="fa-solid fa-bolt"></i> STRIKE! (<span id="bb_strike_count">0</span>)
                    </button>
                    <button id="mazemaster_bb_execute_btn" class="mazemaster-bb-execute-btn" style="display: none;">
                        <i class="fa-solid fa-star"></i> GRANDSTRIKE! (<span id="bb_execute_count">0</span>)
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getBattlebarStyles() {
    return `
        .mazemaster-bb-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10010;
        }

        .mazemaster-bb-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 25px;
            background: #1a1a2e;
            border-radius: 15px;
            border: 2px solid #333;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            width: 450px;
            max-width: 95vw;
            overflow-y: auto;
        }

        .mazemaster-bb-main-title {
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            text-align: center;
        }

        .mazemaster-bb-stage-title {
            font-size: 18px;
            color: #aaa;
            text-align: center;
            min-height: 24px;
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .mazemaster-bb-image-display {
            width: min(300px, 80vw);
            height: min(300px, 40vh);
            border: 3px solid #444;
            border-radius: 10px;
            overflow: hidden;
            background: #222;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mazemaster-bb-image-display img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .mazemaster-bb-stats {
            display: flex;
            gap: 30px;
            font-size: 1.2em;
            font-weight: bold;
        }

        .bb-stat-hits {
            color: #27ae60;
        }

        .bb-stat-misses {
            color: #e74c3c;
        }

        .mazemaster-bb-bar-container {
            padding: 10px;
        }

        .mazemaster-bb-bar {
            position: relative;
            width: min(400px, 90vw);
            height: 50px;
            background: linear-gradient(to bottom, #c0392b, #a93226);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .mazemaster-bb-zone {
            position: absolute;
            height: 100%;
            background: linear-gradient(to bottom, #27ae60, #1e8449);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .mazemaster-bb-arrow {
            position: absolute;
            width: 6px;
            height: 100%;
            background: #fff;
            box-shadow: 0 0 15px #fff, 0 0 30px rgba(255, 255, 255, 0.5);
            left: 0;
            transition: none;
        }

        .mazemaster-bb-instructions {
            font-size: 1.1em;
            color: #aaa;
        }

        .mazemaster-bb-instructions kbd {
            background: #444;
            padding: 5px 15px;
            border-radius: 5px;
            font-weight: bold;
            color: #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .mazemaster-bb-bar.flash-hit {
            animation: flashHit 0.3s ease;
        }

        .mazemaster-bb-bar.flash-miss {
            animation: flashMiss 0.3s ease;
        }

        @keyframes flashHit {
            0%, 100% { box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); }
            50% { box-shadow: 0 0 30px rgba(39, 174, 96, 0.8), 0 0 60px rgba(39, 174, 96, 0.5); }
        }

        @keyframes flashMiss {
            0%, 100% { box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); }
            50% { box-shadow: 0 0 30px rgba(231, 76, 60, 0.8), 0 0 60px rgba(231, 76, 60, 0.5); }
        }

        .mazemaster-bb-hit-btn {
            width: min(100%, 90vw);
            max-width: 400px;
            padding: 20px 30px;
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            margin-top: 10px;
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .mazemaster-bb-hit-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.5);
        }

        .mazemaster-bb-hit-btn:active {
            transform: scale(0.98);
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }

        .mazemaster-bb-hit-btn i {
            margin-right: 10px;
        }

        .mazemaster-bb-hit-btn.victory {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }

        .mazemaster-bb-hit-btn.victory:hover {
            box-shadow: 0 8px 25px rgba(243, 156, 18, 0.5);
        }

        .mazemaster-bb-hit-btn.defeat {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            box-shadow: 0 6px 20px rgba(192, 57, 43, 0.4);
        }

        .mazemaster-bb-hit-btn.defeat:hover {
            box-shadow: 0 8px 25px rgba(192, 57, 43, 0.5);
        }
    `;
}

function startBattlebar(profileName, enemyNameOverride = null) {
    const profile = getBattlebarProfile(profileName);
    if (!profile) {
        return { error: `Battlebar profile "${profileName}" not found` };
    }

    // Check for Time Shard effect (slows battlebar by 50%)
    const timeShardMultiplier = getTimeShardMultiplier();
    const hasTimeShard = timeShardMultiplier < 1.0;

    currentBattlebar = {
        isOpen: true,
        profile: profile,
        hits: 0,
        misses: 0,
        arrowPosition: 0,
        arrowDirection: 1,
        zoneStart: 0,
        zoneEnd: 0,
        animationId: null,
        lastFrameTime: 0,
        isVictory: false,
        isDefeat: false,
        // v1.2.0: Time Shard speed multiplier
        speedMultiplier: timeShardMultiplier,
        // v1.3.1: Enemy name override from minion encounter
        enemyNameOverride: enemyNameOverride,
    };

    randomizeBattlebarZone();
    showBattlebarModal();
    startBattlebarAnimation();
    document.addEventListener('keydown', handleBattlebarKeydown);

    // Consume Time Shard if used
    if (hasTimeShard) {
        consumeTimeShard();
    }

    return { success: true };
}

function showBattlebarModal() {
    const existing = document.getElementById('mazemaster_battlebar_modal');
    if (existing) existing.remove();

    if (!document.getElementById('mazemaster_battlebar_styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_battlebar_styles';
        styleEl.textContent = getBattlebarStyles();
        document.head.appendChild(styleEl);
    }

    const modalContainer = document.createElement('div');
    modalContainer.innerHTML = getBattlebarModalHtml();
    document.body.appendChild(modalContainer.firstElementChild);

    // Update stats display
    updateBattlebarStatsDisplay();

    // Update zone position
    updateBattlebarZoneElement();

    // Show first image if available
    updateBattlebarImageDisplay();

    // Show titles
    updateBattlebarTitles();

    // Attach mobile hit button handler
    const hitBtn = document.getElementById('mazemaster_bb_hit_btn');
    if (hitBtn) {
        hitBtn.addEventListener('click', handleBattlebarHitButton);
        hitBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleBattlebarHitButton(e);
        });
    }

    // Attach Strike button handler
    const powBtn = document.getElementById('mazemaster_bb_strike_btn');
    if (powBtn) {
        powBtn.addEventListener('click', handleStrikeButton);
    }

    // Attach EXECUTE button handler
    const executeBtn = document.getElementById('mazemaster_bb_execute_btn');
    if (executeBtn) {
        executeBtn.addEventListener('click', handleExecuteButton);
    }

    // Update Strike and Execute button visibility
    updateStrikeButtonVisibility();
    updateExecuteButtonVisibility();
}

function updateBattlebarTitles() {
    const profile = currentBattlebar.profile || {};

    // Main title - use minion name override if available, otherwise profile mainTitle
    const mainTitleEl = document.getElementById('bb_main_title');
    if (mainTitleEl) {
        mainTitleEl.textContent = currentBattlebar.enemyNameOverride || profile.mainTitle || '';
    }

    // Stage title (based on current hits = current stage, from image stageMessage)
    const stageTitleEl = document.getElementById('bb_stage_title');
    if (stageTitleEl) {
        const images = profile.images || [];
        const currentStage = currentBattlebar.hits || 0;
        const currentImage = images[currentStage];
        stageTitleEl.textContent = currentImage?.stageMessage || '';
    }
}

function handleBattlebarHitButton(e) {
    e.preventDefault();
    if (!currentBattlebar.isOpen) return;

    // If in victory or defeat state, close the modal
    if (currentBattlebar.isVictory || currentBattlebar.isDefeat) {
        closeBattlebarModal();
        return;
    }

    const inZone = currentBattlebar.arrowPosition >= currentBattlebar.zoneStart
                && currentBattlebar.arrowPosition <= currentBattlebar.zoneEnd;

    console.log('[MazeMaster] Hit check:', {
        arrowPosition: currentBattlebar.arrowPosition,
        zoneStart: currentBattlebar.zoneStart,
        zoneEnd: currentBattlebar.zoneEnd,
        inZone: inZone,
    });

    if (inZone) {
        handleBattlebarHit();
    } else {
        handleBattlebarMiss();
    }
}

/**
 * Update Strike button visibility based on maze inventory
 */
function updateStrikeButtonVisibility() {
    const powBtn = document.getElementById('mazemaster_bb_strike_btn');
    const powCount = document.getElementById('bb_strike_count');

    if (powBtn && currentMaze.isOpen && currentMaze.inventory.strike > 0) {
        powBtn.style.display = '';
        if (powCount) powCount.textContent = currentMaze.inventory.strike;
    } else if (powBtn) {
        powBtn.style.display = 'none';
    }
}

/**
 * Handle Strike button click - guaranteed hit
 */
function handleStrikeButton(e) {
    e.preventDefault();
    if (!currentMaze.isOpen || currentMaze.inventory.strike <= 0) return;
    if (!currentBattlebar.isOpen) return;
    if (currentBattlebar.isVictory || currentBattlebar.isDefeat) return;

    // Use Strike - automatic hit
    removeFromInventory('strike');
    updateStrikeButtonVisibility();

    // Register as a hit
    currentBattlebar.hits++;
    updateBattlebarDisplay();

    // Check for win
    if (currentBattlebar.hits >= currentBattlebar.profile.hitsToWin) {
        handleBattlebarWin();
    }
}

/**
 * Check if current battlebar is a main minion exit encounter
 */
function isMainMinionEncounter() {
    return currentMaze.pendingEncounter && currentMaze.pendingEncounter.type === 'exit_battlebar';
}

/**
 * Update EXECUTE button visibility based on maze inventory and encounter type
 */
function updateExecuteButtonVisibility() {
    const executeBtn = document.getElementById('mazemaster_bb_execute_btn');
    const executeCount = document.getElementById('bb_execute_count');

    // Hide if not in maze, no execute, or fighting main minion
    if (executeBtn && currentMaze.isOpen && currentMaze.inventory.execute > 0 && !isMainMinionEncounter()) {
        executeBtn.style.display = '';
        if (executeCount) executeCount.textContent = currentMaze.inventory.execute;
    } else if (executeBtn) {
        executeBtn.style.display = 'none';
    }
}

/**
 * Handle EXECUTE button click - instant win (except vs main minion)
 */
function handleExecuteButton(e) {
    e.preventDefault();
    if (!currentMaze.isOpen || currentMaze.inventory.execute <= 0) return;
    if (!currentBattlebar.isOpen) return;
    if (currentBattlebar.isVictory || currentBattlebar.isDefeat) return;

    // Cannot use against main minion
    if (isMainMinionEncounter()) {
        console.log('[MazeMaster] EXECUTE cannot be used against the main minion!');
        return;
    }

    // Use EXECUTE - instant win
    removeFromInventory('execute');
    updateExecuteButtonVisibility();

    // Set hits to win threshold - instant victory
    currentBattlebar.hits = currentBattlebar.profile.hitsToWin;
    updateBattlebarDisplay();

    // Trigger win
    handleBattlebarWin();
}

async function closeBattlebarModal() {
    const wasVictory = currentBattlebar.isVictory;
    const wasDefeat = currentBattlebar.isDefeat;

    if (currentBattlebar.animationId) {
        cancelAnimationFrame(currentBattlebar.animationId);
    }
    document.removeEventListener('keydown', handleBattlebarKeydown);

    const modal = document.getElementById('mazemaster_battlebar_modal');
    if (modal) modal.remove();

    currentBattlebar.isOpen = false;
    currentBattlebar.isVictory = false;
    currentBattlebar.isDefeat = false;

    // Handle maze integration if this was a maze encounter
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasVictory) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);
                    if (encounterType === 'exit_battlebar') {
                        // Exit boss defeated - win the maze
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    } else {
                        // Regular encounter - resume maze
                        resumeMaze();
                        return;
                    }
                } else if (wasDefeat) {
                    const lossAction = currentMaze.profile.onBattlebarLoss || 'continue';

                    if (encounterType === 'exit_battlebar') {
                        // Exit boss loss - always respawn or game over (can't continue past exit)
                        if (lossAction === 'gameover') {
                            handleMazeLoss();
                            return;
                        } else {
                            respawnPlayer();
                            return;
                        }
                    } else {
                        // Regular encounter loss
                        switch (lossAction) {
                            case 'gameover':
                                handleMazeLoss();
                                return;
                            case 'respawn':
                                respawnPlayer();
                                return;
                            case 'continue':
                            default:
                                resumeMaze();
                                return;
                        }
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeBattlebarModal:', err);
        }

        // Fallback: ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

function randomizeBattlebarZone() {
    let baseDifficulty = currentBattlebar.profile.difficulty || 5;
    // Legacy support: convert old 1-5 scale to new 1-10 scale
    if (baseDifficulty <= 5 && BATTLEBAR_DIFFICULTY_LEGACY[baseDifficulty]) {
        baseDifficulty = BATTLEBAR_DIFFICULTY_LEGACY[baseDifficulty];
    }
    // Apply maze's battlebar difficulty multiplier if in a maze
    const mazeMultiplier = currentMaze.isOpen ? (currentMaze.profile?.battlebarDifficultyMultiplier ?? 1.0) : 1.0;
    const difficulty = getBattlebarDifficultySettings(baseDifficulty, mazeMultiplier);

    const zoneWidth = difficulty.zoneWidth * 100;
    const maxStart = 100 - zoneWidth;

    currentBattlebar.zoneStart = Math.random() * maxStart;
    currentBattlebar.zoneEnd = currentBattlebar.zoneStart + zoneWidth;
    // Store effective settings for animation
    currentBattlebar.effectiveDifficulty = difficulty;

    console.log('[MazeMaster] Zone randomized:', {
        baseDifficulty,
        mazeMultiplier,
        zoneWidth: zoneWidth.toFixed(1) + '%',
        traverseTime: difficulty.traverseTime + 'ms',
        zoneStart: currentBattlebar.zoneStart.toFixed(1),
        zoneEnd: currentBattlebar.zoneEnd.toFixed(1),
    });
}

function updateBattlebarZoneElement() {
    const zone = document.getElementById('bb_zone');
    if (zone) {
        zone.style.left = `${currentBattlebar.zoneStart}%`;
        zone.style.width = `${currentBattlebar.zoneEnd - currentBattlebar.zoneStart}%`;
    }
}

function updateBattlebarArrowElement() {
    const arrow = document.getElementById('bb_arrow');
    if (arrow) {
        arrow.style.left = `${currentBattlebar.arrowPosition}%`;
    }
}

function updateBattlebarStatsDisplay() {
    const hitsEl = document.getElementById('bb_current_hits');
    const neededEl = document.getElementById('bb_needed_hits');
    const missesEl = document.getElementById('bb_current_misses');
    const maxMissesEl = document.getElementById('bb_max_misses');

    if (hitsEl) hitsEl.textContent = currentBattlebar.hits;
    if (neededEl) neededEl.textContent = currentBattlebar.profile.hitsToWin || 5;
    if (missesEl) missesEl.textContent = currentBattlebar.misses;
    if (maxMissesEl) maxMissesEl.textContent = currentBattlebar.profile.missesToLose || 3;
}

function updateBattlebarImageDisplay() {
    const imgEl = document.getElementById('mazemaster_bb_img');
    if (!imgEl) return;

    const images = currentBattlebar.profile.images || [];
    if (images.length === 0) {
        imgEl.style.display = 'none';
        return;
    }

    // Show image based on current hit count
    const imageIndex = Math.min(currentBattlebar.hits, images.length - 1);
    const currentImage = images[imageIndex];
    // Support both 'imagePath' and 'path' field names
    const imagePath = currentImage.imagePath || currentImage.path || '';
    if (imagePath) {
        imgEl.src = getExtensionImagePath(imagePath);
        imgEl.style.display = 'block';
    } else {
        imgEl.style.display = 'none';
    }
}

function startBattlebarAnimation() {
    // Use pre-calculated difficulty from randomizeBattlebarZone, or calculate fresh
    const difficulty = currentBattlebar.effectiveDifficulty || getBattlebarDifficultySettings(
        currentBattlebar.profile.difficulty || 5,
        currentMaze.isOpen ? (currentMaze.profile?.battlebarDifficultyMultiplier ?? 1.0) : 1.0
    );
    // Apply Time Shard speed multiplier if present (lower = slower)
    const baseSpeed = 100 / difficulty.traverseTime; // % per ms
    const speed = baseSpeed * (currentBattlebar.speedMultiplier || 1.0);

    function animate(timestamp) {
        if (!currentBattlebar.isOpen) return;

        if (currentBattlebar.lastFrameTime === 0) {
            currentBattlebar.lastFrameTime = timestamp;
        }

        const delta = timestamp - currentBattlebar.lastFrameTime;
        currentBattlebar.lastFrameTime = timestamp;

        // Move arrow
        currentBattlebar.arrowPosition += speed * delta * currentBattlebar.arrowDirection;

        // Bounce at edges
        if (currentBattlebar.arrowPosition >= 100) {
            currentBattlebar.arrowPosition = 100;
            currentBattlebar.arrowDirection = -1;
        } else if (currentBattlebar.arrowPosition <= 0) {
            currentBattlebar.arrowPosition = 0;
            currentBattlebar.arrowDirection = 1;
        }

        updateBattlebarArrowElement();
        currentBattlebar.animationId = requestAnimationFrame(animate);
    }

    currentBattlebar.lastFrameTime = 0;
    currentBattlebar.animationId = requestAnimationFrame(animate);
}

function handleBattlebarKeydown(e) {
    if (e.code !== 'Space' || !currentBattlebar.isOpen) return;
    e.preventDefault();

    // If in victory or defeat state, close the modal
    if (currentBattlebar.isVictory || currentBattlebar.isDefeat) {
        closeBattlebarModal();
        return;
    }

    const inZone = currentBattlebar.arrowPosition >= currentBattlebar.zoneStart
                && currentBattlebar.arrowPosition <= currentBattlebar.zoneEnd;

    if (inZone) {
        handleBattlebarHit();
    } else {
        handleBattlebarMiss();
    }
}

async function handleBattlebarHit() {
    currentBattlebar.hits++;

    // Flash green
    const bar = document.querySelector('.mazemaster-bb-bar');
    if (bar) {
        bar.classList.remove('flash-hit', 'flash-miss');
        void bar.offsetWidth; // Trigger reflow
        bar.classList.add('flash-hit');
    }

    updateBattlebarStatsDisplay();
    updateBattlebarImageDisplay();
    updateBattlebarTitles();

    // Execute hit command
    if (currentBattlebar.profile.hitCommand) {
        await executeWithTimeout(currentBattlebar.profile.hitCommand);
    }

    // Check for win
    if (currentBattlebar.hits >= (currentBattlebar.profile.hitsToWin || 5)) {
        await handleBattlebarWin();
        return;
    }

    // Randomize zone for next attempt
    randomizeBattlebarZone();
    updateBattlebarZoneElement();
}

async function handleBattlebarMiss() {
    currentBattlebar.misses++;

    // Flash red
    const bar = document.querySelector('.mazemaster-bb-bar');
    if (bar) {
        bar.classList.remove('flash-hit', 'flash-miss');
        void bar.offsetWidth;
        bar.classList.add('flash-miss');
    }

    updateBattlebarStatsDisplay();

    // Execute miss command
    if (currentBattlebar.profile.missCommand) {
        await executeWithTimeout(currentBattlebar.profile.missCommand);
    }

    // Check for loss
    if (currentBattlebar.misses >= (currentBattlebar.profile.missesToLose || 3)) {
        await handleBattlebarLoss();
        return;
    }
}

async function handleBattlebarWin() {
    const profileName = extensionSettings.currentBattlebarProfile || 'Tutorial - Learn Combat';

    // Store result for macros
    lastResults.battlebar[profileName] = {
        result: 'win',
        hits: currentBattlebar.hits,
        misses: currentBattlebar.misses,
        timestamp: Date.now(),
    };

    // Log to session notes
    if (currentMaze?.isOpen) {
        addSessionNote(`Battlebar victory: ${currentBattlebar.profile?.mainTitle || profileName}`, 'Combat');
        // v1.4.7: Reset combat loss streak on win
        if (currentMaze.fairness) {
            currentMaze.fairness.combatLossStreak = 0;
        }
    }

    // Set victory state
    currentBattlebar.isVictory = true;

    // Handle item drops for maze encounters (v1.8.0: filtered by item pool)
    if (currentMaze.isOpen && currentMaze.pendingEncounter) {
        const profile = currentBattlebar.profile;

        // Roll for core item drops
        if (isItemInPool('key') && Math.random() * 100 < (profile.keyDropChance ?? 40)) {
            addToInventory('key');
        }
        if (isItemInPool('strike') && Math.random() * 100 < (profile.strikeDropChance ?? 20)) {
            addToInventory('strike');
        }
        if (isItemInPool('stealth') && Math.random() * 100 < (profile.stealthDropChance ?? 10)) {
            addToInventory('stealth');
        }
        if (isItemInPool('execute') && Math.random() * 100 < (profile.executeDropChance ?? 2)) {
            addToInventory('execute');
        }
        // Roll for special item drops (rarer)
        if (isItemInPool('floorKey') && Math.random() * 100 < (profile.floorKeyDropChance ?? 5)) {
            addToInventory('floorKey');
        }
        if (isItemInPool('portalStone') && Math.random() * 100 < (profile.portalStoneDropChance ?? 3)) {
            addToInventory('portalStone');
        }
        if (isItemInPool('minionBane') && Math.random() * 100 < (profile.minionBaneDropChance ?? 4)) {
            addToInventory('minionBane');
        }
        if (isItemInPool('mapFragment') && Math.random() * 100 < (profile.mapFragmentDropChance ?? 8)) {
            addToInventory('mapFragment');
        }
        if (isItemInPool('timeShard') && Math.random() * 100 < (profile.timeShardDropChance ?? 2)) {
            addToInventory('timeShard');
        }
        if (isItemInPool('voidWalk') && Math.random() * 100 < (profile.voidWalkDropChance ?? 1)) {
            addToInventory('voidWalk');
        }
        // v1.3.0: HP item drops (only if HP system is enabled)
        if (currentMaze.hpEnabled) {
            if (isItemInPool('healingPotion') && Math.random() * 100 < (profile.healingPotionDropChance ?? 15)) {
                addToInventory('healingPotion');
            }
            if (isItemInPool('greaterHealing') && Math.random() * 100 < (profile.greaterHealingDropChance ?? 5)) {
                addToInventory('greaterHealing');
            }
            if (isItemInPool('elixir') && Math.random() * 100 < (profile.elixirDropChance ?? 1)) {
                addToInventory('elixir');
            }
            if (isItemInPool('revivalCharm') && Math.random() * 100 < (profile.revivalCharmDropChance ?? 0.5)) {
                addToInventory('revivalCharm');
            }
            if (isItemInPool('heartCrystal') && Math.random() * 100 < (profile.heartCrystalDropChance ?? 0.3)) {
                addToInventory('heartCrystal');
            }
        }
    }

    // Stop the arrow animation
    if (currentBattlebar.animationId) {
        cancelAnimationFrame(currentBattlebar.animationId);
        currentBattlebar.animationId = null;
    }

    // Hide the bar and instructions
    const barContainer = document.querySelector('.mazemaster-bb-bar-container');
    const instructions = document.querySelector('.mazemaster-bb-instructions');
    if (barContainer) barContainer.style.display = 'none';
    if (instructions) instructions.style.display = 'none';

    // Show victory image (last image in array) and its message
    const images = currentBattlebar.profile.images || [];
    const victoryImage = images.length > 0 ? images[images.length - 1] : null;

    if (victoryImage) {
        const imgEl = document.getElementById('mazemaster_bb_img');
        if (imgEl) {
            imgEl.src = '/' + victoryImage.path;
        }
    }

    // Update stage title to show victory message from last image
    const stageTitleEl = document.getElementById('bb_stage_title');
    if (stageTitleEl) {
        const victoryMessage = victoryImage?.stageMessage || 'Victory!';
        stageTitleEl.textContent = victoryMessage;
    }

    // Change button to "Close"
    const hitBtn = document.getElementById('mazemaster_bb_hit_btn');
    if (hitBtn) {
        hitBtn.innerHTML = '<i class="fa-solid fa-check"></i> Close';
        hitBtn.classList.add('victory');
    }

    // Execute win command
    if (currentBattlebar.profile.winCommand) {
        await executeWithTimeout(currentBattlebar.profile.winCommand);
    }
}

async function handleBattlebarLoss() {
    const profileName = extensionSettings.currentBattlebarProfile || 'Tutorial - Learn Combat';

    // Store result for macros
    lastResults.battlebar[profileName] = {
        result: 'lose',
        hits: currentBattlebar.hits,
        misses: currentBattlebar.misses,
        timestamp: Date.now(),
    };

    // Log to session notes
    if (currentMaze?.isOpen) {
        addSessionNote(`Battlebar defeat: ${currentBattlebar.profile?.mainTitle || profileName}`, 'Combat');
        // v1.4.7: Increment combat loss streak
        if (currentMaze.fairness) {
            currentMaze.fairness.combatLossStreak++;
            console.log(`[MazeMaster] Fairness: Combat loss streak: ${currentMaze.fairness.combatLossStreak}`);
        }
    }

    // Set defeat state
    currentBattlebar.isDefeat = true;

    // Stop the arrow animation
    if (currentBattlebar.animationId) {
        cancelAnimationFrame(currentBattlebar.animationId);
        currentBattlebar.animationId = null;
    }

    // Hide the bar and instructions
    const barContainer = document.querySelector('.mazemaster-bb-bar-container');
    const instructions = document.querySelector('.mazemaster-bb-instructions');
    if (barContainer) barContainer.style.display = 'none';
    if (instructions) instructions.style.display = 'none';

    // HP System: Apply damage instead of immediate defeat (v1.3.0)
    if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
        const mazeProfile = currentMaze.profile;
        // Get base damage from battlebar profile, apply maze's damage multiplier
        const battlebarDamage = currentBattlebar.profile?.damage || 25;
        const mazeMultiplier = mazeProfile.battlebarDamageMultiplier ?? 1.0;
        const damage = Math.round(battlebarDamage * mazeMultiplier);

        const survived = await applyDamage(damage, 'battlebar');

        if (survived) {
            // Player survived - show "Wounded" instead of "Defeat"
            const stageTitleEl = document.getElementById('bb_stage_title');
            if (stageTitleEl) {
                stageTitleEl.textContent = 'Wounded!';
            }

            // Change button to "Continue"
            const hitBtn = document.getElementById('mazemaster_bb_hit_btn');
            if (hitBtn) {
                hitBtn.innerHTML = '<i class="fa-solid fa-arrow-right"></i> Continue';
                hitBtn.classList.add('wounded');
            }

            // Execute lose command but player continues
            if (currentBattlebar.profile.loseCommand) {
                await executeWithTimeout(currentBattlebar.profile.loseCommand);
            }
            return;
        }

        // Player died - death handling is done by applyDamage -> handlePlayerDeath
        // Execute lose command before closing
        if (currentBattlebar.profile.loseCommand) {
            await executeWithTimeout(currentBattlebar.profile.loseCommand);
        }

        // Close the battlebar modal immediately so the death/gameover screen can show
        currentBattlebar.isDefeat = true;
        closeBattlebarModal();
        return;
    }

    // Non-HP mode: Original behavior
    // Update stage title to show defeat
    const stageTitleEl = document.getElementById('bb_stage_title');
    if (stageTitleEl) {
        stageTitleEl.textContent = 'Defeat...';
    }

    // Change button to "Close"
    const hitBtn = document.getElementById('mazemaster_bb_hit_btn');
    if (hitBtn) {
        hitBtn.innerHTML = '<i class="fa-solid fa-times"></i> Close';
        hitBtn.classList.add('defeat');
    }

    // Execute lose command
    if (currentBattlebar.profile.loseCommand) {
        await executeWithTimeout(currentBattlebar.profile.loseCommand);
    }
}

// =============================================================================
// MAZE LOGIC
// =============================================================================

// =============================================================================
// v1.4.0 BSP GENERATION SYSTEM - Data Structures
// =============================================================================

/**
 * Theme-specific room type pools
 * Each theme has rooms categorized by size: small (2x2), medium (3x3), large (4x4+), special
 */
const THEMED_ROOM_TYPES = {
    fantasy: {
        small: ['alcove', 'guardPost', 'shrine', 'cell', 'storeroom'],
        medium: ['treasureVault', 'library', 'armory', 'chapel', 'barracks'],
        large: ['throneRoom', 'arena', 'crypt', 'greatHall', 'dungeon'],
        special: ['bossLair', 'dragonDen', 'wizardTower']
    },
    scifi: {
        small: ['airlock', 'terminal', 'cryoPod', 'storageUnit', 'junction'],
        medium: ['lab', 'serverRoom', 'medbay', 'armory', 'quarters'],
        large: ['hangar', 'reactor', 'bridge', 'hydroponics', 'cargo'],
        special: ['aiCore', 'alienNest', 'escapePod']
    },
    horror: {
        small: ['closet', 'cell', 'ritualNook', 'crawlspace', 'alcove'],
        medium: ['morgue', 'cultRoom', 'tortureChamber', 'nursery', 'study'],
        large: ['cathedral', 'asylumWard', 'abattoir', 'ritualHall', 'crypt'],
        special: ['finalGate', 'elderShrine', 'heartOfDarkness']
    },
    western: {
        small: ['storeroom', 'jailCell', 'stall', 'privy', 'closet'],
        medium: ['saloon', 'sheriffOffice', 'bankVault', 'generalStore', 'hotel'],
        large: ['townSquare', 'ranchHouse', 'goldMine', 'trainStation', 'church'],
        special: ['showdownStreet', 'outlawHideout', 'ghostTownCenter']
    },
    action: {
        small: ['checkpoint', 'ammoCache', 'commsRoom', 'bunker', 'vent'],
        medium: ['warRoom', 'armory', 'interrogation', 'motorPool', 'barracks'],
        large: ['hangar', 'trainingGround', 'commandCenter', 'missileSilo', 'prison'],
        special: ['bossArena', 'extractionZone', 'doomsdayDevice']
    },
    comedy: {
        small: ['broomCloset', 'vendingCorner', 'awkwardBathroom', 'supplyRoom', 'cubicle'],
        medium: ['breakRoom', 'conferenceDisaster', 'printerGraveyard', 'itDungeon', 'mailRoom'],
        large: ['cafeteria', 'ballPit', 'karaokeHall', 'escapeRoomInception', 'openOffice'],
        special: ['finalBossOffice', 'plotTwistRoom', 'creditsRoom']
    },
    cyberpunk: {
        small: ['jackPoint', 'stash', 'corpoCloset', 'vendingAlcove', 'maintenance'],
        medium: ['netrunnerDen', 'chopShop', 'blackMarket', 'ripperdoc', 'flophouse'],
        large: ['megacorpFloor', 'club', 'dataFortress', 'gangHQ', 'bazaar'],
        special: ['aiCore', 'finalUpload', 'skyGarden']
    }
};

/**
 * Room mechanics define special behaviors for room types
 */
const ROOM_MECHANICS = {
    // Treasure rooms
    treasureVault: { guaranteedChest: true, chestQuality: 'rare', trapDensity: 1.5, minionGuard: true },
    bankVault: { guaranteedChest: true, chestQuality: 'rare', trapDensity: 2.0, minionGuard: true },

    // Combat rooms
    arena: { waveBattle: true, waveCount: { min: 2, max: 4 }, noRetreat: true, rewardOnClear: 'special' },
    bossArena: { bossEncounter: true, lockedUntilCleared: true, specialLoot: true },
    bossLair: { bossEncounter: true, lockedUntilCleared: true, specialLoot: true },
    trainingGround: { waveBattle: true, waveCount: { min: 1, max: 2 }, noRetreat: false },

    // Knowledge rooms
    library: { revealMapOnEnter: true, revealRadius: 3, scholarNPC: true },
    serverRoom: { revealMapOnEnter: true, revealRadius: 4 },
    terminal: { revealMapOnEnter: true, revealRadius: 2 },

    // Safe havens
    shrine: { noEnemies: true, healPercent: 25 },
    chapel: { noEnemies: true, healPercent: 50, savePoint: true },
    medbay: { noEnemies: true, fullHeal: true, savePoint: true },
    ripperdoc: { noEnemies: true, fullHeal: true, merchantNPC: true },

    // Special mechanics
    crypt: { undeadOnly: true, trapDensity: 1.5 },
    reactor: { hazardDamage: 5, noRest: true },
    crawlspace: { stealthBonus: true, noLargeEnemies: true },

    // Default for unlisted types
    default: { }
};

/**
 * BSP style-specific configurations
 */
const BSP_STYLE_CONFIGS = {
    dungeon: {
        minRoomSize: 2,
        maxRoomSize: 3,
        minSplitSize: 2,
        splitVariance: 0.3,
        corridorWidth: 1,
        roomPadding: 0,
        extraConnections: 0.9,
        branchChance: 0.65,
        preferSquareRooms: false
    },
    maze: {
        minRoomSize: 2,
        maxRoomSize: 2,
        minSplitSize: 2,
        splitVariance: 0.3,
        corridorWidth: 1,
        roomPadding: 0,
        extraConnections: 1.0,
        addDeadEnds: true,
        branchChance: 0.7,
        preferSquareRooms: true
    },
    city: {
        minRoomSize: 2,
        maxRoomSize: 3,
        minSplitSize: 2,
        splitVariance: 0.25,
        corridorWidth: 1,
        roomPadding: 0,
        gridAlign: true,
        extraConnections: 0.95,
        branchChance: 0.6,
        preferSquareRooms: false
    },
    forest: {
        minRoomSize: 2,
        maxRoomSize: 3,
        minSplitSize: 2,
        splitVariance: 0.35,
        corridorWidth: 1,
        roomPadding: 0,
        windingCorridors: true,
        extraConnections: 0.9,
        branchChance: 0.7,
        preferSquareRooms: false
    },
    spaceship: {
        minRoomSize: 2,
        maxRoomSize: 3,
        minSplitSize: 2,
        splitVariance: 0.2,
        corridorWidth: 1,
        roomPadding: 0,
        extraConnections: 0.85,
        modularRooms: true,
        branchChance: 0.6,
        preferSquareRooms: true
    },
    arena: {
        minRoomSize: 2,
        maxRoomSize: 3,
        minSplitSize: 2,
        splitVariance: 0.3,
        corridorWidth: 1,
        roomPadding: 0,
        extraConnections: 0.9,
        branchChance: 0.65,
        preferSquareRooms: true
    },
    hospital: {
        minRoomSize: 2,
        maxRoomSize: 3,
        minSplitSize: 2,
        splitVariance: 0.2,
        corridorWidth: 1,
        roomPadding: 0,
        gridAlign: true,
        extraConnections: 0.85,
        branchChance: 0.6,
        preferSquareRooms: false
    }
};

// Map style aliases to BSP configs
const STYLE_TO_BSP_CONFIG = {
    'dungeon': 'dungeon',
    'maze': 'maze',
    'city': 'city',
    'neotokyo': 'city',
    'forest': 'forest',
    'spaceship': 'spaceship',
    'spacestation': 'spaceship',
    'arena': 'arena',
    'outpost': 'dungeon',
    'college': 'hospital',
    'apartment': 'city',
    'hospital': 'hospital',
    'highrise': 'city'
};

// =============================================================================
// v1.4.0 BSP GENERATION ALGORITHM
// =============================================================================

/**
 * Generate a BSP tree for dungeon layout
 * @param {number} x - Start X coordinate
 * @param {number} y - Start Y coordinate
 * @param {number} width - Area width
 * @param {number} height - Area height
 * @param {number} depth - Current recursion depth
 * @param {object} config - BSP configuration
 * @returns {object} BSP node
 */
function generateBSPTree(x, y, width, height, depth, config) {
    const node = {
        x, y, width, height,
        left: null,
        right: null,
        room: null,
        splitHorizontal: null
    };

    // Check if we should stop splitting - use minSplitSize directly, not doubled
    const minSize = config.minSplitSize || 2;
    const maxDepth = config.maxDepth || 8;

    // More aggressive splitting - only stop if we truly can't split
    // Need at least minSize+1 to split (e.g., 3 cells -> 1+2 or 2+1)
    const canSplitWidth = width >= minSize + 1;
    const canSplitHeight = height >= minSize + 1;

    if (depth >= maxDepth || (!canSplitWidth && !canSplitHeight)) {
        // This is a leaf node - generate a room here
        node.room = generateRoomInNode(node, config);
        return node;
    }

    // Decide split direction based on what's possible and aspect ratio
    const aspectRatio = width / height;
    let splitHorizontal;

    if (!canSplitWidth) {
        splitHorizontal = true; // Can only split horizontally
    } else if (!canSplitHeight) {
        splitHorizontal = false; // Can only split vertically
    } else if (aspectRatio > 1.5) {
        splitHorizontal = false; // Split vertically (too wide)
    } else if (aspectRatio < 0.67) {
        splitHorizontal = true; // Split horizontally (too tall)
    } else {
        // For square-ish areas, alternate or randomize
        splitHorizontal = Math.random() < 0.5;
    }

    node.splitHorizontal = splitHorizontal;

    // Calculate split position with variance - allow asymmetric splits
    const variance = config.splitVariance || 0.3;
    const minRatio = Math.max(0.25, 0.5 - variance);
    const maxRatio = Math.min(0.75, 0.5 + variance);
    const splitRatio = minRatio + Math.random() * (maxRatio - minRatio);

    if (splitHorizontal) {
        // Split horizontally (top/bottom)
        const splitY = Math.max(minSize, Math.min(height - minSize, Math.floor(height * splitRatio)));
        if (splitY < 1 || height - splitY < 1) {
            node.room = generateRoomInNode(node, config);
            return node;
        }
        node.left = generateBSPTree(x, y, width, splitY, depth + 1, config);
        node.right = generateBSPTree(x, y + splitY, width, height - splitY, depth + 1, config);
    } else {
        // Split vertically (left/right)
        const splitX = Math.max(minSize, Math.min(width - minSize, Math.floor(width * splitRatio)));
        if (splitX < 1 || width - splitX < 1) {
            node.room = generateRoomInNode(node, config);
            return node;
        }
        node.left = generateBSPTree(x, y, splitX, height, depth + 1, config);
        node.right = generateBSPTree(x + splitX, y, width - splitX, height, depth + 1, config);
    }

    return node;
}

/**
 * Generate a room within a BSP leaf node
 * @param {object} node - BSP leaf node
 * @param {object} config - Room generation config
 * @returns {object} Room data
 */
function generateRoomInNode(node, config) {
    // v2.0.3: Fix - use ?? instead of || so roomPadding: 0 works correctly
    const padding = config.roomPadding ?? 1;
    const minSize = config.minRoomSize || 2;
    const maxSize = config.maxRoomSize || 5;

    // Calculate available space for room
    const availWidth = node.width - padding * 2;
    const availHeight = node.height - padding * 2;

    if (availWidth < minSize || availHeight < minSize) {
        // Not enough space for a room
        return null;
    }

    // Determine room size
    let roomWidth = Math.min(maxSize, availWidth);
    let roomHeight = Math.min(maxSize, availHeight);

    // Add some variance to room size
    roomWidth = Math.max(minSize, Math.floor(roomWidth * (0.7 + Math.random() * 0.3)));
    roomHeight = Math.max(minSize, Math.floor(roomHeight * (0.7 + Math.random() * 0.3)));

    // Prefer square rooms if configured
    if (config.preferSquareRooms) {
        const minDim = Math.min(roomWidth, roomHeight);
        roomWidth = minDim;
        roomHeight = minDim;
    }

    // Position room within node (with some randomness)
    const maxOffsetX = availWidth - roomWidth;
    const maxOffsetY = availHeight - roomHeight;
    const offsetX = maxOffsetX > 0 ? Math.floor(Math.random() * maxOffsetX) : 0;
    const offsetY = maxOffsetY > 0 ? Math.floor(Math.random() * maxOffsetY) : 0;

    const roomX = node.x + padding + offsetX;
    const roomY = node.y + padding + offsetY;

    return {
        x: roomX,
        y: roomY,
        width: roomWidth,
        height: roomHeight,
        centerX: Math.floor(roomX + roomWidth / 2),
        centerY: Math.floor(roomY + roomHeight / 2),
        type: 'common', // Will be assigned later based on theme
        zoneId: null,
        isCleared: false,
        connections: []
    };
}

/**
 * Collect all rooms from a BSP tree
 * @param {object} node - BSP tree root
 * @returns {array} Array of rooms
 */
function collectRoomsFromBSP(node) {
    if (!node) return [];

    if (node.room) {
        return [node.room];
    }

    return [
        ...collectRoomsFromBSP(node.left),
        ...collectRoomsFromBSP(node.right)
    ];
}

/**
 * Find the nearest room in a BSP subtree to a given point
 * @param {object} node - BSP node
 * @param {number} targetX - Target X coordinate
 * @param {number} targetY - Target Y coordinate
 * @returns {object} Nearest room
 */
function findNearestRoom(node, targetX, targetY) {
    if (!node) return null;

    if (node.room) {
        return node.room;
    }

    const leftRoom = findNearestRoom(node.left, targetX, targetY);
    const rightRoom = findNearestRoom(node.right, targetX, targetY);

    if (!leftRoom) return rightRoom;
    if (!rightRoom) return leftRoom;

    const leftDist = Math.abs(leftRoom.centerX - targetX) + Math.abs(leftRoom.centerY - targetY);
    const rightDist = Math.abs(rightRoom.centerX - targetX) + Math.abs(rightRoom.centerY - targetY);

    return leftDist < rightDist ? leftRoom : rightRoom;
}

/**
 * Connect rooms in BSP tree via corridors
 * @param {object} node - BSP node (internal)
 * @param {array} grid - Map grid
 * @param {number} size - Grid size
 * @param {object} config - Configuration
 */
function connectBSPChildren(node, grid, size, config) {
    if (!node || !node.left || !node.right) return;

    // Recursively connect children first
    connectBSPChildren(node.left, grid, size, config);
    connectBSPChildren(node.right, grid, size, config);

    // Find rooms to connect from each child
    const leftRoom = findNearestRoom(node.left, node.x + node.width / 2, node.y + node.height / 2);
    const rightRoom = findNearestRoom(node.right, node.x + node.width / 2, node.y + node.height / 2);

    if (leftRoom && rightRoom) {
        // Create corridor between room centers
        carveCorridor(grid, size,
            leftRoom.centerX, leftRoom.centerY,
            rightRoom.centerX, rightRoom.centerY,
            config);

        // Track connection
        leftRoom.connections.push(rightRoom);
        rightRoom.connections.push(leftRoom);
    }
}

/**
 * Carve a corridor between two points (L-shaped or straight)
 * @param {array} grid - Map grid
 * @param {number} size - Grid size
 * @param {number} x1 - Start X
 * @param {number} y1 - Start Y
 * @param {number} x2 - End X
 * @param {number} y2 - End Y
 * @param {object} config - Configuration
 */
function carveCorridor(grid, size, x1, y1, x2, y2, config, depth = 0) {
    const width = config.corridorWidth || 1;
    const dx = Math.abs(x2 - x1);
    const dy = Math.abs(y2 - y1);
    const distance = dx + dy;

    // Always break up long corridors with multiple segments
    // More aggressive breaking for longer distances
    const shouldBreak = distance > 3 && (Math.random() < 0.75 || distance > 6);

    if (shouldBreak && depth < 4) {
        // Calculate number of segments based on distance
        const segments = distance > 8 ? 3 : 2;

        if (segments === 3 && distance > 8) {
            // Three-segment zigzag for long corridors
            const third = 1 / 3;
            const twoThird = 2 / 3;

            // Add randomized waypoints
            const offset1 = Math.floor((Math.random() - 0.5) * Math.min(4, size / 4));
            const offset2 = Math.floor((Math.random() - 0.5) * Math.min(4, size / 4));

            const mid1X = Math.max(1, Math.min(size - 2, Math.floor(x1 + (x2 - x1) * third) + offset1));
            const mid1Y = Math.max(1, Math.min(size - 2, Math.floor(y1 + (y2 - y1) * third) + offset2));
            const mid2X = Math.max(1, Math.min(size - 2, Math.floor(x1 + (x2 - x1) * twoThird) - offset1));
            const mid2Y = Math.max(1, Math.min(size - 2, Math.floor(y1 + (y2 - y1) * twoThird) - offset2));

            carveCorridor(grid, size, x1, y1, mid1X, mid1Y, config, depth + 1);
            carveCorridor(grid, size, mid1X, mid1Y, mid2X, mid2Y, config, depth + 1);
            carveCorridor(grid, size, mid2X, mid2Y, x2, y2, config, depth + 1);
            return;
        } else {
            // Two-segment L-shape with offset midpoint
            const offsetRange = Math.min(3, Math.floor(distance / 3));
            const midX = Math.max(1, Math.min(size - 2, Math.floor((x1 + x2) / 2) + Math.floor((Math.random() - 0.5) * offsetRange * 2)));
            const midY = Math.max(1, Math.min(size - 2, Math.floor((y1 + y2) / 2) + Math.floor((Math.random() - 0.5) * offsetRange * 2)));

            carveCorridor(grid, size, x1, y1, midX, midY, config, depth + 1);
            carveCorridor(grid, size, midX, midY, x2, y2, config, depth + 1);
            return;
        }
    }

    // For short segments, use alternating direction patterns
    const horizontalFirst = Math.random() < 0.5;

    if (horizontalFirst) {
        // Horizontal then vertical
        carveHorizontalCorridor(grid, size, x1, x2, y1, width);
        carveVerticalCorridor(grid, size, y1, y2, x2, width);
    } else {
        // Vertical then horizontal
        carveVerticalCorridor(grid, size, y1, y2, x1, width);
        carveHorizontalCorridor(grid, size, x1, x2, y2, width);
    }
}

/**
 * Carve a horizontal corridor
 */
function carveHorizontalCorridor(grid, size, x1, x2, y, width) {
    const startX = Math.min(x1, x2);
    const endX = Math.max(x1, x2);

    for (let x = startX; x <= endX; x++) {
        for (let w = 0; w < width; w++) {
            const yPos = y + w;
            if (x >= 0 && x < size && yPos >= 0 && yPos < size) {
                const cell = grid[yPos][x];
                cell.corridorType = 'main';

                // Remove walls for passage
                if (x > startX) cell.walls.left = false;
                if (x < endX) cell.walls.right = false;
                if (x > 0 && x - 1 >= startX) grid[yPos][x - 1].walls.right = false;
                if (x < size - 1 && x + 1 <= endX) grid[yPos][x + 1].walls.left = false;
            }
        }
    }
}

/**
 * Carve a vertical corridor
 */
function carveVerticalCorridor(grid, size, y1, y2, x, width) {
    const startY = Math.min(y1, y2);
    const endY = Math.max(y1, y2);

    for (let y = startY; y <= endY; y++) {
        for (let w = 0; w < width; w++) {
            const xPos = x + w;
            if (xPos >= 0 && xPos < size && y >= 0 && y < size) {
                const cell = grid[y][xPos];
                cell.corridorType = 'main';

                // Remove walls for passage
                if (y > startY) cell.walls.top = false;
                if (y < endY) cell.walls.bottom = false;
                if (y > 0 && y - 1 >= startY) grid[y - 1][xPos].walls.bottom = false;
                if (y < size - 1 && y + 1 <= endY) grid[y + 1][xPos].walls.top = false;
            }
        }
    }
}

/**
 * Carve a room into the grid (remove interior walls)
 * @param {array} grid - Map grid
 * @param {object} room - Room data
 * @param {number} roomId - Room ID to assign
 */
function carveRoomIntoGrid(grid, room, roomId) {
    for (let y = room.y; y < room.y + room.height; y++) {
        for (let x = room.x; x < room.x + room.width; x++) {
            if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
                const cell = grid[y][x];
                cell.roomId = roomId;
                cell.isRoomInterior = true;

                // Remove interior walls (keep perimeter)
                if (x > room.x) cell.walls.left = false;
                if (x < room.x + room.width - 1) cell.walls.right = false;
                if (y > room.y) cell.walls.top = false;
                if (y < room.y + room.height - 1) cell.walls.bottom = false;

                // Also update adjacent cells' walls
                if (x > room.x && x > 0) grid[y][x - 1].walls.right = false;
                if (x < room.x + room.width - 1 && x < grid[0].length - 1) grid[y][x + 1].walls.left = false;
                if (y > room.y && y > 0) grid[y - 1][x].walls.bottom = false;
                if (y < room.y + room.height - 1 && y < grid.length - 1) grid[y + 1][x].walls.top = false;
            }
        }
    }
}

/**
 * Assign themed room types based on size and theme
 * @param {array} rooms - Array of rooms
 * @param {string} theme - Map theme
 */
function assignRoomTypes(rooms, theme) {
    const themeRooms = THEMED_ROOM_TYPES[theme] || THEMED_ROOM_TYPES.fantasy;

    // Ensure at least one special room for larger dungeons
    const hasSpecial = rooms.length > 5;
    let specialAssigned = false;

    rooms.forEach((room, index) => {
        const area = room.width * room.height;

        // Determine size category
        let sizeCategory;
        if (area <= 4) {
            sizeCategory = 'small';
        } else if (area <= 9) {
            sizeCategory = 'medium';
        } else {
            sizeCategory = 'large';
        }

        // Chance for special room (last room or random)
        if (hasSpecial && !specialAssigned && (index === rooms.length - 1 || Math.random() < 0.1)) {
            room.type = themeRooms.special[Math.floor(Math.random() * themeRooms.special.length)];
            specialAssigned = true;
        } else {
            const typePool = themeRooms[sizeCategory];
            room.type = typePool[Math.floor(Math.random() * typePool.length)];
        }

        // Assign mechanics
        room.mechanics = ROOM_MECHANICS[room.type] || ROOM_MECHANICS.default;
    });
}

/**
 * Generate a complete BSP-based grid
 * @param {number} size - Grid size
 * @param {string} mapStyle - Map style name
 * @param {string} theme - Theme name
 * @param {object} overrideConfig - Optional config overrides
 * @returns {object} { grid, rooms }
 */
function generateBSPGrid(size, mapStyle, theme, overrideConfig = {}) {
    // Get style-specific config
    const configName = STYLE_TO_BSP_CONFIG[mapStyle] || 'dungeon';
    const baseConfig = BSP_STYLE_CONFIGS[configName] || BSP_STYLE_CONFIGS.dungeon;
    const config = { ...baseConfig, ...overrideConfig };

    // Calculate max depth based on size - more aggressive splitting for denser mazes
    config.maxDepth = Math.max(4, Math.floor(Math.log2(size) * 1.5));

    // Initialize grid with all walls
    const grid = [];
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = {
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false,
                minion: null,
                trap: null,
                // v1.4.0 BSP properties
                roomId: null,
                zoneId: null,
                isRoomInterior: false,
                secretPassage: null,
                corridorType: null
            };
        }
    }

    // Generate BSP tree
    const root = generateBSPTree(0, 0, size, size, 0, config);

    // Collect rooms from tree
    const rooms = collectRoomsFromBSP(root).filter(r => r !== null);

    // Carve rooms into grid
    rooms.forEach((room, index) => {
        room.id = index;
        carveRoomIntoGrid(grid, room, index);
    });

    // Connect rooms via corridors
    connectBSPChildren(root, grid, size, config);

    // Assign themed room types
    assignRoomTypes(rooms, theme);

    // Add extra connections for variety
    if (config.extraConnections > 0) {
        addExtraBSPConnections(grid, rooms, size, config);
    }

    // Add dead ends if configured (for maze style)
    if (config.addDeadEnds) {
        addBSPDeadEnds(grid, rooms, size, config);
    }

    // Ensure start and exit are accessible
    ensureConnected(grid, size, 0, 0, size - 1, size - 1);

    // Ensure multiple directions from start position for interesting exploration
    ensureMultipleStartDirections(grid, rooms, size, config);

    return { grid, rooms };
}

/**
 * Ensure the start position (0,0) has multiple direction options
 * This prevents boring linear corridors from the start
 */
function ensureMultipleStartDirections(grid, rooms, size, config) {
    const startCell = grid[0][0];
    const directions = [];

    // Count current available directions
    if (!startCell.walls.right) directions.push('east');
    if (!startCell.walls.bottom) directions.push('south');
    // Note: start is at (0,0) so no north or west possible

    // If we already have 2 directions, we're good
    if (directions.length >= 2) return;

    // Find nearby rooms to connect to
    const nearbyRooms = rooms.filter(r => {
        const dist = Math.abs(r.centerX) + Math.abs(r.centerY);
        return dist > 0 && dist < size / 2;
    }).sort((a, b) => {
        const distA = Math.abs(a.centerX) + Math.abs(a.centerY);
        const distB = Math.abs(b.centerX) + Math.abs(b.centerY);
        return distA - distB;
    });

    // Try to open both east and south directions if possible
    if (!directions.includes('east') && size > 1) {
        // Open east - find a room to the east or just open the path
        const eastRoom = nearbyRooms.find(r => r.centerX > 0);
        if (eastRoom) {
            // Carve corridor from (0,0) to a point going east then to room
            let x = 0;
            const targetX = Math.min(3, eastRoom.centerX);
            while (x < targetX && x < size - 1) {
                grid[0][x].walls.right = false;
                grid[0][x + 1].walls.left = false;
                x++;
            }
            // Now connect to the room
            carveCorridor(grid, size, x, 0, eastRoom.centerX, eastRoom.centerY, config);
        } else {
            // Just open a short path east
            grid[0][0].walls.right = false;
            if (size > 1) grid[0][1].walls.left = false;
        }
    }

    if (!directions.includes('south') && size > 1) {
        // Open south - find a room to the south or just open the path
        const southRoom = nearbyRooms.find(r => r.centerY > 0 && r.centerX < size / 3);
        if (southRoom) {
            // Carve corridor from (0,0) going south then to room
            let y = 0;
            const targetY = Math.min(3, southRoom.centerY);
            while (y < targetY && y < size - 1) {
                grid[y][0].walls.bottom = false;
                grid[y + 1][0].walls.top = false;
                y++;
            }
            // Now connect to the room
            carveCorridor(grid, size, 0, y, southRoom.centerX, southRoom.centerY, config);
        } else {
            // Just open a short path south
            grid[0][0].walls.bottom = false;
            if (size > 1) grid[1][0].walls.top = false;
        }
    }
}

/**
 * Add extra random connections between rooms
 */
function addExtraBSPConnections(grid, rooms, size, config) {
    // Add room-to-room connections
    const extraCount = Math.floor(rooms.length * config.extraConnections);

    for (let i = 0; i < extraCount; i++) {
        const room1 = rooms[Math.floor(Math.random() * rooms.length)];
        const room2 = rooms[Math.floor(Math.random() * rooms.length)];

        if (room1 !== room2 && !room1.connections.includes(room2)) {
            carveCorridor(grid, size,
                room1.centerX, room1.centerY,
                room2.centerX, room2.centerY,
                config);
            room1.connections.push(room2);
            room2.connections.push(room1);
        }
    }

    // Add corridor intersections to create more branch points
    addCorridorIntersections(grid, size, config);
}

/**
 * Add intersection points along corridors to create more direction options
 */
function addCorridorIntersections(grid, size, config) {
    const intersectionCount = Math.floor(size * 2.5); // More intersections for larger maps

    for (let i = 0; i < intersectionCount; i++) {
        // Find a corridor cell (not a room interior, not on edge)
        const x = 2 + Math.floor(Math.random() * (size - 4));
        const y = 2 + Math.floor(Math.random() * (size - 4));

        const cell = grid[y][x];

        // Skip room interiors
        if (cell.isRoomInterior) continue;

        // Count current open directions
        let openDirs = 0;
        if (!cell.walls.top) openDirs++;
        if (!cell.walls.right) openDirs++;
        if (!cell.walls.bottom) openDirs++;
        if (!cell.walls.left) openDirs++;

        // If this is a corridor cell (1-2 open directions), open more directions
        if (openDirs >= 1 && openDirs <= 2) {
            // Open 1-2 additional random directions
            const closedDirs = [];
            if (cell.walls.top && y > 0) closedDirs.push('top');
            if (cell.walls.right && x < size - 1) closedDirs.push('right');
            if (cell.walls.bottom && y < size - 1) closedDirs.push('bottom');
            if (cell.walls.left && x > 0) closedDirs.push('left');

            // Shuffle and pick 1-2 to open
            const toOpen = Math.min(closedDirs.length, 1 + Math.floor(Math.random() * 2));
            for (let j = 0; j < toOpen; j++) {
                const idx = Math.floor(Math.random() * closedDirs.length);
                const dir = closedDirs.splice(idx, 1)[0];

                switch (dir) {
                    case 'top':
                        cell.walls.top = false;
                        grid[y - 1][x].walls.bottom = false;
                        break;
                    case 'right':
                        cell.walls.right = false;
                        grid[y][x + 1].walls.left = false;
                        break;
                    case 'bottom':
                        cell.walls.bottom = false;
                        grid[y + 1][x].walls.top = false;
                        break;
                    case 'left':
                        cell.walls.left = false;
                        grid[y][x - 1].walls.right = false;
                        break;
                }
            }
        }
    }
}

/**
 * Add dead-end branches for maze-like feel
 */
function addBSPDeadEnds(grid, rooms, size, config) {
    const deadEndCount = Math.floor(rooms.length * 0.8);

    for (let i = 0; i < deadEndCount; i++) {
        const room = rooms[Math.floor(Math.random() * rooms.length)];

        // Pick a random direction from room center
        const directions = [
            { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
            { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
        ];
        const dir = directions[Math.floor(Math.random() * directions.length)];

        // Carve a short dead-end branch
        const length = 2 + Math.floor(Math.random() * 3);
        let x = room.centerX + dir.dx * (Math.floor(room.width / 2) + 1);
        let y = room.centerY + dir.dy * (Math.floor(room.height / 2) + 1);

        for (let step = 0; step < length; step++) {
            if (x >= 0 && x < size && y >= 0 && y < size) {
                const cell = grid[y][x];
                cell.corridorType = 'branch';

                // Remove wall in direction of travel
                if (dir.dx > 0 && x < size - 1) {
                    cell.walls.right = false;
                    grid[y][x + 1].walls.left = false;
                } else if (dir.dx < 0 && x > 0) {
                    cell.walls.left = false;
                    grid[y][x - 1].walls.right = false;
                } else if (dir.dy > 0 && y < size - 1) {
                    cell.walls.bottom = false;
                    grid[y + 1][x].walls.top = false;
                } else if (dir.dy < 0 && y > 0) {
                    cell.walls.top = false;
                    grid[y - 1][x].walls.bottom = false;
                }

                x += dir.dx;
                y += dir.dy;
            }
        }
    }
}

// =============================================================================
// v1.4.0 ZONE SYSTEM
// =============================================================================

/**
 * Generate zones from rooms
 * @param {array} rooms - Array of rooms
 * @param {number} zoneCount - Number of zones to create
 * @param {string} theme - Theme for zone naming
 * @returns {array} Array of zones
 */
function generateZones(rooms, zoneCount, theme) {
    if (zoneCount <= 1 || rooms.length <= 1) {
        // No zones - all rooms unlocked
        rooms.forEach(room => { room.zoneId = 0; });
        return [{
            id: 0,
            name: 'Main Area',
            rooms: rooms.map((_, i) => i),
            isUnlocked: true,
            unlockCondition: null,
            gatePositions: []
        }];
    }

    // Sort rooms by distance from start (0,0)
    const sortedRooms = [...rooms].sort((a, b) => {
        const distA = a.centerX + a.centerY;
        const distB = b.centerX + b.centerY;
        return distA - distB;
    });

    // Divide rooms into zones
    const roomsPerZone = Math.ceil(sortedRooms.length / zoneCount);
    const zones = [];

    for (let z = 0; z < zoneCount; z++) {
        const startIdx = z * roomsPerZone;
        const endIdx = Math.min(startIdx + roomsPerZone, sortedRooms.length);
        const zoneRooms = sortedRooms.slice(startIdx, endIdx);

        zoneRooms.forEach(room => { room.zoneId = z; });

        zones.push({
            id: z,
            name: getZoneName(z, zoneCount, theme),
            rooms: zoneRooms.map(r => r.id),
            isUnlocked: z === 0, // First zone always unlocked
            unlockCondition: z === 0 ? null : {
                type: 'clear',
                targetZoneId: z - 1,
                requiredClears: Math.max(1, Math.floor(zoneRooms.length * 0.6))
            },
            gatePositions: []
        });
    }

    return zones;
}

/**
 * Get a themed name for a zone
 */
function getZoneName(zoneIndex, totalZones, theme) {
    const zoneNames = {
        fantasy: ['Entrance Hall', 'The Depths', 'Ancient Crypt', 'Dragon\'s Domain', 'Throne of Shadows', 'Final Sanctum'],
        scifi: ['Docking Bay', 'Crew Quarters', 'Engineering', 'Research Labs', 'Command Deck', 'Core Systems'],
        horror: ['Foyer', 'Patient Ward', 'Basement', 'Ritual Chamber', 'The Abyss', 'Heart of Darkness'],
        cyberpunk: ['Street Level', 'Lower Floors', 'Corporate Zone', 'Executive Suite', 'Server Core', 'Penthouse'],
        western: ['Town Entrance', 'Main Street', 'Back Alleys', 'Mine Tunnels', 'Hideout', 'Final Showdown'],
        action: ['Insertion Point', 'Outer Perimeter', 'Inner Complex', 'High Security', 'Command Center', 'Extraction Zone'],
        comedy: ['Lobby', 'Open Office', 'Break Room Hell', 'Management Floor', 'IT Dungeon', 'CEO\'s Lair']
    };

    const names = zoneNames[theme] || zoneNames.fantasy;
    return names[Math.min(zoneIndex, names.length - 1)];
}

/**
 * Apply zones to grid cells
 */
function applyZonesToGrid(grid, zones, rooms) {
    // Mark cells with zone IDs based on room assignments
    rooms.forEach(room => {
        for (let y = room.y; y < room.y + room.height; y++) {
            for (let x = room.x; x < room.x + room.width; x++) {
                if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
                    grid[y][x].zoneId = room.zoneId;
                }
            }
        }
    });

    // Mark corridors with zone IDs (use nearest room's zone)
    for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[0].length; x++) {
            const cell = grid[y][x];
            if (cell.corridorType && cell.zoneId === null) {
                // Find nearest room and use its zone
                let nearestRoom = null;
                let nearestDist = Infinity;
                rooms.forEach(room => {
                    const dist = Math.abs(room.centerX - x) + Math.abs(room.centerY - y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestRoom = room;
                    }
                });
                if (nearestRoom) {
                    cell.zoneId = nearestRoom.zoneId;
                }
            }
        }
    }
}

/**
 * v1.4.0: Mark a room as cleared and check zone unlocks
 * Called when player defeats a minion in a room
 * @param {number} x - Player x position
 * @param {number} y - Player y position
 */
async function markRoomCleared(x, y) {
    if (!currentMaze || !currentMaze.floorsData) return;

    const floorData = currentMaze.floorsData[currentMaze.currentFloor];
    if (!floorData || !floorData.rooms) return;

    const cell = currentMaze.grid[y]?.[x];
    if (!cell || cell.roomId === undefined || cell.roomId === null) return;

    // Find the room
    const room = floorData.rooms.find(r => r.id === cell.roomId);
    if (!room || room.isCleared) return;

    // Mark as cleared
    room.isCleared = true;
    console.log(`[MazeMaster] Room ${room.id} (${room.type}) cleared`);

    // Fire room clear hook
    await fireHook('onRoomClear', { roomId: room.id, roomType: room.type, x, y });

    // Check zone unlock conditions
    await checkZoneUnlocks();
}

/**
 * v1.4.0: Check if any zones should be unlocked
 */
async function checkZoneUnlocks() {
    if (!currentMaze || !currentMaze.floorsData) return;

    const floorData = currentMaze.floorsData[currentMaze.currentFloor];
    if (!floorData || !floorData.zones || !floorData.rooms) return;

    for (const zone of floorData.zones) {
        if (zone.isUnlocked) continue;

        const condition = zone.unlockCondition;
        if (!condition) continue;

        let shouldUnlock = false;

        switch (condition.type) {
            case 'clear':
                // Count cleared rooms in the target zone (or previous zone)
                const targetZoneId = condition.targetZoneId ?? (zone.id - 1);
                const targetZoneRooms = floorData.rooms.filter(r => r.zoneId === targetZoneId);
                const clearedCount = targetZoneRooms.filter(r => r.isCleared).length;
                const requiredClears = condition.requiredClears || 1;
                shouldUnlock = clearedCount >= requiredClears;
                break;

            case 'boss':
                // Check if boss room in target zone is cleared
                const bossRoom = floorData.rooms.find(r =>
                    r.zoneId === (condition.targetZoneId ?? (zone.id - 1)) &&
                    (r.type === 'bossLair' || r.type === 'boss-arena')
                );
                shouldUnlock = bossRoom?.isCleared === true;
                break;

            case 'key':
                // Check if player has zone key (future implementation)
                shouldUnlock = false; // TODO: implement zone keys
                break;

            case 'start':
                // Starting zone is always unlocked
                shouldUnlock = true;
                break;
        }

        if (shouldUnlock) {
            zone.isUnlocked = true;
            console.log(`[MazeMaster] Zone ${zone.id} (${zone.name}) unlocked!`);
            addMazeMessage('Zone Unlocked', `${zone.name} is now accessible!`);
            await fireHook('onZoneUnlock', { zoneId: zone.id, zoneName: zone.name });
        }
    }
}

/**
 * v1.4.0: Get current zone progress for HUD display
 * @returns {object} Zone progress info
 */
function getZoneProgress() {
    if (!currentMaze || !currentMaze.floorsData) return null;

    const floorData = currentMaze.floorsData[currentMaze.currentFloor];
    if (!floorData || !floorData.zones) return null;

    // Find current zone based on player position
    const cell = currentMaze.grid[currentMaze.playerY]?.[currentMaze.playerX];
    const currentZoneId = cell?.zoneId ?? 0;
    const currentZone = floorData.zones[currentZoneId];

    if (!currentZone) return null;

    // Count cleared rooms in current zone
    const zoneRooms = floorData.rooms.filter(r => r.zoneId === currentZoneId);
    const clearedRooms = zoneRooms.filter(r => r.isCleared).length;

    // Find next locked zone and its unlock requirement
    const nextLockedZone = floorData.zones.find(z => !z.isUnlocked);
    let unlockHint = null;

    if (nextLockedZone) {
        const condition = nextLockedZone.unlockCondition;
        if (condition?.type === 'clear') {
            const targetZoneRooms = floorData.rooms.filter(r => r.zoneId === (condition.targetZoneId ?? (nextLockedZone.id - 1)));
            const targetCleared = targetZoneRooms.filter(r => r.isCleared).length;
            unlockHint = `Clear ${condition.requiredClears - targetCleared} more room(s) to unlock ${nextLockedZone.name}`;
        }
    }

    return {
        zoneName: currentZone.name,
        zoneId: currentZoneId,
        totalRooms: zoneRooms.length,
        clearedRooms,
        isUnlocked: currentZone.isUnlocked,
        unlockHint
    };
}

// =============================================================================
// v1.4.0 SECRET PASSAGES
// =============================================================================

/**
 * Generate secret passages in the grid
 * @param {array} grid - Map grid
 * @param {number} size - Grid size
 * @param {object} config - Secret passage configuration
 */
function generateSecretPassages(grid, size, config) {
    const density = config.secretDensity || 0.02;
    const secretCount = Math.max(1, Math.floor(size * size * density));

    let placed = 0;
    let attempts = 0;
    const maxAttempts = secretCount * 10;

    while (placed < secretCount && attempts < maxAttempts) {
        attempts++;

        // Pick a random cell
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const cell = grid[y][x];

        // Skip if already has a secret or is special
        if (cell.secretPassage || cell.staircase || cell.portal) continue;

        // Find walls that could become secrets
        const wallDirections = [];
        if (cell.walls.top && y > 0) wallDirections.push('top');
        if (cell.walls.right && x < size - 1) wallDirections.push('right');
        if (cell.walls.bottom && y < size - 1) wallDirections.push('bottom');
        if (cell.walls.left && x > 0) wallDirections.push('left');

        if (wallDirections.length === 0) continue;

        // Pick a random wall direction
        const direction = wallDirections[Math.floor(Math.random() * wallDirections.length)];

        // Get target cell
        let targetX = x, targetY = y;
        if (direction === 'top') targetY--;
        if (direction === 'bottom') targetY++;
        if (direction === 'left') targetX--;
        if (direction === 'right') targetX++;

        const targetCell = grid[targetY]?.[targetX];
        if (!targetCell) continue;

        // Don't create secrets to start or exit areas
        if ((x === 0 && y === 0) || (targetX === 0 && targetY === 0)) continue;
        if ((x === size - 1 && y === size - 1) || (targetX === size - 1 && targetY === size - 1)) continue;

        // Create secret passage
        const hintLevel = config.secretHints ? Math.floor(Math.random() * 4) : 0;

        cell.secretPassage = {
            direction,
            revealed: false,
            hintLevel,
            targetCell: { x: targetX, y: targetY }
        };

        placed++;
    }

    console.log(`[MazeMaster] Placed ${placed} secret passages`);
}

/**
 * Attempt to discover a secret passage
 * @param {object} cell - Cell to check
 * @param {string} direction - Direction to check
 * @param {string} method - Discovery method: 'tap', 'item', 'passive'
 * @param {object} inventory - Player inventory
 * @returns {object} { found, revealed, hint }
 */
function attemptSecretDiscovery(cell, direction, method, inventory) {
    const secret = cell.secretPassage;

    if (!secret || secret.direction !== direction || secret.revealed) {
        return { found: false };
    }

    // Calculate discovery chance
    // v1.4.9: Improved chances - level 3 hints ("clearly visible") are near-guaranteed
    let chance = 0;
    switch (method) {
        case 'tap':
            // Level 0: 15%, Level 1: 30%, Level 2: 60%, Level 3: 95%
            chance = 0.15 + (secret.hintLevel * 0.25);
            if (secret.hintLevel >= 3) chance = 0.95;
            break;
        case 'item':
            chance = 0.9 + (secret.hintLevel * 0.025);
            break;
        case 'passive':
            chance = secret.hintLevel >= 3 ? 0.7 : 0;
            break;
    }

    // Bonus from Secret Sense item
    if (inventory?.secretSense > 0) {
        chance += 0.2;
    }

    chance = Math.min(chance, 1.0);

    if (Math.random() < chance) {
        return { found: true, revealed: true };
    }

    // Return hint if available
    if (secret.hintLevel > 0 && method === 'tap') {
        return { found: false, hint: true, hintLevel: secret.hintLevel };
    }

    return { found: false };
}

/**
 * Reveal a secret passage
 */
function revealSecretPassage(grid, x, y, direction) {
    const cell = grid[y][x];
    if (!cell.secretPassage || cell.secretPassage.direction !== direction) return false;

    cell.secretPassage.revealed = true;
    cell.walls[direction] = false;

    // Open corresponding wall on target cell
    const target = cell.secretPassage.targetCell;
    const oppositeDir = { top: 'bottom', bottom: 'top', left: 'right', right: 'left' }[direction];
    if (grid[target.y]?.[target.x]) {
        grid[target.y][target.x].walls[oppositeDir] = false;
    }

    return true;
}

/**
 * v1.4.0: Try to discover a secret when bumping into a wall
 * Called from tryMazeMove when player walks into a wall
 */
function trySecretDiscovery(cell, direction) {
    if (!cell.secretPassage || cell.secretPassage.direction !== direction) {
        return { found: false, attempted: false };
    }

    if (cell.secretPassage.revealed) {
        return { found: false, attempted: false };
    }

    // Use the attemptSecretDiscovery function with 'tap' method
    const inventory = currentMaze?.inventory;
    const result = attemptSecretDiscovery(cell, direction, 'tap', inventory);

    if (result.found) {
        return { found: true, attempted: true };
    }

    // Provide hints based on hint level
    let message = 'The wall feels solid...';
    if (result.hint) {
        switch (result.hintLevel) {
            case 1:
                message = 'You notice something unusual about this wall...';
                break;
            case 2:
                message = 'There\'s a faint crack here. Try again?';
                break;
            case 3:
                message = 'This section of wall seems hollow!';
                break;
        }
    }

    return { found: false, attempted: true, message };
}

// =============================================================================
// ORIGINAL MAZE GENERATION (preserved for compatibility)
// =============================================================================

function generateMaze(size) {
    // Create grid of cells with all walls
    const grid = [];
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = {
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false,
                minion: null, // { minionId, triggered }
                trap: null // { trapId, triggered }
            };
        }
    }

    // Recursive backtracking
    const stack = [];
    let current = { x: 0, y: 0 };
    grid[0][0].visited = true;

    function getUnvisitedNeighbors(x, y) {
        const neighbors = [];
        if (y > 0 && !grid[y-1][x].visited) neighbors.push({ x, y: y-1, dir: 'top' });
        if (x < size-1 && !grid[y][x+1].visited) neighbors.push({ x: x+1, y, dir: 'right' });
        if (y < size-1 && !grid[y+1][x].visited) neighbors.push({ x, y: y+1, dir: 'bottom' });
        if (x > 0 && !grid[y][x-1].visited) neighbors.push({ x: x-1, y, dir: 'left' });
        return neighbors;
    }

    while (true) {
        const neighbors = getUnvisitedNeighbors(current.x, current.y);
        if (neighbors.length > 0) {
            const next = neighbors[Math.floor(Math.random() * neighbors.length)];
            stack.push(current);

            // Remove walls between current and next
            if (next.dir === 'top') {
                grid[current.y][current.x].walls.top = false;
                grid[next.y][next.x].walls.bottom = false;
            } else if (next.dir === 'right') {
                grid[current.y][current.x].walls.right = false;
                grid[next.y][next.x].walls.left = false;
            } else if (next.dir === 'bottom') {
                grid[current.y][current.x].walls.bottom = false;
                grid[next.y][next.x].walls.top = false;
            } else if (next.dir === 'left') {
                grid[current.y][current.x].walls.left = false;
                grid[next.y][next.x].walls.right = false;
            }

            current = { x: next.x, y: next.y };
            grid[current.y][current.x].visited = true;
        } else if (stack.length > 0) {
            current = stack.pop();
        } else {
            break;
        }
    }

    // Add extra passages for multiple pathways and dead ends
    addExtraPassages(grid, size);

    // Reset visited flags for gameplay
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            grid[y][x].visited = false;
        }
    }

    return grid;
}

// =============================================================================
// v1.2.0 MAP STYLE GENERATION ALGORITHMS
// =============================================================================

/**
 * Generate a city-style grid with streets between building blocks
 */
function generateCityGrid(size) {
    const grid = [];

    // Initialize all cells with walls
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = {
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false,
                minion: null,
                trap: null
            };
        }
    }

    // Create main street grid (every 3-4 cells)
    const streetSpacing = Math.max(3, Math.floor(size / 4));

    // Create horizontal streets
    for (let y = 0; y < size; y++) {
        if (y % streetSpacing === 1 || y === 0 || y === size - 1) {
            for (let x = 0; x < size - 1; x++) {
                grid[y][x].walls.right = false;
                grid[y][x + 1].walls.left = false;
            }
        }
    }

    // Create vertical streets
    for (let x = 0; x < size; x++) {
        if (x % streetSpacing === 1 || x === 0 || x === size - 1) {
            for (let y = 0; y < size - 1; y++) {
                grid[y][x].walls.bottom = false;
                grid[y + 1][x].walls.top = false;
            }
        }
    }

    // Add random alleys within blocks (20% chance per potential alley)
    for (let y = 0; y < size - 1; y++) {
        for (let x = 0; x < size - 1; x++) {
            if (Math.random() < 0.2) {
                const dir = Math.random() < 0.5 ? 'right' : 'bottom';
                if (dir === 'right') {
                    grid[y][x].walls.right = false;
                    grid[y][x + 1].walls.left = false;
                } else {
                    grid[y][x].walls.bottom = false;
                    grid[y + 1][x].walls.top = false;
                }
            }
        }
    }

    // Ensure start and exit are connected
    ensureConnected(grid, size, 0, 0, size - 1, size - 1);

    return grid;
}

/**
 * Generate a forest-style grid with organic winding paths
 */
function generateForestGrid(size) {
    const grid = [];

    // Initialize all cells with walls
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = {
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false,
                minion: null,
                trap: null
            };
        }
    }

    // Create main winding path from start to exit using weighted random walk
    let x = 0, y = 0;
    const visited = new Set(['0,0']);
    const path = [{ x: 0, y: 0 }];
    grid[0][0].visited = true;

    while (x !== size - 1 || y !== size - 1) {
        // Weight movement toward exit
        const directions = [];
        if (y > 0) directions.push({ dx: 0, dy: -1, weight: 0.1 });  // up (away from exit)
        if (x < size - 1) directions.push({ dx: 1, dy: 0, weight: 0.4 }); // right (toward exit)
        if (y < size - 1) directions.push({ dx: 0, dy: 1, weight: 0.4 }); // down (toward exit)
        if (x > 0) directions.push({ dx: -1, dy: 0, weight: 0.1 }); // left (away from exit)

        // Filter unvisited cells with walls
        const validDirs = directions.filter(d => {
            const nx = x + d.dx;
            const ny = y + d.dy;
            return nx >= 0 && nx < size && ny >= 0 && ny < size;
        });

        if (validDirs.length === 0) break;

        // Weighted random selection
        const totalWeight = validDirs.reduce((sum, d) => sum + d.weight, 0);
        let rand = Math.random() * totalWeight;
        let chosen = validDirs[0];
        for (const dir of validDirs) {
            rand -= dir.weight;
            if (rand <= 0) { chosen = dir; break; }
        }

        const nx = x + chosen.dx;
        const ny = y + chosen.dy;

        // Remove wall between cells
        if (chosen.dx === 1) { grid[y][x].walls.right = false; grid[ny][nx].walls.left = false; }
        if (chosen.dx === -1) { grid[y][x].walls.left = false; grid[ny][nx].walls.right = false; }
        if (chosen.dy === 1) { grid[y][x].walls.bottom = false; grid[ny][nx].walls.top = false; }
        if (chosen.dy === -1) { grid[y][x].walls.top = false; grid[ny][nx].walls.bottom = false; }

        x = nx;
        y = ny;
        visited.add(`${x},${y}`);
        path.push({ x, y });
        grid[y][x].visited = true;
    }

    // Add branch paths from main path to create exploration areas
    const branchCount = Math.floor(size * 0.8);
    for (let i = 0; i < branchCount; i++) {
        const start = path[Math.floor(Math.random() * path.length)];
        createBranchPath(grid, size, start.x, start.y, Math.floor(size / 2));
    }

    // Add clearings (open 2x2 areas)
    const clearingCount = Math.floor(size / 5);
    for (let i = 0; i < clearingCount; i++) {
        const cx = 1 + Math.floor(Math.random() * (size - 2));
        const cy = 1 + Math.floor(Math.random() * (size - 2));
        createClearing(grid, cx, cy);
    }

    // Reset visited flags
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            grid[y][x].visited = false;
        }
    }

    ensureConnected(grid, size, 0, 0, size - 1, size - 1);
    return grid;
}

/**
 * Generate a spaceship-style grid with room pods connected by corridors
 */
function generateSpaceshipGrid(size) {
    const grid = [];

    // Initialize all cells with walls
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = {
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false,
                minion: null,
                trap: null
            };
        }
    }

    // Generate room pods (2x2 or 3x3 open areas)
    const rooms = [];
    const roomCount = Math.max(4, Math.floor((size * size) / 20));

    for (let i = 0; i < roomCount * 3; i++) { // Try multiple times to place rooms
        if (rooms.length >= roomCount) break;

        const roomSize = Math.random() < 0.5 ? 2 : 3;
        const rx = Math.floor(Math.random() * (size - roomSize));
        const ry = Math.floor(Math.random() * (size - roomSize));

        // Check for overlap with existing rooms
        let overlaps = false;
        for (const room of rooms) {
            if (rx < room.x + room.size + 1 && rx + roomSize + 1 > room.x &&
                ry < room.y + room.size + 1 && ry + roomSize + 1 > room.y) {
                overlaps = true;
                break;
            }
        }

        if (!overlaps) {
            rooms.push({ x: rx, y: ry, size: roomSize });
            // Open the room
            for (let dy = 0; dy < roomSize; dy++) {
                for (let dx = 0; dx < roomSize; dx++) {
                    if (dx < roomSize - 1) {
                        grid[ry + dy][rx + dx].walls.right = false;
                        grid[ry + dy][rx + dx + 1].walls.left = false;
                    }
                    if (dy < roomSize - 1) {
                        grid[ry + dy][rx + dx].walls.bottom = false;
                        grid[ry + dy + 1][rx + dx].walls.top = false;
                    }
                }
            }
        }
    }

    // Ensure start and exit rooms exist
    if (!rooms.some(r => r.x === 0 && r.y === 0)) {
        rooms.unshift({ x: 0, y: 0, size: 2 });
        grid[0][0].walls.right = false; grid[0][1].walls.left = false;
        grid[1][0].walls.right = false; grid[1][1].walls.left = false;
        grid[0][0].walls.bottom = false; grid[1][0].walls.top = false;
        grid[0][1].walls.bottom = false; grid[1][1].walls.top = false;
    }

    // Connect rooms with corridors
    for (let i = 0; i < rooms.length - 1; i++) {
        const r1 = rooms[i];
        const r2 = rooms[i + 1];
        connectRoomsWithCorridor(grid, size, r1, r2);
    }

    // Connect last room to first to ensure full connectivity
    if (rooms.length > 2) {
        connectRoomsWithCorridor(grid, size, rooms[rooms.length - 1], rooms[0]);
    }

    ensureConnected(grid, size, 0, 0, size - 1, size - 1);
    return grid;
}

/**
 * Generate a dungeon-style grid with BSP-like chambers and hallways
 */
function generateDungeonGrid(size) {
    const grid = [];

    // Initialize all cells with walls
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = {
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false,
                minion: null,
                trap: null
            };
        }
    }

    // Create rectangular chambers
    const chambers = [];
    const minChamberSize = 2;
    const maxChamberSize = Math.max(3, Math.floor(size / 3));

    // Place chambers
    for (let attempts = 0; attempts < size * 2; attempts++) {
        const w = minChamberSize + Math.floor(Math.random() * (maxChamberSize - minChamberSize + 1));
        const h = minChamberSize + Math.floor(Math.random() * (maxChamberSize - minChamberSize + 1));
        const x = Math.floor(Math.random() * (size - w));
        const y = Math.floor(Math.random() * (size - h));

        // Check overlap
        let valid = true;
        for (const c of chambers) {
            if (x < c.x + c.w + 1 && x + w + 1 > c.x &&
                y < c.y + c.h + 1 && y + h + 1 > c.y) {
                valid = false;
                break;
            }
        }

        if (valid) {
            chambers.push({ x, y, w, h });
            // Carve out chamber
            for (let cy = y; cy < y + h; cy++) {
                for (let cx = x; cx < x + w; cx++) {
                    if (cx < x + w - 1) {
                        grid[cy][cx].walls.right = false;
                        grid[cy][cx + 1].walls.left = false;
                    }
                    if (cy < y + h - 1) {
                        grid[cy][cx].walls.bottom = false;
                        grid[cy + 1][cx].walls.top = false;
                    }
                }
            }
        }
    }

    // Ensure start chamber exists
    if (!chambers.some(c => c.x <= 1 && c.y <= 1)) {
        chambers.unshift({ x: 0, y: 0, w: 2, h: 2 });
        grid[0][0].walls.right = false; grid[0][1].walls.left = false;
        grid[1][0].walls.right = false; grid[1][1].walls.left = false;
        grid[0][0].walls.bottom = false; grid[1][0].walls.top = false;
    }

    // Connect chambers with hallways
    for (let i = 0; i < chambers.length - 1; i++) {
        const c1 = chambers[i];
        const c2 = chambers[i + 1];
        connectChambersWithHallway(grid, size, c1, c2);
    }

    // Connect first and last chambers
    if (chambers.length > 2) {
        connectChambersWithHallway(grid, size, chambers[chambers.length - 1], chambers[0]);
    }

    ensureConnected(grid, size, 0, 0, size - 1, size - 1);
    return grid;
}

/**
 * Generate grid based on map style
 * v1.4.0: Now uses BSP generation for all styles
 * @param {number} size - Grid size
 * @param {string} mapStyle - Map style name
 * @param {string} theme - Theme for room typing (default: 'fantasy')
 * @param {object} bspConfig - Optional BSP configuration overrides
 * @returns {object} { grid, rooms } - Grid and room data
 */
function generateGridByStyle(size, mapStyle, theme = 'fantasy', bspConfig = {}) {
    // v1.4.0: Use BSP generation for all styles
    console.log(`[MazeMaster] Generating BSP grid: size=${size}, style=${mapStyle}, theme=${theme}`);

    const result = generateBSPGrid(size, mapStyle, theme, bspConfig);

    // Log generation stats
    console.log(`[MazeMaster] Generated ${result.rooms.length} rooms`);

    return result;
}

/**
 * Legacy wrapper for backward compatibility
 * Returns just the grid (used by old code paths)
 */
function generateGridByStyleLegacy(size, mapStyle) {
    switch (mapStyle) {
        case 'city':
        case 'neotokyo':
            return generateCityGrid(size);
        case 'forest':
            return generateForestGrid(size);
        case 'spaceship':
        case 'spacestation':
            return generateSpaceshipGrid(size);
        case 'dungeon':
            return generateDungeonGrid(size);
        case 'outpost':
        case 'arena':
            return generateDungeonGrid(size);
        case 'college':
        case 'apartment':
        case 'hospital':
        case 'highrise':
            return generateCityGrid(size);
        case 'maze':
        default:
            return generateMaze(size);
    }
}

// Helper functions for map generation

function createBranchPath(grid, size, startX, startY, maxLength) {
    let x = startX, y = startY;
    for (let i = 0; i < maxLength; i++) {
        const dirs = [];
        if (y > 0) dirs.push({ dx: 0, dy: -1 });
        if (x < size - 1) dirs.push({ dx: 1, dy: 0 });
        if (y < size - 1) dirs.push({ dx: 0, dy: 1 });
        if (x > 0) dirs.push({ dx: -1, dy: 0 });

        if (dirs.length === 0) break;

        const chosen = dirs[Math.floor(Math.random() * dirs.length)];
        const nx = x + chosen.dx;
        const ny = y + chosen.dy;

        // Remove wall
        if (chosen.dx === 1) { grid[y][x].walls.right = false; grid[ny][nx].walls.left = false; }
        if (chosen.dx === -1) { grid[y][x].walls.left = false; grid[ny][nx].walls.right = false; }
        if (chosen.dy === 1) { grid[y][x].walls.bottom = false; grid[ny][nx].walls.top = false; }
        if (chosen.dy === -1) { grid[y][x].walls.top = false; grid[ny][nx].walls.bottom = false; }

        x = nx;
        y = ny;
    }
}

function createClearing(grid, cx, cy) {
    // Open a 2x2 area
    if (cx > 0 && cy > 0 && cx < grid[0].length - 1 && cy < grid.length - 1) {
        grid[cy][cx].walls.right = false; grid[cy][cx + 1].walls.left = false;
        grid[cy + 1][cx].walls.right = false; grid[cy + 1][cx + 1].walls.left = false;
        grid[cy][cx].walls.bottom = false; grid[cy + 1][cx].walls.top = false;
        grid[cy][cx + 1].walls.bottom = false; grid[cy + 1][cx + 1].walls.top = false;
    }
}

function connectRoomsWithCorridor(grid, size, r1, r2) {
    // Find center points of rooms
    const x1 = Math.floor(r1.x + r1.size / 2);
    const y1 = Math.floor(r1.y + r1.size / 2);
    const x2 = Math.floor(r2.x + r2.size / 2);
    const y2 = Math.floor(r2.y + r2.size / 2);

    // L-shaped corridor
    let x = x1, y = y1;

    // Move horizontally first
    while (x !== x2) {
        const nx = x < x2 ? x + 1 : x - 1;
        if (nx >= 0 && nx < size) {
            if (x < x2) { grid[y][x].walls.right = false; grid[y][nx].walls.left = false; }
            else { grid[y][x].walls.left = false; grid[y][nx].walls.right = false; }
            x = nx;
        } else break;
    }

    // Then vertically
    while (y !== y2) {
        const ny = y < y2 ? y + 1 : y - 1;
        if (ny >= 0 && ny < size) {
            if (y < y2) { grid[y][x].walls.bottom = false; grid[ny][x].walls.top = false; }
            else { grid[y][x].walls.top = false; grid[ny][x].walls.bottom = false; }
            y = ny;
        } else break;
    }
}

function connectChambersWithHallway(grid, size, c1, c2) {
    // Find edge midpoints
    const x1 = Math.floor(c1.x + c1.w / 2);
    const y1 = Math.floor(c1.y + c1.h / 2);
    const x2 = Math.floor(c2.x + c2.w / 2);
    const y2 = Math.floor(c2.y + c2.h / 2);

    // L-shaped hallway
    let x = x1, y = y1;

    // Horizontal then vertical (or vice versa randomly)
    const horizontalFirst = Math.random() < 0.5;

    if (horizontalFirst) {
        while (x !== x2) {
            const nx = x < x2 ? x + 1 : x - 1;
            if (nx >= 0 && nx < size) {
                if (x < x2) { grid[y][x].walls.right = false; grid[y][nx].walls.left = false; }
                else { grid[y][x].walls.left = false; grid[y][nx].walls.right = false; }
                x = nx;
            } else break;
        }
        while (y !== y2) {
            const ny = y < y2 ? y + 1 : y - 1;
            if (ny >= 0 && ny < size) {
                if (y < y2) { grid[y][x].walls.bottom = false; grid[ny][x].walls.top = false; }
                else { grid[y][x].walls.top = false; grid[ny][x].walls.bottom = false; }
                y = ny;
            } else break;
        }
    } else {
        while (y !== y2) {
            const ny = y < y2 ? y + 1 : y - 1;
            if (ny >= 0 && ny < size) {
                if (y < y2) { grid[y][x].walls.bottom = false; grid[ny][x].walls.top = false; }
                else { grid[y][x].walls.top = false; grid[ny][x].walls.bottom = false; }
                y = ny;
            } else break;
        }
        while (x !== x2) {
            const nx = x < x2 ? x + 1 : x - 1;
            if (nx >= 0 && nx < size) {
                if (x < x2) { grid[y][x].walls.right = false; grid[y][nx].walls.left = false; }
                else { grid[y][x].walls.left = false; grid[y][nx].walls.right = false; }
                x = nx;
            } else break;
        }
    }
}

function ensureConnected(grid, size, startX, startY, endX, endY) {
    // Use BFS to check if end is reachable from start
    const visited = new Set([`${startX},${startY}`]);
    const queue = [{ x: startX, y: startY }];

    while (queue.length > 0) {
        const { x, y } = queue.shift();
        if (x === endX && y === endY) return; // Already connected

        // Check each direction
        if (!grid[y][x].walls.top && y > 0 && !visited.has(`${x},${y - 1}`)) {
            visited.add(`${x},${y - 1}`);
            queue.push({ x, y: y - 1 });
        }
        if (!grid[y][x].walls.right && x < size - 1 && !visited.has(`${x + 1},${y}`)) {
            visited.add(`${x + 1},${y}`);
            queue.push({ x: x + 1, y });
        }
        if (!grid[y][x].walls.bottom && y < size - 1 && !visited.has(`${x},${y + 1}`)) {
            visited.add(`${x},${y + 1}`);
            queue.push({ x, y: y + 1 });
        }
        if (!grid[y][x].walls.left && x > 0 && !visited.has(`${x - 1},${y}`)) {
            visited.add(`${x - 1},${y}`);
            queue.push({ x: x - 1, y });
        }
    }

    // Not connected - carve a winding path with multiple turns
    // Create 2-4 waypoints for a more interesting route
    const waypoints = [];
    const numWaypoints = 2 + Math.floor(Math.random() * 3);

    for (let i = 1; i <= numWaypoints; i++) {
        const t = i / (numWaypoints + 1);
        // Add randomness to waypoint positions
        const baseX = startX + Math.floor((endX - startX) * t);
        const baseY = startY + Math.floor((endY - startY) * t);
        const offsetX = Math.floor((Math.random() - 0.5) * size * 0.4);
        const offsetY = Math.floor((Math.random() - 0.5) * size * 0.4);
        waypoints.push({
            x: Math.max(0, Math.min(size - 1, baseX + offsetX)),
            y: Math.max(0, Math.min(size - 1, baseY + offsetY))
        });
    }

    // Carve path through waypoints
    let x = startX, y = startY;
    const allPoints = [...waypoints, { x: endX, y: endY }];

    for (const target of allPoints) {
        // Randomly choose horizontal-first or vertical-first for each segment
        const horizontalFirst = Math.random() < 0.5;

        if (horizontalFirst) {
            // Move horizontally first
            while (x !== target.x) {
                const nx = x < target.x ? x + 1 : x - 1;
                if (nx >= 0 && nx < size) {
                    if (x < target.x) { grid[y][x].walls.right = false; grid[y][nx].walls.left = false; }
                    else { grid[y][x].walls.left = false; grid[y][nx].walls.right = false; }
                    x = nx;
                } else break;
            }
            // Then vertically
            while (y !== target.y) {
                const ny = y < target.y ? y + 1 : y - 1;
                if (ny >= 0 && ny < size) {
                    if (y < target.y) { grid[y][x].walls.bottom = false; grid[ny][x].walls.top = false; }
                    else { grid[y][x].walls.top = false; grid[ny][x].walls.bottom = false; }
                    y = ny;
                } else break;
            }
        } else {
            // Move vertically first
            while (y !== target.y) {
                const ny = y < target.y ? y + 1 : y - 1;
                if (ny >= 0 && ny < size) {
                    if (y < target.y) { grid[y][x].walls.bottom = false; grid[ny][x].walls.top = false; }
                    else { grid[y][x].walls.top = false; grid[ny][x].walls.bottom = false; }
                    y = ny;
                } else break;
            }
            // Then horizontally
            while (x !== target.x) {
                const nx = x < target.x ? x + 1 : x - 1;
                if (nx >= 0 && nx < size) {
                    if (x < target.x) { grid[y][x].walls.right = false; grid[y][nx].walls.left = false; }
                    else { grid[y][x].walls.left = false; grid[y][nx].walls.right = false; }
                    x = nx;
                } else break;
            }
        }
    }
}

/**
 * Add staircases connecting multiple floors
 */
/**
 * Check if a cell is reachable from a start point using BFS
 */
function isCellReachable(grid, size, startX, startY, targetX, targetY) {
    if (startX === targetX && startY === targetY) return true;

    const visited = new Set([`${startX},${startY}`]);
    const queue = [{ x: startX, y: startY }];

    while (queue.length > 0) {
        const { x, y } = queue.shift();
        if (x === targetX && y === targetY) return true;

        if (!grid[y][x].walls.top && y > 0 && !visited.has(`${x},${y - 1}`)) {
            visited.add(`${x},${y - 1}`);
            queue.push({ x, y: y - 1 });
        }
        if (!grid[y][x].walls.right && x < size - 1 && !visited.has(`${x + 1},${y}`)) {
            visited.add(`${x + 1},${y}`);
            queue.push({ x: x + 1, y });
        }
        if (!grid[y][x].walls.bottom && y < size - 1 && !visited.has(`${x},${y + 1}`)) {
            visited.add(`${x},${y + 1}`);
            queue.push({ x, y: y + 1 });
        }
        if (!grid[y][x].walls.left && x > 0 && !visited.has(`${x - 1},${y}`)) {
            visited.add(`${x - 1},${y}`);
            queue.push({ x: x - 1, y });
        }
    }
    return false;
}

/**
 * Check if a cell has at least one open wall (is accessible)
 */
function hasOpenWall(cell) {
    return !cell.walls.top || !cell.walls.right || !cell.walls.bottom || !cell.walls.left;
}

function addStaircasesToFloors(floors, size, requireFloorKey, exitX, exitY) {
    const totalFloors = floors.length;

    for (let f = 0; f < totalFloors - 1; f++) {
        const lowerFloor = floors[f];
        const upperFloor = floors[f + 1];

        // Find suitable positions for stairs - must be reachable and have open walls
        const validPositions = [];
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                // Skip start (0,0) and exit position
                if ((x === 0 && y === 0) || (x === exitX && y === exitY)) continue;
                // Skip cells with existing features
                const lowerCell = lowerFloor[y][x];
                const upperCell = upperFloor[y][x];
                if (lowerCell.minion || lowerCell.trap || lowerCell.chest) continue;
                if (upperCell.minion || upperCell.trap || upperCell.chest) continue;
                // Must have at least one open wall on both floors
                if (!hasOpenWall(lowerCell) || !hasOpenWall(upperCell)) continue;
                // Must be reachable from start on lower floor
                if (!isCellReachable(lowerFloor, size, 0, 0, x, y)) continue;
                validPositions.push({ x, y });
            }
        }

        if (validPositions.length < 1) {
            console.warn(`[MazeMaster] No valid staircase positions found for floor ${f} -> ${f + 1}`);
            continue;
        }

        // Pick 1-2 staircase locations per floor connection
        const staircaseCount = Math.min(2, Math.max(1, Math.floor(size / 5)));

        for (let s = 0; s < staircaseCount && validPositions.length > 0; s++) {
            const idx = Math.floor(Math.random() * validPositions.length);
            const pos = validPositions.splice(idx, 1)[0];

            // Add ascending staircase on lower floor
            lowerFloor[pos.y][pos.x].staircase = {
                direction: 'up',
                targetFloor: f + 1,
                targetX: pos.x,
                targetY: pos.y,
                requireKey: requireFloorKey,
            };

            // Add descending staircase on upper floor (same position)
            upperFloor[pos.y][pos.x].staircase = {
                direction: 'down',
                targetFloor: f,
                targetX: pos.x,
                targetY: pos.y,
                requireKey: false, // Going down doesn't require key
            };

            // Ensure the staircase position on upper floor is connected to that floor's exit
            ensureConnected(upperFloor, size, pos.x, pos.y, exitX, exitY);
            console.log(`[MazeMaster] Staircase placed at (${pos.x}, ${pos.y}) connecting floor ${f} to ${f + 1}`);
        }
    }
}

/**
 * Guarantee floor keys are available on floors that need them
 * For each floor with an ascending staircase that requires a key,
 * ensure at least one chest on that floor will drop a floor key.
 * Returns the number of keys that couldn't be placed in chests (to add to starting inventory)
 * @param {Array} floors - Array of floor grids
 * @param {number} size - Grid size
 * @returns {number} Number of floor keys to add to starting inventory
 */
function guaranteeFloorKeys(floors, size) {
    let keysNeededInInventory = 0;

    for (let f = 0; f < floors.length; f++) {
        const floor = floors[f];

        // Check if this floor has an ascending staircase that requires a key
        let needsKey = false;
        for (let y = 0; y < size && !needsKey; y++) {
            for (let x = 0; x < size && !needsKey; x++) {
                const cell = floor[y][x];
                if (cell.staircase?.direction === 'up' && cell.staircase?.requireKey) {
                    needsKey = true;
                }
            }
        }

        if (!needsKey) continue;

        // Find chests on this floor to guarantee a floor key
        const chestsOnFloor = [];
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const cell = floor[y][x];
                if (cell.chest && !cell.chest.guaranteedFloorKey) {
                    chestsOnFloor.push({ x, y, cell });
                }
            }
        }

        if (chestsOnFloor.length > 0) {
            // Pick a random chest to guarantee the floor key
            const chosenIdx = Math.floor(Math.random() * chestsOnFloor.length);
            const chosen = chestsOnFloor[chosenIdx];
            chosen.cell.chest.guaranteedFloorKey = true;
            console.log(`[MazeMaster] Floor ${f}: Guaranteed floor key in chest at (${chosen.x}, ${chosen.y})`);
        } else {
            // No chest available - need to add to starting inventory
            keysNeededInInventory++;
            console.log(`[MazeMaster] Floor ${f}: No chest found - adding floor key to starting inventory`);
        }
    }

    return keysNeededInInventory;
}

/**
 * Enforce wall consistency - ensure both sides of each wall match
 * If cell A has no right wall, cell B (to the right) should have no left wall
 * This fixes rendering/movement mismatches caused by asymmetric wall data
 */
function enforceWallConsistency(grid, size) {
    let fixes = 0;

    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const cell = grid[y][x];

            // Check right neighbor - walls must be symmetric
            if (x < size - 1) {
                const rightCell = grid[y][x + 1];
                const rightWallMismatch = cell.walls.right !== rightCell.walls.left;
                if (rightWallMismatch) {
                    // If either says open, make both open
                    if (!cell.walls.right || !rightCell.walls.left) {
                        cell.walls.right = false;
                        rightCell.walls.left = false;
                    } else {
                        // Both say closed but somehow different? Keep closed
                        cell.walls.right = true;
                        rightCell.walls.left = true;
                    }
                    fixes++;
                }
            }

            // Check bottom neighbor - walls must be symmetric
            if (y < size - 1) {
                const bottomCell = grid[y + 1][x];
                const bottomWallMismatch = cell.walls.bottom !== bottomCell.walls.top;
                if (bottomWallMismatch) {
                    // If either says open, make both open
                    if (!cell.walls.bottom || !bottomCell.walls.top) {
                        cell.walls.bottom = false;
                        bottomCell.walls.top = false;
                    } else {
                        cell.walls.bottom = true;
                        bottomCell.walls.top = true;
                    }
                    fixes++;
                }
            }
        }
    }
}

/**
 * Add extra passages to create alternate pathways (sparingly to keep maze challenging)
 */
function addExtraPassages(grid, size) {
    // Calculate how many extra passages based on grid size (~3% of cells)
    // Lower = more challenging maze, higher = more alternate routes
    const extraCount = Math.floor(size * size * 0.03);

    for (let i = 0; i < extraCount; i++) {
        // Pick random cell (not on edge to avoid border issues)
        const x = 1 + Math.floor(Math.random() * (size - 2));
        const y = 1 + Math.floor(Math.random() * (size - 2));

        // Pick random direction
        const directions = ['top', 'right', 'bottom', 'left'];
        const dir = directions[Math.floor(Math.random() * 4)];

        // Remove wall if it exists (creates alternate path)
        removeWallBetweenCells(grid, x, y, dir, size);
    }
}

/**
 * Remove wall between a cell and its neighbor in a given direction
 */
function removeWallBetweenCells(grid, x, y, dir, size) {
    const cell = grid[y][x];
    if (dir === 'top' && y > 0) {
        cell.walls.top = false;
        grid[y-1][x].walls.bottom = false;
    } else if (dir === 'right' && x < size - 1) {
        cell.walls.right = false;
        grid[y][x+1].walls.left = false;
    } else if (dir === 'bottom' && y < size - 1) {
        cell.walls.bottom = false;
        grid[y+1][x].walls.top = false;
    } else if (dir === 'left' && x > 0) {
        cell.walls.left = false;
        grid[y][x-1].walls.right = false;
    }
}

/**
 * Normalize tile distribution from percentages to counts
 * Applies difficulty scaling multipliers
 */
function normalizeTileDistribution(profile, totalValidCells) {
    const result = {
        minionPlacements: [],
        trapPlacements: [],
        chestCount: 0,
    };

    // Get difficulty settings for scaling
    const difficulty = getDifficultySettings(profile);
    const encounterMult = difficulty.encounterDensityMult || 1.0;
    const trapMult = difficulty.trapFrequencyMult || 1.0;

    // Calculate raw percentages
    const chestPercent = profile.chestTilePercent || 0;
    const minionEncounters = profile.minionEncounters || [];
    const trapEncounters = profile.trapEncounters || [];

    // Apply difficulty multipliers to percentages
    let totalMinionPercent = minionEncounters.reduce((sum, e) => sum + ((e.percent || 0) * encounterMult), 0);
    let totalTrapPercent = trapEncounters.reduce((sum, e) => sum + ((e.percent || 0) * trapMult), 0);

    // Calculate total allocation
    const totalPercent = chestPercent + totalMinionPercent + totalTrapPercent;

    // Scale down proportionally if over 100%
    let scale = 1;
    if (totalPercent > 100) {
        scale = 100 / totalPercent;
        console.log(`[MazeMaster] Distribution over 100% (${totalPercent}%), scaling down by ${scale.toFixed(2)}`);
    }

    // Calculate chest count
    result.chestCount = Math.floor(totalValidCells * (chestPercent * scale) / 100);

    // Convert minion percentages to counts (with difficulty scaling)
    // Use Math.round to ensure small percentages still produce encounters
    for (const encounter of minionEncounters) {
        const scaledPercent = (encounter.percent || 0) * encounterMult * scale;
        const count = Math.round(totalValidCells * scaledPercent / 100);
        if (count > 0) {
            result.minionPlacements.push({ minionId: encounter.minionId, count });
        }
    }

    // Convert trap percentages to counts (with difficulty scaling)
    for (const encounter of trapEncounters) {
        const scaledPercent = (encounter.percent || 0) * trapMult * scale;
        const count = Math.round(totalValidCells * scaledPercent / 100);
        if (count > 0) {
            result.trapPlacements.push({ trapId: encounter.trapId, count });
        }
    }

    return result;
}

/**
 * v1.8.1: Place minions respecting zone boundaries and safe start radius
 * Implements proper zone-based encounter progression
 */
function placeMinionsByZone(grid, profile, size, mainMinionId) {
    const zoneCount = profile.bspConfig?.zoneCount || 4;
    const safeRadius = profile.safeStartRadius ?? 2;
    const minionEncounters = profile.minionEncounters || [];
    const difficulty = getDifficultySettings(profile);
    const encounterMult = difficulty.encounterDensityMult || 1.0;

    // Group valid cells by zone, excluding safe radius around spawn
    const cellsByZone = {};
    let totalCells = 0;

    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            // Skip spawn and exit
            if ((x === 0 && y === 0) || (x === size - 1 && y === size - 1)) continue;
            // Must be walkable
            if (!hasOpenWall(grid[y][x])) continue;
            // Skip cells with chests (minions placed after chests)
            if (grid[y][x].chest) continue;
            // Skip cells within safe start radius (Manhattan distance from spawn)
            if ((x + y) <= safeRadius) continue;

            const zoneId = grid[y][x].zoneId ?? 0;
            if (!cellsByZone[zoneId]) cellsByZone[zoneId] = [];
            cellsByZone[zoneId].push({ x, y });
            totalCells++;
        }
    }

    // Shuffle each zone independently for random placement within zones
    Object.values(cellsByZone).forEach(shuffleArray);

    let totalPlaced = 0;

    // Place each minion type respecting zone boundaries
    for (const encounter of minionEncounters) {
        let { minionId, percent, zoneMin = 0, zoneMax = 99 } = encounter;

        // CRITICAL: Main boss can only appear in final zone as regular encounter
        if (minionId === mainMinionId) {
            const finalZone = zoneCount - 1;
            if (zoneMin < finalZone) {
                console.log(`[MazeMaster] Restricting ${minionId} to final zone (was zoneMin: ${zoneMin}, now: ${finalZone})`);
                zoneMin = finalZone;
            }
        }

        // Calculate target count based on percent and difficulty
        const scaledPercent = (percent || 0) * encounterMult;
        const targetCount = Math.round(totalCells * scaledPercent / 100);
        if (targetCount <= 0) continue;

        // Collect cells from valid zones only
        const validCells = [];
        for (let z = Math.max(0, zoneMin); z <= Math.min(zoneMax, zoneCount - 1); z++) {
            if (cellsByZone[z]) {
                // Only include cells that don't already have a minion
                validCells.push(...cellsByZone[z].filter(c => !grid[c.y][c.x].minion));
            }
        }

        shuffleArray(validCells);

        // Place minions
        let placed = 0;
        for (const cell of validCells) {
            if (placed >= targetCount) break;
            if (grid[cell.y][cell.x].minion) continue; // Double-check
            grid[cell.y][cell.x].minion = { minionId, triggered: false };
            placed++;
            totalPlaced++;
        }

        if (placed > 0) {
            console.log(`[MazeMaster] Placed ${placed}/${targetCount} ${minionId} in zones ${zoneMin}-${Math.min(zoneMax, zoneCount - 1)}`);
        }
    }

    return totalPlaced;
}

/**
 * Determine chest type based on profile settings
 */
function determineChestType(profile) {
    const roll = Math.random() * 100;
    if (roll < (profile.chestMimicPercent || 0)) return 'mimic';
    if (roll < (profile.chestMimicPercent || 0) + (profile.chestLockedPercent || 0)) return 'locked';
    return 'normal';
}

/**
 * Place tiles (chests and minions) on the maze based on profile configuration
 */
function placeTiles(grid, profile, size) {
    // Collect all valid cells (not start, not exit, must be walkable)
    const validCells = [];
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            if ((x === 0 && y === 0) || (x === size-1 && y === size-1)) continue;
            // Only include walkable cells (at least one open wall)
            if (!hasOpenWall(grid[y][x])) continue;
            validCells.push({ x, y });
        }
    }

    // Shuffle valid cells
    shuffleArray(validCells);

    const distribution = normalizeTileDistribution(profile, validCells.length);
    let cellIndex = 0;

    // Place chests first
    for (let i = 0; i < distribution.chestCount && cellIndex < validCells.length; i++) {
        const cell = validCells[cellIndex++];
        const chestType = determineChestType(profile);
        grid[cell.y][cell.x].chest = { type: chestType, opened: false };
    }

    // v1.8.1: Place minions using zone-based system with safe start radius
    // This respects zoneMin/zoneMax and protects spawn area from dangerous encounters
    const minionCount = placeMinionsByZone(grid, profile, size, profile.mainMinion);

    // Place traps
    const trapStartIndex = cellIndex;
    for (const placement of distribution.trapPlacements) {
        for (let i = 0; i < placement.count && cellIndex < validCells.length; i++) {
            const cell = validCells[cellIndex++];
            grid[cell.y][cell.x].trap = { trapId: placement.trapId, triggered: false };
        }
    }
    const trapCount = cellIndex - trapStartIndex;

    // Place portals (use remaining valid cells for random placement)
    const remainingCells = validCells.slice(cellIndex);
    const placedPortals = placePortals(grid, profile, size, remainingCells);

    // Place safe rooms on empty cells (HP system feature)
    const safeRoomCount = profile.safeRoomCount ?? 3;
    if (safeRoomCount > 0) {
        // Find truly empty cells (no chest, minion, trap, portal, staircase, and must be walkable)
        const emptyCells = [];
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                if ((x === 0 && y === 0) || (x === size-1 && y === size-1)) continue;
                const cell = grid[y][x];
                // Must be walkable (at least one open wall)
                if (!hasOpenWall(cell)) continue;
                if (!cell.chest && !cell.minion && !cell.trap && !cell.portal && !cell.staircase) {
                    emptyCells.push({ x, y });
                }
            }
        }
        shuffleArray(emptyCells);

        const actualCount = Math.min(safeRoomCount, emptyCells.length);
        for (let i = 0; i < actualCount; i++) {
            const cellPos = emptyCells[i];
            grid[cellPos.y][cellPos.x].safeRoom = { exhausted: false };
        }
        console.log(`[MazeMaster] Placed ${actualCount} safe rooms`);
    }

    console.log(`[MazeMaster] Placed ${distribution.chestCount} chests, ${minionCount} minions, ${trapCount} traps`);

    // v1.3.2: Apply "Find Early" guaranteed items to nearby chests
    applyFindEarlyItems(grid, profile, size);

    return { placedPortals: placedPortals || [] };
}

/**
 * Apply "Find Early" guaranteed items to chests near the starting position
 * @param {Array} grid - The maze grid
 * @param {Object} profile - Maze profile with findEarly config
 * @param {number} size - Grid size
 */
function applyFindEarlyItems(grid, profile, size) {
    const findEarly = profile.findEarly;
    if (!findEarly || !findEarly.items || findEarly.items.length === 0) return;

    const radius = findEarly.radius || 4;  // Manhattan distance from start (0,0)
    // v1.8.0: Filter items against item pool before distributing
    const items = findEarly.items.filter(itemId => isItemInPool(itemId, profile));
    if (items.length === 0) return;  // All items filtered out by pool

    // Find all chests within radius of start (0,0)
    const nearbyChests = [];
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const manhattanDist = x + y;  // Distance from (0,0)
            if (manhattanDist <= radius && manhattanDist > 0) {
                const cell = grid[y][x];
                if (cell.chest && !cell.chest.opened) {
                    nearbyChests.push({ x, y, dist: manhattanDist });
                }
            }
        }
    }

    // Sort by distance (closest first)
    nearbyChests.sort((a, b) => a.dist - b.dist);

    // Distribute guaranteed items across nearby chests
    let itemIndex = 0;
    for (const chestPos of nearbyChests) {
        if (itemIndex >= items.length) break;

        const chest = grid[chestPos.y][chestPos.x].chest;
        if (!chest.guaranteedItems) chest.guaranteedItems = [];

        // Add 1-2 items per chest depending on config
        const itemsPerChest = findEarly.itemsPerChest || 1;
        for (let i = 0; i < itemsPerChest && itemIndex < items.length; i++) {
            chest.guaranteedItems.push(items[itemIndex]);
            itemIndex++;
        }
    }

    if (itemIndex > 0) {
        console.log(`[MazeMaster] Find Early: Assigned ${itemIndex} guaranteed items to ${nearbyChests.length} nearby chests`);
    }
}

/**
 * Helper: Shuffle array in place (Fisher-Yates)
 */
function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

/**
 * Helper: Get random element from array
 */
function getRandomFromArray(arr) {
    if (!arr || arr.length === 0) return null;
    return arr[Math.floor(Math.random() * arr.length)];
}

/**
 * Helper: Promise-based delay
 */
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function getCellSize(gridSize) {
    // Delegate to the current renderer
    return RendererRegistry.getRenderer().getCellSize(gridSize);
}

async function startMaze(profileName) {
    // v2.0.3: Get profile early to determine loading screen configuration
    const profile = getMazeProfileWithDefaults(profileName);
    if (!profile) {
        console.error(`[MazeMaster] Maze profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    const size = profile.gridSize || 10;
    const mapStyle = profile.mapStyle || 'maze';
    const totalFloors = Math.max(1, Math.min(10, profile.floors || 1));
    const llmEnabled = profile.llmEnhanceRooms === true;
    const avatarGenEnabled = extensionSettings.avatarGenerationEnabled === true;

    // v2.0.3: PHASE 0 - Create early modal with loading screen BEFORE any generation
    console.log('[MazeMaster] Creating early modal for loading screen...');
    createMazeModalEarly(totalFloors > 1, llmEnabled, avatarGenEnabled);

    // v2.0.3: Preload background image and wait for it to render
    await new Promise(resolve => {
        const img = new Image();
        img.onload = () => {
            console.log('[MazeMaster] Loading screen background image loaded');
            resolve();
        };
        img.onerror = () => {
            console.warn('[MazeMaster] Loading screen background failed to load');
            resolve();
        };
        img.src = '/scripts/extensions/third-party/SillyTavern-MazeMaster/images/maze-master-logo.jpg';
        // Timeout fallback in case image is cached and events don't fire
        setTimeout(resolve, 100);
    });

    updateLoadingPercent(0);
    addLoadingLog('Loading profile...', 'current');
    await tick(); // Single tick to render loading screen

    // Close current chat to prevent context bleed (if enabled)
    if (extensionSettings.closeChatOnStart !== false) {
        try {
            const context = SillyTavern.getContext();
            if (context && typeof context.clearChat === 'function') {
                context.clearChat();
                addLoadingLog('Chat cleared', 'success');
            } else if (typeof doNewChat === 'function') {
                doNewChat();
                addLoadingLog('New chat started', 'success');
            }
        } catch (e) {
            console.warn('[MazeMaster] Could not close chat:', e);
        }
    }

    addLoadingLog(`Profile loaded: ${profileName}`, 'success');
    updateLoadingPercent(10);

    // Generate all floors
    const floors = [];

    // Randomize exit position based on difficulty and floor count
    // For multi-floor mazes or hard difficulties, make exit less predictable
    let exitX, exitY;
    const difficulty = profile.difficulty || 'normal';
    const isHardOrMultiFloor = totalFloors > 1 || difficulty === 'hard' || difficulty === 'nightmare';

    if (isHardOrMultiFloor) {
        // Pick exit from corners/edges that aren't the start
        const exitOptions = [];
        // Add corners (excluding start 0,0)
        exitOptions.push({ x: size - 1, y: 0 });        // Top-right
        exitOptions.push({ x: 0, y: size - 1 });        // Bottom-left
        exitOptions.push({ x: size - 1, y: size - 1 }); // Bottom-right

        // For very hard, add some mid-edge positions too
        if (difficulty === 'nightmare' || totalFloors >= 3) {
            exitOptions.push({ x: Math.floor(size / 2), y: size - 1 }); // Bottom-middle
            exitOptions.push({ x: size - 1, y: Math.floor(size / 2) }); // Right-middle
        }

        const chosen = exitOptions[Math.floor(Math.random() * exitOptions.length)];
        exitX = chosen.x;
        exitY = chosen.y;
        console.log(`[MazeMaster] Randomized exit position: (${exitX}, ${exitY}) for ${difficulty} maze with ${totalFloors} floor(s)`);
    } else {
        // Easy/normal single-floor: classic bottom-right
        exitX = size - 1;
        exitY = size - 1;
    }

    // v1.4.0: Store all floor data including BSP rooms
    const floorsData = [];

    // v2.0.3: PHASE 2 - Grid Generation (10% - 35%)
    addLoadingLog('Generating maze grid...', 'current');
    updateLoadingPercent(12);
    await tick(); // Single tick before generation phase

    for (let f = 0; f < totalFloors; f++) {
        // v2.0.3: Update loading text and percent for each floor (no tick in loop)
        const gridProgress = 12 + (((f + 1) / totalFloors) * 23);
        updateLoadingPercent(gridProgress);
        if (totalFloors > 1) {
            addLoadingLog(`Generating floor ${f + 1}/${totalFloors}...`, 'current');
        }

        // v2.0.3: Clone BSP config to avoid mutating profile across floors
        const baseBspConfig = profile.bspConfig || {};
        const bspConfig = { ...baseBspConfig };

        // v2.0.3: Sanity check - cap secretDensity at 0.2 (20%) max
        // This fixes corrupted profiles from earlier mutation bugs
        if (bspConfig.secretDensity > 0.2) {
            console.warn(`[MazeMaster] Corrupted secretDensity detected (${bspConfig.secretDensity}), resetting to 0.05`);
            bspConfig.secretDensity = 0.05;
        }

        // v1.4.0: Per-floor complexity scaling
        if (bspConfig.floorComplexityScaling !== false && totalFloors > 1) {
            const depthRatio = f / Math.max(1, totalFloors - 1);
            const baseMaxDepth = baseBspConfig.maxDepth || 4;
            bspConfig.maxDepth = baseMaxDepth + Math.floor(depthRatio * 2);
            const baseSecretDensity = Math.min(bspConfig.secretDensity || 0.02, 0.2); // Cap at 20%
            bspConfig.secretDensity = Math.min(baseSecretDensity * (1 + depthRatio), 0.2); // Final cap
        }

        // v1.4.0: Generate BSP grid with rooms
        const theme = profile.theme || 'fantasy';
        const bspResult = generateGridByStyle(size, mapStyle, theme, bspConfig);
        const floorGrid = bspResult.grid;
        const floorRooms = bspResult.rooms;
        addLoadingLog(`BSP generated: ${floorRooms.length} rooms`, 'success');

        // v1.4.0: Generate zones if enabled
        const zoneCount = bspConfig.zoneCount || 1;
        const floorZones = generateZones(floorRooms, zoneCount, theme);
        applyZonesToGrid(floorGrid, floorZones, floorRooms);
        if (zoneCount > 1) {
            addLoadingLog(`Zones created: ${zoneCount}`, 'success');
        }

        // v1.4.0: Add secret passages if enabled
        if (bspConfig.secretDensity > 0) {
            generateSecretPassages(floorGrid, size, {
                secretDensity: bspConfig.secretDensity,
                secretHints: bspConfig.secretHints !== false
            });
        }

        // Ensure wall consistency (both sides of each wall match)
        enforceWallConsistency(floorGrid, size);

        floors.push(floorGrid);
        floorsData.push({
            grid: floorGrid,
            rooms: floorRooms,
            zones: floorZones
        });
    }

    addLoadingLog(`Grid complete: ${totalFloors} floor(s)`, 'success');
    updateLoadingPercent(35);

    // v2.0.3: PHASE 3 - Tile Placement (minions, traps, chests, etc.) (35% - 55%)
    addLoadingLog('Placing tiles...', 'current');
    updateLoadingPercent(37);
    await tick(); // Single tick before tiles phase

    for (let f = 0; f < totalFloors; f++) {
        // v2.0.3: Update loading text and percent for each floor (no tick in loop)
        const tilesProgress = 37 + (((f + 1) / totalFloors) * 18);
        updateLoadingPercent(tilesProgress);
        if (totalFloors > 1) {
            addLoadingLog(`Placing tiles floor ${f + 1}/${totalFloors}...`, 'current');
        }

        placeTiles(floors[f], profile, size);
        // v1.2.1: Generate room names for each cell
        generateRoomInfoForGrid(floors[f], profile, size, exitX, exitY);
    }

    addLoadingLog('Tiles placed', 'success');
    updateLoadingPercent(55);

    // v2.0.3: PHASE 4 - Multi-Floor Connections (staircases) (55% - 65%)
    let guaranteedFloorKeysNeeded = 0;
    if (totalFloors > 1) {
        addLoadingLog('Connecting floors...', 'current');
        updateLoadingPercent(57);

        addStaircasesToFloors(floors, size, profile.requireFloorKey || false, exitX, exitY);

        // Guarantee floor keys are available when requireFloorKey is enabled
        if (profile.requireFloorKey) {
            guaranteedFloorKeysNeeded = guaranteeFloorKeys(floors, size);
        }

        // For multi-floor mazes: Block the exit area on floor 0 to force stair usage
        // Add walls around the exit on the starting floor
        const startFloor = floors[0];
        if (startFloor[exitY] && startFloor[exitY][exitX]) {
            // Wall off the exit cell on floor 0 so player MUST use stairs
            startFloor[exitY][exitX].walls = { top: true, right: true, bottom: true, left: true };
        }

        addLoadingLog('Floors connected', 'success');
        updateLoadingPercent(65);
    }

    // Use first floor as active grid
    const grid = floors[0];

    // Get starting inventory config - use profile values directly (no multiplier)
    // Each profile's startingInventory already has the exact intended values for that difficulty
    const baseStartInv = profile.startingInventory || { key: 0, stealth: 0, strike: 0, execute: 0 };
    const startInv = {
        key: baseStartInv.key || 0,
        stealth: baseStartInv.stealth || 0,
        strike: baseStartInv.strike || 0,
        execute: baseStartInv.execute || 0,
        // v1.2.0 new items - add guaranteed floor keys if chests weren't available
        floorKey: (baseStartInv.floorKey || 0) + guaranteedFloorKeysNeeded,
        portalStone: baseStartInv.portalStone || 0,
        minionBane: baseStartInv.minionBane || 0,
        mapFragment: baseStartInv.mapFragment || 0,
        timeShard: baseStartInv.timeShard || 0,
        voidWalk: baseStartInv.voidWalk || 0,
        // v1.8.0 HP items from profile
        healingPotion: baseStartInv.healingPotion || 0,
        greaterHealing: baseStartInv.greaterHealing || 0,
        elixir: baseStartInv.elixir || 0,
        revivalCharm: baseStartInv.revivalCharm || 0,
        heartCrystal: baseStartInv.heartCrystal || 0,
        // v1.8.0 Equipment - Iron Guard
        ironGuard: baseStartInv.ironGuard || 0,
        // v1.8.0 Visibility items
        torch: baseStartInv.torch || 0,
        lantern: baseStartInv.lantern || 0,
        revealScroll: baseStartInv.revealScroll || 0,
        sightPotion: baseStartInv.sightPotion || 0,
        crystalBall: baseStartInv.crystalBall || 0,
        // v1.9.3 Equipment - Weapons
        weapon_rusty_sword: baseStartInv.weapon_rusty_sword || 0,
        weapon_iron_sword: baseStartInv.weapon_iron_sword || 0,
        weapon_steel_blade: baseStartInv.weapon_steel_blade || 0,
        weapon_enchanted_blade: baseStartInv.weapon_enchanted_blade || 0,
        weapon_shadow_dagger: baseStartInv.weapon_shadow_dagger || 0,
        // v1.9.3 Equipment - Armor
        armor_leather: baseStartInv.armor_leather || 0,
        armor_chainmail: baseStartInv.armor_chainmail || 0,
        armor_plate: baseStartInv.armor_plate || 0,
        // v1.9.3 Equipment - Accessories
        accessory_ring_power: baseStartInv.accessory_ring_power || 0,
        accessory_amulet_protection: baseStartInv.accessory_amulet_protection || 0,
        accessory_lucky_charm: baseStartInv.accessory_lucky_charm || 0,
        accessory_vampiric_pendant: baseStartInv.accessory_vampiric_pendant || 0,
    };

    // Determine initial minion display (main story, main minion intro, or default)
    let initialMinion = getDefaultMinion();
    const mainMinion = profile.mainMinion ? getMinion(profile.mainMinion) : null;

    // Use main story if available, otherwise use main minion intro
    if (profile.storyConfig?.mainStory) {
        initialMinion = {
            name: mainMinion?.name || 'Story',
            role: 'Narrator',
            imagePath: mainMinion?.imagePath || '',
            message: profile.storyConfig.mainStory,
        };
    } else if (mainMinion) {
        initialMinion = {
            name: mainMinion.name,
            role: 'Main Minion',
            imagePath: mainMinion.imagePath,
            message: profile.mainMinionIntroMessage || 'Welcome to my maze...',
        };
    }

    // v2.0.2: Store original minion name for alias system (LLM enhancement happens after modal shows)
    let mainMinionOriginalName = mainMinion?.name || null;
    let mainMinionAlias = mainMinionOriginalName;

    currentMaze = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        grid: grid,
        size: size,
        playerX: 0,
        playerY: 0,
        playerDirection: 'south',  // Last movement direction for sprite facing
        exitX: size - 1,
        exitY: size - 1,
        visited: new Set(['0:0,0']),  // Format: "floor:x,y"
        isVictory: false,
        currentMinion: initialMinion,
        // Encounter system
        isPaused: false,
        pendingEncounter: null,
        exitEncounterDone: false,
        pendingConfirmation: null,
        pendingChest: null,
        // Inventory
        inventory: {
            key: startInv.key || 0,
            stealth: startInv.stealth || 0,
            strike: startInv.strike || 0,
            execute: startInv.execute || 0,
            // v1.2.0 new items
            floorKey: startInv.floorKey || 0,
            portalStone: startInv.portalStone || 0,
            minionBane: startInv.minionBane || 0,
            mapFragment: startInv.mapFragment || 0,
            timeShard: startInv.timeShard || 0,
            voidWalk: startInv.voidWalk || 0,
            // v1.3.0 HP items - v1.8.0 use startInv values
            healingPotion: startInv.healingPotion || 0,
            greaterHealing: startInv.greaterHealing || 0,
            elixir: startInv.elixir || 0,
            revivalCharm: startInv.revivalCharm || 0,
            heartCrystal: startInv.heartCrystal || 0,
            // v1.8.0 Equipment
            ironGuard: startInv.ironGuard || 0,
            // v1.3.2 Visibility items - v1.8.0 use startInv values
            torch: startInv.torch || 0,
            lantern: startInv.lantern || 0,
            revealScroll: startInv.revealScroll || 0,
            sightPotion: startInv.sightPotion || 0,
            crystalBall: startInv.crystalBall || 0,
            // v1.4.0 Secret detection item
            secretSense: 0,
        },
        // v1.3.2 Visibility system
        visibility: {
            baseRadius: 1,
            tempBonus: 0,
            tempMovesLeft: 0,
            permBonus: 0,
            floorRevealed: false,
        },
        // Story milestones
        shownMilestones: new Set(),
        // Statistics tracking
        stats: initSessionStats(),
        explorationComplete: false,
        // Moving enemies
        moveCount: 0,
        movingMinions: [],
        // Teleport tiles
        portals: [],
        // Quest/Objective system
        objectiveProgress: initObjectives(profile),
        allObjectivesComplete: false,
        // v1.2.0 Multi-floor
        currentFloor: 0,
        totalFloors: totalFloors,
        floors: floors,
        floorsData: floorsData,  // v1.4.0: BSP rooms, zones per floor
        voidWalkActive: false,
        messageLog: [],  // v1.2.1: Persistent message history
        chatHistory: [],  // v2.x: In-game chat history for LLM context
        chatEnabled: true,  // v2.x: Whether chat input is enabled
        // v1.3.0 HP System
        hpEnabled: profile.hpEnabled !== false,
        hp: initHP(profile),
        restCooldown: 0,
        // v1.4.6: Session Notes (auto-populated adventure log)
        sessionNotes: '',
        // v1.4.7: Fairness system - tracks luck for pity mechanics
        fairness: {
            chestsWithoutKey: 0,        // Chests opened without finding a key
            combatLossStreak: 0,        // Consecutive combat losses
            chestsWithoutHealing: 0,    // Chests without healing items
            lockedChestsSkipped: 0,     // Locked chests skipped due to no key
            lastHealingFoundFloor: 0,   // Floor where last healing was found
        },
        // v1.4.8: LLM Enhanced Room Descriptions
        enhancedRooms: {},  // Map of "floor:x,y" -> enhanced description
        // v2.0.2: LLM-enhanced main minion alias
        mainMinionOriginalName: mainMinionOriginalName,
        mainMinionAlias: mainMinionAlias,
        // v1.5.0: Quest System
        quests: initializeQuestState(),
        // v1.8.0: Equipment System
        equipment: {
            weapon: profile.startingEquipment?.weapon ? getEquipment(profile.startingEquipment.weapon) : null,
            armor: profile.startingEquipment?.armor ? getEquipment(profile.startingEquipment.armor) : null,
            accessory: profile.startingEquipment?.accessory ? getEquipment(profile.startingEquipment.accessory) : null,
        },
        equipmentInventory: [],
    };

    // v1.9.4: Populate equipmentInventory from starting inventory equipment items
    const equipmentItems = [
        'weapon_rusty_sword', 'weapon_iron_sword', 'weapon_steel_blade', 'weapon_enchanted_blade', 'weapon_shadow_dagger',
        'armor_leather', 'armor_chainmail', 'armor_plate',
        'accessory_ring_power', 'accessory_amulet_protection', 'accessory_lucky_charm', 'accessory_vampiric_pendant',
        'ironGuard'
    ];
    for (const itemId of equipmentItems) {
        const count = startInv[itemId] || 0;
        for (let i = 0; i < count; i++) {
            currentMaze.equipmentInventory.push(itemId);
        }
    }

    // Auto-equip first available weapon/armor/accessory from starting inventory
    if (!currentMaze.equipment.weapon) {
        const startWeapon = equipmentItems.filter(id => id.startsWith('weapon_')).find(id => startInv[id] > 0);
        if (startWeapon) {
            currentMaze.equipment.weapon = getEquipment(startWeapon);
            // Remove from inventory since it's equipped
            const idx = currentMaze.equipmentInventory.indexOf(startWeapon);
            if (idx >= 0) currentMaze.equipmentInventory.splice(idx, 1);
        }
    }
    if (!currentMaze.equipment.armor) {
        // Iron Guard counts as armor (all armor is consumable with charges)
        const startArmor = equipmentItems.filter(id => id.startsWith('armor_') || id === 'ironGuard').find(id => startInv[id] > 0);
        if (startArmor) {
            currentMaze.equipment.armor = getEquipment(startArmor);
            const idx = currentMaze.equipmentInventory.indexOf(startArmor);
            if (idx >= 0) currentMaze.equipmentInventory.splice(idx, 1);
        }
    }
    if (!currentMaze.equipment.accessory) {
        const startAccessory = equipmentItems.filter(id => id.startsWith('accessory_')).find(id => startInv[id] > 0);
        if (startAccessory) {
            currentMaze.equipment.accessory = getEquipment(startAccessory);
            const idx = currentMaze.equipmentInventory.indexOf(startAccessory);
            if (idx >= 0) currentMaze.equipmentInventory.splice(idx, 1);
        }
    }

    // Add initial session note
    addSessionNote(`Adventure begins: ${profileName}`);
    addSessionNote(`Floor 1/${profile.floors || 1} - ${size}x${size} ${profile.theme || 'fantasy'} ${profile.mapStyle || 'dungeon'}`);

    // v2.0.5: Set initial facing direction based on available exits from starting room
    const startCell = grid[0][0];
    if (startCell) {
        // Priority: south > east > north > west (prefer towards exit at bottom-right)
        if (!startCell.walls.south) {
            currentMaze.playerDirection = 'south';
        } else if (!startCell.walls.east) {
            currentMaze.playerDirection = 'east';
        } else if (!startCell.walls.north) {
            currentMaze.playerDirection = 'north';
        } else if (!startCell.walls.west) {
            currentMaze.playerDirection = 'west';
        }
    }

    // v2.0.3: PHASE 5 - Systems Initialization (65% - 80%)
    addLoadingLog('Initializing systems...', 'current');
    updateLoadingPercent(67);
    await tick(); // Single tick before systems phase

    // Initialize all systems (fast synchronous operations - no tick needed)
    currentMaze.movingMinions = initMovingMinions(grid, size);
    addLoadingLog('Minions initialized', 'success');

    // v1.6.0: Initialize enhanced lighting system
    try {
        initLighting(profile.mapStyle || 'maze');
        addLoadingLog('Lighting initialized', 'success');
    } catch (e) {
        console.error('[MazeMaster] initLighting error:', e);
    }

    // v1.6.0: Initialize faction reputation system
    try {
        initFactions();
        addLoadingLog('Factions initialized', 'success');
    } catch (e) {
        console.error('[MazeMaster] initFactions error:', e);
    }

    // v1.6.0: Initialize permadeath campaign if enabled
    try {
        initPermadeathCampaign();
    } catch (e) {
        console.error('[MazeMaster] initPermadeathCampaign error:', e);
    }

    // v1.5.0: Offer quests from profile's quest pool
    if (profile.questPool && profile.questPool.length > 0) {
        currentMaze.quests.available = offerRandomQuests(profile, 2);
        if (currentMaze.quests.available.length > 0) {
            addLoadingLog(`${currentMaze.quests.available.length} quests available`, 'success');
        }
    }

    // v1.7.0: Initialize quests from Quest Profile
    initializeQuestsFromProfile();

    addLoadingLog('Systems ready', 'success');
    updateLoadingPercent(80);

    // v2.0.3: PHASE 6 - Create full game UI (loading screen is preserved)
    console.log('[MazeMaster] About to show maze modal...');
    try {
        showMazeModal();
        console.log('[MazeMaster] Modal shown');

        // v2.0.3: Loading screen is already visible from createMazeModalEarly()
        // Just need to get minions needing avatars for later
        const minionsNeedingAvatars = avatarGenEnabled ? getMinionsNeedingAvatars(profile) : [];
        const shouldGenerateAvatars = avatarGenEnabled && minionsNeedingAvatars.length > 0;

        // v2.0.3: PHASE 7 - LLM Enhancements (80% - 100%)
        if (llmEnabled && mainMinion?.name) {
            addLoadingLog(`LLM: Enhancing ${mainMinion.name}...`, 'current');
            updateLoadingPercent(82);
            try {
                mainMinionAlias = await generateMinionAlias(mainMinion.name, profile.theme);
                currentMaze.mainMinionAlias = mainMinionAlias;
                if (currentMaze.currentMinion && mainMinionAlias !== mainMinionOriginalName) {
                    currentMaze.currentMinion.name = mainMinionAlias;
                }
                addLoadingLog(`Minion: ${mainMinionAlias}`, 'success');
                updateLoadingPercent(85);
            } catch (e) {
                console.error('[MazeMaster] Failed to generate minion alias:', e);
                mainMinionAlias = mainMinionOriginalName;
                addLoadingLog('Minion enhancement skipped', '');
                updateLoadingPercent(85);
            }
        } else {
            updateLoadingPercent(85);
        }

        if (llmEnabled && currentMaze.currentMinion?.message) {
            addLoadingLog('LLM: Enhancing story...', 'current');
            updateLoadingPercent(87);
            try {
                const enhancedStory = await generateEnhancedStoryIntro(
                    currentMaze.currentMinion.message,
                    profile.theme,
                    mainMinionAlias
                );
                if (enhancedStory && enhancedStory !== currentMaze.currentMinion.message) {
                    currentMaze.currentMinion.message = enhancedStory;
                }
                addLoadingLog('Story enhanced', 'success');
                updateLoadingPercent(90);
            } catch (e) {
                console.error('[MazeMaster] Failed to enhance story intro:', e);
                addLoadingLog('Story enhancement skipped', '');
                updateLoadingPercent(90);
            }
        } else {
            updateLoadingPercent(90);
        }

        // v1.3.2: Apply initial visibility radius at spawn
        applyVisibilityAtPosition(0, 0, size);
        console.log('[MazeMaster] Visibility applied');

        renderMazeGrid();
        console.log('[MazeMaster] Grid rendered');

        updatePlayerPosition(false); // Set initial position without animation
        updateMazeHero();
        initChatInput();  // v2.x: Initialize in-game chat input
        updateRestButton(); // Initialize rest button state
        updateRoomInfoBox();  // v1.2.1: Update room info display
        updateInventoryDisplay();
        updateStatsDisplay();
        updateHPDisplay();  // v1.3.0: Initialize HP display
        updateObjectivesDisplay();
        updateEquipmentDisplay();  // v1.8.0: Initialize equipment display with starting gear
        startStatsTimer();
        console.log('[MazeMaster] UI updated');

        // v1.2.0: Update multi-floor UI
        updateFloorIndicator();
        updateDpadFloorButtons();

        document.addEventListener('keydown', handleMazeKeydown, { capture: true });

        // v1.4.8: Enhance starting room description
        if (llmEnabled) {
            addLoadingLog('LLM: Enhancing entry room...', 'current');
            updateLoadingPercent(92);
        }
        await enhanceRoomOnEntry(0, 0);
        if (llmEnabled) {
            addLoadingLog('Entry room enhanced', 'success');
            updateLoadingPercent(95);
        }

        // v2.1.0: Generate avatars for minions that need them
        if (shouldGenerateAvatars) {
            addLoadingLog('Generating avatars...', 'current');
            updateLoadingPercent(96);

            try {
                const sdAvailable = await isImageGenerationAvailable();
                if (sdAvailable) {
                    let generatedCount = 0;
                    for (const { id: minionId, minion } of minionsNeedingAvatars) {
                        addLoadingLog(`Avatar: ${minion.name}...`, 'current');

                        const imagePath = await generateMinionAvatar(minionId, minion, profile.theme);
                        if (imagePath) {
                            generatedCount++;
                            if (minionId === profile.mainMinion && currentMaze.currentMinion) {
                                currentMaze.currentMinion.imagePath = imagePath;
                            }
                        }
                    }

                    if (generatedCount > 0) {
                        addLoadingLog(`${generatedCount} avatar(s) generated`, 'success');
                        updateMazeHero();
                    }
                }
            } catch (e) {
                console.error('[MazeMaster] Avatar generation error:', e);
                addLoadingLog('Avatar generation failed', '');
            }
        }

        // v2.0.3: Set to 100% before hiding
        addLoadingLog('Ready!', 'success');
        updateLoadingPercent(100);

        // v2.0.2: Hide loading screen - game is ready
        hideLoadingScreen();

        console.log(`[MazeMaster] Maze "${profileName}" started (${size}x${size}, ${totalFloors} floor${totalFloors > 1 ? 's' : ''})`);
    } catch (error) {
        console.error('[MazeMaster] Error during maze rendering:', error);
        hideLoadingScreen(); // Hide loading screen on error too
        return { error: `Failed to render maze: ${error.message}` };
    }
    return { success: true };
}

/**
 * v2.0.3: Create maze modal early for loading screen display
 * Called before maze generation to show progress
 * @param {boolean} showMultiFloor - Whether to show multi-floor status item
 * @param {boolean} llmEnabled - Whether LLM enhancement is enabled
 * @param {boolean} avatarGenEnabled - Whether avatar generation is enabled
 */
function createMazeModalEarly(showMultiFloor = false, llmEnabled = false, avatarGenEnabled = false) {
    console.log('[MazeMaster] Creating early modal for loading screen');

    // Remove existing modal if any
    const existing = document.getElementById('mazemaster_maze_modal');
    if (existing) existing.remove();

    const modal = document.createElement('div');
    modal.id = 'mazemaster_maze_modal';
    modal.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.95);';
    modal.innerHTML = `
        <style>
            .mazemaster-maze-overlay {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                height: 100%;
            }
            .mazemaster-maze-container {
                position: relative;
                width: 90vw;
                max-width: 1200px;
                height: 94vh;
                max-height: 960px;
                background: #1a1a2e;
                border-radius: 15px;
                border: 2px solid #333;
            }
            .maze-loading-screen {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: #000;
                background-size: 100% 100%;
                background-position: center center;
                background-repeat: no-repeat;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-end;
                padding-bottom: 80px;
                z-index: 1000;
                border-radius: 15px;
            }
            .maze-loading-card {
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.85);
                backdrop-filter: blur(8px);
                border-radius: 12px;
                padding: 15px 25px;
                border: 1px solid rgba(212, 175, 55, 0.3);
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
                text-align: center;
                z-index: 10;
            }
            .maze-loading-header {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                margin-bottom: 10px;
                color: #d4af37;
            }
            .maze-loading-header i {
                font-size: 0.9em;
            }
            .maze-loading-subtitle {
                font-size: 0.95em;
                letter-spacing: 0.15em;
                text-transform: uppercase;
            }
            .maze-loading-percent {
                font-size: 0.9em;
                font-weight: bold;
                color: #d4af37;
            }
            .maze-loading-console {
                background: rgba(0, 0, 0, 0.5);
                border: 1px solid rgba(212, 175, 55, 0.3);
                border-radius: 8px;
                padding: 8px 12px;
                width: 280px;
                height: 80px;
                min-height: 80px;
                max-height: 80px;
                overflow-y: auto;
                font-family: monospace;
                font-size: 0.75em;
                text-align: left;
                color: #aaa;
            }
            .maze-loading-console .log-line {
                margin: 2px 0;
                white-space: nowrap;
            }
            .maze-loading-console .log-line.success {
                color: #4ade80;
            }
            .maze-loading-console .log-line.current {
                color: #d4af37;
            }
            /* v2.0.3: Hide game UI while loading screen is visible */
            .mazemaster-maze-container.loading-active .mazemaster-maze-top,
            .mazemaster-maze-container.loading-active .maze-dpad {
                display: none !important;
            }
        </style>
        <div class="mazemaster-maze-overlay">
            <div class="mazemaster-maze-container">
                <!-- v2.0.3: Loading Screen Overlay with Generation Progress -->
                <div id="maze_loading_screen" class="maze-loading-screen" style="background-image: url('/scripts/extensions/third-party/SillyTavern-MazeMaster/images/maze-master-logo.jpg');">
                    <div class="maze-loading-card">
                        <div class="maze-loading-header">
                            <i class="fa-solid fa-spinner fa-spin"></i>
                            <span class="maze-loading-subtitle">Generating Maze</span>
                            <span id="maze_loading_percent" class="maze-loading-percent">0%</span>
                        </div>
                        <div id="maze_loading_console" class="maze-loading-console">
                            <div class="log-line current">Initializing...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(modal);

    // v2.0.2: Set loading screen background image
    const loadingScreen = document.getElementById('maze_loading_screen');
    if (loadingScreen) {
        const logoPath = `/scripts/extensions/third-party/SillyTavern-MazeMaster/images/maze-master-logo.jpg`;
        loadingScreen.style.backgroundImage = `url("${logoPath}")`;
    }

    return modal;
}

function showMazeModal() {
    console.log('[MazeMaster] showMazeModal() called, currentMaze:', currentMaze?.isOpen, 'size:', currentMaze?.size);

    // v2.0.3: Capture loading screen state before replacing modal
    const existing = document.getElementById('mazemaster_maze_modal');
    const existingLoadingScreen = existing?.querySelector('#maze_loading_screen');
    const loadingWasVisible = existingLoadingScreen && !existingLoadingScreen.classList.contains('hidden');
    const loadingContent = existingLoadingScreen?.innerHTML;
    const loadingBackgroundImage = existingLoadingScreen?.style.backgroundImage;

    // Remove existing modal if any
    if (existing) {
        console.log('[MazeMaster] Removing existing modal');
        existing.remove();
    }

    const cellSize = getCellSize(currentMaze.size);
    console.log('[MazeMaster] Cell size:', cellSize);

    const modal = document.createElement('div');
    modal.id = 'mazemaster_maze_modal';
    modal.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.95);';
    modal.innerHTML = `
        <div class="mazemaster-maze-overlay">
            <div class="mazemaster-maze-container">
                <!-- v2.0.3: Loading Screen Overlay with Generation Progress -->
                <div id="maze_loading_screen" class="maze-loading-screen">
                    <div class="maze-loading-card">
                        <div class="maze-loading-header">
                            <i class="fa-solid fa-spinner fa-spin"></i>
                            <span class="maze-loading-subtitle">Generating Maze</span>
                            <span id="maze_loading_percent" class="maze-loading-percent">0%</span>
                        </div>
                        <div id="maze_loading_console" class="maze-loading-console">
                            <div class="log-line">Initializing...</div>
                        </div>
                    </div>
                </div>
                <!-- TOP PANEL: Info & Controls -->
                <div class="mazemaster-maze-top">
                    <!-- Left Column: Message Box, Stats, Inventory -->
                    <div class="mazemaster-maze-left-column">
                        <!-- Hero Section (Message Box) -->
                        <div class="mazemaster-maze-hero">
                            <div class="mazemaster-maze-hero-content">
                                <div class="mazemaster-maze-hero-avatar">
                                    <img id="maze_minion_img" src="" alt="" style="display: none;">
                                    <div id="maze_generating_indicator" class="maze-generating-indicator">
                                        <i class="fa-solid fa-comment-dots"></i>
                                    </div>
                                </div>
                                <div class="maze-hero-text">
                                    <div id="maze_minion_name" class="maze-minion-name"></div>
                                    <div id="maze_minion_role" class="maze-minion-role"></div>
                                    <div id="maze_message_log" class="maze-message-log"></div>
                                </div>
                            </div>
                            <!-- v2.0.3: Chat input moved outside hero-content to span full width -->
                            <div id="maze_chat_input_container" class="maze-chat-input-container">
                                <div class="maze-chat-buttons">
                                    <button id="maze_chat_impersonate" class="maze-chat-action-btn" title="Impersonate - Generate message as {{user}}">
                                        <i class="fa-solid fa-comment-dots"></i>
                                    </button>
                                    <button id="maze_chat_response" class="maze-chat-action-btn" title="Response - Generate creature/narrator reply">
                                        <i class="fa-solid fa-reply"></i>
                                    </button>
                                </div>
                                <input type="text" id="maze_chat_input" class="maze-chat-input"
                                       placeholder="Say something..." maxlength="200" autocomplete="off">
                                <button id="maze_chat_send" class="maze-chat-send-btn" title="Send message">
                                    <i class="fa-solid fa-paper-plane"></i>
                                </button>
                            </div>
                        </div>

                    <!-- ROW 2: Stats and Inventory -->
                    <div class="mazemaster-maze-info-stack">
                        <!-- Stats Bar -->
                        <div class="mazemaster-maze-stats-bar">
                            <div class="stats-item stats-persona" title="Current Persona">
                                <i class="fa-solid fa-user"></i>
                                <span id="maze_stat_persona">${getCurrentPersonaName()}</span>
                            </div>
                            <div class="stats-item" title="Moves">
                                <i class="fa-solid fa-shoe-prints"></i>
                                <span id="maze_stat_moves">0</span>
                            </div>
                            <div class="stats-item" title="Time Elapsed">
                                <i class="fa-solid fa-clock"></i>
                                <span id="maze_stat_time">0:00</span>
                            </div>
                            <div class="stats-item" title="Exploration">
                                <i class="fa-solid fa-map"></i>
                                <span id="maze_stat_explore">0%</span>
                            </div>
                            <div class="stats-item" title="Difficulty">
                                <i class="fa-solid fa-skull"></i>
                                <span id="maze_stat_difficulty">${getDifficultySettings(currentMaze.profile).name}</span>
                            </div>
                            <div class="stats-item maze-floor-indicator" title="Current Floor" style="${currentMaze.totalFloors <= 1 ? 'display:none;' : ''}">
                                <i class="fa-solid fa-layer-group"></i>
                                <span><span id="maze_floor_current">${currentMaze.currentFloor + 1}</span>/<span id="maze_floor_total">${currentMaze.totalFloors}</span></span>
                            </div>
                            <div class="stats-item maze-zone-indicator" id="maze_zone_display" title="Current Zone" style="display: none;">
                                <i class="fa-solid fa-map-pin"></i>
                                <span id="maze_zone_name">Zone 1</span>
                                <span id="maze_zone_progress" style="font-size: 0.8em; opacity: 0.7;"></span>
                            </div>
                        </div>
                    </div>

                    <!-- Objectives Section (if any) -->
                    <div class="maze-objectives-section ${(currentMaze.profile?.objectives?.length || 0) === 0 ? 'hidden' : ''}">
                        <div class="objectives-header">
                            <i class="fa-solid fa-list-check"></i>
                            <span>Objectives</span>
                        </div>
                        <div id="maze_objectives_list" class="objectives-list">
                            <!-- Populated by updateObjectivesDisplay() -->
                        </div>
                    </div>
                    </div>

                    <!-- ROOM INFO BOX (right side, full height) -->
                    <div class="mazemaster-maze-room-info" id="maze_room_info">
                        <div class="room-info-content">
                            <div class="room-info-name" id="room_info_name">Unknown Room</div>
                            <div class="room-info-desc" id="room_info_desc">...</div>
                            <div class="room-info-section">
                                <div class="room-info-label"><i class="fa-solid fa-users"></i> Occupants</div>
                                <div id="room_info_occupants">None</div>
                            </div>
                            <div class="room-info-section">
                                <div class="room-info-label"><i class="fa-solid fa-skull"></i> Defeated</div>
                                <div id="room_info_defeated">None</div>
                            </div>
                            <div class="room-info-section room-info-exits-section">
                                <div class="room-info-label"><i class="fa-solid fa-compass"></i> Exits</div>
                                <div id="room_info_exits" class="room-info-exits-list">None</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Power Button (top right corner) -->
                <button id="maze_power_btn" class="maze-power-btn" title="Exit Maze">
                    <i class="fa-solid fa-power-off"></i>
                </button>

                <!-- Inventory Info Button (below power button) -->
                <div class="maze-inventory-info-wrapper" id="maze_inventory_wrapper">
                    <button id="maze_inventory_btn" class="maze-info-btn" title="Inventory">
                        <i class="fa-solid fa-info"></i>
                    </button>
                    <div class="maze-inventory-dropdown hidden" id="maze_inventory_menu">
                        <!-- Dungeon Items -->
                        <div class="inventory-menu-section">
                            <div class="inventory-menu-header">Dungeon Items</div>
                            <div class="inventory-menu-item" data-item="key" title="Unlock locked chests">
                                <i class="fa-solid fa-key" style="color: #f1c40f;"></i>
                                <span class="item-name">Skeleton Key</span>
                                <span class="item-count" id="maze_inv_key">${currentMaze.inventory.key}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="floorKey" title="Unlock staircases">
                                <i class="fa-solid fa-stairs" style="color: #9b59b6;"></i>
                                <span class="item-name">Floor Key</span>
                                <span class="item-count" id="maze_inv_floorKey">${currentMaze.inventory.floorKey}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="portalStone" data-usable="true" title="Teleport to any revealed portal">
                                <i class="fa-solid fa-gem" style="color: #3498db;"></i>
                                <span class="item-name">Portal Stone</span>
                                <span class="item-count" id="maze_inv_portalStone">${currentMaze.inventory.portalStone}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="mapFragment" data-usable="true" title="Reveal 3x3 area around you">
                                <i class="fa-solid fa-scroll" style="color: #e67e22;"></i>
                                <span class="item-name">Map Fragment</span>
                                <span class="item-count" id="maze_inv_mapFragment">${currentMaze.inventory.mapFragment}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="voidWalk" data-usable="true" title="Phase through one wall">
                                <i class="fa-solid fa-ghost" style="color: #1abc9c;"></i>
                                <span class="item-name">Void Walk</span>
                                <span class="item-count" id="maze_inv_voidWalk">${currentMaze.inventory.voidWalk}</span>
                            </div>
                        </div>
                        <!-- Combat Items -->
                        <div class="inventory-menu-section">
                            <div class="inventory-menu-header">Combat Items</div>
                            <div class="inventory-menu-item" data-item="stealth" title="Sneak past enemies">
                                <i class="fa-solid fa-user-ninja" style="color: #95a5a6;"></i>
                                <span class="item-name">Shadow Cloak</span>
                                <span class="item-count" id="maze_inv_stealth">${currentMaze.inventory.stealth}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="strike" title="Combat boost">
                                <i class="fa-solid fa-bolt" style="color: #f39c12;"></i>
                                <span class="item-name">Battle Surge</span>
                                <span class="item-count" id="maze_inv_pow">${currentMaze.inventory.strike}</span>
                            </div>
                            <div class="inventory-menu-item execute" data-item="execute" title="Instant victory!">
                                <i class="fa-solid fa-star" style="color: #e74c3c;"></i>
                                <span class="item-name">Death Blow</span>
                                <span class="item-count" id="maze_inv_execute">${currentMaze.inventory.execute}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="minionBane" title="Auto-defeat next minion">
                                <i class="fa-solid fa-skull-crossbones" style="color: #8e44ad;"></i>
                                <span class="item-name">Minion Bane</span>
                                <span class="item-count" id="maze_inv_minionBane">${currentMaze.inventory.minionBane}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="timeShard" title="Slow next battlebar by 50%">
                                <i class="fa-solid fa-hourglass-half" style="color: #2980b9;"></i>
                                <span class="item-name">Time Shard</span>
                                <span class="item-count" id="maze_inv_timeShard">${currentMaze.inventory.timeShard}</span>
                            </div>
                        </div>
                        <!-- HP Items (v1.3.0) -->
                        <div class="inventory-menu-section hp-items-section" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                            <div class="inventory-menu-header">Healing & Restoration</div>
                            <div class="inventory-menu-item" data-item="healingPotion" data-usable="true" data-hp-item="healingPotion" title="Restore 25% HP">
                                <i class="fa-solid fa-flask" style="color: #e74c3c;"></i>
                                <span class="item-name">Minor Elixir</span>
                                <span class="item-count" id="maze_inv_healingPotion">${currentMaze.inventory.healingPotion}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="greaterHealing" data-usable="true" data-hp-item="greaterHealing" title="Restore 50% HP">
                                <i class="fa-solid fa-flask-vial" style="color: #9b59b6;"></i>
                                <span class="item-name">Healing Draught</span>
                                <span class="item-count" id="maze_inv_greaterHealing">${currentMaze.inventory.greaterHealing}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="elixir" data-usable="true" data-hp-item="elixir" title="Full HP restore">
                                <i class="fa-solid fa-wine-bottle" style="color: #f1c40f;"></i>
                                <span class="item-name">Grand Elixir</span>
                                <span class="item-count" id="maze_inv_elixir">${currentMaze.inventory.elixir}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="revivalCharm" data-usable="true" data-hp-item="revivalCharm" title="Auto-resurrect on death">
                                <i class="fa-solid fa-feather" style="color: #3498db;"></i>
                                <span class="item-name">Phoenix Feather</span>
                                <span class="item-count" id="maze_inv_revivalCharm">${currentMaze.inventory.revivalCharm}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="heartCrystal" data-usable="true" data-hp-item="heartCrystal" title="+10 Max HP permanent">
                                <i class="fa-solid fa-gem" style="color: #e91e63;"></i>
                                <span class="item-name">Heart Crystal</span>
                                <span class="item-count" id="maze_inv_heartCrystal">${currentMaze.inventory.heartCrystal}</span>
                            </div>
                        </div>
                        <!-- Visibility Items (v1.3.2) -->
                        <div class="inventory-menu-section vis-items-section">
                            <div class="inventory-menu-header">Vision & Awareness</div>
                            <div class="inventory-menu-item" data-item="torch" data-usable="true" data-vis-item="torch" title="Temporary +2 visibility (3 moves)">
                                <i class="fa-solid fa-fire" style="color: #f39c12;"></i>
                                <span class="item-name">Torch</span>
                                <span class="item-count" id="maze_inv_torch">${currentMaze.inventory.torch}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="lantern" title="Passive +1 visibility while held">
                                <i class="fa-solid fa-lightbulb" style="color: #f1c40f;"></i>
                                <span class="item-name">Lantern</span>
                                <span class="item-count" id="maze_inv_lantern">${currentMaze.inventory.lantern}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="revealScroll" data-usable="true" data-vis-item="revealScroll" title="Reveals entire floor for 1 move">
                                <i class="fa-solid fa-scroll" style="color: #9b59b6;"></i>
                                <span class="item-name">Reveal Scroll</span>
                                <span class="item-count" id="maze_inv_revealScroll">${currentMaze.inventory.revealScroll}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="sightPotion" data-usable="true" data-vis-item="sightPotion" title="Permanent +1 visibility">
                                <i class="fa-solid fa-eye" style="color: #3498db;"></i>
                                <span class="item-name">Sight Potion</span>
                                <span class="item-count" id="maze_inv_sightPotion">${currentMaze.inventory.sightPotion}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="crystalBall" data-usable="true" data-vis-item="crystalBall" title="Reveals all minions on floor">
                                <i class="fa-solid fa-circle" style="color: #8e44ad;"></i>
                                <span class="item-name">Crystal Ball</span>
                                <span class="item-count" id="maze_inv_crystalBall">${currentMaze.inventory.crystalBall}</span>
                            </div>
                            <!-- v1.7.0 Equipment Items -->
                            <div class="inventory-menu-item" data-item="ironGuard" data-usable="false" title="Absorbs damage from combat and traps">
                                <i class="fa-solid fa-shield-halved" style="color: #95a5a6;"></i>
                                <span class="item-name">Iron Guard</span>
                                <span class="item-count" id="maze_inv_ironGuard">${currentMaze.inventory.ironGuard || 0}</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Session Memory Button (below inventory button) -->
                <div class="maze-memory-wrapper" id="maze_memory_wrapper">
                    <button id="maze_memory_btn" class="maze-memory-btn" title="Session Notes">
                        <i class="fa-solid fa-note-sticky"></i>
                    </button>
                </div>

                <!-- Player Stats Button (below memory button) -->
                <div class="maze-player-wrapper" id="maze_player_wrapper">
                    <button id="maze_player_btn" class="maze-player-btn" title="Player Stats">
                        <i class="fa-solid fa-person"></i>
                    </button>
                </div>

                <!-- Skills Button (below player button) -->
                <div class="maze-skills-wrapper" id="maze_skills_wrapper">
                    <button id="maze_skills_btn" class="maze-skills-btn" title="Skills">
                        <i class="fa-solid fa-toolbox"></i>
                    </button>
                </div>

                <!-- Quest Button (below skills button) -->
                <div class="maze-quest-wrapper" id="maze_quest_wrapper">
                    <button id="maze_quest_btn" class="maze-quest-btn" title="Quests">
                        Ω
                    </button>
                </div>

                <!-- Session Memory Panel -->
                <div id="maze_memory_panel" class="maze-memory-panel" style="display: none;">
                    <div class="maze-memory-header">
                        <h3>Session Notes</h3>
                        <button id="maze_memory_close" class="maze-memory-close">&times;</button>
                    </div>
                    <div class="maze-memory-content">
                        <textarea id="maze_memory_textarea" class="maze-memory-textarea" placeholder="Write notes about your adventure...&#10;&#10;These notes are saved with this maze session."></textarea>
                    </div>
                    <div class="maze-memory-footer">
                        <button id="maze_memory_save" class="maze-memory-save-btn">Save Notes</button>
                    </div>
                </div>
                <div id="maze_memory_backdrop" class="maze-memory-backdrop" style="display: none;"></div>

                <!-- Player Stats Panel -->
                <div id="maze_player_panel" class="maze-player-panel" style="display: none;">
                    <div class="maze-player-header">
                        <h3>Player Stats</h3>
                        <button id="maze_player_close" class="maze-player-close">&times;</button>
                    </div>
                    <div class="maze-player-content">
                        <!-- Level & XP Section -->
                        <div class="player-stats-section">
                            <div class="player-level-display">
                                <span class="level-label">Level</span>
                                <span class="level-value" id="player_level">1</span>
                            </div>
                            <div class="player-xp-bar-wrapper">
                                <div class="player-xp-bar">
                                    <div class="player-xp-fill" id="player_xp_fill" style="width: 0%;"></div>
                                </div>
                                <div class="player-xp-text">
                                    <span id="player_xp_current">0</span> / <span id="player_xp_needed">100</span> XP
                                </div>
                            </div>
                        </div>

                        <!-- Character Stats Section -->
                        <div class="player-stats-section">
                            <h4>Stats</h4>
                            <div class="player-stat-row">
                                <span class="stat-icon"><i class="fa-solid fa-heart"></i></span>
                                <span class="stat-name">HP</span>
                                <span class="stat-value" id="player_stat_hp">100/100</span>
                            </div>
                            <div class="player-stat-row">
                                <span class="stat-icon"><i class="fa-solid fa-sword"></i></span>
                                <span class="stat-name">Attack</span>
                                <span class="stat-value" id="player_stat_atk">0 <span class="stat-bonus" id="player_stat_atk_bonus"></span></span>
                            </div>
                            <div class="player-stat-row">
                                <span class="stat-icon"><i class="fa-solid fa-shield"></i></span>
                                <span class="stat-name">Defense</span>
                                <span class="stat-value" id="player_stat_def">0 <span class="stat-bonus" id="player_stat_def_bonus"></span></span>
                            </div>
                            <div class="player-stat-row">
                                <span class="stat-icon"><i class="fa-solid fa-crosshairs"></i></span>
                                <span class="stat-name">Crit Chance</span>
                                <span class="stat-value" id="player_stat_crit">5% <span class="stat-bonus" id="player_stat_crit_bonus"></span></span>
                            </div>
                        </div>

                        <!-- Skill Points Section -->
                        <div class="player-stats-section">
                            <div class="player-skill-points">
                                <span class="skill-points-label">Skill Points Available</span>
                                <span class="skill-points-value" id="player_skill_points">0</span>
                            </div>
                        </div>

                        <!-- Equipment Summary -->
                        <div class="player-stats-section">
                            <h4>Equipment</h4>
                            <div class="player-equip-summary" id="player_equip_summary">
                                <!-- Populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
                <div id="maze_player_backdrop" class="maze-player-backdrop" style="display: none;"></div>

                <!-- Skill Tree Panel -->
                <div id="maze_skill_panel" class="maze-skill-panel" style="display: none;">
                    <div class="maze-skill-header">
                        <h3><i class="fa-solid fa-book-sparkles"></i> Skills</h3>
                        <div class="skill-points-header">
                            <span>Skill Points:</span>
                            <span id="skill_points_display" class="skill-points-value">0</span>
                        </div>
                        <button id="maze_skill_close" class="maze-skill-close">&times;</button>
                    </div>
                    <div class="maze-skill-content">
                        <div id="skill_tree_content" class="skill-tree-container">
                            <!-- Populated dynamically -->
                        </div>
                    </div>
                </div>
                <div id="maze_skill_backdrop" class="maze-skill-backdrop" style="display: none;"></div>

                <!-- Quest Panel -->
                <div id="maze_quest_panel" class="maze-quest-panel" style="display: none;">
                    <div class="maze-quest-header">
                        <h3><i class="fa-solid fa-scroll"></i> Quests</h3>
                        <button id="maze_quest_close" class="maze-quest-close">&times;</button>
                    </div>
                    <div class="maze-quest-content">
                        <div class="quest-tabs">
                            <button class="quest-tab active" data-quest-tab="active">Active</button>
                            <button class="quest-tab" data-quest-tab="available">Available</button>
                            <button class="quest-tab" data-quest-tab="completed">Completed</button>
                        </div>
                        <div id="quest_list_content" class="quest-list">
                            <!-- Populated dynamically -->
                        </div>
                    </div>
                </div>
                <div id="maze_quest_backdrop" class="maze-quest-backdrop" style="display: none;"></div>

                <!-- Ability Bar (bottom of screen during combat) -->
                <div id="ability_bar" class="ability-bar">
                    <!-- Populated dynamically -->
                </div>

                <!-- Encounter Actions (shows when needed) -->
                <div id="maze_encounter_confirm" class="maze-action-buttons">
                    <!-- Populated dynamically when encounter happens -->
                </div>

                <!-- BOTTOM PANEL: Map Area -->
                <div class="mazemaster-maze-bottom">
                    <div class="mazemaster-maze-area">
                        <div id="maze_grid_container" class="mazemaster-maze-grid-wrapper" style="position: relative;">
                            <!-- Renderer inserts grid/canvas here -->
                        </div>

                        <!-- HP Overlay (upper-right corner of map) -->
                        <div class="maze-hp-overlay" id="maze_hp_overlay" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                            <div class="hp-overlay-bar">
                                <i class="fa-solid fa-heart"></i>
                                <div class="hp-overlay-bar-bg">
                                    <div class="hp-overlay-bar-fill high" id="maze_hp_bar" style="width: 100%;"></div>
                                </div>
                                <span class="hp-overlay-text">
                                    <span id="maze_hp_current">${currentMaze.hp?.current || 100}</span>/<span id="maze_hp_max">${(currentMaze.hp?.max || 100) + (currentMaze.hp?.maxBonus || 0)}</span>
                                </span>
                            </div>
                        </div>

                        <!-- v1.6.0: Minimap Overlay -->
                        ${getMinimapHTML()}

                        <!-- Inventory Symbols Overlay (upper-left corner of map) -->
                        <div class="maze-inventory-overlay" id="maze_inventory_overlay">
                            <div class="inv-overlay-item" data-item="key" title="Skeleton Key">
                                <i class="fa-solid fa-key" style="color: #f1c40f;"></i>
                                <span id="maze_ov_key">${currentMaze.inventory.key}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="stealth" title="Shadow Cloak">
                                <i class="fa-solid fa-user-ninja" style="color: #95a5a6;"></i>
                                <span id="maze_ov_stealth">${currentMaze.inventory.stealth}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="strike" title="Battle Surge">
                                <i class="fa-solid fa-bolt" style="color: #f39c12;"></i>
                                <span id="maze_ov_strike">${currentMaze.inventory.strike}</span>
                            </div>
                            <div class="inv-overlay-item execute" data-item="execute" title="Death Blow">
                                <i class="fa-solid fa-star" style="color: #e74c3c;"></i>
                                <span id="maze_ov_execute">${currentMaze.inventory.execute}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="floorKey" title="Floor Key" style="${currentMaze.totalFloors > 1 ? '' : 'display:none;'}">
                                <i class="fa-solid fa-stairs" style="color: #9b59b6;"></i>
                                <span id="maze_ov_floorKey">${currentMaze.inventory.floorKey}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="portalStone" title="Portal Stone">
                                <i class="fa-solid fa-gem" style="color: #3498db;"></i>
                                <span id="maze_ov_portalStone">${currentMaze.inventory.portalStone}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="minionBane" title="Minion Bane">
                                <i class="fa-solid fa-skull-crossbones" style="color: #8e44ad;"></i>
                                <span id="maze_ov_minionBane">${currentMaze.inventory.minionBane}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="mapFragment" title="Map Fragment">
                                <i class="fa-solid fa-scroll" style="color: #e67e22;"></i>
                                <span id="maze_ov_mapFragment">${currentMaze.inventory.mapFragment}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="timeShard" title="Time Shard">
                                <i class="fa-solid fa-hourglass-half" style="color: #2980b9;"></i>
                                <span id="maze_ov_timeShard">${currentMaze.inventory.timeShard}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="voidWalk" title="Void Walk">
                                <i class="fa-solid fa-ghost" style="color: #1abc9c;"></i>
                                <span id="maze_ov_voidWalk">${currentMaze.inventory.voidWalk}</span>
                            </div>
                            <!-- HP Items -->
                            <div class="inv-overlay-item hp-item" data-item="healingPotion" title="Minor Elixir" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                                <i class="fa-solid fa-flask" style="color: #e74c3c;"></i>
                                <span id="maze_ov_healingPotion">${currentMaze.inventory.healingPotion}</span>
                            </div>
                            <div class="inv-overlay-item hp-item" data-item="greaterHealing" title="Healing Draught" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                                <i class="fa-solid fa-flask-vial" style="color: #9b59b6;"></i>
                                <span id="maze_ov_greaterHealing">${currentMaze.inventory.greaterHealing}</span>
                            </div>
                            <div class="inv-overlay-item hp-item" data-item="elixir" title="Grand Elixir" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                                <i class="fa-solid fa-wine-bottle" style="color: #f1c40f;"></i>
                                <span id="maze_ov_elixir">${currentMaze.inventory.elixir}</span>
                            </div>
                            <div class="inv-overlay-item hp-item" data-item="revivalCharm" title="Phoenix Feather" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                                <i class="fa-solid fa-feather" style="color: #3498db;"></i>
                                <span id="maze_ov_revivalCharm">${currentMaze.inventory.revivalCharm}</span>
                            </div>
                            <div class="inv-overlay-item hp-item" data-item="heartCrystal" title="Heart Crystal" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                                <i class="fa-solid fa-gem" style="color: #e91e63;"></i>
                                <span id="maze_ov_heartCrystal">${currentMaze.inventory.heartCrystal}</span>
                            </div>
                            <!-- Visibility Items -->
                            <div class="inv-overlay-item vis-item" data-item="torch" data-usable="true" title="Torch: +2 visibility for 3 moves">
                                <i class="fa-solid fa-fire" style="color: #f39c12;"></i>
                                <span id="maze_ov_torch">${currentMaze.inventory.torch}</span>
                            </div>
                            <div class="inv-overlay-item vis-item" data-item="lantern" title="Lantern: Passive +1 visibility">
                                <i class="fa-solid fa-lightbulb" style="color: #f1c40f;"></i>
                                <span id="maze_ov_lantern">${currentMaze.inventory.lantern}</span>
                            </div>
                            <div class="inv-overlay-item vis-item" data-item="revealScroll" data-usable="true" title="Reveal Scroll: Shows entire floor">
                                <i class="fa-solid fa-scroll" style="color: #9b59b6;"></i>
                                <span id="maze_ov_revealScroll">${currentMaze.inventory.revealScroll}</span>
                            </div>
                            <div class="inv-overlay-item vis-item" data-item="sightPotion" data-usable="true" title="Sight Potion: Permanent +1 visibility">
                                <i class="fa-solid fa-eye" style="color: #3498db;"></i>
                                <span id="maze_ov_sightPotion">${currentMaze.inventory.sightPotion}</span>
                            </div>
                            <div class="inv-overlay-item vis-item" data-item="crystalBall" data-usable="true" title="Crystal Ball: Reveals all minions">
                                <i class="fa-solid fa-crystal-ball" style="color: #8e44ad;"></i>
                                <span id="maze_ov_crystalBall">${currentMaze.inventory.crystalBall}</span>
                            </div>
                            <!-- v1.7.0 Equipment Items -->
                            <div class="inv-overlay-item equip-item" data-item="ironGuard" data-usable="false" title="Iron Guard: Absorbs damage">
                                <i class="fa-solid fa-shield-halved" style="color: #95a5a6;"></i>
                                <span id="maze_ov_ironGuard">${currentMaze.inventory.ironGuard || 0}</span>
                            </div>
                        </div>

                        <!-- v1.5.0: Equipment Overlay (bottom-left corner of map) -->
                        <div class="maze-equipment-overlay" id="maze_equipment_overlay">
                            <div class="equip-overlay-header">
                                <i class="fa-solid fa-shield-halved"></i> Equipment
                                <span class="equip-stats-summary">
                                    <span id="maze_equip_total_atk">+0</span> ATK
                                    <span id="maze_equip_total_def">+0</span> DEF
                                    <span id="maze_equip_total_crit">+0%</span> Crit
                                </span>
                            </div>
                            <div class="equip-slots">
                                <div class="equip-slot" id="maze_equip_weapon" data-slot="weapon" title="Empty weapon slot">
                                    <div class="equip-item empty" data-slot="weapon">
                                        <i class="fa-solid fa-sword"></i>
                                        <span class="equip-name">Weapon</span>
                                    </div>
                                </div>
                                <div class="equip-slot" id="maze_equip_armor" data-slot="armor" title="Empty armor slot">
                                    <div class="equip-item empty" data-slot="armor">
                                        <i class="fa-solid fa-shield"></i>
                                        <span class="equip-name">Armor</span>
                                    </div>
                                </div>
                                <div class="equip-slot" id="maze_equip_accessory" data-slot="accessory" title="Empty accessory slot">
                                    <div class="equip-item empty" data-slot="accessory">
                                        <i class="fa-solid fa-ring"></i>
                                        <span class="equip-name">Accessory</span>
                                    </div>
                                </div>
                            </div>
                            <div class="equip-inventory-toggle">
                                <button id="maze_equip_toggle" class="equip-toggle-btn" title="View Equipment Inventory">
                                    <i class="fa-solid fa-backpack"></i> Backpack
                                </button>
                            </div>
                            <div class="equip-inventory-dropdown" id="maze_equipment_inventory" style="display: none;">
                                <div class="equip-inv-empty">No equipment in backpack</div>
                            </div>
                        </div>

                        <!-- Action Popup Overlay (for encounter buttons) - OUTSIDE grid container so it persists through re-renders -->
                        <div id="maze_action_popup" class="maze-action-popup" style="display: none;">
                            <div class="maze-action-popup-content">
                                <div id="maze_action_popup_buttons" class="maze-action-popup-buttons">
                                    <!-- Buttons populated dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Circular D-Pad (floating) -->
                <div id="maze_dpad" class="maze-dpad ${extensionSettings.dpadConfig?.floating !== false ? 'floating' : ''}"
                     style="${extensionSettings.dpadConfig?.enabled === false ? 'display: none;' : ''}${extensionSettings.dpadConfig?.position?.x ? `left: ${extensionSettings.dpadConfig.position.x}px; top: ${extensionSettings.dpadConfig.position.y}px;` : ''}">
                    <div class="dpad-ring">
                        <button class="dpad-btn dpad-up" data-dir="up" title="Move Up (Arrow Up)">
                            <i class="fa-solid fa-chevron-up"></i>
                        </button>
                        <button class="dpad-btn dpad-right" data-dir="right" title="Move Right (Arrow Right)">
                            <i class="fa-solid fa-chevron-right"></i>
                        </button>
                        <button class="dpad-btn dpad-down" data-dir="down" title="Move Down (Arrow Down)">
                            <i class="fa-solid fa-chevron-down"></i>
                        </button>
                        <button class="dpad-btn dpad-left" data-dir="left" title="Move Left (Arrow Left)">
                            <i class="fa-solid fa-chevron-left"></i>
                        </button>
                        <!-- Floor navigation buttons (shown when on staircase) -->
                        <button class="dpad-btn dpad-floor-up hidden" data-dir="floor-up" title="Go Up Floor (Shift+Up)">
                            <i class="fa-solid fa-arrow-up"></i><span>UP</span>
                        </button>
                        <button class="dpad-btn dpad-floor-down hidden" data-dir="floor-down" title="Go Down Floor (Shift+Down)">
                            <i class="fa-solid fa-arrow-down"></i><span>DN</span>
                        </button>
                    </div>
                    <div class="dpad-center"></div>
                    <div class="dpad-drag-handle" title="Drag to reposition">
                        <i class="fa-solid fa-grip"></i>
                    </div>
                    <!-- Rest button (HP system) - positioned safely away from directional buttons -->
                    <button id="maze_rest_btn" class="dpad-rest-btn" title="Rest to recover HP" style="display: none;">
                        <i class="fa-solid fa-bed"></i>
                        <span class="rest-cooldown-badge" style="display: none;"></span>
                    </button>
                </div>

                <!-- Close Button (shown on victory) -->
                <button id="maze_close_btn" class="menu_button menu_button_primary maze-close-btn" style="display: none;">
                    <i class="fa-solid fa-check"></i> Close
                </button>
            </div>
        </div>

        <style>
            .mazemaster-maze-overlay {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                height: 100%;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* v2.0.2: Loading Screen Overlay */
            .maze-loading-screen {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: #000;
                background-size: 100% 100%;
                background-position: center center;
                background-repeat: no-repeat;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                border-radius: 15px;
                transition: opacity 0.5s ease-out;
            }

            .maze-loading-screen.hidden {
                opacity: 0;
                pointer-events: none;
            }

            .maze-loading-card {
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.85);
                backdrop-filter: blur(8px);
                -webkit-backdrop-filter: blur(8px);
                border-radius: 12px;
                padding: 15px 25px;
                border: 1px solid rgba(212, 175, 55, 0.3);
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
                text-align: center;
                z-index: 10;
            }

            .maze-loading-header {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                margin-bottom: 10px;
                color: #d4af37;
            }

            .maze-loading-header i {
                font-size: 0.9em;
            }

            .maze-loading-subtitle {
                font-size: 0.95em;
                letter-spacing: 0.15em;
                text-transform: uppercase;
            }

            .maze-loading-percent {
                font-size: 0.9em;
                font-weight: bold;
                color: #d4af37;
            }

            .maze-loading-console {
                background: rgba(0, 0, 0, 0.5);
                border: 1px solid rgba(212, 175, 55, 0.3);
                border-radius: 8px;
                padding: 8px 12px;
                width: 280px;
                height: 80px;
                min-height: 80px;
                max-height: 80px;
                overflow-y: auto;
                font-family: monospace;
                font-size: 0.75em;
                text-align: left;
                color: #aaa;
            }

            .maze-loading-console .log-line {
                margin: 2px 0;
                white-space: nowrap;
            }

            .maze-loading-console .log-line.success {
                color: #4ade80;
            }

            .maze-loading-console .log-line.current {
                color: #d4af37;
            }

            /* v2.0.3: Hide game UI while loading screen is visible */
            .mazemaster-maze-container.loading-active .mazemaster-maze-top,
            .mazemaster-maze-container.loading-active .maze-dpad {
                display: none !important;
            }

            .mazemaster-maze-container {
                position: relative;
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 15px;
                width: 90vw;
                max-width: 1200px;
                height: 94vh;
                max-height: 960px;
                margin: 10px;
                background: #1a1a2e;
                border-radius: 15px;
                border: 2px solid #333;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                overflow: hidden;
            }

            /* Top Panel - Info & Controls */
            .mazemaster-maze-top {
                display: flex;
                flex-direction: row;
                gap: 16px;
                flex-shrink: 0;
                min-height: 240px;
                height: 280px;
            }

            /* Left Column - Message Box, Stats, Inventory stacked */
            .mazemaster-maze-left-column {
                display: flex;
                flex-direction: column;
                gap: 8px;
                width: 50.1%;
                flex-shrink: 0;
            }

            /* Info Stack - Stats and Inventory */
            .mazemaster-maze-info-stack {
                display: flex;
                flex-direction: column;
                gap: 8px;
                width: 100%;
                position: relative;
            }

            /* ROOM INFO BOX - right side, full height */
            .mazemaster-maze-room-info {
                flex: 1;
                margin-right: 46px; /* Space for power button */
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                padding: 10px 12px;
                border: 1px solid #444;
                display: flex;
                flex-direction: column;
            }

            .room-info-content {
                flex: 1;
                display: flex;
                flex-direction: column;
                color: #aaa;
                font-size: 0.9em;
                gap: 8px;
                overflow-y: auto;
            }

            .room-info-name {
                font-size: 1.1em;
                font-weight: 600;
                color: #ecf0f1;
                margin-bottom: 2px;
            }

            .room-info-desc {
                font-style: italic;
                color: #bdc3c7;
                font-size: 0.9em;
                line-height: 1.3;
                padding-bottom: 8px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            .room-info-section {
                display: flex;
                flex-direction: column;
                gap: 2px;
            }

            .room-info-label {
                font-size: 0.75em;
                color: #7f8c8d;
                text-transform: uppercase;
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .room-info-label i {
                font-size: 0.9em;
                color: #3498db;
            }

            .room-info-section > div:last-child {
                color: #ecf0f1;
                font-size: 0.95em;
            }

            .maze-hero-text {
                display: flex;
                flex-direction: column;
                flex: 1;
                min-width: 0;
            }

            /* Power Button - Top Right Corner */
            .maze-power-btn {
                position: absolute;
                top: 16px;
                right: 10px;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: 2px solid #e94560;
                background: rgba(233, 69, 96, 0.2);
                color: #e94560;
                font-size: 18px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
                z-index: 100;
            }

            .maze-power-btn:hover {
                background: #e94560;
                color: #fff;
                transform: scale(1.1);
            }

            /* Inventory Info Button - Below Power Button */
            .maze-inventory-info-wrapper {
                position: absolute;
                top: 66px;
                right: 10px;
                z-index: 200;
            }

            .maze-inventory-info-wrapper.open {
                z-index: 10100;
            }

            .maze-info-btn {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: 2px solid #f1c40f;
                background: rgba(241, 196, 15, 0.2);
                color: #f1c40f;
                font-size: 18px;
                font-weight: bold;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .maze-info-btn:hover {
                background: #f1c40f;
                color: #1a1a2e;
                transform: scale(1.1);
            }

            .maze-inventory-info-wrapper.open .maze-info-btn {
                background: #f1c40f;
                color: #1a1a2e;
            }

            /* Session Memory Button - Below Inventory Button */
            .maze-memory-wrapper {
                position: absolute;
                top: 112px;
                right: 10px;
                z-index: 200;
            }

            .maze-memory-btn {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: 2px solid #5dade2;
                background: rgba(93, 173, 226, 0.2);
                color: #5dade2;
                font-size: 18px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .maze-memory-btn:hover {
                background: #5dade2;
                color: #1a1a2e;
                transform: scale(1.1);
            }

            .maze-memory-btn.active {
                background: #5dade2;
                color: #1a1a2e;
            }

            /* Session Memory Panel */
            .maze-memory-panel {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 500px;
                max-height: 80vh;
                background: rgba(20, 25, 35, 0.98);
                border: 2px solid #5dade2;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                z-index: 10200;
                display: flex;
                flex-direction: column;
            }

            .maze-memory-panel.hidden {
                display: none;
            }

            .maze-memory-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 16px;
                border-bottom: 1px solid rgba(93, 173, 226, 0.3);
                background: rgba(93, 173, 226, 0.1);
                border-radius: 10px 10px 0 0;
            }

            .maze-memory-header h3 {
                margin: 0;
                color: #5dade2;
                font-size: 16px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .maze-memory-close {
                background: none;
                border: none;
                color: #888;
                font-size: 20px;
                cursor: pointer;
                padding: 4px 8px;
                transition: color 0.2s;
            }

            .maze-memory-close:hover {
                color: #e74c3c;
            }

            .maze-memory-content {
                flex: 1;
                padding: 16px;
                overflow-y: auto;
            }

            .maze-memory-textarea {
                width: 100%;
                height: 300px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(93, 173, 226, 0.3);
                border-radius: 8px;
                color: #e0e0e0;
                font-family: 'Segoe UI', Tahoma, sans-serif;
                font-size: 14px;
                line-height: 1.5;
                padding: 12px;
                resize: vertical;
            }

            .maze-memory-textarea:focus {
                outline: none;
                border-color: #5dade2;
            }

            .maze-memory-textarea::placeholder {
                color: #666;
                font-style: italic;
            }

            .maze-memory-footer {
                padding: 12px 16px;
                border-top: 1px solid rgba(93, 173, 226, 0.2);
                display: flex;
                justify-content: flex-end;
                gap: 10px;
            }

            .maze-memory-save-btn {
                background: linear-gradient(135deg, #5dade2 0%, #3498db 100%);
                border: none;
                color: white;
                padding: 8px 20px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: bold;
                transition: transform 0.2s, box-shadow 0.2s;
            }

            .maze-memory-save-btn:hover {
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(93, 173, 226, 0.4);
            }

            .maze-memory-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.6);
                z-index: 10199;
            }

            .maze-memory-backdrop.hidden {
                display: none;
            }

            /* Player Stats Button - Below Memory Button */
            .maze-player-wrapper {
                position: absolute;
                top: 158px;
                right: 10px;
                z-index: 200;
            }

            .maze-player-btn {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: 2px solid #58d68d;
                background: rgba(88, 214, 141, 0.2);
                color: #58d68d;
                font-size: 18px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .maze-player-btn:hover {
                background: #58d68d;
                color: #1a1a2e;
                transform: scale(1.1);
            }

            .maze-player-btn.active {
                background: #58d68d;
                color: #1a1a2e;
            }

            /* Player Stats Panel */
            .maze-player-panel {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 400px;
                max-height: 80vh;
                background: rgba(20, 25, 35, 0.98);
                border: 2px solid #58d68d;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                z-index: 10200;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .maze-player-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 16px;
                border-bottom: 1px solid rgba(88, 214, 141, 0.3);
                background: rgba(88, 214, 141, 0.1);
                border-radius: 10px 10px 0 0;
            }

            .maze-player-header h3 {
                margin: 0;
                color: #58d68d;
                font-size: 16px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .maze-player-close {
                background: none;
                border: none;
                color: #888;
                font-size: 20px;
                cursor: pointer;
                padding: 4px 8px;
                transition: color 0.2s;
            }

            .maze-player-close:hover {
                color: #e74c3c;
            }

            .maze-player-content {
                flex: 1;
                padding: 16px;
                overflow-y: auto;
            }

            .player-stats-section {
                margin-bottom: 20px;
                padding-bottom: 16px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            .player-stats-section:last-child {
                border-bottom: none;
                margin-bottom: 0;
            }

            .player-stats-section h4 {
                margin: 0 0 12px 0;
                color: #58d68d;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .player-level-display {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 12px;
                margin-bottom: 12px;
            }

            .level-label {
                color: #888;
                font-size: 14px;
                text-transform: uppercase;
            }

            .level-value {
                font-size: 36px;
                font-weight: bold;
                color: #58d68d;
                text-shadow: 0 0 10px rgba(88, 214, 141, 0.5);
            }

            .player-xp-bar-wrapper {
                width: 100%;
            }

            .player-xp-bar {
                width: 100%;
                height: 20px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 10px;
                overflow: hidden;
                border: 1px solid rgba(88, 214, 141, 0.3);
            }

            .player-xp-fill {
                height: 100%;
                background: linear-gradient(90deg, #27ae60, #58d68d);
                border-radius: 10px;
                transition: width 0.5s ease;
            }

            .player-xp-text {
                text-align: center;
                margin-top: 6px;
                color: #aaa;
                font-size: 13px;
            }

            .player-stat-row {
                display: flex;
                align-items: center;
                padding: 8px 0;
                border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            }

            .player-stat-row:last-child {
                border-bottom: none;
            }

            .stat-icon {
                width: 30px;
                text-align: center;
                color: #58d68d;
            }

            .stat-name {
                flex: 1;
                color: #ccc;
                font-size: 14px;
            }

            .stat-value {
                color: #fff;
                font-weight: bold;
                font-size: 14px;
            }

            .stat-bonus {
                color: #58d68d;
                font-size: 12px;
                margin-left: 4px;
            }

            .player-skill-points {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px;
                background: rgba(88, 214, 141, 0.1);
                border-radius: 8px;
                border: 1px solid rgba(88, 214, 141, 0.3);
            }

            .skill-points-label {
                color: #ccc;
                font-size: 14px;
            }

            .skill-points-value {
                font-size: 24px;
                font-weight: bold;
                color: #f1c40f;
            }

            .player-equip-summary {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .equip-slot-row {
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 6px 8px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 6px;
            }

            .equip-slot-icon {
                width: 24px;
                text-align: center;
                color: #888;
            }

            .equip-slot-name {
                width: 70px;
                color: #888;
                font-size: 12px;
                text-transform: uppercase;
            }

            .equip-slot-item {
                flex: 1;
                color: #fff;
                font-size: 13px;
            }

            .equip-slot-item.empty {
                color: #555;
                font-style: italic;
            }

            .maze-player-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.6);
                z-index: 10199;
            }

            /* Skills Button - Below Player Button */
            .maze-skills-wrapper {
                position: absolute;
                top: 204px;
                right: 10px;
                z-index: 200;
            }

            .maze-skills-btn {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: 2px solid #f39c12;
                background: rgba(243, 156, 18, 0.2);
                color: #f39c12;
                font-size: 16px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .maze-skills-btn:hover {
                background: #f39c12;
                color: #1a1a2e;
                transform: scale(1.1);
            }

            .maze-skills-btn.active {
                background: #f39c12;
                color: #1a1a2e;
            }

            /* Skill Tree Panel */
            .maze-skill-panel {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 95%;
                max-width: 900px;
                max-height: 85vh;
                background: rgba(20, 25, 35, 0.98);
                border: 2px solid #f39c12;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                z-index: 10200;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .maze-skill-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 16px;
                border-bottom: 1px solid rgba(243, 156, 18, 0.3);
                background: rgba(243, 156, 18, 0.1);
                border-radius: 10px 10px 0 0;
                gap: 16px;
            }

            .maze-skill-header h3 {
                margin: 0;
                color: #f39c12;
                font-size: 16px;
                display: flex;
                align-items: center;
                gap: 8px;
                flex: 1;
            }

            .skill-points-header {
                display: flex;
                align-items: center;
                gap: 8px;
                color: #ccc;
                font-size: 14px;
            }

            .skill-points-header .skill-points-value {
                font-size: 20px;
                font-weight: bold;
                color: #f1c40f;
            }

            .maze-skill-close {
                background: none;
                border: none;
                color: #888;
                font-size: 20px;
                cursor: pointer;
                padding: 4px 8px;
                transition: color 0.2s;
            }

            .maze-skill-close:hover {
                color: #e74c3c;
            }

            .maze-skill-content {
                flex: 1;
                padding: 16px;
                overflow-y: auto;
            }

            .skill-tree-container {
                display: flex;
                gap: 16px;
                flex-wrap: wrap;
                justify-content: center;
            }

            .skill-tree {
                flex: 1;
                min-width: 250px;
                max-width: 300px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                padding: 12px;
            }

            .skill-tree-header {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 12px;
                border-radius: 6px;
                border: 2px solid;
                background: rgba(0, 0, 0, 0.3);
                margin-bottom: 12px;
                font-weight: bold;
            }

            .skill-tree-skills {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .skill-node {
                padding: 10px 12px;
                border-radius: 8px;
                border: 2px solid #444;
                background: rgba(0, 0, 0, 0.4);
                transition: all 0.2s ease;
            }

            .skill-node.locked {
                opacity: 0.5;
                border-color: #333;
            }

            .skill-node.available {
                border-color: var(--tree-color, #f39c12);
                cursor: pointer;
            }

            .skill-node.available:hover {
                background: rgba(243, 156, 18, 0.1);
                transform: translateY(-2px);
            }

            .skill-node.learned {
                border-color: var(--tree-color, #f39c12);
                background: rgba(243, 156, 18, 0.15);
                box-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
            }

            .skill-node-header {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 4px;
            }

            .skill-node-header i {
                color: var(--tree-color, #f39c12);
            }

            .skill-name {
                flex: 1;
                font-weight: bold;
                color: #fff;
                font-size: 13px;
            }

            .skill-rank {
                font-size: 12px;
                color: #888;
                background: rgba(0, 0, 0, 0.3);
                padding: 2px 6px;
                border-radius: 4px;
            }

            .skill-node.learned .skill-rank {
                color: var(--tree-color, #f39c12);
                background: rgba(0, 0, 0, 0.5);
            }

            .skill-node-desc {
                font-size: 11px;
                color: #aaa;
                margin-bottom: 4px;
            }

            .skill-cooldown {
                font-size: 10px;
                color: #888;
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .skill-learn-btn {
                width: 100%;
                margin-top: 8px;
                padding: 6px 12px;
                background: var(--tree-color, #f39c12);
                border: none;
                border-radius: 4px;
                color: #1a1a2e;
                font-weight: bold;
                font-size: 12px;
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .skill-learn-btn:hover {
                transform: scale(1.02);
                box-shadow: 0 2px 8px rgba(243, 156, 18, 0.4);
            }

            .skill-locked-reason {
                font-size: 10px;
                color: #e74c3c;
                margin-top: 4px;
                font-style: italic;
            }

            .maze-skill-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.6);
                z-index: 10199;
            }

            /* Quest Button - Below Skills Button */
            .maze-quest-wrapper {
                position: absolute;
                top: 250px;
                right: 10px;
                z-index: 200;
            }

            .maze-quest-btn {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: 2px solid #e91e63;
                background: rgba(233, 30, 99, 0.2);
                color: #e91e63;
                font-size: 18px;
                font-weight: bold;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .maze-quest-btn:hover {
                background: #e91e63;
                color: #1a1a2e;
                transform: scale(1.1);
            }

            .maze-quest-btn.active {
                background: #e91e63;
                color: #1a1a2e;
            }

            /* Quest Panel */
            .maze-quest-panel {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 500px;
                max-height: 70vh;
                background: rgba(20, 25, 35, 0.98);
                border: 2px solid #e91e63;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                z-index: 10200;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .maze-quest-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 16px;
                border-bottom: 1px solid rgba(233, 30, 99, 0.3);
                background: rgba(233, 30, 99, 0.1);
                border-radius: 10px 10px 0 0;
            }

            .maze-quest-header h3 {
                margin: 0;
                color: #e91e63;
                font-size: 16px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .maze-quest-close {
                background: none;
                border: none;
                color: #888;
                font-size: 24px;
                cursor: pointer;
                padding: 0;
                width: 28px;
                height: 28px;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: color 0.2s ease;
            }

            .maze-quest-close:hover {
                color: #e91e63;
            }

            .maze-quest-content {
                flex: 1;
                overflow-y: auto;
                padding: 16px;
            }

            .quest-tabs {
                display: flex;
                gap: 8px;
                margin-bottom: 16px;
            }

            .quest-tab {
                flex: 1;
                padding: 8px 12px;
                border: 1px solid #444;
                background: rgba(0, 0, 0, 0.3);
                color: #888;
                font-size: 13px;
                cursor: pointer;
                border-radius: 6px;
                transition: all 0.2s ease;
            }

            .quest-tab:hover {
                background: rgba(233, 30, 99, 0.1);
                color: #e91e63;
                border-color: #e91e63;
            }

            .quest-tab.active {
                background: rgba(233, 30, 99, 0.2);
                color: #e91e63;
                border-color: #e91e63;
            }

            .quest-list {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            .quest-card {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid #333;
                border-radius: 8px;
                padding: 12px;
                transition: all 0.2s ease;
            }

            .quest-card:hover {
                border-color: #555;
            }

            .quest-card-header {
                display: flex;
                justify-content: space-between;
                align-items: flex-start;
                margin-bottom: 8px;
            }

            .quest-card-title {
                color: #fff;
                font-size: 14px;
                font-weight: bold;
                margin: 0;
            }

            .quest-card-type {
                font-size: 11px;
                color: #888;
                background: rgba(0, 0, 0, 0.3);
                padding: 2px 8px;
                border-radius: 10px;
            }

            .quest-card-description {
                color: #aaa;
                font-size: 12px;
                margin-bottom: 10px;
                line-height: 1.4;
            }

            .quest-progress-bar {
                height: 6px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 3px;
                overflow: hidden;
                margin-bottom: 8px;
            }

            .quest-progress-fill {
                height: 100%;
                background: linear-gradient(90deg, #e91e63, #ff6b9d);
                border-radius: 3px;
                transition: width 0.3s ease;
            }

            .quest-progress-text {
                font-size: 11px;
                color: #888;
                margin-bottom: 8px;
            }

            .quest-rewards {
                display: flex;
                gap: 12px;
                font-size: 12px;
                color: #f1c40f;
                margin-bottom: 10px;
            }

            .quest-reward-item {
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .quest-actions {
                display: flex;
                gap: 8px;
            }

            .quest-accept-btn,
            .quest-abandon-btn {
                padding: 6px 14px;
                font-size: 12px;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .quest-accept-btn {
                background: #e91e63;
                color: #fff;
                border: none;
            }

            .quest-accept-btn:hover {
                background: #ff4081;
            }

            .quest-abandon-btn {
                background: transparent;
                color: #888;
                border: 1px solid #555;
            }

            .quest-abandon-btn:hover {
                color: #e74c3c;
                border-color: #e74c3c;
            }

            .quest-empty-message {
                text-align: center;
                color: #666;
                padding: 30px;
                font-style: italic;
            }

            .quest-completed-badge {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                color: #27ae60;
                font-size: 12px;
            }

            .maze-quest-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.6);
                z-index: 10199;
            }

            /* Ability Bar */
            .ability-bar {
                position: absolute;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                gap: 8px;
                padding: 8px 12px;
                background: rgba(20, 25, 35, 0.95);
                border: 2px solid #444;
                border-radius: 8px;
                z-index: 150;
            }

            .ability-slot {
                width: 60px;
                height: 50px;
                border-radius: 6px;
                border: 2px solid #555;
                background: rgba(0, 0, 0, 0.4);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.2s ease;
                position: relative;
            }

            .ability-slot.ready {
                border-color: var(--ability-color, #f39c12);
                background: rgba(243, 156, 18, 0.15);
            }

            .ability-slot.ready:hover {
                transform: translateY(-3px);
                box-shadow: 0 4px 12px rgba(243, 156, 18, 0.3);
            }

            .ability-slot.on-cooldown {
                border-color: #444;
                opacity: 0.6;
                cursor: not-allowed;
            }

            .ability-slot.empty {
                border-color: #333;
                opacity: 0.4;
            }

            .ability-hotkey {
                position: absolute;
                top: 2px;
                left: 4px;
                font-size: 10px;
                color: #888;
                font-weight: bold;
            }

            .ability-name {
                font-size: 9px;
                color: #fff;
                text-align: center;
                line-height: 1.1;
                max-width: 55px;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .ability-cooldown {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 18px;
                font-weight: bold;
                color: #e74c3c;
                text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            }

            .ability-empty {
                font-size: 16px;
                color: #444;
            }

            /* Inventory Dropdown from Info Button */
            .maze-inventory-dropdown {
                position: absolute;
                top: calc(100% + 8px);
                right: 0;
                min-width: 220px;
                max-height: 70vh;
                overflow-y: auto;
                background: rgba(20, 25, 35, 0.98);
                border: 1px solid rgba(241, 196, 15, 0.3);
                border-radius: 10px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
                backdrop-filter: blur(10px);
                z-index: 10100;
            }

            .maze-inventory-dropdown.hidden {
                display: none;
            }

            .maze-inventory-dropdown .inventory-menu-section {
                padding: 8px 0;
                border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            }

            .maze-inventory-dropdown .inventory-menu-section:last-child {
                border-bottom: none;
            }

            .maze-inventory-dropdown .inventory-menu-header {
                padding: 4px 12px 6px;
                font-size: 0.7em;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                color: #f1c40f;
                font-weight: 600;
            }

            .maze-inventory-dropdown .inventory-menu-item {
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 8px 12px;
                cursor: pointer;
                transition: background 0.15s ease;
            }

            .maze-inventory-dropdown .inventory-menu-item:hover {
                background: rgba(255, 255, 255, 0.08);
            }

            .maze-inventory-dropdown .inventory-menu-item[data-usable="true"]:hover {
                background: rgba(46, 204, 113, 0.15);
            }

            .maze-inventory-dropdown .inventory-menu-item i {
                font-size: 14px;
                width: 18px;
                text-align: center;
            }

            .maze-inventory-dropdown .inventory-menu-item .item-name {
                flex: 1;
                font-size: 0.85em;
                color: #ecf0f1;
            }

            .maze-inventory-dropdown .inventory-menu-item .item-count {
                font-size: 0.85em;
                font-weight: 600;
                color: #f1c40f;
                min-width: 20px;
                text-align: right;
            }

            .maze-inventory-dropdown .inventory-menu-item.execute .item-name {
                color: #e74c3c;
            }

            .maze-inventory-dropdown .inventory-menu-item.execute .item-count {
                color: #e74c3c;
            }

            /* Save Dialog */
            #maze_save_dialog {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 1000;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .maze-save-dialog-backdrop {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
            }

            .maze-save-dialog-content {
                position: relative;
                background: #1a1a2e;
                border: 2px solid #4a90d9;
                border-radius: 12px;
                padding: 24px 32px;
                text-align: center;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            }

            .maze-save-dialog-title {
                color: #fff;
                font-size: 18px;
                font-weight: 600;
                margin-bottom: 20px;
            }

            .maze-save-dialog-buttons {
                display: flex;
                gap: 12px;
                justify-content: center;
            }

            .maze-save-btn {
                padding: 10px 24px;
                border-radius: 6px;
                border: none;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .maze-save-yes {
                background: #27ae60;
                color: #fff;
            }

            .maze-save-yes:hover {
                background: #2ecc71;
            }

            .maze-save-no {
                background: #e74c3c;
                color: #fff;
            }

            .maze-save-no:hover {
                background: #c0392b;
            }

            .maze-save-cancel {
                background: #7f8c8d;
                color: #fff;
            }

            .maze-save-cancel:hover {
                background: #95a5a6;
            }

            /* Bottom Panel - Map Area */
            .mazemaster-maze-bottom {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-end;
                flex: 1;
                min-height: 200px;
                padding-bottom: 15px;
                overflow: auto;
            }

            /* Hero Section - Minion Area (fills remaining height) */
            .mazemaster-maze-hero {
                display: flex;
                flex-direction: column;
                flex: 1;
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                padding: 10px 12px;
                border: 1px solid #444;
                min-height: 80px;
            }

            .maze-minion-name {
                font-weight: bold;
                font-size: 1.2em;
                color: #e94560;
                flex-shrink: 0;
                margin-bottom: 0;
            }

            .maze-minion-role {
                font-size: 0.8em;
                color: #f1c40f;
                flex-shrink: 0;
                margin-bottom: 4px;
            }

            .mazemaster-maze-hero-content {
                display: flex;
                gap: 10px;
                align-items: flex-start;
                flex: 1;
            }

            .mazemaster-maze-hero-avatar {
                width: 72px;
                height: 72px;
                min-width: 72px;
                flex-shrink: 0;
                border-radius: 6px;
                overflow: hidden;
                background: #16213e;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
            }

            .mazemaster-maze-hero-avatar img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                object-position: center top;
                display: block;
            }

            /* LLM Generating Indicator - overlays the entire image */
            .maze-generating-indicator {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(52, 152, 219, 0.7);
                border-radius: 8px;
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 10;
            }

            .maze-generating-indicator.active {
                display: flex;
            }

            .maze-generating-indicator i {
                color: #fff;
                font-size: 32px;
                animation: maze-pulse 1s ease-in-out infinite;
                text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            }

            @keyframes maze-pulse {
                0%, 100% { transform: scale(1); opacity: 1; }
                50% { transform: scale(1.2); opacity: 0.7; }
            }

            .maze-message-log {
                flex: 1;
                color: #eee;
                line-height: 1.4;
                font-size: 0.9em;
                overflow-y: auto;
                max-height: 120px;
                display: flex;
                flex-direction: column;
                gap: 4px;
                padding-right: 4px;
            }

            .maze-message-log::-webkit-scrollbar {
                width: 6px;
            }

            .maze-message-log::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.2);
                border-radius: 3px;
            }

            .maze-message-log::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 3px;
            }

            .maze-message-log::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.5);
            }

            .maze-message-entry {
                padding: 4px 8px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 6px;
                border-left: 3px solid rgba(52, 152, 219, 0.6);
            }

            .maze-message-entry:last-child {
                border-left-color: rgba(46, 204, 113, 0.8);
            }

            .maze-message-speaker {
                font-weight: 600;
                color: #3498db;
                font-size: 0.85em;
                margin-bottom: 2px;
            }

            .maze-message-text {
                font-style: italic;
                color: #ecf0f1;
            }

            /* Chat Input Styles */
            .maze-chat-input-container {
                display: flex;
                gap: 6px;
                padding-top: 8px;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                margin-top: 8px;
                align-items: center;
            }

            /* v2.0.3: Buttons wrapper aligned with avatar column */
            .maze-chat-buttons {
                display: flex;
                gap: 4px;
                width: 82px;  /* Match avatar width (72px) + gap (10px) */
                min-width: 82px;
                flex-shrink: 0;
                justify-content: flex-start;
            }

            .maze-chat-input {
                flex: 1;
                background: rgba(0, 0, 0, 0.4);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 6px;
                padding: 8px 12px;
                color: #ecf0f1;
                font-size: 0.9em;
                outline: none;
                transition: border-color 0.2s;
            }

            .maze-chat-input:focus {
                border-color: rgba(52, 152, 219, 0.6);
            }

            .maze-chat-input::placeholder {
                color: rgba(255, 255, 255, 0.4);
            }

            .maze-chat-input:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .maze-chat-send-btn {
                background: rgba(52, 152, 219, 0.6);
                border: none;
                border-radius: 6px;
                padding: 8px 12px;
                color: white;
                cursor: pointer;
                transition: background 0.2s, transform 0.1s;
            }

            .maze-chat-send-btn:hover:not(:disabled) {
                background: rgba(52, 152, 219, 0.8);
                transform: scale(1.05);
            }

            .maze-chat-send-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .maze-chat-action-btn {
                background: rgba(100, 100, 100, 0.4);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 6px;
                padding: 8px 10px;
                color: rgba(255, 255, 255, 0.7);
                cursor: pointer;
                transition: all 0.2s;
                font-size: 0.85em;
            }

            .maze-chat-action-btn:hover:not(:disabled) {
                background: rgba(212, 175, 55, 0.4);
                border-color: rgba(212, 175, 55, 0.6);
                color: #d4af37;
                transform: scale(1.05);
            }

            .maze-chat-action-btn:disabled {
                opacity: 0.4;
                cursor: not-allowed;
            }

            .maze-chat-action-btn.generating {
                animation: pulse-gold 1s ease-in-out infinite;
            }

            @keyframes pulse-gold {
                0%, 100% { background: rgba(212, 175, 55, 0.3); }
                50% { background: rgba(212, 175, 55, 0.6); }
            }

            /* Player message styling - green border */
            .maze-message-entry.player-message {
                border-left-color: rgba(46, 204, 113, 0.6);
            }

            /* Creature chat reply styling - cyan/teal border */
            .maze-message-entry.creature-chat {
                border-left-color: rgba(26, 188, 156, 0.8);
            }

            /* Typing indicator */
            .maze-message-entry.typing {
                opacity: 0.7;
            }

            .maze-message-entry.typing .maze-message-text::after {
                content: '...';
                animation: maze-typing-dots 1.5s infinite;
            }

            @keyframes maze-typing-dots {
                0%, 20% { content: '.'; }
                40% { content: '..'; }
                60%, 100% { content: '...'; }
            }

            /* Stats Bar */
            .mazemaster-maze-stats-bar {
                display: flex;
                justify-content: center;
                flex-wrap: wrap;
                gap: 12px;
                width: 100%;
                padding: 6px 12px;
                background: linear-gradient(135deg, rgba(52, 73, 94, 0.4) 0%, rgba(44, 62, 80, 0.4) 100%);
                border-radius: 8px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .stats-item {
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 0.85em;
                color: #bdc3c7;
            }

            .stats-item i {
                color: #3498db;
                font-size: 0.9em;
            }

            .stats-item span {
                font-weight: 500;
                color: #ecf0f1;
            }

            /* HP Bar Styles (v1.3.0) */
            .stats-hp {
                min-width: 120px;
            }

            .hp-bar-container {
                position: relative;
                width: 80px;
                height: 16px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 8px;
                overflow: hidden;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }

            .hp-bar-fill {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
                background: linear-gradient(90deg, #27ae60, #1e8449);
                transition: width 0.3s ease, background 0.3s ease;
                border-radius: 8px;
            }

            .hp-bar-fill.low {
                background: linear-gradient(90deg, #e74c3c, #c0392b);
                animation: hp-pulse 1s infinite;
            }

            .hp-bar-fill.medium {
                background: linear-gradient(90deg, #f39c12, #d68910);
            }

            .hp-bar-fill.high {
                background: linear-gradient(90deg, #27ae60, #1e8449);
            }

            .hp-bar-text {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.7em;
                font-weight: 600;
                color: #fff;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                white-space: nowrap;
            }

            @keyframes hp-pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.6; }
            }

            /* Damage/Heal Flash Effects */
            .maze-hp-flash {
                position: fixed;
                inset: 0;
                pointer-events: none;
                z-index: 9999;
                animation: hp-flash 0.3s ease-out forwards;
            }

            .maze-hp-flash.damage {
                background: radial-gradient(circle, rgba(231, 76, 60, 0.3) 0%, transparent 70%);
            }

            .maze-hp-flash.heal {
                background: radial-gradient(circle, rgba(46, 204, 113, 0.3) 0%, transparent 70%);
            }

            @keyframes hp-flash {
                from { opacity: 1; }
                to { opacity: 0; }
            }

            /* Low HP Warning Border */
            .mazemaster-maze-container.low-hp {
                animation: low-hp-border 2s infinite;
            }

            @keyframes low-hp-border {
                0%, 100% { box-shadow: inset 0 0 0 2px transparent; }
                50% { box-shadow: inset 0 0 0 2px #e74c3c; }
            }

            /* ============================================= */
            /* HP OVERLAY (upper-right of map) */
            /* ============================================= */
            .maze-hp-overlay {
                position: absolute;
                top: 8px;
                right: 8px;
                z-index: 100;
                pointer-events: none;
            }

            .hp-overlay-bar {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 6px 10px;
                background: rgba(0, 0, 0, 0.6);
                border-radius: 20px;
                backdrop-filter: blur(4px);
                border: 1px solid rgba(255, 255, 255, 0.15);
            }

            .hp-overlay-bar > i {
                color: #e74c3c;
                font-size: 14px;
            }

            .hp-overlay-bar-bg {
                position: relative;
                width: 70px;
                height: 12px;
                background: rgba(0, 0, 0, 0.5);
                border-radius: 6px;
                overflow: hidden;
            }

            .hp-overlay-bar-fill {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
                border-radius: 6px;
                transition: width 0.3s ease, background 0.3s ease;
            }

            .hp-overlay-bar-fill.high {
                background: linear-gradient(90deg, #27ae60, #2ecc71);
            }

            .hp-overlay-bar-fill.medium {
                background: linear-gradient(90deg, #f39c12, #f1c40f);
            }

            .hp-overlay-bar-fill.low {
                background: linear-gradient(90deg, #c0392b, #e74c3c);
                animation: hp-pulse 1s infinite;
            }

            .hp-overlay-text {
                font-size: 11px;
                font-weight: 600;
                color: #fff;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
                white-space: nowrap;
                min-width: 45px;
                text-align: center;
            }

            /* ============================================= */
            /* INVENTORY OVERLAY (upper-left of map) */
            /* ============================================= */
            .maze-inventory-overlay {
                position: absolute;
                top: 8px;
                left: 8px;
                z-index: 100;
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
                pointer-events: none;
                max-width: calc(100% - 16px);
            }

            .inv-overlay-item {
                display: flex;
                align-items: center;
                gap: 4px;
                padding: 4px 8px;
                background: rgba(0, 0, 0, 0.6);
                border-radius: 12px;
                backdrop-filter: blur(4px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                font-size: 12px;
            }

            .inv-overlay-item i {
                font-size: 12px;
                width: 14px;
                text-align: center;
            }

            .inv-overlay-item span {
                font-weight: 600;
                color: #fff;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
                min-width: 16px;
                text-align: center;
            }

            .inv-overlay-item.execute {
                border-color: rgba(231, 76, 60, 0.4);
            }

            .inv-overlay-item.execute i {
                animation: star-glow 2s ease-in-out infinite;
            }

            @keyframes star-glow {
                0%, 100% { filter: drop-shadow(0 0 2px #e74c3c); }
                50% { filter: drop-shadow(0 0 6px #e74c3c); }
            }

            /* Hide items with 0 count */
            .inv-overlay-item span:empty,
            .inv-overlay-item[data-count="0"] {
                display: none;
            }

            /* ============================================= */
            /* EQUIPMENT OVERLAY (bottom-left of map) v1.5.0 */
            /* ============================================= */
            .maze-equipment-overlay {
                position: absolute;
                bottom: 8px;
                left: 8px;
                z-index: 100;
                display: flex;
                flex-direction: column;
                gap: 4px;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 8px;
                padding: 8px;
                backdrop-filter: blur(4px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                min-width: 140px;
            }

            .equip-overlay-header {
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 11px;
                color: #e67e22;
                font-weight: 600;
                padding-bottom: 4px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            .equip-stats-summary {
                font-size: 10px;
                color: #95a5a6;
                margin-left: auto;
            }

            .equip-stats-summary span {
                margin-left: 4px;
            }

            #maze_equip_total_atk { color: #e74c3c; }
            #maze_equip_total_def { color: #3498db; }
            #maze_equip_total_crit { color: #f1c40f; }

            .equip-slots {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .equip-slot {
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .equip-slot:hover {
                transform: translateX(2px);
            }

            .equip-item {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 4px 8px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                font-size: 11px;
            }

            .equip-item.empty {
                color: #7f8c8d;
            }

            .equip-item.equipped {
                color: #2ecc71;
                border-color: rgba(46, 204, 113, 0.3);
            }

            .equip-item i {
                width: 14px;
                text-align: center;
            }

            .equip-name {
                flex: 1;
            }

            .equip-inventory-toggle {
                margin-top: 4px;
            }

            .equip-toggle-btn {
                width: 100%;
                padding: 4px 8px;
                font-size: 10px;
                background: rgba(52, 152, 219, 0.2);
                border: 1px solid rgba(52, 152, 219, 0.3);
                border-radius: 4px;
                color: #3498db;
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .equip-toggle-btn:hover {
                background: rgba(52, 152, 219, 0.3);
            }

            .equip-inventory-dropdown {
                margin-top: 4px;
                max-height: 150px;
                overflow-y: auto;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 4px;
                padding: 4px;
            }

            .equip-inv-empty {
                text-align: center;
                font-size: 10px;
                color: #7f8c8d;
                padding: 8px;
            }

            .equip-inv-item {
                display: flex;
                align-items: center;
                gap: 4px;
                padding: 4px 6px;
                margin-bottom: 2px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 4px;
                font-size: 10px;
                border-left: 2px solid transparent;
            }

            .equip-inv-item.rarity-common { border-left-color: #95a5a6; }
            .equip-inv-item.rarity-uncommon { border-left-color: #2ecc71; }
            .equip-inv-item.rarity-rare { border-left-color: #3498db; }
            .equip-inv-item.rarity-epic { border-left-color: #9b59b6; }

            .equip-inv-item .item-name {
                flex: 1;
                color: #ecf0f1;
            }

            .equip-inv-item .item-stats {
                color: #7f8c8d;
                font-size: 9px;
            }

            .equip-btn {
                padding: 2px 6px;
                font-size: 9px;
                background: rgba(46, 204, 113, 0.2);
                border: 1px solid rgba(46, 204, 113, 0.3);
                border-radius: 3px;
                color: #2ecc71;
                cursor: pointer;
            }

            .equip-btn:hover {
                background: rgba(46, 204, 113, 0.4);
            }

            /* Objectives Section */
            .maze-objectives-section {
                width: 550px;
                max-width: 95vw;
                padding: 8px 12px;
                background: linear-gradient(135deg, rgba(52, 73, 94, 0.4) 0%, rgba(44, 62, 80, 0.4) 100%);
                border-radius: 8px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .maze-objectives-section.hidden {
                display: none;
            }

            .maze-objectives-section .objectives-header {
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 0.8em;
                color: #95a5a6;
                margin-bottom: 6px;
            }

            .maze-objectives-section .objectives-list {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .maze-objectives-section .objective-item {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 0.85em;
                padding: 4px 8px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
            }

            .maze-objectives-section .objective-item i {
                font-size: 0.9em;
            }

            .maze-objectives-section .objective-description {
                flex: 1;
            }

            .maze-objectives-section .objective-progress {
                font-weight: 500;
                font-size: 0.9em;
            }

            .maze-objectives-section .objective-required i {
                color: #e74c3c;
            }

            .maze-objectives-section .objective-optional i {
                color: #95a5a6;
            }

            .maze-objectives-section .objective-complete {
                opacity: 0.7;
            }

            .maze-objectives-section .objective-complete i {
                color: #27ae60 !important;
            }

            .maze-objectives-section.objectives-flash {
                animation: objectives-flash-anim 0.5s ease-out;
            }

            @keyframes objectives-flash-anim {
                0%, 100% {
                    border-color: rgba(255, 255, 255, 0.1);
                }
                50% {
                    border-color: #e74c3c;
                    box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
                }
            }

            /* Player Overlay for Smooth Movement Animation */
            .maze-player-overlay {
                position: absolute;
                top: 2px;
                left: 2px;
                pointer-events: none;
                z-index: 10;
                transition: transform 0.15s ease-out;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .maze-player-marker {
                width: 60%;
                height: 60%;
                background: radial-gradient(circle, #4ecdc4 0%, #2d8f8f 100%);
                border-radius: 50%;
                box-shadow: 0 0 10px rgba(78, 205, 196, 0.6), 0 0 20px rgba(78, 205, 196, 0.3);
                animation: player-pulse 1.5s ease-in-out infinite;
            }

            @keyframes player-pulse {
                0%, 100% { transform: scale(1); opacity: 1; }
                50% { transform: scale(1.1); opacity: 0.9; }
            }

            .maze-player-overlay.teleporting .maze-player-marker {
                animation: teleport-flash 0.2s ease-out;
            }

            @keyframes teleport-flash {
                0% { opacity: 1; transform: scale(1); }
                50% { opacity: 0; transform: scale(0.2); }
                100% { opacity: 1; transform: scale(1); }
            }

            /* Control Bar */
            .maze-action-buttons {
                display: flex;
                gap: 6px;
                justify-content: center;
                flex-wrap: wrap;
            }

            .mazemaster-maze-inventory {
                display: flex;
                flex-wrap: wrap;
                justify-content: space-evenly;
                background: rgba(0, 0, 0, 0.3);
                padding: 8px 12px;
                border-radius: 6px;
            }

            .inventory-item {
                display: flex;
                align-items: center;
                gap: 4px;
                font-size: 0.9em;
            }

            /* Inventory item icon colors */
            .inventory-item i.fa-key { color: #f1c40f; }
            .inventory-item i.fa-user-ninja { color: #9b59b6; }
            .inventory-item i.fa-bolt { color: #e74c3c; }
            .inventory-item.execute i { color: #ffd700; text-shadow: 0 0 4px #ffd700; }
            .inventory-item.floor-key i { color: #3498db; }
            .inventory-item.portal-stone i { color: #9b59b6; }
            .inventory-item.minion-bane i { color: #c0392b; }
            .inventory-item.map-fragment i { color: #27ae60; }
            .inventory-item.time-shard i { color: #f39c12; }
            .inventory-item.void-walk i { color: #7f8c8d; }

            /* Inventory expand icon */
            .inventory-expand-icon {
                margin-left: auto;
                padding-left: 8px;
                color: #888;
                cursor: pointer;
                transition: transform 0.2s;
            }
            .mazemaster-maze-inventory.expanded .inventory-expand-icon {
                transform: rotate(180deg);
            }
            .mazemaster-maze-inventory {
                cursor: pointer;
            }

            /* Inventory Drawer */
            .maze-inventory-drawer {
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: rgba(26, 26, 46, 0.98);
                border: 1px solid #444;
                border-top: none;
                border-radius: 0 0 8px 8px;
                padding: 10px 12px;
                z-index: 200;
                max-height: 300px;
                overflow-y: auto;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            }
            .maze-inventory-drawer.hidden {
                display: none;
            }
            .inventory-drawer-content {
                display: flex;
                flex-direction: column;
                gap: 6px;
            }
            .inventory-drawer-item {
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 6px 8px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 4px;
            }
            .inventory-drawer-item.empty {
                opacity: 0.4;
            }
            .inventory-drawer-item i {
                width: 20px;
                text-align: center;
            }
            .inventory-drawer-item .item-name {
                flex: 1;
                font-size: 0.9em;
            }
            .inventory-drawer-item .item-count {
                font-weight: bold;
                min-width: 24px;
                text-align: right;
            }
            /* Drawer item icon colors - match the bar */
            .inventory-drawer-item i.fa-key { color: #f1c40f; }
            .inventory-drawer-item i.fa-user-ninja { color: #9b59b6; }
            .inventory-drawer-item i.fa-bolt { color: #e74c3c; }
            .inventory-drawer-item.execute i { color: #ffd700; text-shadow: 0 0 4px #ffd700; }
            .inventory-drawer-item.floor-key i { color: #3498db; }
            .inventory-drawer-item.portal-stone i { color: #9b59b6; }
            .inventory-drawer-item.minion-bane i { color: #c0392b; }
            .inventory-drawer-item.map-fragment i { color: #27ae60; }
            .inventory-drawer-item.time-shard i { color: #f39c12; }
            .inventory-drawer-item.void-walk i { color: #7f8c8d; }

            /* Usable items have click cursor and glow */
            .inventory-item[data-usable="true"] {
                cursor: pointer;
                transition: transform 0.2s, box-shadow 0.2s;
            }
            .inventory-item[data-usable="true"]:hover {
                transform: scale(1.1);
                text-shadow: 0 0 8px currentColor;
            }
            .inventory-item.hidden { display: none; }

            .mazemaster-maze-save-exit {
                display: flex;
                gap: 8px;
                justify-content: center;
                margin-top: auto;
                padding-top: 10px;
            }

            /* Maze Area */
            .mazemaster-maze-area {
                position: relative; /* Required for action popup overlay positioning */
                width: 100%;
                height: 100%;
                overflow: hidden;
                cursor: grab;
                user-select: none;
                background: #0a0a1a;
                border-radius: 8px;
            }

            .mazemaster-maze-grid-wrapper {
                position: absolute;
                top: 0;
                left: 0;
                /* Position controlled by JS transforms */
            }

            /* Circular D-Pad */
            .maze-dpad {
                position: absolute;
                bottom: 60px;
                right: 20px;
                width: 140px;
                height: 140px;
                z-index: 100;
            }

            .maze-dpad.floating {
                position: fixed;
                z-index: 10001;
                bottom: 100px;
                right: 20px;
            }

            .dpad-ring {
                position: relative;
                width: 100%;
                height: 100%;
                border-radius: 50%;
                background: radial-gradient(circle, #2c3e50 0%, #1a1a2e 100%);
                border: 3px solid var(--theme-primary, #3498db);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            }

            .dpad-btn {
                position: absolute;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: linear-gradient(to bottom, var(--theme-primary, #3498db), var(--theme-secondary, #2980b9));
                border: 2px solid var(--theme-accent, #5dade2);
                color: white;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.15s;
                font-size: 1em;
            }

            .dpad-btn:hover {
                filter: brightness(1.2);
            }

            .dpad-btn:active {
                filter: brightness(0.9);
            }

            .dpad-up { top: 5px; left: 50%; transform: translateX(-50%); }
            .dpad-up:hover { transform: translateX(-50%) scale(1.1); }
            .dpad-up:active { transform: translateX(-50%) scale(0.95); }

            .dpad-right { right: 5px; top: 50%; transform: translateY(-50%); }
            .dpad-right:hover { transform: translateY(-50%) scale(1.1); }
            .dpad-right:active { transform: translateY(-50%) scale(0.95); }

            .dpad-down { bottom: 5px; left: 50%; transform: translateX(-50%); }
            .dpad-down:hover { transform: translateX(-50%) scale(1.1); }
            .dpad-down:active { transform: translateX(-50%) scale(0.95); }

            .dpad-left { left: 5px; top: 50%; transform: translateY(-50%); }
            .dpad-left:hover { transform: translateY(-50%) scale(1.1); }
            .dpad-left:active { transform: translateY(-50%) scale(0.95); }

            .dpad-center {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 30px;
                height: 30px;
                border-radius: 50%;
                background: #1a1a2e;
                border: 2px solid #34495e;
            }

            /* Floor navigation buttons - appear on LEFT side of D-pad when on stairs */
            .dpad-floor-up, .dpad-floor-down {
                position: absolute;
                width: 36px;
                height: 36px;
                border-radius: 8px;
                font-size: 0.65em;
                background: linear-gradient(to bottom, #27ae60, #1e8449);
                border: 2px solid #2ecc71;
                flex-direction: column;
                gap: 1px;
                z-index: 10;
                box-shadow: 0 2px 8px rgba(46, 204, 113, 0.5);
                left: -50px;
            }

            .dpad-floor-up {
                top: 15px;
            }
            .dpad-floor-up:hover {
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(46, 204, 113, 0.7);
            }
            .dpad-floor-up:active {
                transform: scale(0.95);
            }

            .dpad-floor-down {
                bottom: 15px;
                background: linear-gradient(to bottom, #e67e22, #d35400);
                border-color: #f39c12;
                box-shadow: 0 2px 8px rgba(243, 156, 18, 0.5);
            }
            .dpad-floor-down:hover {
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(243, 156, 18, 0.7);
            }
            .dpad-floor-down:active {
                transform: scale(0.95);
            }

            .dpad-floor-up.hidden, .dpad-floor-down.hidden {
                display: none !important;
            }

            .dpad-floor-up span, .dpad-floor-down span {
                font-size: 0.65em;
                font-weight: bold;
            }

            .dpad-drag-handle {
                position: absolute;
                bottom: -22px;
                left: 50%;
                transform: translateX(-50%);
                padding: 3px 8px;
                background: rgba(0, 0, 0, 0.5);
                border-radius: 4px;
                color: #666;
                font-size: 0.75em;
                cursor: grab;
                display: none;
            }

            .maze-dpad.floating .dpad-drag-handle {
                display: block;
            }

            .maze-dpad:not(.floating) .dpad-drag-handle {
                display: none;
            }

            /* Rest button - positioned top-right corner, away from directional buttons */
            .dpad-rest-btn {
                position: absolute;
                top: -15px;
                right: -15px;
                width: 36px;
                height: 36px;
                border-radius: 50%;
                background: linear-gradient(135deg, #14b8a6, #0d9488);
                border: 2px solid #2dd4bf;
                color: #fff;
                font-size: 14px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 2px 8px rgba(20, 184, 166, 0.4);
                transition: all 0.2s ease;
                z-index: 10;
            }

            .dpad-rest-btn:hover:not(:disabled) {
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(20, 184, 166, 0.6);
            }

            .dpad-rest-btn:active:not(:disabled) {
                transform: scale(0.95);
            }

            .dpad-rest-btn:disabled {
                background: linear-gradient(135deg, #6b7280, #4b5563);
                border-color: #9ca3af;
                cursor: not-allowed;
                opacity: 0.7;
            }

            .dpad-rest-btn .rest-cooldown-badge {
                position: absolute;
                bottom: -4px;
                right: -4px;
                min-width: 16px;
                height: 16px;
                padding: 0 4px;
                background: #ef4444;
                border-radius: 8px;
                font-size: 10px;
                font-weight: bold;
                color: #fff;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* Void Walk active indicator */
            .maze-dpad.void-walk-active .dpad-ring {
                animation: void-walk-pulse 1s infinite;
                border-color: #7f8c8d;
            }
            .maze-dpad.void-walk-active .dpad-btn {
                background: linear-gradient(to bottom, #7f8c8d, #5d6d7e);
                border-color: #95a5a6;
            }
            @keyframes void-walk-pulse {
                0%, 100% { box-shadow: 0 4px 15px rgba(127, 140, 141, 0.5); }
                50% { box-shadow: 0 4px 25px rgba(127, 140, 141, 0.8); }
            }

            .mazemaster-maze-grid {
                display: grid;
                gap: 0;
                background: #333;
                padding: 2px;
                border-radius: 5px;
                border: 2px solid #555;
            }

            .maze-cell {
                width: ${cellSize}px;
                height: ${cellSize}px;
                background: #1a1a2e;
                position: relative;
                box-sizing: border-box;
            }

            .maze-cell.hidden {
                background: #0a0a0a;
            }

            .maze-cell.completely-hidden {
                background: transparent;
                border: none !important;
                visibility: hidden;
            }

            .maze-cell.wall-top { border-top: 2px solid #fff; }
            .maze-cell.wall-right { border-right: 2px solid #fff; }
            .maze-cell.wall-bottom { border-bottom: 2px solid #fff; }
            .maze-cell.wall-left { border-left: 2px solid #fff; }

            /* Player marker now handled by .maze-player-overlay for smooth animation */
            .maze-cell.player {
                /* Player position cell styling - marker is in overlay */
            }

            .maze-cell.exit::before {
                content: '';
                position: absolute;
                top: 50%; left: 50%;
                transform: translate(-50%, -50%);
                width: 70%; height: 70%;
                background: #27ae60;
                border-radius: 3px;
            }

            .maze-cell.visited:not(.hidden) {
                background: #1e2a4a;
            }

            /* Legacy arrow buttons (kept for backwards compatibility) */
            .maze-arrow-btn {
                display: none; /* Hide legacy buttons */
            }

            /* Action buttons */
            .maze-action-btn {
                padding: 8px 14px;
                font-size: 0.85em;
                border-radius: 5px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
            }

            .maze-exit-btn {
                background: linear-gradient(to bottom, #555, #444) !important;
            }

            .maze-close-btn {
                padding: 10px 28px;
                font-size: 1em;
            }

            /* =====================================================
               ACTION POPUP OVERLAY (over map)
               ===================================================== */
            .maze-action-popup {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(0, 0, 0, 0.75);
                z-index: 100;
                backdrop-filter: blur(3px);
                animation: popupFadeIn 0.2s ease-out;
            }

            @keyframes popupFadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }

            .maze-action-popup-content {
                background: linear-gradient(145deg, #2a2a3a, #1a1a2a);
                border: 2px solid #4a4a6a;
                border-radius: 12px;
                padding: 20px 30px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(100, 100, 200, 0.2);
                min-width: 200px;
                max-width: 90%;
            }

            .maze-action-popup-buttons {
                display: flex;
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .maze-action-popup-buttons .menu_button,
            .maze-action-popup-buttons .maze-confirm-btn {
                padding: 12px 24px;
                font-size: 1.1em;
                font-weight: 600;
                border-radius: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                transition: all 0.15s ease;
                min-width: 150px;
            }

            .maze-action-popup-buttons .menu_button:hover,
            .maze-action-popup-buttons .maze-confirm-btn:hover {
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            }

            .maze-action-popup-buttons .maze-accept-btn {
                background: linear-gradient(145deg, #2ecc71, #27ae60) !important;
                border-color: #27ae60 !important;
            }

            .maze-action-popup-buttons .maze-slip-btn {
                background: linear-gradient(145deg, #9b59b6, #8e44ad) !important;
                border-color: #8e44ad !important;
            }

            .maze-cell.victory-glow {
                animation: victoryPulse 1s infinite;
            }

            @keyframes victoryPulse {
                0%, 100% { background: #27ae60; }
                50% { background: #2ecc71; }
            }

            /* =====================================================
               MOBILE / PORTRAIT LAYOUT (v1.2.0)
               ===================================================== */
            .layout-mobile .mazemaster-maze-container,
            #mazemaster_maze_modal.layout-mobile .mazemaster-maze-container {
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
                padding: 8px;
                gap: 6px;
                border-radius: 0;
                margin: 0;
            }

            .layout-mobile .mazemaster-maze-top {
                flex-direction: column;
                max-height: none;
                gap: 8px;
            }

            .layout-mobile .mazemaster-maze-hero {
                width: 100%;
                max-width: 100%;
                min-width: unset;
            }

            .layout-mobile .mazemaster-maze-info-col {
                width: 100%;
            }

            .layout-mobile .mazemaster-maze-buttons-col {
                flex-direction: row;
                width: 100%;
                justify-content: center;
            }

            .layout-mobile .mazemaster-maze-stats-bar {
                flex-wrap: wrap;
                gap: 6px;
                justify-content: center;
            }

            .layout-mobile .mazemaster-maze-inventory {
                flex-wrap: wrap;
                justify-content: center;
            }

            .layout-mobile .maze-action-buttons {
                flex-wrap: wrap;
                justify-content: center;
            }

            .layout-mobile .maze-dpad {
                position: fixed;
                bottom: 90px;
                right: 10px;
                z-index: 10000;
            }

            /* Make grid scrollable on mobile */
            .layout-mobile .maze-grid-area {
                overflow: auto;
                max-height: 50vh;
            }

            /* Larger touch targets on mobile */
            .layout-mobile .dpad-btn {
                min-width: 50px;
                min-height: 50px;
            }

            @media (max-width: 600px) {
                .mazemaster-maze-hero {
                    height: auto;
                    min-height: 80px;
                }

                .maze-message-log {
                    font-size: 0.85em;
                    max-height: 80px;
                }

                .stats-item {
                    font-size: 0.75em;
                    padding: 3px 6px;
                }

                .inventory-item {
                    padding: 4px 6px;
                    font-size: 0.85em;
                }
            }
        </style>
    `;

    document.body.appendChild(modal);
    console.log('[MazeMaster] Modal appended to body');

    // v2.0.3: Restore loading screen state if it was visible during early modal
    const loadingScreen = document.getElementById('maze_loading_screen');
    if (loadingScreen) {
        // Set background image
        const logoPath = `/scripts/extensions/third-party/SillyTavern-MazeMaster/images/maze-master-logo.jpg`;
        loadingScreen.style.backgroundImage = loadingBackgroundImage || `url("${logoPath}")`;

        // Restore loading screen content and visibility if it was visible
        if (loadingWasVisible && loadingContent) {
            loadingScreen.innerHTML = loadingContent;
            loadingScreen.classList.remove('hidden');
            // v2.0.3: Add loading-active class to container to hide game UI
            const container = loadingScreen.closest('.mazemaster-maze-container');
            if (container) {
                container.classList.add('loading-active');
            }
            console.log('[MazeMaster] Restored loading screen state');
        } else {
            // Loading was not visible (e.g., resuming a maze) - hide loading screen
            loadingScreen.classList.add('hidden');
        }
    }

    // Initialize the renderer and insert grid/canvas into container
    const renderer = RendererRegistry.getRenderer();
    console.log('[MazeMaster] Renderer type:', renderer?.constructor?.name || 'unknown');

    const gridContainer = document.getElementById('maze_grid_container');
    console.log('[MazeMaster] Grid container found:', !!gridContainer);

    if (gridContainer) {
        // Insert renderer-specific grid HTML
        gridContainer.innerHTML = renderer.getGridHTML(currentMaze.size);
        console.log('[MazeMaster] Grid HTML inserted');

        // Add player overlay for CSS grid renderer (canvas renderers draw player on canvas)
        const overlayHTML = renderer.getPlayerOverlayHTML(cellSize);
        if (overlayHTML) {
            gridContainer.insertAdjacentHTML('beforeend', overlayHTML);
        }
        // Initialize renderer (gets canvas context for canvas-based renderers)
        renderer.init(gridContainer, currentMaze);
        console.log('[MazeMaster] Renderer initialized');
    }

    // Apply layout mode (responsive)
    applyLayoutMode();
    console.log('[MazeMaster] showMazeModal() complete');

    // Add D-Pad control handlers
    modal.querySelectorAll('.dpad-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const dir = btn.dataset.dir;
            if (dir === 'up') tryMazeMove(0, -1);
            else if (dir === 'down') tryMazeMove(0, 1);
            else if (dir === 'left') tryMazeMove(-1, 0);
            else if (dir === 'right') tryMazeMove(1, 0);
            else if (dir === 'floor-up') tryFloorChange('up');
            else if (dir === 'floor-down') tryFloorChange('down');
        });
        // Touch support for mobile
        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            btn.click();
        });
    });

    // Initialize D-Pad drag functionality
    initDpadDrag();

    // Rest button handler
    const restBtn = document.getElementById('maze_rest_btn');
    if (restBtn) {
        restBtn.addEventListener('click', () => handleRestAction());
        restBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleRestAction();
        });
    }

    // Initialize rest button state
    updateRestButton();

    // Initialize pinch-zoom and pan/drag for the map
    initMapPanZoom();

    // v1.6.0: Initialize minimap
    const minimapToggle = document.getElementById('mazemaster_minimap_toggle');
    if (minimapToggle) {
        minimapToggle.addEventListener('click', () => toggleMinimap());
    }
    renderMinimap();

    // Inventory info button toggle (v1.3.0 redesign)
    const inventoryWrapper = document.getElementById('maze_inventory_wrapper');
    const inventoryBtn = document.getElementById('maze_inventory_btn');
    const inventoryMenu = document.getElementById('maze_inventory_menu');

    if (inventoryBtn && inventoryMenu) {
        inventoryBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isOpen = !inventoryMenu.classList.contains('hidden');
            if (isOpen) {
                inventoryMenu.classList.add('hidden');
                inventoryWrapper?.classList.remove('open');
            } else {
                inventoryMenu.classList.remove('hidden');
                inventoryWrapper?.classList.add('open');
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!inventoryWrapper?.contains(e.target)) {
                inventoryMenu.classList.add('hidden');
                inventoryWrapper?.classList.remove('open');
            }
        });
    }

    // Inventory menu item click handlers
    const menuItems = modal.querySelectorAll('.inventory-menu-item[data-usable="true"]');
    menuItems.forEach(item => {
        item.addEventListener('click', async (e) => {
            e.stopPropagation();
            const itemType = item.dataset.item;
            const hpItem = item.dataset.hpItem;

            if (hpItem) {
                await useHPItem(hpItem);
            } else if (itemType === 'portalStone') {
                await usePortalStone();
            } else if (itemType === 'mapFragment') {
                await useMapFragment();
            } else if (itemType === 'voidWalk') {
                activateVoidWalk();
            } else if (item.dataset.visItem) {
                await useVisibilityItem(item.dataset.visItem);
            }

            // Close menu after use
            inventoryMenu?.classList.add('hidden');
            inventoryWrapper?.classList.remove('open');
        });
    });

    // v1.5.0: Equipment UI handlers
    const equipToggleBtn = document.getElementById('maze_equip_toggle');
    const equipInventory = document.getElementById('maze_equipment_inventory');

    // Toggle equipment inventory dropdown
    if (equipToggleBtn && equipInventory) {
        equipToggleBtn.addEventListener('click', () => {
            const isVisible = equipInventory.style.display !== 'none';
            equipInventory.style.display = isVisible ? 'none' : 'block';
            equipToggleBtn.innerHTML = isVisible
                ? '<i class="fa-solid fa-backpack"></i> Backpack'
                : '<i class="fa-solid fa-times"></i> Close';
        });
    }

    // Equipment slot click handler (opens modal for stats/repair/unequip)
    const equipSlots = modal.querySelectorAll('.equip-slot');
    console.log('[MazeMaster] Found', equipSlots.length, 'equipment slots to attach click handlers');
    equipSlots.forEach(slot => {
        slot.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent event bubbling
            const slotType = slot.dataset.slot;
            console.log('[MazeMaster] Equipment slot clicked:', slotType, 'Has item:', !!currentMaze.equipment?.[slotType]);
            if (currentMaze.equipment?.[slotType]) {
                showEquipmentModal(slotType);
            }
        });
    });

    // Equipment inventory item click handler (equip)
    if (equipInventory) {
        equipInventory.addEventListener('click', async (e) => {
            const equipBtn = e.target.closest('.equip-btn');
            if (equipBtn) {
                const itemId = equipBtn.dataset.itemId;
                if (itemId) {
                    await equipItem(itemId);
                }
            }
        });
    }

    // Apply theme colors
    applyThemeColors(currentMaze.profile);

    // Close button handler
    const closeBtn = document.getElementById('maze_close_btn');
    if (closeBtn) {
        closeBtn.addEventListener('click', closeMaze);
        closeBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            closeMaze();
        });
    }

    // Power button handler - shows custom save dialog with Yes/No/Cancel
    const powerHandler = () => {
        showSaveDialog();
    };
    document.getElementById('maze_power_btn')?.addEventListener('click', powerHandler);

    // Session Memory button handler (v1.4.6)
    const memoryBtn = document.getElementById('maze_memory_btn');
    const memoryPanel = document.getElementById('maze_memory_panel');
    const memoryBackdrop = document.getElementById('maze_memory_backdrop');
    const memoryTextarea = document.getElementById('maze_memory_textarea');
    const memorySaveBtn = document.getElementById('maze_memory_save');
    const memoryCloseBtn = document.getElementById('maze_memory_close');

    const openMemoryPanel = () => {
        if (memoryPanel && memoryBackdrop && memoryTextarea) {
            // Load current notes into textarea
            memoryTextarea.value = currentMaze.sessionNotes || '';
            memoryPanel.style.display = 'flex';
            memoryBackdrop.style.display = 'block';
            memoryBtn?.classList.add('active');
            memoryTextarea.focus();
        }
    };

    const closeMemoryPanel = (save = false) => {
        if (save && memoryTextarea) {
            currentMaze.sessionNotes = memoryTextarea.value;
            // Auto-save on close
            saveMazeProgress();
            console.log('[MazeMaster] Session notes saved');
        }
        if (memoryPanel) memoryPanel.style.display = 'none';
        if (memoryBackdrop) memoryBackdrop.style.display = 'none';
        memoryBtn?.classList.remove('active');
    };

    memoryBtn?.addEventListener('click', openMemoryPanel);
    memoryCloseBtn?.addEventListener('click', () => closeMemoryPanel(true)); // Save on close
    memoryBackdrop?.addEventListener('click', () => closeMemoryPanel(true)); // Save on backdrop click
    memorySaveBtn?.addEventListener('click', () => {
        if (memoryTextarea) {
            currentMaze.sessionNotes = memoryTextarea.value;
            saveMazeProgress();
            console.log('[MazeMaster] Session notes saved');
            // Flash the button to indicate save
            memorySaveBtn.textContent = 'Saved!';
            setTimeout(() => {
                memorySaveBtn.textContent = 'Save Notes';
            }, 1500);
        }
    });

    // Player Stats button handler (v1.5.0)
    const playerBtn = document.getElementById('maze_player_btn');
    const playerPanel = document.getElementById('maze_player_panel');
    const playerBackdrop = document.getElementById('maze_player_backdrop');
    const playerCloseBtn = document.getElementById('maze_player_close');
    console.log('[MazeMaster] Player button elements at attach time:', {
        playerBtn: !!playerBtn,
        playerPanel: !!playerPanel,
        playerBackdrop: !!playerBackdrop,
        playerCloseBtn: !!playerCloseBtn
    });

    playerBtn?.addEventListener('click', () => {
        console.log('[MazeMaster] Player button clicked!');
        togglePlayerPanel();
    });
    playerCloseBtn?.addEventListener('click', () => togglePlayerPanel());
    playerBackdrop?.addEventListener('click', () => togglePlayerPanel());

    // Skills button handler (v1.5.0)
    const skillsBtn = document.getElementById('maze_skills_btn');
    const skillPanel = document.getElementById('maze_skill_panel');
    const skillBackdrop = document.getElementById('maze_skill_backdrop');
    const skillCloseBtn = document.getElementById('maze_skill_close');
    console.log('[MazeMaster] Skills button elements at attach time:', {
        skillsBtn: !!skillsBtn,
        skillPanel: !!skillPanel,
        skillBackdrop: !!skillBackdrop,
        skillCloseBtn: !!skillCloseBtn
    });

    skillsBtn?.addEventListener('click', () => {
        console.log('[MazeMaster] Skills button clicked!');
        toggleSkillTreePanel();
    });
    skillCloseBtn?.addEventListener('click', () => toggleSkillTreePanel());
    skillBackdrop?.addEventListener('click', () => toggleSkillTreePanel());

    // Quest button handler (v1.5.0)
    const questBtn = document.getElementById('maze_quest_btn');
    const questPanel = document.getElementById('maze_quest_panel');
    const questBackdrop = document.getElementById('maze_quest_backdrop');
    const questCloseBtn = document.getElementById('maze_quest_close');

    questBtn?.addEventListener('click', () => toggleQuestPanel());
    questCloseBtn?.addEventListener('click', () => toggleQuestPanel());
    questBackdrop?.addEventListener('click', () => toggleQuestPanel());

    // Quest tab switching
    document.querySelectorAll('.quest-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
            document.querySelectorAll('.quest-tab').forEach(t => t.classList.remove('active'));
            e.target.classList.add('active');
            const tabName = e.target.dataset.questTab;
            updateQuestDisplay(tabName);
        });
    });

    // Quest actions via delegated click
    document.getElementById('quest_list_content')?.addEventListener('click', (e) => {
        const acceptBtn = e.target.closest('.quest-accept-btn');
        const abandonBtn = e.target.closest('.quest-abandon-btn');

        if (acceptBtn) {
            const questId = acceptBtn.dataset.quest;
            acceptQuest(questId);
            updateQuestDisplay('active');
        }

        if (abandonBtn) {
            const questId = abandonBtn.dataset.quest;
            abandonQuest(questId);
            updateQuestDisplay('active');
        }
    });

    // Skill learning via delegated click
    document.getElementById('skill_tree_content')?.addEventListener('click', async (e) => {
        const learnBtn = e.target.closest('.skill-learn-btn');
        if (learnBtn) {
            const skillId = learnBtn.dataset.skill;
            await learnSkill(skillId);
        }
    });

    // Ability bar click handler
    document.getElementById('ability_bar')?.addEventListener('click', async (e) => {
        const slot = e.target.closest('.ability-slot');
        if (slot && slot.classList.contains('ready')) {
            const skillId = slot.dataset.skill;
            if (skillId) {
                // v1.5.0: Use combat skill execution when in turn-based combat
                if (currentTurnBased?.isOpen && currentTurnBased.currentTurn === 'player') {
                    const result = await executePlayerCombatSkill(skillId);
                    // If skill didn't end combat, switch to enemy turn
                    if (result.success && !result.victory && !result.escaped) {
                        currentTurnBased.currentTurn = 'enemy';
                        updateTurnBasedDisplay();
                        setTimeout(() => processEnemyTurn(), 1000);
                    }
                } else {
                    // Out of combat - just use the skill normally
                    await useSkill(skillId, { inCombat: false });
                }
            }
        }
    });
}

/**
 * Show custom save dialog with Yes/No/Cancel buttons
 */
function showSaveDialog() {
    // Remove any existing dialog
    const existingDialog = document.getElementById('maze_save_dialog');
    if (existingDialog) existingDialog.remove();

    const dialog = document.createElement('div');
    dialog.id = 'maze_save_dialog';
    dialog.innerHTML = `
        <div class="maze-save-dialog-backdrop"></div>
        <div class="maze-save-dialog-content">
            <div class="maze-save-dialog-title">Do you wish to save?</div>
            <div class="maze-save-dialog-buttons">
                <button id="maze_save_yes" class="maze-save-btn maze-save-yes">Yes</button>
                <button id="maze_save_no" class="maze-save-btn maze-save-no">No</button>
                <button id="maze_save_cancel" class="maze-save-btn maze-save-cancel">Cancel</button>
            </div>
        </div>
    `;

    const modal = document.getElementById('mazemaster_maze_modal');
    if (modal) {
        modal.appendChild(dialog);
    } else {
        document.body.appendChild(dialog);
    }

    // Button handlers
    document.getElementById('maze_save_yes').addEventListener('click', () => {
        try {
            dialog.remove();
            saveMazeProgress();
            console.log('[MazeMaster] Save complete, closing maze modal');
            closeMaze();
            renderSavedGamesList();
        } catch (e) {
            console.error('[MazeMaster] Error in save/close:', e);
            closeMaze(); // Still try to close on error
        }
    });

    document.getElementById('maze_save_no').addEventListener('click', () => {
        dialog.remove();
        closeMaze();
    });

    document.getElementById('maze_save_cancel').addEventListener('click', () => {
        dialog.remove();
    });

    // Backdrop click = cancel
    dialog.querySelector('.maze-save-dialog-backdrop').addEventListener('click', () => {
        dialog.remove();
    });
}

function closeMaze() {
    console.log('[MazeMaster] closeMaze called');
    currentMaze.isOpen = false;
    document.removeEventListener('keydown', handleMazeKeydown, { capture: true });

    const modal = document.getElementById('mazemaster_maze_modal');
    if (modal) {
        console.log('[MazeMaster] Removing maze modal');
        modal.remove();
    } else {
        console.warn('[MazeMaster] Modal not found when trying to close');
    }
}

function renderMazeGrid() {
    // Delegate to the pluggable renderer system
    const renderer = RendererRegistry.getRenderer();
    renderer.render(currentMaze);
}

/**
 * Add an entry to the session notes (auto-populated adventure log)
 * @param {string} entry - The log entry text
 * @param {string} category - Optional category for the entry (encounter, item, story, etc.)
 */
function addSessionNote(entry, category = '') {
    if (!currentMaze || !entry) return;

    // Format timestamp as HH:MM
    const now = new Date();
    const time = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });

    // Format the entry with optional category prefix
    const prefix = category ? `[${category}] ` : '';
    const formattedEntry = `${time} - ${prefix}${entry}`;

    // Append to session notes
    if (currentMaze.sessionNotes) {
        currentMaze.sessionNotes += '\n' + formattedEntry;
    } else {
        currentMaze.sessionNotes = formattedEntry;
    }

    // Update textarea if panel is open
    const textarea = document.getElementById('maze_memory_textarea');
    if (textarea && document.getElementById('maze_memory_panel')?.style.display !== 'none') {
        textarea.value = currentMaze.sessionNotes;
        // Auto-scroll to bottom
        textarea.scrollTop = textarea.scrollHeight;
    }
}

/**
 * Add a message to the maze message log and render it
 * @param {string} speaker - Name of who's speaking
 * @param {string} message - The message text
 * @param {boolean} skipSave - If true, don't save to persistent log (for re-rendering)
 */
function addMazeMessage(speaker, message, skipSave = false, isPlayer = false, isCreatureChat = false) {
    if (!message) return;

    // Add to persistent log (unless we're just re-rendering)
    if (!skipSave) {
        currentMaze.messageLog.push({
            speaker,
            message,
            timestamp: Date.now(),
            isPlayer,        // v2.x: Player chat message
            isCreatureChat   // v2.x: Creature chat response
        });
    }

    // Render the message log
    renderMessageLog();
}

/**
 * Render the entire message log to the UI
 */
function renderMessageLog() {
    const logEl = document.getElementById('maze_message_log');
    if (!logEl) return;

    logEl.innerHTML = currentMaze.messageLog.map(entry => {
        // v2.0.2: Apply minion alias to speaker and message text
        const speaker = applyMinionAlias(entry.speaker);
        const message = applyMinionAlias(entry.message);
        // v2.x: Determine styling classes for chat messages
        const classes = ['maze-message-entry'];
        if (entry.isPlayer) classes.push('player-message');
        if (entry.isCreatureChat) classes.push('creature-chat');
        return `
        <div class="${classes.join(' ')}">
            <div class="maze-message-speaker">${escapeHtml(speaker)}</div>
            <div class="maze-message-text">${escapeHtml(message)}</div>
        </div>
    `;
    }).join('');

    // Auto-scroll to the latest message
    logEl.scrollTop = logEl.scrollHeight;
}

// ============================================================================
// IN-GAME CHAT FUNCTIONS (v2.x)
// ============================================================================

/**
 * Get default chat response when LLM is unavailable
 * @returns {string}
 */
function getDefaultChatResponse() {
    const responses = [
        '*watches you silently*',
        '*nods slowly*',
        '...',
        '*seems distracted*',
        '*mutters something incomprehensible*'
    ];
    return responses[Math.floor(Math.random() * responses.length)];
}

/**
 * Determine who should respond to chat based on current game state
 * @returns {{ name: string, role: string, description: string }}
 */
function getChatRespondent() {
    // If there's a current minion, they respond
    if (currentMaze.currentMinion?.name) {
        const minion = currentMaze.currentMinion;
        // Try to find full minion data for description
        const minionId = Object.keys(extensionSettings.minions || {}).find(
            id => extensionSettings.minions[id].name === minion.name
        );
        const fullMinion = minionId ? extensionSettings.minions[minionId] : null;

        return {
            name: minion.name,
            role: minion.role || 'a creature in the maze',
            description: fullMinion?.description || ''
        };
    }

    // Fallback to main minion from profile
    const mainMinionId = currentMaze.profile?.mainMinion;
    const mainMinion = mainMinionId ? extensionSettings.minions?.[mainMinionId] : null;

    if (mainMinion) {
        return {
            name: mainMinion.name,
            role: 'the maze master',
            description: mainMinion.description || ''
        };
    }

    // Ultimate fallback - narrator
    return {
        name: 'The Maze',
        role: 'Narrator',
        description: 'A mysterious voice that echoes through the corridors'
    };
}

/**
 * Check if chat is currently allowed
 * @returns {boolean}
 */
function canChat() {
    if (!currentMaze?.isOpen) return false;
    if (currentMaze.isVictory) return false;
    if (typeof currentTurnBased !== 'undefined' && currentTurnBased?.isOpen) return false;
    if (currentMaze.chatEnabled === false) return false;
    return true;
}

/**
 * Enable/disable chat input UI
 * @param {boolean} enabled
 */
function setChatInputEnabled(enabled) {
    const input = document.getElementById('maze_chat_input');
    const btn = document.getElementById('maze_chat_send');
    if (input) input.disabled = !enabled;
    if (btn) btn.disabled = !enabled;
}

/**
 * Show typing indicator in message log
 * @param {string} speakerName
 */
function showTypingIndicator(speakerName) {
    const logEl = document.getElementById('maze_message_log');
    if (!logEl) return;

    const typingDiv = document.createElement('div');
    typingDiv.id = 'maze_typing_indicator';
    typingDiv.className = 'maze-message-entry typing creature-chat';
    typingDiv.innerHTML = `
        <div class="maze-message-speaker">${escapeHtml(speakerName)}</div>
        <div class="maze-message-text"></div>
    `;
    logEl.appendChild(typingDiv);
    logEl.scrollTop = logEl.scrollHeight;
}

/**
 * Remove typing indicator from message log
 */
function removeTypingIndicator() {
    const indicator = document.getElementById('maze_typing_indicator');
    if (indicator) indicator.remove();
}

/**
 * Update chat input placeholder based on who would respond
 */
function updateChatPlaceholder() {
    const input = document.getElementById('maze_chat_input');
    if (!input) return;

    const respondent = getChatRespondent();
    const displayName = applyMinionAlias(respondent.name);
    input.placeholder = `Say something to ${displayName}...`;
}

/**
 * Generate a chat response from the current creature/NPC using LLM
 * @param {string} playerMessage - What the player said
 * @param {object} respondent - { name, role, description } of who's responding
 * @returns {Promise<string>} The generated response
 */
async function generateChatResponse(playerMessage, respondent) {
    // Check if LLM is available
    if (typeof generateQuietPrompt !== 'function') {
        console.log('[MazeMaster] generateQuietPrompt not available for chat');
        return getDefaultChatResponse();
    }

    if (extensionSettings.llmEnabled === false) {
        console.log('[MazeMaster] LLM disabled, using default chat response');
        return getDefaultChatResponse();
    }

    const playerName = getCurrentPersonaName();
    const profile = currentMaze.profile;
    const mainStory = profile?.storyConfig?.mainStory || '';
    const theme = profile?.theme || 'Fantasy';

    // Build chat history context (last 12 messages = ~6 exchanges)
    const recentChat = (currentMaze.chatHistory || []).slice(-12).map(entry =>
        `${entry.speaker}: "${entry.message}"`
    ).join('\n');

    // Get recent session notes for additional context
    const recentNotes = currentMaze.sessionNotes
        ? currentMaze.sessionNotes.slice(-300).split('\n').slice(-3).join('\n')
        : '';

    const prompt = `You are ${respondent.name}, ${respondent.role || 'a creature in a maze'}.
Theme: ${theme}
${mainStory ? `Story: ${mainStory}\n` : ''}${respondent.description ? `Your nature: ${respondent.description}\n` : ''}
${recentNotes ? `Recent events:\n${recentNotes}\n` : ''}
${recentChat ? `Recent conversation:\n${recentChat}\n` : ''}
The player ${playerName} says to you: "${playerMessage}"

Respond in character (2-4 sentences). Be atmospheric, immersive and stay in theme. You may be mysterious, helpful, threatening, or cryptic based on your nature. Engage with what the player said. Do not use quotation marks around your response.`;

    try {
        console.log('[MazeMaster] Generating chat response from:', respondent.name);
        showGeneratingIndicator(true);

        const maxTokens = currentMaze.profile?.llmMaxTokens || 250;
        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,
            max_length: maxTokens,
        });

        showGeneratingIndicator(false);

        if (response && response.trim()) {
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            console.log('[MazeMaster] Chat response:', cleaned);
            return cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] Chat LLM generation failed:', error);
        showGeneratingIndicator(false);
    }

    return getDefaultChatResponse();
}

/**
 * Send a player chat message and generate creature response
 * @param {string} playerMessage - The player's message text
 */
async function sendChatMessage(playerMessage) {
    if (!currentMaze?.isOpen || !playerMessage?.trim()) return;

    const trimmedMessage = playerMessage.trim();
    const playerName = getCurrentPersonaName();

    // Check if chat is currently allowed
    if (!canChat()) {
        if (typeof toastr !== 'undefined') {
            toastr.warning('Cannot chat right now');
        }
        return;
    }

    // Add player message to log with player styling
    addMazeMessage(playerName, trimmedMessage, false, true); // isPlayer = true

    // Add to chat history for context
    if (!currentMaze.chatHistory) currentMaze.chatHistory = [];
    currentMaze.chatHistory.push({
        speaker: playerName,
        message: trimmedMessage,
        timestamp: Date.now(),
        isPlayer: true
    });

    // Trim chat history to last 20 messages (10 exchanges)
    if (currentMaze.chatHistory.length > 20) {
        currentMaze.chatHistory = currentMaze.chatHistory.slice(-20);
    }

    // Log to session notes
    addSessionNote(`${playerName} said: "${trimmedMessage}"`, 'Chat');

    // Disable input while generating
    setChatInputEnabled(false);

    // Show typing indicator
    const respondent = getChatRespondent();
    const displayName = applyMinionAlias(respondent.name);
    showTypingIndicator(displayName);

    try {
        // Generate LLM response
        const response = await generateChatResponse(trimmedMessage, respondent);

        // Remove typing indicator and add real response
        removeTypingIndicator();

        if (response) {
            addMazeMessage(displayName, response, false, false, true); // isCreatureChat = true

            // Add to chat history
            currentMaze.chatHistory.push({
                speaker: respondent.name,
                message: response,
                timestamp: Date.now(),
                isPlayer: false
            });

            // Log response to session notes
            addSessionNote(`${displayName} replied: "${response}"`, 'Chat');
        }
    } catch (error) {
        console.error('[MazeMaster] Chat response failed:', error);
        removeTypingIndicator();
        addMazeMessage(displayName, '*remains silent*', false, false, true);
    } finally {
        setChatInputEnabled(true);
        saveMazeProgress();
    }
}

/**
 * Generate an impersonation message as the player using LLM
 * Fills the input box but doesn't auto-send
 */
async function generateImpersonation() {
    if (!currentMaze?.isOpen) return;
    if (!canChat()) return;

    const input = document.getElementById('maze_chat_input');
    const impersonateBtn = document.getElementById('maze_chat_impersonate');
    if (!input) return;

    const seedText = input.value.trim();
    const playerName = getCurrentPersonaName();
    const profile = currentMaze.profile;
    const theme = profile?.theme || 'Fantasy';
    const mainStory = profile?.storyConfig?.mainStory || '';

    // Check if LLM is available
    if (typeof generateQuietPrompt !== 'function' || extensionSettings.llmEnabled === false) {
        if (typeof toastr !== 'undefined') toastr.warning('LLM not available');
        return;
    }

    // Build context
    const respondent = getChatRespondent();
    const recentChat = (currentMaze.chatHistory || []).slice(-8).map(entry =>
        `${entry.speaker}: "${entry.message}"`
    ).join('\n');

    const recentNotes = currentMaze.sessionNotes
        ? currentMaze.sessionNotes.slice(-300).split('\n').slice(-3).join('\n')
        : '';

    const prompt = `You are writing dialogue for ${playerName}, the player character in a ${theme} dungeon crawler.
${mainStory ? `Story: ${mainStory}\n` : ''}
${recentNotes ? `Recent events:\n${recentNotes}\n` : ''}
${recentChat ? `Recent conversation:\n${recentChat}\n` : ''}
The player is facing ${respondent.name} (${respondent.role || 'a creature'}).
${seedText ? `The player wants to say something like: "${seedText}"\n` : ''}
Write a short in-character message (1-2 sentences) as ${playerName} would say it. Be natural and fitting for the situation. Do not use quotation marks around the response.`;

    try {
        // Show generating state
        if (impersonateBtn) impersonateBtn.classList.add('generating');
        setChatInputEnabled(false);
        input.placeholder = 'Generating...';

        const maxTokens = currentMaze.profile?.llmMaxTokens || 250;
        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,
            max_length: Math.min(maxTokens, 150),
        });

        if (response && response.trim()) {
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            input.value = cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] Impersonation failed:', error);
    } finally {
        if (impersonateBtn) impersonateBtn.classList.remove('generating');
        setChatInputEnabled(true);
        updateChatPlaceholder();
        input.focus();
    }
}

/**
 * Generate a response from the creature/narrator without player input
 */
async function generateNarratorResponse() {
    if (!currentMaze?.isOpen) return;
    if (!canChat()) return;

    const responseBtn = document.getElementById('maze_chat_response');

    // Check if LLM is available
    if (typeof generateQuietPrompt !== 'function' || extensionSettings.llmEnabled === false) {
        if (typeof toastr !== 'undefined') toastr.warning('LLM not available');
        return;
    }

    const playerName = getCurrentPersonaName();
    const profile = currentMaze.profile;
    const theme = profile?.theme || 'Fantasy';
    const mainStory = profile?.storyConfig?.mainStory || '';

    // Get respondent
    const respondent = getChatRespondent();
    const displayName = applyMinionAlias(respondent.name);

    // Build context
    const recentChat = (currentMaze.chatHistory || []).slice(-8).map(entry =>
        `${entry.speaker}: "${entry.message}"`
    ).join('\n');

    const recentNotes = currentMaze.sessionNotes
        ? currentMaze.sessionNotes.slice(-300).split('\n').slice(-3).join('\n')
        : '';

    const prompt = `You are ${respondent.name}, ${respondent.role || 'a creature in a maze'}.
Theme: ${theme}
${mainStory ? `Story: ${mainStory}\n` : ''}${respondent.description ? `Your nature: ${respondent.description}\n` : ''}
${recentNotes ? `Recent events:\n${recentNotes}\n` : ''}
${recentChat ? `Recent conversation:\n${recentChat}\n` : ''}
The player ${playerName} is present. Speak unprompted - make an observation, taunt, hint, or atmospheric comment. Be in character (2-4 sentences). Do not use quotation marks around your response.`;

    try {
        // Show generating state
        if (responseBtn) responseBtn.classList.add('generating');
        setChatInputEnabled(false);
        showTypingIndicator(displayName);

        const maxTokens = currentMaze.profile?.llmMaxTokens || 250;
        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,
            max_length: maxTokens,
        });

        removeTypingIndicator();

        if (response && response.trim()) {
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');

            addMazeMessage(displayName, cleaned, false, false, true);

            // Add to chat history
            currentMaze.chatHistory = currentMaze.chatHistory || [];
            currentMaze.chatHistory.push({
                speaker: respondent.name,
                message: cleaned,
                timestamp: Date.now(),
                isPlayer: false
            });

            // Log to session notes
            addSessionNote(`${displayName} said: "${cleaned}"`, 'Chat');
            saveMazeProgress();
        }
    } catch (error) {
        console.error('[MazeMaster] Narrator response failed:', error);
        removeTypingIndicator();
    } finally {
        if (responseBtn) responseBtn.classList.remove('generating');
        setChatInputEnabled(true);
    }
}

/**
 * Initialize chat input event handlers
 * Call this after maze modal is rendered
 */
function initChatInput() {
    const input = document.getElementById('maze_chat_input');
    const sendBtn = document.getElementById('maze_chat_send');
    const impersonateBtn = document.getElementById('maze_chat_impersonate');
    const responseBtn = document.getElementById('maze_chat_response');

    if (!input || !sendBtn) return;

    // Handle Enter key
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const message = input.value.trim();
            if (message) {
                sendChatMessage(message);
                input.value = '';
            }
        }
    });

    // Handle send button click
    sendBtn.addEventListener('click', () => {
        const message = input.value.trim();
        if (message) {
            sendChatMessage(message);
            input.value = '';
        }
    });

    // Handle impersonate button click
    if (impersonateBtn) {
        impersonateBtn.addEventListener('click', () => {
            generateImpersonation();
        });
    }

    // Handle response button click
    if (responseBtn) {
        responseBtn.addEventListener('click', () => {
            generateNarratorResponse();
        });
    }

    // Update placeholder based on current respondent
    updateChatPlaceholder();
}

// ============================================================================
// END IN-GAME CHAT FUNCTIONS
// ============================================================================

function updateMazeHero() {
    const { currentMinion, isVictory, profile, messageLog } = currentMaze;

    const imgEl = document.getElementById('maze_minion_img');
    const nameEl = document.getElementById('maze_minion_name');
    const roleEl = document.getElementById('maze_minion_role');

    if (isVictory) {
        // Victory state
        if (profile.winImage && imgEl) {
            imgEl.src = getExtensionImagePath(profile.winImage);
            imgEl.style.display = '';
        }
        if (nameEl) nameEl.textContent = 'Victory!';
        if (roleEl) roleEl.textContent = '';

        // Add victory message to log
        const victoryMessage = profile.winMessage || 'You escaped the maze!';
        const lastEntry = messageLog[messageLog.length - 1];
        if (!lastEntry || lastEntry.message !== victoryMessage) {
            addMazeMessage('Victory!', victoryMessage);
        }
    } else if (currentMinion) {
        // Normal minion display
        if (currentMinion.imagePath && imgEl) {
            imgEl.src = getExtensionImagePath(currentMinion.imagePath);
            imgEl.style.display = 'block';
        } else if (imgEl) {
            imgEl.style.display = 'none';
        }
        // v2.0.2: Apply minion alias to name display
        const displayName = applyMinionAlias(currentMinion.name || '');
        if (nameEl) nameEl.textContent = displayName;
        if (roleEl) roleEl.textContent = currentMinion.role || '';

        // Add message to log if it's new (avoid duplicating the same message)
        if (currentMinion.message) {
            const lastEntry = messageLog[messageLog.length - 1];
            if (!lastEntry || lastEntry.message !== currentMinion.message) {
                addMazeMessage(displayName || 'Unknown', currentMinion.message);
            }
        }
    }

    // Render the message log (in case we're restoring state)
    renderMessageLog();

    // v2.x: Update chat placeholder based on current minion
    updateChatPlaceholder();
}

/**
 * Show or hide the LLM generating indicator
 * Also updates the player gem indicator color (orange when generating)
 */
function showGeneratingIndicator(show) {
    const indicator = document.getElementById('maze_generating_indicator');
    if (indicator) {
        indicator.classList.toggle('active', show);
    }

    // v1.4.8: Update global state for player gem indicator
    isLLMGenerating = show;

    // Trigger re-render to update player gem color
    if (currentMaze?.isOpen) {
        renderMazeGrid();
    }
}

/**
 * v2.0.2: Loading screen control functions
 * v2.1.0: Added avatarGenEnabled parameter for avatar generation status
 */
function showLoadingScreen(llmEnabled = false, avatarGenEnabled = false) {
    const loadingScreen = document.getElementById('maze_loading_screen');
    if (!loadingScreen) return;

    loadingScreen.classList.remove('hidden');

    // Show/hide LLM-specific items based on whether LLM enhancement is enabled
    const minionItem = document.getElementById('loading_item_minion');
    const storyItem = document.getElementById('loading_item_story');
    const roomItem = document.getElementById('loading_item_room');
    const avatarItem = document.getElementById('loading_item_avatar');

    if (minionItem) {
        minionItem.style.display = '';
        minionItem.querySelector('.loading-text').textContent = llmEnabled
            ? 'LLM Enhancing...Main Minion Name'
            : 'Initializing Maze...';
        minionItem.className = 'maze-loading-item active';
        minionItem.querySelector('.loading-icon').innerHTML = '<i class="fa-solid fa-spinner"></i>';
    }

    if (storyItem) {
        storyItem.style.display = llmEnabled ? '' : 'none';
        storyItem.className = 'maze-loading-item';
        storyItem.querySelector('.loading-icon').innerHTML = '<i class="fa-solid fa-circle"></i>';
    }

    if (roomItem) {
        roomItem.style.display = llmEnabled ? '' : 'none';
        roomItem.className = 'maze-loading-item';
        roomItem.querySelector('.loading-icon').innerHTML = '<i class="fa-solid fa-circle"></i>';
    }

    // v2.1.0: Avatar generation status item
    if (avatarItem) {
        avatarItem.style.display = avatarGenEnabled ? '' : 'none';
        avatarItem.className = 'maze-loading-item';
        avatarItem.querySelector('.loading-icon').innerHTML = '<i class="fa-solid fa-circle"></i>';
        avatarItem.querySelector('.loading-text').textContent = 'Generating Avatar...';
    }
}

function updateLoadingStatus(step, status = 'active') {
    const itemId = {
        // v2.0.3: Generation phase items
        'profile': 'loading_item_profile',
        'grid': 'loading_item_grid',
        'tiles': 'loading_item_tiles',
        'floors': 'loading_item_floors',
        'systems': 'loading_item_systems',
        // LLM phase items
        'minion': 'loading_item_minion',
        'story': 'loading_item_story',
        'room': 'loading_item_room',
        'avatar': 'loading_item_avatar', // v2.1.0
    }[step];

    const item = document.getElementById(itemId);
    if (!item) return;

    // v2.0.3: Ensure item is visible when updating status
    if (status === 'active') {
        item.style.display = '';
        item.className = 'maze-loading-item active';
        item.querySelector('.loading-icon').innerHTML = '<i class="fa-solid fa-spinner"></i>';
    } else if (status === 'complete') {
        item.className = 'maze-loading-item complete';
        item.querySelector('.loading-icon').innerHTML = '<i class="fa-solid fa-check"></i>';
    } else if (status === 'skip') {
        item.className = 'maze-loading-item complete';
        item.querySelector('.loading-icon').innerHTML = '<i class="fa-solid fa-forward"></i>';
        item.querySelector('.loading-text').textContent += ' (Skipped)';
    }
}

function hideLoadingScreen() {
    const loadingScreen = document.getElementById('maze_loading_screen');
    if (!loadingScreen) return;

    // v2.0.3: Remove loading-active class from container to show game UI
    const container = loadingScreen.closest('.mazemaster-maze-container');
    if (container) {
        container.classList.remove('loading-active');
    }

    // Add hidden class which triggers fade-out transition
    loadingScreen.classList.add('hidden');

    // Remove from DOM after transition completes
    setTimeout(() => {
        if (loadingScreen.parentNode) {
            loadingScreen.remove();
        }
    }, 500);

    // v2.0.3: Center camera on player after loading screen fades
    setTimeout(() => {
        if (typeof window.mazeCenterOnPlayer === 'function') {
            window.mazeCenterOnPlayer(false); // Instant center, no animation
        }
    }, 100);

    // v2.0.5: Check for any pending level-ups after maze loads
    setTimeout(async () => {
        const result = await checkForLevelUp();
        if (result.levelsGained > 0) {
            console.log(`[MazeMaster] Processed ${result.levelsGained} pending level-up(s) after maze load`);
        }
    }, 600);
}

/**
 * v2.0.3: Allow UI to repaint between synchronous generation steps
 * Uses requestAnimationFrame for smoother updates
 */
function tick() {
    return new Promise(resolve => requestAnimationFrame(resolve));
}

/**
 * v2.0.3: Add a log line to the loading console
 * @param {string} message - The message to log (without [MazeMaster] prefix)
 * @param {string} status - 'current', 'success', or '' for default
 */
function addLoadingLog(message, status = 'current') {
    const console = document.getElementById('maze_loading_console');
    if (!console) return;

    // Remove 'current' class from previous lines
    const previousCurrent = console.querySelectorAll('.log-line.current');
    previousCurrent.forEach(el => el.classList.remove('current'));

    // Add new line
    const line = document.createElement('div');
    line.className = `log-line ${status}`;
    line.textContent = message;
    console.appendChild(line);

    // Scroll to bottom
    console.scrollTop = console.scrollHeight;
}

/**
 * v2.0.3: Update loading percentage display
 * @param {number} percent - Percentage (0-100)
 */
function updateLoadingPercent(percent) {
    const percentEl = document.getElementById('maze_loading_percent');
    if (percentEl) {
        percentEl.textContent = `${Math.round(percent)}%`;
    }
}

/**
 * v2.0.3: Update loading item text dynamically
 * @param {string} step - The step identifier
 * @param {string} text - The new text to display
 */
function updateLoadingText(step, text) {
    const itemId = {
        'profile': 'loading_item_profile',
        'grid': 'loading_item_grid',
        'tiles': 'loading_item_tiles',
        'floors': 'loading_item_floors',
        'systems': 'loading_item_systems',
        'minion': 'loading_item_minion',
        'story': 'loading_item_story',
        'room': 'loading_item_room',
        'avatar': 'loading_item_avatar',
    }[step];

    const item = document.getElementById(itemId);
    if (!item) return;

    const textEl = item.querySelector('.loading-text');
    if (textEl) textEl.textContent = text;
}

/**
 * Update the room info box with current cell information
 */
function updateRoomInfoBox() {
    if (!currentMaze.isOpen) return;

    const { playerX, playerY, grid } = currentMaze;
    const cell = grid[playerY]?.[playerX];
    if (!cell) return;

    // Update name & description
    const nameEl = document.getElementById('room_info_name');
    const descEl = document.getElementById('room_info_desc');
    if (nameEl) nameEl.textContent = cell.roomInfo?.name || 'Unknown Room';

    // v1.4.8: Use enhanced description if available, otherwise fall back to base
    const floor = currentMaze.currentFloor || 0;
    const roomKey = `${floor}:${playerX},${playerY}`;
    const enhancedDesc = currentMaze.enhancedRooms?.[roomKey] || cell.roomInfo?.enhancedDescription;
    let description = enhancedDesc || cell.roomInfo?.description || '...';

    // v1.4.1: Add secret passage hints based on hint level
    if (cell.secretPassage && !cell.secretPassage.revealed) {
        const hintLevel = cell.secretPassage.hintLevel || 0;
        const direction = cell.secretPassage.direction;
        const dirName = direction === 'top' ? 'north' : direction === 'bottom' ? 'south' :
                        direction === 'left' ? 'west' : 'east';

        if (hintLevel >= 3) {
            description += ` <span style="color: #ffcc00;"><i class="fa-solid fa-eye"></i> A hidden passage is clearly visible to the ${dirName}!</span>`;
        } else if (hintLevel >= 2) {
            description += ` <span style="color: #aaaaaa;"><i class="fa-solid fa-question"></i> The ${dirName} wall has suspicious cracks...</span>`;
        } else if (hintLevel >= 1) {
            description += ` <span style="color: #666666;"><i class="fa-solid fa-wind"></i> A faint draft from the ${dirName}...</span>`;
        }
    }

    if (descEl) descEl.innerHTML = description;

    // Update exits based on walls - show direction and room name
    const exitsEl = document.getElementById('room_info_exits');
    if (exitsEl) {
        const exits = [];
        const size = currentMaze.size;

        // North (top wall = y-1)
        if (!cell.walls.top && playerY > 0) {
            const northCell = grid[playerY - 1]?.[playerX];
            const roomName = northCell?.roomInfo?.name || 'Unknown';
            exits.push(`North → ${roomName}`);
        }
        // East (right wall = x+1)
        if (!cell.walls.right && playerX < size - 1) {
            const eastCell = grid[playerY]?.[playerX + 1];
            const roomName = eastCell?.roomInfo?.name || 'Unknown';
            exits.push(`East → ${roomName}`);
        }
        // South (bottom wall = y+1)
        if (!cell.walls.bottom && playerY < size - 1) {
            const southCell = grid[playerY + 1]?.[playerX];
            const roomName = southCell?.roomInfo?.name || 'Unknown';
            exits.push(`South → ${roomName}`);
        }
        // West (left wall = x-1)
        if (!cell.walls.left && playerX > 0) {
            const westCell = grid[playerY]?.[playerX - 1];
            const roomName = westCell?.roomInfo?.name || 'Unknown';
            exits.push(`West → ${roomName}`);
        }

        // Up/Down staircases
        if (cell.staircase) {
            const targetFloor = cell.staircase.targetFloor;
            const targetX = cell.staircase.targetX;
            const targetY = cell.staircase.targetY;
            const targetGrid = currentMaze.floorsData?.[targetFloor]?.grid || currentMaze.floors?.[targetFloor];
            const targetCell = targetGrid?.[targetY]?.[targetX];
            const targetRoomName = targetCell?.roomInfo?.name || `Floor ${targetFloor + 1}`;

            if (cell.staircase.direction === 'up') {
                exits.push(`<i class="fa-solid fa-stairs"></i> Up → ${targetRoomName}`);
            } else if (cell.staircase.direction === 'down') {
                exits.push(`<i class="fa-solid fa-stairs"></i> Down → ${targetRoomName}`);
            }
        }

        exitsEl.innerHTML = exits.length ? exits.join('<br>') : 'None';
    }

    // Update occupants (active minions)
    const occupantsEl = document.getElementById('room_info_occupants');
    if (occupantsEl) {
        const occupants = [];
        if (cell.minion && !cell.minion.defeated && !cell.minion.triggered) {
            const minion = getMinion(cell.minion.minionId);
            occupants.push(minion?.name || 'Unknown Entity');
        }
        if (cell.chest && !cell.chest.opened) {
            occupants.push(cell.chest.type === 'locked' ? 'Locked Chest' : 'Chest');
        }
        if (cell.trap && !cell.trap.triggered) {
            occupants.push('Something feels off...');
        }
        occupantsEl.textContent = occupants.length ? occupants.join(', ') : 'None';
    }

    // Update defeated list
    const defeatedEl = document.getElementById('room_info_defeated');
    if (defeatedEl) {
        const defeated = [];
        if (cell.minion?.defeated || cell.minion?.triggered) {
            const minion = getMinion(cell.minion.minionId);
            defeated.push(minion?.name || 'Unknown');
        }
        if (cell.chest?.opened) {
            defeated.push('Opened Chest');
        }
        if (cell.trap?.triggered) {
            defeated.push('Triggered Trap');
        }
        defeatedEl.textContent = defeated.length ? defeated.join(', ') : 'None';
    }
}

function handleMazeKeydown(e) {
    if (!currentMaze.isOpen || currentMaze.isVictory) return;

    // v1.2.0: SHIFT+Arrow for floor changes
    if (e.shiftKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
        const floorDir = e.key === 'ArrowUp' ? 'up' : 'down';
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        tryFloorChange(floorDir);
        return;
    }

    let dx = 0, dy = 0;
    if (e.key === 'ArrowUp') dy = -1;
    else if (e.key === 'ArrowDown') dy = 1;
    else if (e.key === 'ArrowLeft') dx = -1;
    else if (e.key === 'ArrowRight') dx = 1;
    else return;

    // Block event from reaching ST's swipe handlers
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    tryMazeMove(dx, dy);
}

async function tryMazeMove(dx, dy) {
    if (!currentMaze.isOpen || currentMaze.isVictory) return;

    // Don't allow movement if paused (encounter in progress)
    if (currentMaze.isPaused) return;

    // v1.4.9: Block movement while LLM is generating room description
    if (isLLMGenerating) return;

    const { playerX, playerY, grid, size } = currentMaze;
    const newX = playerX + dx;
    const newY = playerY + dy;

    // Check bounds
    if (newX < 0 || newX >= size || newY < 0 || newY >= size) return;

    // Check walls (with Void Walk support)
    const currentCell = grid[playerY][playerX];
    let blockedByWall = false;
    if (dx === 1 && currentCell.walls.right) blockedByWall = true;
    if (dx === -1 && currentCell.walls.left) blockedByWall = true;
    if (dy === 1 && currentCell.walls.bottom) blockedByWall = true;
    if (dy === -1 && currentCell.walls.top) blockedByWall = true;

    // v1.6.0: Check for locked doors in movement direction
    if (!blockedByWall) {
        const moveDirection = dx === 1 ? 'east' : dx === -1 ? 'west' : dy === 1 ? 'south' : 'north';
        const blockingDoor = checkDoorBlocking(playerX, playerY, moveDirection);
        if (blockingDoor) {
            // Attempt to unlock the door
            const opened = await handleLockedDoorInteraction(blockingDoor);
            if (!opened) {
                return; // Door remains locked, block movement
            }
            // Door opened, continue with movement
        }
    }

    // v1.2.0: Void Walk allows phasing through one wall
    if (blockedByWall) {
        if (currentMaze.voidWalkActive) {
            // Phase through the wall, consume the Void Walk
            await consumeVoidWalk();
            blockedByWall = false;
        } else {
            // v1.4.0: Try secret discovery when bumping a wall
            const direction = dx === 1 ? 'right' : dx === -1 ? 'left' : dy === 1 ? 'bottom' : 'top';
            const discoveryResult = trySecretDiscovery(currentCell, direction);
            if (discoveryResult.found) {
                // Secret was discovered! Open the passage
                revealSecretPassage(grid, playerX, playerY, direction);
                addMazeMessage('Secret Found!', 'You discovered a hidden passage!');
                await fireHook('onSecretFound', { x: playerX, y: playerY, direction });
                blockedByWall = false;
            } else if (discoveryResult.attempted) {
                addMazeMessage('Wall', discoveryResult.message || 'The wall seems solid...');
                return;
            } else {
                return; // Normal block
            }
        }
    } else if (currentMaze.voidWalkActive) {
        // If Void Walk is active but no wall was encountered, cancel it
        cancelVoidWalk();
    }

    // v1.4.0: Check zone blocking
    // v1.7.0: Quest-based zone gating support
    const targetCell = grid[newY][newX];
    if (targetCell.zoneId !== undefined && targetCell.zoneId !== null) {
        const floorData = currentMaze.floorsData?.[currentMaze.currentFloor];
        const zone = floorData?.zones?.[targetCell.zoneId];
        if (zone && !zone.isUnlocked) {
            // v1.7.0: Check quest-based unlocking first
            if (currentMaze.questProfileMeta?.questGatingEnabled) {
                if (!isAreaUnlockedByQuest('zone', targetCell.zoneId)) {
                    const hint = getQuestUnlockHint('zone', targetCell.zoneId);
                    addMazeMessage('Area Locked', hint);
                    return;
                }
                // Quest unlocks the zone - mark it as unlocked
                zone.isUnlocked = true;
            } else {
                // Original room-clearing logic
                addMazeMessage('Zone Locked', zone.lockedMessage || `${zone.name} is sealed. Clear more rooms to unlock.`);
                return;
            }
        }
    }

    // Determine direction for hook and sprite facing
    const direction = dx === 1 ? 'right' : dx === -1 ? 'left' : dy === 1 ? 'down' : 'up';
    // Convert to compass for sprite facing (right=east, left=west, down=south, up=north)
    const compassDirection = dx === 1 ? 'east' : dx === -1 ? 'west' : dy === 1 ? 'south' : 'north';

    // Move player
    currentMaze.playerX = newX;
    currentMaze.playerY = newY;
    currentMaze.playerDirection = compassDirection;

    // v1.6.0: Play footstep sound and walk animation
    playSound('footstep');
    startAnimation('player', 'player_walk', () => {
        // Return to idle after walk completes (non-looping animation path)
        // For looping animations, this won't trigger
    });

    // Reveal tiles within visibility radius (with line-of-sight checking)
    const gridSize = currentMaze.grid.length;
    applyVisibilityAtPosition(newX, newY, gridSize);
    currentMaze.moveCount++;

    // Update visibility timers (torch burnout, etc.)
    updateVisibilityOnMove();

    // v1.6.0: Update enhanced lighting system (torch/potion durations)
    await updateLightingOnMove();

    // Track move stat
    await incrementStat('moves', 1);

    // Fire onMove hook
    await fireHook('onMove', { x: newX, y: newY, direction });

    // Decrement rest cooldown
    decrementRestCooldown();

    // Update stats display
    updateStatsDisplay();

    // Update floor buttons based on current tile (staircase check)
    updateDpadFloorButtons();

    // Check for exploration complete
    checkExplorationComplete();

    // Animate player movement
    updatePlayerPosition(true);

    // Update grid (fog of war, etc.)
    renderMazeGrid();

    // Update minimap position
    updateMinimapPosition();

    // Center camera on player (smooth pan)
    if (typeof window.mazeCenterOnPlayer === 'function') {
        window.mazeCenterOnPlayer(true);
    }

    // v1.4.8: Enhance room description BEFORE any encounters trigger
    // This ensures the room is described before combat/chest/trap popups appear
    await enhanceRoomOnEntry(newX, newY);

    // Check for exit - only on final floor
    if (newX === currentMaze.exitX && newY === currentMaze.exitY &&
        currentMaze.currentFloor === currentMaze.totalFloors - 1) {
        handleExitReached();
        return;
    }

    const cell = grid[newY][newX];

    // Check for chest encounter (before minions)
    if (cell.chest && !cell.chest.opened) {
        triggerChestEncounter(cell.chest, newX, newY);
        return;
    }

    // Check for minion encounter
    if (cell.minion && !cell.minion.triggered) {
        triggerMinionEncounter(cell.minion.minionId, newX, newY);
        return;
    }

    // Check for trap encounter
    if (cell.trap && !cell.trap.triggered) {
        triggerTrapEncounter(cell.trap.trapId, newX, newY);
        return;
    }

    // Check for safe room (HP system - popup with Heal/Ignore)
    if (cell.safeRoom && !cell.safeRoom.exhausted && currentMaze.hpEnabled && currentMaze.hp) {
        triggerSafeRoomEncounter(newX, newY);
        return;
    }

    // Check for portal teleportation
    if (cell.portal) {
        const teleported = await handleTeleport(newX, newY, cell.portal);
        if (teleported) {
            // Re-render grid after teleport
            renderMazeGrid();
            // Update minimap after teleport
            updateMinimapPosition();
            // Center camera on new player position
            if (typeof window.mazeCenterOnPlayer === 'function') {
                window.mazeCenterOnPlayer(true);
            }
            // v1.4.9: Enhance teleport destination room before encounters
            await enhanceRoomOnEntry(currentMaze.playerX, currentMaze.playerY);
            // Check destination cell for encounters
            const destCell = grid[currentMaze.playerY][currentMaze.playerX];
            if (destCell.chest && !destCell.chest.opened) {
                triggerChestEncounter(destCell.chest, currentMaze.playerX, currentMaze.playerY);
                return;
            }
            if (destCell.minion && !destCell.minion.triggered) {
                triggerMinionEncounter(destCell.minion.minionId, currentMaze.playerX, currentMaze.playerY);
                return;
            }
            if (destCell.trap && !destCell.trap.triggered) {
                triggerTrapEncounter(destCell.trap.trapId, currentMaze.playerX, currentMaze.playerY);
                return;
            }
        }
    }

    // Check for main minion random message (after room enhancement completes)
    await maybeShowMainMinionMessage();

    // Check story milestones (after room enhancement completes)
    await checkStoryMilestones();

    // Process moving minions after player's move
    await processMinionMovement();

    // Re-render grid if minions moved
    if (currentMaze.movingMinions && currentMaze.movingMinions.length > 0) {
        renderMazeGrid();
    }
}

/**
 * Handle reaching the exit tile
 */
async function handleExitReached() {
    const profile = currentMaze.profile;

    // Check if all required objectives are complete
    if (!canWinMaze()) {
        // Show message that objectives need to be completed
        const mainMinion = profile.mainMinion ? getMinion(profile.mainMinion) : null;
        // v2.0.2: Use alias for main minion name
        const displayName = currentMaze.mainMinionAlias || mainMinion?.name || 'Exit';
        currentMaze.currentMinion = {
            name: displayName,
            imagePath: mainMinion?.imagePath || '',
            message: "You haven't completed all required objectives yet! Explore the maze to find what you need.",
        };
        updateMazeHero();

        // Flash the objectives display
        const objectivesSection = document.querySelector('.maze-objectives-section');
        if (objectivesSection) {
            objectivesSection.classList.add('objectives-flash');
            setTimeout(() => objectivesSection.classList.remove('objectives-flash'), 500);
        }
        return;
    }

    // If no main minion or exit encounter already done, just win
    if (!profile.mainMinion || currentMaze.exitEncounterDone) {
        handleMazeWin();
        return;
    }

    const mainMinion = getMinion(profile.mainMinion);
    if (!mainMinion) {
        handleMazeWin();
        return;
    }

    // Pause for exit encounter
    currentMaze.isPaused = true;

    // Show main minion as final boss
    // v2.0.2: Use alias for main minion name
    const exitDisplayName = currentMaze.mainMinionAlias || mainMinion.name;
    currentMaze.currentMinion = {
        name: exitDisplayName,
        imagePath: mainMinion.imagePath,
        message: "You've reached the exit... but first, face me!",
    };
    updateMazeHero();

    const exitType = profile.mainMinionExitType || 'messenger';
    const exitProfile = profile.mainMinionExitProfile;

    switch (exitType) {
        case 'messenger':
            await delay(2000);
            currentMaze.exitEncounterDone = true;
            currentMaze.isPaused = false;
            handleMazeWin();
            break;

        case 'battlebar':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_battlebar', profile: exitProfile };
                startBattlebar(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'prizewheel':
            if (exitProfile) {
                const wheelResult = loadWheelFromProfile(exitProfile);
                if (wheelResult.error) {
                    console.warn(`[MazeMaster] Exit wheel profile "${exitProfile}" failed to load: ${wheelResult.error}. Winning maze.`);
                    currentMaze.exitEncounterDone = true;
                    currentMaze.isPaused = false;
                    handleMazeWin();
                } else {
                    currentMaze.pendingEncounter = { type: 'exit_wheel', profile: exitProfile };
                    showWheelModal();
                }
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'turnbased':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_turnbased', profile: exitProfile };
                startTurnBased(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'qte':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_qte', profile: exitProfile };
                startQTE(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'dice':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_dice', profile: exitProfile };
                startDice(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'stealth':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_stealth', profile: exitProfile };
                startStealth(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'puzzle':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_puzzle', profile: exitProfile };
                startPuzzle(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'negotiation':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_negotiation', profile: exitProfile };
                startNegotiation(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        default:
            handleMazeWin();
    }
}

/**
 * Trigger a minion encounter when stepping on a minion tile
 */
async function triggerMinionEncounter(minionId, x, y) {
    const minion = getMinion(minionId);
    if (!minion) {
        console.warn(`[MazeMaster] Minion "${minionId}" not found`);
        return;
    }

    // Double-check not already triggered (safety check)
    const cell = currentMaze.grid[y][x];
    if (cell.minion?.triggered) {
        console.log(`[MazeMaster] Minion at ${x},${y} already triggered, skipping`);
        return;
    }

    // Mark as triggered FIRST
    cell.minion.triggered = true;
    console.log(`[MazeMaster] Marked minion at ${x},${y} as triggered`);

    // Log encounter to session notes
    const minionType = minion.type || 'messenger';
    addSessionNote(`Encountered ${minion.name} (${minionType})`, 'Encounter');

    // v1.2.0: Check for Minion Bane - auto-defeat non-messenger minions
    if (minionType !== 'messenger' && currentMaze.inventory.minionBane > 0) {
        const baneUsed = await checkMinionBane();
        if (baneUsed) {
            // Auto-defeat the minion
            cell.minion.defeated = true;
            await incrementStat('encountersWon', 1);
            await updateObjectiveProgress('defeat', minionId, 1);
            // v1.4.0: Mark room as cleared for zone progression
            await markRoomCleared(x, y);
            renderMazeGrid();

            // Brief pause then resume
            setTimeout(() => {
                currentMaze.isPaused = false;
                resetMazeHero();
            }, 2000);
            return;
        }
    }

    // Track encounter stat
    await incrementStat('encountersTotal', 1);

    // Update defeat objective (counts when encountered - for battlebar types, this may be premature but we track the encounter)
    await updateObjectiveProgress('defeat', minionId, 1);

    // Pause maze
    currentMaze.isPaused = true;

    // Show minion with placeholder immediately
    currentMaze.currentMinion = {
        name: minion.name,
        imagePath: minion.imagePath,
        message: '...',
    };
    updateMazeHero();
    renderMazeGrid();

    // Get base message
    const baseMessage = getRandomFromArray(minion.messages) || `You encountered ${minion.name}!`;

    // Show generating indicator
    showGeneratingIndicator(true);

    // Generate LLM message if enabled
    let message = baseMessage;
    try {
        message = await generateMinionMessage({
            minionName: minion.name,
            minionDescription: minion.description,
            baseMessage: baseMessage,
            mainStory: getMainStory(),
            currentMilestone: getCurrentMilestone(),
            minionType: minion.type || 'messenger',
        });
    } catch (error) {
        console.error('[MazeMaster] LLM generation error:', error);
    }

    // Hide generating indicator
    showGeneratingIndicator(false);

    // Update with actual message
    currentMaze.currentMinion.message = message;
    updateMazeHero();

    // Execute encounter script if present
    if (minion.encounterScript && minion.encounterScript.trim()) {
        console.log(`[MazeMaster] Executing encounter script for ${minion.name}`);
        await executeWithTimeout(minion.encounterScript);
    }

    // Show confirmation buttons instead of auto-triggering (minionType already defined above)
    showEncounterConfirmation(minionId, x, y, minion.type || 'messenger');
}

/**
 * Trigger a trap encounter when stepping on a trap tile
 */
async function triggerTrapEncounter(trapId, x, y) {
    const trap = getTrap(trapId);
    if (!trap) {
        console.warn(`[MazeMaster] Trap "${trapId}" not found`);
        return;
    }

    // Check for avoidance (future: modified by player stats)
    const avoidChance = trap.avoidChance ?? 0;
    if (avoidChance > 0) {
        const roll = Math.random() * 100;
        if (roll < avoidChance) {
            // Trap avoided!
            console.log(`[MazeMaster] Trap "${trap.name}" avoided (rolled ${roll.toFixed(1)} vs ${avoidChance}%)`);

            // Mark as triggered (used up)
            currentMaze.grid[y][x].trap.triggered = true;
            renderMazeGrid();

            // Track avoided trap stat
            await incrementStat('trapsAvoided', 1);

            // Show avoid message
            const avoidMessage = trap.avoidMessage || `You skillfully avoided the ${trap.name}!`;
            addMazeMessage('Trap Avoided', avoidMessage);

            // Execute avoid script if present
            if (trap.avoidScript && trap.avoidScript.trim()) {
                console.log(`[MazeMaster] Executing avoid script for ${trap.name}`);
                await executeWithTimeout(trap.avoidScript);
            }

            // Don't execute trap script, just continue
            return;
        }
    }

    // Mark as triggered
    currentMaze.grid[y][x].trap.triggered = true;
    renderMazeGrid();

    // Log to session notes
    addSessionNote(`Triggered trap: ${trap.name}`, 'Trap');

    // Track trap stat
    await incrementStat('trapsTriggered', 1);

    // Pause maze
    currentMaze.isPaused = true;

    // Show trap in hero section with placeholder
    currentMaze.currentMinion = {
        name: trap.name,
        imagePath: trap.imagePath,
        message: '...',
    };
    updateMazeHero();

    // Show generating indicator
    showGeneratingIndicator(true);

    // Generate LLM message for trap
    const baseMessage = trap.message || 'You triggered a trap!';
    let message = baseMessage;
    try {
        message = await generateTrapMessage({
            trapName: trap.name,
            baseMessage: baseMessage,
            mainStory: getMainStory(),
        });
    } catch (error) {
        console.error('[MazeMaster] Trap LLM generation error:', error);
    }

    // Hide generating indicator
    showGeneratingIndicator(false);

    // Update with actual message
    currentMaze.currentMinion.message = message;
    updateMazeHero();

    // Execute trap script if present (script can use /mazedamage to deal HP damage)
    if (trap.script && trap.script.trim()) {
        console.log(`[MazeMaster] Executing trap script for ${trap.name}`);
        await executeWithTimeout(trap.script);
    }

    // Show a continue button
    showTrapContinueButton(x, y);
}

/**
 * Show continue button after trap encounter
 */
function showTrapContinueButton(x, y) {
    const buttons = `<button id="maze_trap_continue" class="menu_button maze-confirm-btn">Continue</button>`;
    showActionPopup(buttons);

    document.getElementById('maze_trap_continue')?.addEventListener('click', () => {
        hideActionPopup();
        resumeMaze();
    });
}

/**
 * Resume maze after an encounter completes
 */
function resumeMaze() {
    currentMaze.isPaused = false;
    currentMaze.pendingEncounter = null;

    // Clear action buttons
    const confirmEl = document.getElementById('maze_encounter_confirm');
    if (confirmEl) {
        confirmEl.innerHTML = '';
        confirmEl.style.display = 'none';
    }

    // Restore main minion display if configured
    const profile = currentMaze.profile;
    if (profile.mainMinion) {
        const mainMinion = getMinion(profile.mainMinion);
        if (mainMinion) {
            // v2.0.2: Use alias for main minion name
            const displayName = currentMaze.mainMinionAlias || mainMinion.name;
            currentMaze.currentMinion = {
                name: displayName,
                imagePath: mainMinion.imagePath,
                message: '', // v2.1.0: Clear message between encounters
            };
            updateMazeHero();
            return;
        }
    }

    // Otherwise restore default
    currentMaze.currentMinion = getDefaultMinion();
    updateMazeHero();
}

/**
 * Populate the inventory drawer with themed item names
 */
function populateInventoryDrawer() {
    const drawer = document.querySelector('.inventory-drawer-content');
    if (!drawer) return;

    const profile = currentMaze.profile;
    const inv = currentMaze.inventory;

    const items = [
        { id: 'key', icon: 'fa-key', colorClass: '' },
        { id: 'stealth', icon: 'fa-user-ninja', colorClass: '' },
        { id: 'strike', icon: 'fa-bolt', colorClass: '' },
        { id: 'execute', icon: 'fa-star', colorClass: 'execute' },
        { id: 'floorKey', icon: 'fa-stairs', colorClass: 'floor-key' },
        { id: 'portalStone', icon: 'fa-gem', colorClass: 'portal-stone' },
        { id: 'minionBane', icon: 'fa-skull-crossbones', colorClass: 'minion-bane' },
        { id: 'mapFragment', icon: 'fa-scroll', colorClass: 'map-fragment' },
        { id: 'timeShard', icon: 'fa-hourglass-half', colorClass: 'time-shard' },
        { id: 'voidWalk', icon: 'fa-ghost', colorClass: 'void-walk' },
    ];

    drawer.innerHTML = items.map(item => {
        const count = inv[item.id] || 0;
        const themedName = getThemedItemName(item.id, profile);
        const emptyClass = count === 0 ? 'empty' : '';
        return `
            <div class="inventory-drawer-item ${item.colorClass} ${emptyClass}">
                <i class="fa-solid ${item.icon}"></i>
                <span class="item-name">${themedName}</span>
                <span class="item-count">x${count}</span>
            </div>
        `;
    }).join('');
}

/**
 * Update the inventory display in the maze modal
 */
function updateInventoryDisplay() {
    // Helper to update an element and its parent visibility
    const updateItemElement = (id, value, overlayId = null) => {
        const el = document.getElementById(id);
        if (el) {
            el.textContent = value;
        }
        // Also update overlay element if provided
        if (overlayId) {
            const ovEl = document.getElementById(overlayId);
            if (ovEl) {
                ovEl.textContent = value;
                // Show/hide overlay item based on count
                const parent = ovEl.closest('.inv-overlay-item');
                if (parent) {
                    parent.style.display = value > 0 ? '' : 'none';
                }
            }
        }
    };

    // Legacy element ID mappings for backwards compatibility
    const legacyIdMappings = {
        'strike': 'pow',  // maze_inv_pow instead of maze_inv_strike
    };

    // Dynamically iterate through all item profiles
    const allItemIds = getItemProfileIds();
    for (const itemId of allItemIds) {
        const value = currentMaze.inventory[itemId] || 0;

        // Use legacy ID if available, otherwise use item ID directly
        const elementId = legacyIdMappings[itemId] || itemId;
        updateItemElement(`maze_inv_${elementId}`, value, `maze_ov_${elementId}`);

        // Also try the direct item ID in case the element uses that
        if (legacyIdMappings[itemId]) {
            updateItemElement(`maze_inv_${itemId}`, value, `maze_ov_${itemId}`);
        }

        // Show charges in tooltip for equipment items
        const itemProfile = getItemProfile(itemId);
        if (itemProfile?.type === 'equipment') {
            const charges = getTotalItemCharges(itemId);
            const el = document.getElementById(`maze_inv_${elementId}`) || document.getElementById(`maze_inv_${itemId}`);
            if (el && charges > 0) {
                const theme = currentMaze.profile?.theme || 'fantasy';
                const displayName = getItemDisplayName(itemId, theme);
                el.title = `${displayName} (${charges} charges)`;
            }
        }
    }
}

/**
 * Add items to inventory
 */
async function addToInventory(item, amount = 1) {
    if (currentMaze.inventory[item] !== undefined) {
        currentMaze.inventory[item] += amount;

        // v1.7.0: Initialize charges for equipment items
        for (let i = 0; i < amount; i++) {
            initializeItemCharges(item);
        }

        updateInventoryDisplay();

        // Track item collection stats
        if (currentMaze.stats?.itemsCollected?.[item] !== undefined) {
            currentMaze.stats.itemsCollected[item] += amount;
        }

        // Fire hook
        await fireHook('onItemAdd', {
            item,
            count: amount,
            total: currentMaze.inventory[item]
        });

        // Update collect objectives
        await updateObjectiveProgress('collect', item, amount);
    }
}

/**
 * Remove items from inventory
 */
async function removeFromInventory(item, amount = 1) {
    if (currentMaze.inventory[item] !== undefined) {
        const prevAmount = currentMaze.inventory[item];
        currentMaze.inventory[item] = Math.max(0, prevAmount - amount);
        updateInventoryDisplay();

        // Fire hook
        await fireHook('onItemRemove', {
            item,
            count: Math.min(prevAmount, amount),
            total: currentMaze.inventory[item]
        });
    }
}

// =============================================================================
// EQUIPMENT SYSTEM FUNCTIONS (v1.5.0)
// =============================================================================

/**
 * Get equipment definition by ID
 * @param {string} itemId - Equipment item ID
 * @returns {object|null} Equipment definition or null
 */
function getEquipment(itemId) {
    return DEFAULT_EQUIPMENT[itemId] || null;
}

/**
 * Calculate total stats from all equipped items
 * @returns {object} Combined stats { attack, defense, critBonus, specials }
 */
function getEquippedStats() {
    const stats = {
        attack: 0,
        defense: 0,
        critBonus: 0,
        specials: [], // Array of { type, value } for special effects
    };

    if (!currentMaze.equipment) return stats;

    for (const slot of ['weapon', 'armor', 'accessory']) {
        const item = currentMaze.equipment[slot];
        if (item) {
            stats.attack += item.attack || 0;
            stats.defense += item.defense || 0;
            stats.critBonus += item.critBonus || 0;
            if (item.special) {
                stats.specials.push(item.special);
            }
        }
    }

    return stats;
}

/**
 * Add equipment item to equipment inventory
 * @param {string} itemId - Equipment item ID
 */
async function addEquipmentToInventory(itemId) {
    const item = getEquipment(itemId);
    if (!item) {
        console.warn(`[MazeMaster] Unknown equipment: ${itemId}`);
        return false;
    }

    if (!currentMaze.equipmentInventory) {
        currentMaze.equipmentInventory = [];
    }

    currentMaze.equipmentInventory.push(itemId);
    updateEquipmentDisplay();

    addMazeMessage('Loot', `Found ${item.name}!`);
    await fireHook('onEquipmentFound', {
        itemId,
        name: item.name,
        slot: item.slot,
        rarity: item.rarity,
    });

    return true;
}

/**
 * Equip an item from equipment inventory
 * @param {string} itemId - Equipment item ID to equip
 * @returns {boolean} Success
 */
async function equipItem(itemId) {
    const item = getEquipment(itemId);
    if (!item) {
        console.warn(`[MazeMaster] Cannot equip unknown item: ${itemId}`);
        return false;
    }

    // Check if item is in equipment inventory
    const invIndex = currentMaze.equipmentInventory?.indexOf(itemId);
    if (invIndex === -1 || invIndex === undefined) {
        console.warn(`[MazeMaster] Item not in inventory: ${itemId}`);
        return false;
    }

    // Unequip current item in slot (if any)
    const previousItem = currentMaze.equipment[item.slot];
    if (previousItem) {
        currentMaze.equipmentInventory.push(previousItem.id);
    }

    // Remove from inventory and equip
    currentMaze.equipmentInventory.splice(invIndex, 1);
    currentMaze.equipment[item.slot] = item;

    updateEquipmentDisplay();

    addMazeMessage('Equipment', `Equipped ${item.name}!`);
    await fireHook('onEquip', {
        itemId: item.id,
        name: item.name,
        slot: item.slot,
        attack: item.attack,
        defense: item.defense,
        critBonus: item.critBonus,
    });

    return true;
}

/**
 * Unequip an item from a slot
 * @param {string} slot - Slot to unequip ('weapon', 'armor', 'accessory')
 * @returns {boolean} Success
 */
async function unequipItem(slot) {
    if (!currentMaze.equipment?.[slot]) {
        return false;
    }

    const item = currentMaze.equipment[slot];
    currentMaze.equipment[slot] = null;

    if (!currentMaze.equipmentInventory) {
        currentMaze.equipmentInventory = [];
    }
    currentMaze.equipmentInventory.push(item.id);

    updateEquipmentDisplay();

    addMazeMessage('Equipment', `Unequipped ${item.name}.`);
    await fireHook('onUnequip', {
        itemId: item.id,
        name: item.name,
        slot,
    });

    return true;
}

/**
 * Update equipment display in the maze UI
 */
function updateEquipmentDisplay() {
    // Update equipped slots
    for (const slot of ['weapon', 'armor', 'accessory']) {
        const slotEl = document.getElementById(`maze_equip_${slot}`);
        const item = currentMaze.equipment?.[slot];

        if (slotEl) {
            if (item) {
                slotEl.innerHTML = `
                    <div class="equip-item equipped" data-item-id="${item.id}" data-slot="${slot}">
                        <i class="fa-solid ${item.icon}"></i>
                        <span class="equip-name">${item.name}</span>
                    </div>
                `;
                slotEl.title = `${item.name}\n+${item.attack} ATK, +${item.defense} DEF${item.critBonus ? `, +${item.critBonus}% Crit` : ''}\n${item.description}`;
                slotEl.classList.add('has-item');
            } else {
                slotEl.innerHTML = `
                    <div class="equip-item empty" data-slot="${slot}">
                        <i class="fa-solid fa-plus"></i>
                        <span class="equip-name">Empty</span>
                    </div>
                `;
                slotEl.title = `Empty ${slot} slot`;
                slotEl.classList.remove('has-item');
            }
        }
    }

    // Update total stats display
    const stats = getEquippedStats();
    const atkEl = document.getElementById('maze_equip_total_atk');
    const defEl = document.getElementById('maze_equip_total_def');
    const critEl = document.getElementById('maze_equip_total_crit');

    if (atkEl) atkEl.textContent = `+${stats.attack}`;
    if (defEl) defEl.textContent = `+${stats.defense}`;
    if (critEl) critEl.textContent = `+${stats.critBonus}%`;

    // Update equipment inventory list
    updateEquipmentInventoryList();
}

/**
 * Update the equipment inventory dropdown/list
 */
function updateEquipmentInventoryList() {
    const listEl = document.getElementById('maze_equipment_inventory');
    if (!listEl) return;

    const items = currentMaze.equipmentInventory || [];

    if (items.length === 0) {
        listEl.innerHTML = '<div class="equip-inv-empty">No equipment in backpack</div>';
        return;
    }

    listEl.innerHTML = items.map(itemId => {
        const item = getEquipment(itemId);
        if (!item) return '';

        const rarityClass = `rarity-${item.rarity}`;
        return `
            <div class="equip-inv-item ${rarityClass}" data-item-id="${itemId}" title="${item.description}">
                <i class="fa-solid ${item.icon}"></i>
                <span class="item-name">${item.name}</span>
                <span class="item-stats">+${item.attack}/${item.defense}</span>
                <button class="equip-btn" data-action="equip" data-item-id="${itemId}">Equip</button>
            </div>
        `;
    }).join('');
}

/**
 * Trigger equipment drop from combat or chest
 * @param {number} dropChance - Percent chance (0-100) for equipment to drop
 * @param {number} luckModifier - Bonus to rare drop chances (0-100)
 * @returns {object|null} Dropped equipment or null
 */
async function triggerEquipmentDrop(dropChance = 10, luckModifier = 0) {
    if (Math.random() * 100 > dropChance) {
        return null;
    }

    const equipment = rollEquipmentDrop(luckModifier);
    if (equipment) {
        await addEquipmentToInventory(equipment.id);
        return equipment;
    }

    return null;
}

// =============================================================================
// EQUIPMENT MODAL (v2.0.0)
// =============================================================================

/**
 * Get equipment modal styles
 */
function getEquipmentModalStyles() {
    return `
        .equip-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            z-index: 9999999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .equip-modal-container {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            min-width: 320px;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .equip-modal-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .equip-modal-icon {
            font-size: 32px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .equip-modal-icon.rarity-common { color: #9e9e9e; }
        .equip-modal-icon.rarity-uncommon { color: #4caf50; }
        .equip-modal-icon.rarity-rare { color: #2196f3; }
        .equip-modal-icon.rarity-epic { color: #9c27b0; }
        .equip-modal-icon.rarity-legendary { color: #ff9800; }

        .equip-modal-title {
            flex: 1;
        }

        .equip-modal-name {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            margin: 0;
        }

        .equip-modal-slot {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
        }

        .equip-modal-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .equip-modal-stat {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .equip-modal-stat-value {
            font-size: 20px;
            font-weight: bold;
        }

        .equip-modal-stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }

        .equip-modal-stat.attack .equip-modal-stat-value { color: #e74c3c; }
        .equip-modal-stat.defense .equip-modal-stat-value { color: #3498db; }
        .equip-modal-stat.crit .equip-modal-stat-value { color: #f1c40f; }

        .equip-modal-durability {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .equip-modal-durability-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .equip-modal-durability-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
        }

        .equip-modal-durability-value {
            font-size: 14px;
            font-weight: bold;
        }

        .equip-modal-durability-bar {
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            overflow: hidden;
        }

        .equip-modal-durability-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #2ecc71);
            transition: width 0.3s ease;
        }

        .equip-modal-durability-fill.low { background: #e74c3c; }
        .equip-modal-durability-fill.medium { background: #f39c12; }
        .equip-modal-durability-fill.high { background: #2ecc71; }

        .equip-modal-special {
            background: rgba(156, 39, 176, 0.2);
            border: 1px solid rgba(156, 39, 176, 0.4);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 16px;
            font-size: 12px;
            color: #ce93d8;
        }

        .equip-modal-description {
            font-size: 13px;
            color: #aaa;
            margin-bottom: 16px;
            font-style: italic;
        }

        .equip-modal-buttons {
            display: flex;
            gap: 8px;
        }

        .equip-modal-btn {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .equip-modal-btn:hover:not(:disabled) {
            transform: translateY(-2px);
        }

        .equip-modal-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .equip-modal-btn.unequip {
            background: #95a5a6;
            color: #fff;
        }

        .equip-modal-btn.unequip:hover:not(:disabled) {
            background: #7f8c8d;
        }

        .equip-modal-btn.repair {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: #fff;
        }

        .equip-modal-btn.repair:hover:not(:disabled) {
            background: linear-gradient(135deg, #229954, #27ae60);
        }

        .equip-modal-btn.close {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }

        .equip-modal-btn.close:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .equip-modal-repair-info {
            font-size: 11px;
            color: #666;
            text-align: center;
            margin-top: 8px;
        }
    `;
}

/**
 * Get current durability of an equipment item
 * @param {string} itemId - Equipment ID
 * @param {string} slot - Slot type
 * @returns {object} { current, max }
 */
function getEquipmentDurability(itemId, slot) {
    const baseEquip = DEFAULT_EQUIPMENT[itemId];
    if (!baseEquip) return { current: 0, max: 0 };

    const maxDurability = baseEquip.maxDurability || 10;

    // For absorb-type armor, use equipmentCharges
    if (baseEquip.special?.type === 'absorb') {
        const charges = currentMaze.equipmentCharges?.[itemId];
        if (typeof charges !== 'undefined') {
            return { current: charges, max: baseEquip.special.charges || maxDurability };
        }
        return { current: baseEquip.special.charges || maxDurability, max: baseEquip.special.charges || maxDurability };
    }

    // For regular equipment, use equipmentDurability tracking
    if (!currentMaze.equipmentDurability) {
        currentMaze.equipmentDurability = {};
    }

    if (typeof currentMaze.equipmentDurability[itemId] === 'undefined') {
        currentMaze.equipmentDurability[itemId] = maxDurability;
    }

    return { current: currentMaze.equipmentDurability[itemId], max: maxDurability };
}

/**
 * Show equipment modal for a slot
 * @param {string} slot - The slot type ('weapon', 'armor', 'accessory')
 */
function showEquipmentModal(slot) {
    console.log('[MazeMaster] showEquipmentModal called for slot:', slot);
    const item = currentMaze.equipment?.[slot];
    console.log('[MazeMaster] Item in slot:', item);
    if (!item) {
        console.log('[MazeMaster] No item found, returning');
        return;
    }

    // Remove existing modal
    const existing = document.getElementById('mazemaster_equip_modal');
    if (existing) existing.remove();

    // Add styles if not present
    if (!document.getElementById('mazemaster_equip_modal_styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_equip_modal_styles';
        styleEl.textContent = getEquipmentModalStyles();
        document.head.appendChild(styleEl);
    }

    // Get durability
    const durability = getEquipmentDurability(item.id, slot);
    const durabilityPercent = durability.max > 0 ? (durability.current / durability.max) * 100 : 100;
    const durabilityClass = durabilityPercent <= 25 ? 'low' : durabilityPercent <= 50 ? 'medium' : 'high';

    // Check repair kits
    const repairKits = currentMaze.inventory?.repairKit || 0;
    const needsRepair = durability.current < durability.max;
    const canRepair = repairKits > 0 && needsRepair;

    // Get themed name for repair kit
    const theme = currentMaze.theme || 'fantasy';
    const repairProfile = getItemProfile('repairKit');
    const repairKitName = repairProfile?.aliases?.[theme] || 'Repair Kit';

    // Build special text
    let specialHtml = '';
    if (item.special) {
        const specialTypes = {
            fire: 'Deals fire damage',
            backstab: `+${item.special.value}% backstab damage`,
            lifesteal: `Heals ${item.special.value}% of damage dealt`,
            absorb: `Absorbs ${item.special.value} hits`,
        };
        specialHtml = `<div class="equip-modal-special"><i class="fa-solid fa-star"></i> Special: ${specialTypes[item.special.type] || item.special.type}</div>`;
    }

    // Create modal HTML
    const modalHtml = `
        <div id="mazemaster_equip_modal" class="equip-modal-overlay">
            <div class="equip-modal-container">
                <div class="equip-modal-header">
                    <div class="equip-modal-icon rarity-${item.rarity}">
                        <i class="fa-solid ${item.icon}"></i>
                    </div>
                    <div class="equip-modal-title">
                        <h3 class="equip-modal-name">${item.name}</h3>
                        <span class="equip-modal-slot">${slot} • ${item.rarity}</span>
                    </div>
                </div>

                <div class="equip-modal-stats">
                    <div class="equip-modal-stat attack">
                        <div class="equip-modal-stat-value">+${item.attack}</div>
                        <div class="equip-modal-stat-label">Attack</div>
                    </div>
                    <div class="equip-modal-stat defense">
                        <div class="equip-modal-stat-value">+${item.defense}</div>
                        <div class="equip-modal-stat-label">Defense</div>
                    </div>
                    <div class="equip-modal-stat crit">
                        <div class="equip-modal-stat-value">+${item.critBonus}%</div>
                        <div class="equip-modal-stat-label">Crit</div>
                    </div>
                </div>

                <div class="equip-modal-durability">
                    <div class="equip-modal-durability-header">
                        <span class="equip-modal-durability-label">Durability</span>
                        <span class="equip-modal-durability-value">${durability.current} / ${durability.max}</span>
                    </div>
                    <div class="equip-modal-durability-bar">
                        <div class="equip-modal-durability-fill ${durabilityClass}" style="width: ${durabilityPercent}%"></div>
                    </div>
                </div>

                ${specialHtml}

                <div class="equip-modal-description">${item.description}</div>

                <div class="equip-modal-buttons">
                    <button class="equip-modal-btn unequip" id="equip_modal_unequip">
                        <i class="fa-solid fa-circle-minus"></i> Unequip
                    </button>
                    <button class="equip-modal-btn repair" id="equip_modal_repair" ${canRepair ? '' : 'disabled'}>
                        <i class="fa-solid fa-wrench"></i> Repair
                    </button>
                    <button class="equip-modal-btn close" id="equip_modal_close">
                        <i class="fa-solid fa-times"></i>
                    </button>
                </div>

                <div class="equip-modal-repair-info">
                    ${repairKitName}s: ${repairKits} available${!needsRepair ? ' (fully repaired)' : ''}
                </div>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHtml);
    console.log('[MazeMaster] Equipment modal HTML inserted');

    // Attach event handlers
    document.getElementById('equip_modal_close').addEventListener('click', closeEquipmentModal);
    console.log('[MazeMaster] Equipment modal event handlers attached');

    document.getElementById('equip_modal_unequip').addEventListener('click', async () => {
        await unequipItem(slot);
        closeEquipmentModal();
    });

    document.getElementById('equip_modal_repair').addEventListener('click', async () => {
        await repairEquipment(slot);
        // Refresh modal to show updated durability
        closeEquipmentModal();
        showEquipmentModal(slot);
    });

    // Close on backdrop click
    document.getElementById('mazemaster_equip_modal').addEventListener('click', (e) => {
        if (e.target.id === 'mazemaster_equip_modal') {
            closeEquipmentModal();
        }
    });
}

/**
 * Close equipment modal
 */
function closeEquipmentModal() {
    const modal = document.getElementById('mazemaster_equip_modal');
    if (modal) modal.remove();
}

/**
 * Repair equipment in a slot using repair kit
 * @param {string} slot - The slot type
 * @returns {boolean} Success
 */
async function repairEquipment(slot) {
    const item = currentMaze.equipment?.[slot];
    if (!item) return false;

    const repairKits = currentMaze.inventory?.repairKit || 0;
    if (repairKits <= 0) {
        addMazeMessage('Repair', 'No repair kits available!');
        return false;
    }

    const durability = getEquipmentDurability(item.id, slot);
    if (durability.current >= durability.max) {
        addMazeMessage('Repair', `${item.name} is already fully repaired.`);
        return false;
    }

    // Consume repair kit
    currentMaze.inventory.repairKit--;
    if (currentMaze.inventory.repairKit <= 0) {
        delete currentMaze.inventory.repairKit;
    }

    // Get repair amount from profile
    const repairProfile = getItemProfile('repairKit');
    const repairAmount = repairProfile?.repairAmount || 3;

    // For absorb-type armor, restore charges
    const baseEquip = DEFAULT_EQUIPMENT[item.id];
    if (baseEquip?.special?.type === 'absorb') {
        if (!currentMaze.equipmentCharges) currentMaze.equipmentCharges = {};
        const maxCharges = baseEquip.special.charges || 3;
        currentMaze.equipmentCharges[item.id] = Math.min(
            (currentMaze.equipmentCharges[item.id] || 0) + repairAmount,
            maxCharges
        );
        const newCharges = currentMaze.equipmentCharges[item.id];
        addMazeMessage('Repair', `Restored ${item.name} to ${newCharges}/${maxCharges} charges!`);
    } else {
        // Regular durability repair
        if (!currentMaze.equipmentDurability) currentMaze.equipmentDurability = {};
        const maxDur = baseEquip?.maxDurability || 10;
        currentMaze.equipmentDurability[item.id] = Math.min(
            (currentMaze.equipmentDurability[item.id] || maxDur) + repairAmount,
            maxDur
        );
        const newDur = currentMaze.equipmentDurability[item.id];
        addMazeMessage('Repair', `Restored ${item.name} to ${newDur}/${maxDur} durability!`);
    }

    updateInventoryDisplay();
    updateEquipmentDisplay();

    await fireHook('onRepair', {
        itemId: item.id,
        name: item.name,
        slot,
    });

    return true;
}

/**
 * Reduce equipment durability after use in combat
 * @param {string} slot - The slot type ('weapon', 'armor', 'accessory')
 * @param {number} amount - Amount to reduce (default 1)
 * @returns {boolean} True if equipment broke
 */
function reduceEquipmentDurability(slot, amount = 1) {
    const item = currentMaze.equipment?.[slot];
    if (!item) return false;

    const baseEquip = DEFAULT_EQUIPMENT[item.id];
    if (!baseEquip) return false;

    // Skip absorb-type armor (handled separately in tryAbsorbDamage)
    if (baseEquip.special?.type === 'absorb') return false;

    // Initialize durability tracking
    if (!currentMaze.equipmentDurability) {
        currentMaze.equipmentDurability = {};
    }

    const maxDur = baseEquip.maxDurability || 10;
    if (typeof currentMaze.equipmentDurability[item.id] === 'undefined') {
        currentMaze.equipmentDurability[item.id] = maxDur;
    }

    // Reduce durability
    currentMaze.equipmentDurability[item.id] -= amount;

    // Check if broken
    if (currentMaze.equipmentDurability[item.id] <= 0) {
        addMazeMessage('Equipment', `Your ${item.name} broke!`);
        currentMaze.equipment[slot] = null;
        delete currentMaze.equipmentDurability[item.id];
        updateEquipmentDisplay();
        return true;
    }

    // Low durability warning
    if (currentMaze.equipmentDurability[item.id] <= 2) {
        addMazeMessage('Warning', `Your ${item.name} is about to break!`);
    }

    return false;
}

// =============================================================================
// XP & LEVELING SYSTEM
// =============================================================================

/**
 * Default XP reward values (fallback for profiles without xpConfig)
 * v2.0.3: Now used as fallback - profiles can override via xpConfig
 */
const XP_REWARDS = {
    combatVictory: 25,          // Base XP for winning combat
    combatDifficultyBonus: 5,   // Additional XP per difficulty level
    lockedChest: 20,            // Opening a locked chest
    normalChest: 10,            // Opening a normal chest
    exploration10: 20,          // Every 10% of map explored
    objectiveComplete: 50,      // Completing an objective
    bossDefeat: 75,             // Defeating a boss minion
    puzzleSolved: 30,           // Solving a puzzle encounter
    trapDisarmed: 15,           // Disarming a trap
    questComplete: 100,         // Completing a quest
};

/**
 * v2.0.3: Get XP reward for a specific activity type
 * Checks the current profile's xpConfig first, then falls back to XP_REWARDS defaults
 * @param {string} type - The XP reward type (e.g., 'combatVictory', 'lockedChest')
 * @returns {number} XP amount for this activity
 */
function getXpReward(type) {
    // Check current profile's xpConfig first
    const profileXp = currentMaze?.profile?.xpConfig?.[type];
    if (typeof profileXp === 'number') {
        return profileXp;
    }
    // Fall back to global XP_REWARDS
    return XP_REWARDS[type] || 0;
}

/**
 * Calculate XP required for a given level
 * Formula: 100 * 1.5^(level-1)
 * @param {number} level - The level to calculate XP for
 * @returns {number} XP required to reach this level
 */
function getXpForLevel(level) {
    return Math.floor(100 * Math.pow(1.5, level - 1));
}

/**
 * Get stat bonuses for a given level
 * Per level: +5 max HP, +1 ATK, +1 DEF, +1 skill point
 * @param {number} level - Character level
 * @returns {object} Stat bonuses
 */
function getLevelStats(level) {
    const bonusLevels = level - 1;
    return {
        maxHpBonus: bonusLevels * 5,
        attackBonus: bonusLevels * 1,
        defenseBonus: bonusLevels * 1,
        skillPoints: bonusLevels,
    };
}

/**
 * Grant XP to the player and handle level ups
 * @param {number} amount - Amount of XP to grant
 * @param {string} source - Source of XP (for logging and hooks)
 * @returns {object} Result with xpGained, leveledUp, newLevel
 */
async function grantXp(amount, source = 'unknown') {
    if (!currentMaze?.isOpen || amount <= 0) {
        return { xpGained: 0, leveledUp: false, newLevel: currentMaze?.character?.level || 1 };
    }

    const character = currentMaze.character;
    const oldLevel = character.level;
    character.xp += amount;

    // Fire XP gain hook
    const profile = extensionSettings.maze.profiles?.[currentMaze.profileName] || {};
    if (profile.onXpGain) {
        await fireHook(profile.onXpGain, {
            amount: amount,
            source: source,
            totalXp: character.xp,
            level: character.level,
        });
    }

    // Check for level up(s)
    let levelsGained = 0;
    while (character.xp >= character.xpToNextLevel) {
        character.xp -= character.xpToNextLevel;
        character.level++;

        // v2.0.5: Roll dice for skill points (configurable)
        const skillPointDice = profile.skillPointDice || '1d3';
        const skillPointsGained = rollDice(skillPointDice);
        character.skillPoints += skillPointsGained;

        character.xpToNextLevel = getXpForLevel(character.level + 1);
        levelsGained++;

        // Apply HP bonus from level up
        const levelStats = getLevelStats(character.level);
        if (currentMaze.hpEnabled && currentMaze.hp) {
            const oldMax = currentMaze.hp.max;
            currentMaze.hp.max = 100 + levelStats.maxHpBonus + (currentMaze.hp.maxBonus || 0);
            currentMaze.hp.current = Math.min(currentMaze.hp.current + (currentMaze.hp.max - oldMax), currentMaze.hp.max);
            updateHpDisplay();
        }

        // Fire level up hook
        if (profile.onLevelUp) {
            await fireHook(profile.onLevelUp, {
                newLevel: character.level,
                skillPointsAvailable: character.skillPoints,
                skillPointsGained: skillPointsGained,
                skillPointDice: skillPointDice,
                stats: levelStats,
            });
        }

        // Show level up message in log
        addToMessageLog(`Level Up! You are now level ${character.level}! Rolled ${skillPointDice}: +${skillPointsGained} skill points!`, 'success');

        // v2.0.5: Show /echo notification for level-up with dice roll
        try {
            const echoMessage = `🎉 **LEVEL UP!** You are now **Level ${character.level}**!\n` +
                `🎲 Rolled ${skillPointDice}: **+${skillPointsGained} Skill Points**\n` +
                `📊 Total Skill Points: ${character.skillPoints}`;
            await executeSlashCommandsWithOptions(`/echo ${echoMessage}`);
        } catch (e) {
            console.log('[MazeMaster] Could not show level-up echo:', e);
        }

        // v1.6.0: Play level up sound and VFX
        playSound('level_up');
        const mazeContainer = document.querySelector('.maze-container') || document.querySelector('#mazemaster_grid');
        if (mazeContainer) {
            triggerVFX('level_up', mazeContainer);
        }
    }

    // Update UI
    updatePlayerStatsDisplay();

    return {
        xpGained: amount,
        leveledUp: levelsGained > 0,
        levelsGained: levelsGained,
        newLevel: character.level,
    };
}

/**
 * v2.0.5: Check for pending level-ups and process them
 * Called on game load and when displaying stats to catch any missed level-ups
 * @returns {Promise<object>} Result with levelsGained, newLevel
 */
async function checkForLevelUp() {
    if (!currentMaze?.isOpen || !currentMaze.character) {
        return { levelsGained: 0, newLevel: 1 };
    }

    const character = currentMaze.character;
    const profile = extensionSettings.maze.profiles?.[currentMaze.profileName] || {};

    // Ensure xpToNextLevel is set correctly
    if (!character.xpToNextLevel || character.xpToNextLevel <= 0) {
        character.xpToNextLevel = getXpForLevel(character.level + 1);
    }

    let levelsGained = 0;

    // Process any pending level-ups
    while (character.xp >= character.xpToNextLevel) {
        character.xp -= character.xpToNextLevel;
        character.level++;

        // v2.0.5: Roll dice for skill points (configurable)
        const skillPointDice = profile.skillPointDice || '1d3';
        const skillPointsGained = rollDice(skillPointDice);
        character.skillPoints += skillPointsGained;

        character.xpToNextLevel = getXpForLevel(character.level + 1);
        levelsGained++;

        // Apply HP bonus from level up
        const levelStats = getLevelStats(character.level);
        if (currentMaze.hpEnabled && currentMaze.hp) {
            const oldMax = currentMaze.hp.max;
            currentMaze.hp.max = 100 + levelStats.maxHpBonus + (currentMaze.hp.maxBonus || 0);
            currentMaze.hp.current = Math.min(currentMaze.hp.current + (currentMaze.hp.max - oldMax), currentMaze.hp.max);
            updateHpDisplay();
        }

        // Fire level up hook
        if (profile.onLevelUp) {
            await fireHook(profile.onLevelUp, {
                newLevel: character.level,
                skillPointsAvailable: character.skillPoints,
                skillPointsGained: skillPointsGained,
                skillPointDice: skillPointDice,
                stats: levelStats,
            });
        }

        // Show level up message in log
        addToMessageLog(`Level Up! You are now level ${character.level}! Rolled ${skillPointDice}: +${skillPointsGained} skill points!`, 'success');

        // v2.0.5: Show /echo notification for level-up with dice roll
        try {
            const echoMessage = `🎉 **LEVEL UP!** You are now **Level ${character.level}**!\n` +
                `🎲 Rolled ${skillPointDice}: **+${skillPointsGained} Skill Points**\n` +
                `📊 Total Skill Points: ${character.skillPoints}`;
            await executeSlashCommandsWithOptions(`/echo ${echoMessage}`);
        } catch (e) {
            console.log('[MazeMaster] Could not show level-up echo:', e);
        }

        // Play level up sound and VFX
        playSound('level_up');
        const mazeContainer = document.querySelector('.maze-container') || document.querySelector('#mazemaster_grid');
        if (mazeContainer) {
            triggerVFX('level_up', mazeContainer);
        }

        console.log(`[MazeMaster] Level up! Now level ${character.level}, gained ${skillPointsGained} skill points`);
    }

    if (levelsGained > 0) {
        updatePlayerStatsDisplay();
        console.log(`[MazeMaster] checkForLevelUp processed ${levelsGained} level(s)`);
    }

    return {
        levelsGained: levelsGained,
        newLevel: character.level,
    };
}

/**
 * Get total attack including level bonuses
 * @returns {number} Attack bonus from level
 */
function getLevelAttackBonus() {
    if (!currentMaze?.isOpen || !currentMaze.character) return 0;
    return getLevelStats(currentMaze.character.level).attackBonus;
}

/**
 * Get total defense including level bonuses
 * @returns {number} Defense bonus from level
 */
function getLevelDefenseBonus() {
    if (!currentMaze?.isOpen || !currentMaze.character) return 0;
    return getLevelStats(currentMaze.character.level).defenseBonus;
}

/**
 * Update the player stats panel UI
 */
function updatePlayerStatsDisplay() {
    if (!currentMaze?.isOpen) return;

    const character = currentMaze.character;
    const equipStats = getEquippedStats();
    const levelStats = getLevelStats(character.level);

    // Level and XP
    $('#player_level').text(character.level);
    $('#player_xp_current').text(character.xp);
    $('#player_xp_needed').text(character.xpToNextLevel);
    const xpPercent = (character.xp / character.xpToNextLevel) * 100;
    $('#player_xp_fill').css('width', `${xpPercent}%`);

    // HP
    if (currentMaze.hpEnabled && currentMaze.hp) {
        $('#player_stat_hp').text(`${currentMaze.hp.current}/${currentMaze.hp.max}`);
    } else {
        $('#player_stat_hp').text('Disabled');
    }

    // Attack (level + equipment)
    const totalAtk = levelStats.attackBonus + equipStats.attack;
    $('#player_stat_atk').html(`${totalAtk} <span class="stat-bonus">${levelStats.attackBonus > 0 ? `(+${levelStats.attackBonus} lvl` : ''}${equipStats.attack > 0 ? ` +${equipStats.attack} eq)` : levelStats.attackBonus > 0 ? ')' : ''}</span>`);

    // Defense (level + equipment)
    const totalDef = levelStats.defenseBonus + equipStats.defense;
    $('#player_stat_def').html(`${totalDef} <span class="stat-bonus">${levelStats.defenseBonus > 0 ? `(+${levelStats.defenseBonus} lvl` : ''}${equipStats.defense > 0 ? ` +${equipStats.defense} eq)` : levelStats.defenseBonus > 0 ? ')' : ''}</span>`);

    // Crit (base 5% + equipment)
    const baseCrit = 5;
    const totalCrit = baseCrit + equipStats.critBonus;
    $('#player_stat_crit').html(`${totalCrit}% ${equipStats.critBonus > 0 ? `<span class="stat-bonus">(+${equipStats.critBonus}% eq)</span>` : ''}`);

    // Skill points
    $('#player_skill_points').text(character.skillPoints);

    // Equipment summary
    // v2.0.3: Fix equipment display - item may be an object or string ID
    const equipSummaryHtml = ['weapon', 'armor', 'accessory'].map(slot => {
        const item = currentMaze.equipment[slot];
        const icons = { weapon: 'fa-sword', armor: 'fa-shield', accessory: 'fa-ring' };
        let itemName = 'Empty';
        if (item) {
            // Item can be an object (with name property) or a string ID
            if (typeof item === 'object' && item.name) {
                itemName = item.name;
            } else if (typeof item === 'string') {
                itemName = getEquipment(item)?.name || item;
            } else {
                itemName = 'Unknown';
            }
        }
        return `
            <div class="equip-slot-row">
                <span class="equip-slot-icon"><i class="fa-solid ${icons[slot]}"></i></span>
                <span class="equip-slot-name">${slot.toUpperCase()}</span>
                <span class="equip-slot-item${item ? '' : ' empty'}">${itemName}</span>
            </div>
        `;
    }).join('');
    $('#player_equip_summary').html(equipSummaryHtml);
}

/**
 * Toggle the player stats panel
 */
function togglePlayerPanel() {
    console.log('[MazeMaster] togglePlayerPanel() called');
    const panel = document.getElementById('maze_player_panel');
    const backdrop = document.getElementById('maze_player_backdrop');
    const btn = document.getElementById('maze_player_btn');
    console.log('[MazeMaster] Player panel elements - panel:', !!panel, 'backdrop:', !!backdrop, 'btn:', !!btn);

    if (!panel || !backdrop) {
        console.warn('[MazeMaster] Player panel elements not found!');
        return;
    }

    const isVisible = panel.style.display !== 'none' && panel.style.display !== '';
    console.log('[MazeMaster] Panel currently visible:', isVisible, 'display:', panel.style.display);

    if (isVisible) {
        panel.style.display = 'none';
        backdrop.style.display = 'none';
        btn?.classList.remove('active');
        console.log('[MazeMaster] Player panel hidden');
    } else {
        // Ensure character data exists
        if (currentMaze?.isOpen) {
            if (!currentMaze.character) {
                currentMaze.character = { level: 1, xp: 0, xpToNextLevel: 100, skillPoints: 0 };
            }
            if (!currentMaze.equipment) {
                currentMaze.equipment = { weapon: null, armor: null, accessory: null };
            }
            if (!currentMaze.skills) {
                currentMaze.skills = { learned: {}, active: {} };
            }
            try {
                updatePlayerStatsDisplay();
            } catch (e) {
                console.warn('[MazeMaster] Error updating player stats:', e);
            }
        }
        panel.style.display = 'flex';
        backdrop.style.display = 'block';
        btn?.classList.add('active');
        console.log('[MazeMaster] Player panel shown');
    }
}

// =============================================================================
// SKILLS SYSTEM FUNCTIONS
// =============================================================================

/**
 * Check if player can learn a skill
 * @param {string} skillId - Skill to check
 * @returns {object} { canLearn, reason }
 */
function canLearnSkill(skillId) {
    if (!currentMaze?.isOpen || !currentMaze.skills) {
        return { canLearn: false, reason: 'No active maze' };
    }

    const skill = getSkill(skillId);
    if (!skill) {
        return { canLearn: false, reason: 'Skill not found' };
    }

    const currentRank = currentMaze.skills.learned[skillId] || 0;
    const maxRank = skill.ranks.length;

    // Check if already maxed
    if (currentRank >= maxRank) {
        return { canLearn: false, reason: 'Skill already maxed' };
    }

    // Check skill points
    if (currentMaze.character.skillPoints <= 0) {
        return { canLearn: false, reason: 'No skill points available' };
    }

    // Check prerequisites (only for first rank)
    if (currentRank === 0 && skill.prerequisites.length > 0) {
        for (const prereq of skill.prerequisites) {
            if (!currentMaze.skills.learned[prereq]) {
                const prereqSkill = getSkill(prereq);
                return { canLearn: false, reason: `Requires ${prereqSkill?.name || prereq}` };
            }
        }
    }

    return { canLearn: true, reason: null };
}

/**
 * Learn or upgrade a skill
 * @param {string} skillId - Skill to learn
 * @returns {object} { success, newRank, message }
 */
async function learnSkill(skillId) {
    const check = canLearnSkill(skillId);
    if (!check.canLearn) {
        return { success: false, newRank: 0, message: check.reason };
    }

    const skill = getSkill(skillId);
    const currentRank = currentMaze.skills.learned[skillId] || 0;
    const newRank = currentRank + 1;

    // Spend skill point
    currentMaze.character.skillPoints--;
    currentMaze.skills.learned[skillId] = newRank;

    // Auto-add to ability bar if it's an active skill and bar has space
    if (skill.type === 'active' && currentRank === 0) {
        if (currentMaze.skills.abilityBar.length < 5) {
            currentMaze.skills.abilityBar.push(skillId);
        }
    }

    // Fire hook
    const profile = extensionSettings.maze.profiles?.[currentMaze.profileName] || {};
    if (profile.onSkillLearn) {
        await fireHook(profile.onSkillLearn, {
            skillId,
            skillName: skill.name,
            rank: newRank,
            tree: skill.tree,
        });
    }

    // Update UI
    updateSkillTreeDisplay();
    updateAbilityBarDisplay();
    updatePlayerStatsDisplay();

    const rankText = newRank === 1 ? 'learned' : `upgraded to rank ${newRank}`;
    addToMessageLog(`${skill.name} ${rankText}!`, 'success');

    return { success: true, newRank, message: `${skill.name} ${rankText}` };
}

/**
 * Check if a skill can be used right now
 * @param {string} skillId - Skill to check
 * @param {boolean} inCombat - Whether currently in combat
 * @returns {object} { canUse, reason }
 */
function canUseSkill(skillId, inCombat = false) {
    if (!currentMaze?.isOpen || !currentMaze.skills) {
        return { canUse: false, reason: 'No active maze' };
    }

    const skill = getSkill(skillId);
    if (!skill) {
        return { canUse: false, reason: 'Skill not found' };
    }

    const rank = currentMaze.skills.learned[skillId];
    if (!rank) {
        return { canUse: false, reason: 'Skill not learned' };
    }

    if (skill.type === 'passive') {
        return { canUse: false, reason: 'Passive skills cannot be activated' };
    }

    // Check cooldown
    const cooldown = currentMaze.skills.cooldowns[skillId] || 0;
    if (cooldown > 0) {
        return { canUse: false, reason: `On cooldown (${cooldown} turns)` };
    }

    // Check combat context
    if (!inCombat && !skill.usableOutsideCombat) {
        return { canUse: false, reason: 'Only usable in combat' };
    }

    return { canUse: true, reason: null };
}

/**
 * Use an active skill
 * @param {string} skillId - Skill to use
 * @param {object} context - Context data (target, position, etc.)
 * @returns {object} { success, effect, message }
 */
async function useSkill(skillId, context = {}) {
    const inCombat = context.inCombat ?? (currentTurnBased?.isOpen || false);
    const check = canUseSkill(skillId, inCombat);
    if (!check.canUse) {
        return { success: false, effect: null, message: check.reason };
    }

    const skill = getSkill(skillId);
    const rank = currentMaze.skills.learned[skillId];
    const effect = getSkillEffect(skillId, rank);

    // Apply cooldown (reduced by Mana Surge if learned)
    let cooldown = skill.cooldown;
    const manaSurgeRank = currentMaze.skills.learned['magic_mana_surge'] || 0;
    if (manaSurgeRank > 0) {
        const surgeEffect = getSkillEffect('magic_mana_surge', manaSurgeRank);
        cooldown = Math.max(0, cooldown - (surgeEffect.cooldownReduction || 0));
    }
    if (cooldown > 0) {
        currentMaze.skills.cooldowns[skillId] = cooldown;
    }

    // Handle duration-based effects
    if (skill.duration) {
        currentMaze.skills.activeEffects.push({
            skillId,
            effect: effect,
            turnsRemaining: skill.duration,
            data: context,
        });
    }

    // Fire hook
    const profile = extensionSettings.maze.profiles?.[currentMaze.profileName] || {};
    if (profile.onSkillUse) {
        await fireHook(profile.onSkillUse, {
            skillId,
            skillName: skill.name,
            rank,
            effect: JSON.stringify(effect),
        });
    }

    // Update UI
    updateAbilityBarDisplay();

    return { success: true, effect, message: `Used ${skill.name}!` };
}

/**
 * v1.5.0: Execute player combat skill effects (damage, status effects)
 * @param {string} skillId - The skill to execute
 * @returns {object} Result with damage dealt, status applied, etc.
 */
async function executePlayerCombatSkill(skillId) {
    if (!currentTurnBased?.isOpen) {
        return { success: false, message: 'Not in combat' };
    }

    const result = await useSkill(skillId, { inCombat: true });
    if (!result.success) {
        return result;
    }

    const skill = getSkill(skillId);
    const effect = result.effect;
    let damage = 0;
    let statusApplied = null;

    // Handle skill-specific combat effects
    switch (skillId) {
        case 'magic_fireball':
            // Deal fire damage
            damage = effect.damage || 20;
            currentTurnBased.enemyHP = Math.max(0, currentTurnBased.enemyHP - damage);
            flashHPBar(false, true);
            addTBLogEntry(`<span class="tb-log-burn">Fireball hits for ${damage} fire damage!</span>`);

            // Roll for burn
            if (Math.random() * 100 < (effect.burnChance || 20)) {
                applyStatusEffect('enemy', 'burning');
                statusApplied = 'burning';
                addTBLogEntry(`<span class="tb-log-burn">The enemy is burning!</span>`);
            }
            break;

        case 'magic_arcane_blast':
            // Deal AoE magic damage
            damage = effect.damage || 50;
            currentTurnBased.enemyHP = Math.max(0, currentTurnBased.enemyHP - damage);
            flashHPBar(false, true);
            addTBLogEntry(`<span class="tb-log-crit">Arcane Blast deals ${damage} damage!</span>`);
            break;

        case 'combat_power_strike':
            // Already handled in calculateDamage via active effects
            addTBLogEntry(`<span class="tb-log-damage">You prepare a powerful strike!</span>`);
            break;

        case 'combat_berserker':
            // Buff handled via active effects, add enraged for visual
            applyStatusEffect('player', 'enraged', 3);
            addTBLogEntry(`<span class="tb-log-crit">You enter a berserker rage!</span>`);
            break;

        case 'combat_execution':
            // Check if enemy is below 20% HP
            const hpPercent = (currentTurnBased.enemyHP / currentTurnBased.enemyMaxHP) * 100;
            if (hpPercent <= 20) {
                currentTurnBased.enemyHP = 0;
                addTBLogEntry(`<span class="tb-log-crit">EXECUTION! You slay the weakened enemy!</span>`);
            } else {
                addTBLogEntry(`<span class="tb-log-damage">Enemy HP too high for Execution (needs ≤20%)</span>`);
            }
            break;

        case 'magic_ice_shield':
            // Shield effect is handled in processEnemyTurn via activeEffects
            applyStatusEffect('player', 'shielded', effect.duration || 2);
            addTBLogEntry(`<span class="tb-log-freeze">You conjure an Ice Shield!</span>`);
            break;

        case 'stealth_smoke_bomb':
            // Attempt to flee combat
            addTBLogEntry(`<span class="tb-log-flee">You throw a smoke bomb and escape!</span>`);
            currentTurnBased.isVictory = false;
            currentTurnBased.isDefeat = false;
            clearAllStatusEffects();
            showTurnBasedResult('fled');
            return { success: true, escaped: true, message: 'Escaped with Smoke Bomb!' };

        case 'stealth_assassinate':
            // High chance instant kill on first strike
            if (currentTurnBased.isFirstStrike) {
                const killChance = effect.killChance || 50;
                if (Math.random() * 100 < killChance) {
                    currentTurnBased.enemyHP = 0;
                    addTBLogEntry(`<span class="tb-log-crit">ASSASSINATE! Instant kill from the shadows!</span>`);
                } else {
                    damage = Math.round(currentTurnBased.enemyMaxHP * 0.5);
                    currentTurnBased.enemyHP = Math.max(0, currentTurnBased.enemyHP - damage);
                    flashHPBar(false, true);
                    addTBLogEntry(`<span class="tb-log-damage">Assassination attempt: ${damage} damage!</span>`);
                }
            } else {
                addTBLogEntry(`<span class="tb-log-damage">Assassinate only works on first strike!</span>`);
            }
            break;

        case 'stealth_vanish':
            // Go invisible - guaranteed crit on next attack
            addTBLogEntry(`<span class="tb-log-flee">You vanish into the shadows...</span>`);
            // Vanish effect handled in calculateDamage via activeEffects
            break;
    }

    updateStatusEffectsDisplay();

    // Check for victory
    if (currentTurnBased.enemyHP <= 0) {
        await handleTurnBasedWin();
        return { success: true, damage, statusApplied, victory: true };
    }

    return { success: true, damage, statusApplied, effect };
}

/**
 * Tick all skill cooldowns (called at end of combat turn)
 */
function tickSkillCooldowns() {
    if (!currentMaze?.skills?.cooldowns) return;

    for (const skillId of Object.keys(currentMaze.skills.cooldowns)) {
        if (currentMaze.skills.cooldowns[skillId] > 0) {
            currentMaze.skills.cooldowns[skillId]--;
            if (currentMaze.skills.cooldowns[skillId] <= 0) {
                delete currentMaze.skills.cooldowns[skillId];
            }
        }
    }

    // Tick active effects
    currentMaze.skills.activeEffects = currentMaze.skills.activeEffects.filter(eff => {
        eff.turnsRemaining--;
        return eff.turnsRemaining > 0;
    });

    updateAbilityBarDisplay();
}

/**
 * Get aggregate passive skill bonuses
 * @returns {object} Combined passive effects
 */
function getPassiveSkillBonuses() {
    const bonuses = {
        critBonus: 0,
        lifestealPercent: 0,
        firstStrikeBonus: 0,
        damageBonus: 0,
        damageReduction: 0,
    };

    if (!currentMaze?.skills?.learned) return bonuses;

    for (const [skillId, rank] of Object.entries(currentMaze.skills.learned)) {
        const skill = getSkill(skillId);
        if (!skill || skill.type !== 'passive') continue;

        const effect = getSkillEffect(skillId, rank);
        if (!effect) continue;

        // Aggregate all passive bonuses
        if (effect.critBonus) bonuses.critBonus += effect.critBonus;
        if (effect.lifestealPercent) bonuses.lifestealPercent += effect.lifestealPercent;
        if (effect.firstStrikeBonus) bonuses.firstStrikeBonus += effect.firstStrikeBonus;
    }

    return bonuses;
}

/**
 * Get active skill effects currently in play
 * @returns {object} Combined active effects
 */
function getActiveSkillEffects() {
    const effects = {
        damageBonus: 0,
        damageReduction: 0,
        freezeChance: 0,
        guaranteedCrit: false,
    };

    if (!currentMaze?.skills?.activeEffects) return effects;

    for (const active of currentMaze.skills.activeEffects) {
        const eff = active.effect;
        if (eff.damageBonus) effects.damageBonus += eff.damageBonus;
        if (eff.damageReduction) effects.damageReduction += eff.damageReduction;
        if (eff.freezeChance) effects.freezeChance += eff.freezeChance;
        if (eff.guaranteedCrit) effects.guaranteedCrit = true;
    }

    return effects;
}

/**
 * Update the skill tree panel display
 */
function updateSkillTreeDisplay() {
    if (!currentMaze?.isOpen) return;

    const container = $('#skill_tree_content');
    if (!container.length) return;

    const skillPoints = currentMaze.character.skillPoints;
    $('#skill_points_display').text(skillPoints);

    // Build skill trees
    let html = '';
    for (const [treeId, tree] of Object.entries(SKILL_TREES)) {
        const skills = getSkillsByTree(treeId).sort((a, b) => a.tier - b.tier);

        html += `
            <div class="skill-tree" data-tree="${treeId}">
                <div class="skill-tree-header" style="border-color: ${tree.color};">
                    <i class="fa-solid ${tree.icon}" style="color: ${tree.color};"></i>
                    <span>${tree.name}</span>
                </div>
                <div class="skill-tree-skills">
        `;

        for (const skill of skills) {
            const rank = currentMaze.skills.learned[skill.id] || 0;
            const maxRank = skill.ranks.length;
            const canLearn = canLearnSkill(skill.id);
            const effect = rank > 0 ? getSkillEffect(skill.id, rank) : skill.ranks[0];

            const stateClass = rank > 0 ? 'learned' : (canLearn.canLearn ? 'available' : 'locked');
            const typeIcon = skill.type === 'active' ? 'fa-bolt' : 'fa-circle';

            html += `
                <div class="skill-node ${stateClass}" data-skill="${skill.id}" style="--tree-color: ${tree.color};">
                    <div class="skill-node-header">
                        <i class="fa-solid ${typeIcon}"></i>
                        <span class="skill-name">${skill.name}</span>
                        <span class="skill-rank">${rank}/${maxRank}</span>
                    </div>
                    <div class="skill-node-desc">${effect.description}</div>
                    ${skill.cooldown > 0 ? `<div class="skill-cooldown"><i class="fa-solid fa-clock"></i> ${skill.cooldown} turns</div>` : ''}
                    ${canLearn.canLearn ? `<button class="skill-learn-btn" data-skill="${skill.id}">Learn</button>` : ''}
                    ${!canLearn.canLearn && rank === 0 ? `<div class="skill-locked-reason">${canLearn.reason}</div>` : ''}
                </div>
            `;
        }

        html += '</div></div>';
    }

    container.html(html);
}

/**
 * Update the ability bar display
 */
function updateAbilityBarDisplay() {
    if (!currentMaze?.isOpen) return;

    const bar = $('#ability_bar');
    if (!bar.length) return;

    let html = '';
    const abilityBar = currentMaze.skills.abilityBar || [];

    for (let i = 0; i < 5; i++) {
        const skillId = abilityBar[i];
        const hotkey = i + 1;

        if (skillId) {
            const skill = getSkill(skillId);
            const rank = currentMaze.skills.learned[skillId] || 0;
            const cooldown = currentMaze.skills.cooldowns[skillId] || 0;
            const tree = SKILL_TREES[skill.tree];
            const canUse = cooldown === 0;

            html += `
                <div class="ability-slot ${canUse ? 'ready' : 'on-cooldown'}" data-skill="${skillId}" data-slot="${i}" style="--ability-color: ${tree.color};">
                    <span class="ability-hotkey">${hotkey}</span>
                    <span class="ability-name">${skill.name}</span>
                    ${cooldown > 0 ? `<span class="ability-cooldown">${cooldown}</span>` : ''}
                </div>
            `;
        } else {
            html += `
                <div class="ability-slot empty" data-slot="${i}">
                    <span class="ability-hotkey">${hotkey}</span>
                    <span class="ability-empty">-</span>
                </div>
            `;
        }
    }

    bar.html(html);
}

/**
 * Toggle the skill tree panel
 */
function toggleSkillTreePanel() {
    console.log('[MazeMaster] toggleSkillTreePanel() called');
    const panel = document.getElementById('maze_skill_panel');
    const backdrop = document.getElementById('maze_skill_backdrop');
    const btn = document.getElementById('maze_skills_btn');
    console.log('[MazeMaster] Skill panel elements - panel:', !!panel, 'backdrop:', !!backdrop, 'btn:', !!btn);

    if (!panel || !backdrop) {
        console.warn('[MazeMaster] Skill panel elements not found!');
        return;
    }

    const isVisible = panel.style.display !== 'none' && panel.style.display !== '';
    console.log('[MazeMaster] Panel currently visible:', isVisible, 'display:', panel.style.display);

    if (isVisible) {
        panel.style.display = 'none';
        backdrop.style.display = 'none';
        btn?.classList.remove('active');
        console.log('[MazeMaster] Skill panel hidden');
    } else {
        // Ensure skills data exists
        if (currentMaze?.isOpen) {
            if (!currentMaze.character) {
                currentMaze.character = { level: 1, xp: 0, xpToNextLevel: 100, skillPoints: 0 };
            }
            if (!currentMaze.skills) {
                currentMaze.skills = { learned: {}, active: {} };
            }
            try {
                updateSkillTreeDisplay();
            } catch (e) {
                console.warn('[MazeMaster] Error updating skill tree:', e);
            }
        }
        panel.style.display = 'flex';
        backdrop.style.display = 'block';
        btn?.classList.add('active');
        console.log('[MazeMaster] Skill panel shown');
    }
}

/**
 * Toggle the quest panel
 */
function toggleQuestPanel() {
    const panel = document.getElementById('maze_quest_panel');
    const backdrop = document.getElementById('maze_quest_backdrop');
    const btn = document.getElementById('maze_quest_btn');

    if (!panel || !backdrop) {
        console.warn('[MazeMaster] Quest panel elements not found!');
        return;
    }

    const isVisible = panel.style.display !== 'none' && panel.style.display !== '';

    if (isVisible) {
        panel.style.display = 'none';
        backdrop.style.display = 'none';
        btn?.classList.remove('active');
    } else {
        updateQuestDisplay('active');
        panel.style.display = 'flex';
        backdrop.style.display = 'block';
        btn?.classList.add('active');
    }
}

/**
 * Update quest display based on selected tab
 * @param {string} tab - 'active', 'available', or 'completed'
 */
function updateQuestDisplay(tab = 'active') {
    const container = $('#quest_list_content');
    if (!container.length) return;

    if (!currentMaze.quests) {
        currentMaze.quests = initializeQuestState();
    }

    let html = '';

    if (tab === 'active') {
        if (currentMaze.quests.active.length === 0) {
            html = '<div class="quest-empty-message">No active quests. Check available quests!</div>';
        } else {
            for (const activeQuest of currentMaze.quests.active) {
                const quest = getQuest(activeQuest.questId);
                if (!quest) continue;

                const questType = getQuestType(quest.type);
                const progress = activeQuest.progress || 0;
                const required = quest.objective?.count || 1;
                const percent = Math.min(100, (progress / required) * 100);

                html += `
                    <div class="quest-card" data-quest="${activeQuest.questId}">
                        <div class="quest-card-header">
                            <h4 class="quest-card-title">${quest.name}</h4>
                            <span class="quest-card-type"><i class="fa-solid ${questType.icon}"></i> ${questType.name}</span>
                        </div>
                        <div class="quest-card-description">${quest.description}</div>
                        <div class="quest-progress-bar">
                            <div class="quest-progress-fill" style="width: ${percent}%;"></div>
                        </div>
                        <div class="quest-progress-text">${progress} / ${required}</div>
                        <div class="quest-rewards">
                            ${quest.rewards?.xp ? `<span class="quest-reward-item"><i class="fa-solid fa-star"></i> ${quest.rewards.xp} XP</span>` : ''}
                        </div>
                        <div class="quest-actions">
                            <button class="quest-abandon-btn" data-quest="${activeQuest.questId}">Abandon</button>
                        </div>
                    </div>
                `;
            }
        }
    } else if (tab === 'available') {
        if (currentMaze.quests.available.length === 0) {
            html = '<div class="quest-empty-message">No quests available at this time.</div>';
        } else {
            for (const availableQuest of currentMaze.quests.available) {
                const quest = getQuest(availableQuest.questId);
                if (!quest) continue;

                const questType = getQuestType(quest.type);
                const required = quest.objective?.count || 1;

                html += `
                    <div class="quest-card" data-quest="${availableQuest.questId}">
                        <div class="quest-card-header">
                            <h4 class="quest-card-title">${quest.name}</h4>
                            <span class="quest-card-type"><i class="fa-solid ${questType.icon}"></i> ${questType.name}</span>
                        </div>
                        <div class="quest-card-description">${quest.description}</div>
                        <div class="quest-progress-text">Objective: ${required} ${quest.objective?.target || 'progress'}</div>
                        <div class="quest-rewards">
                            ${quest.rewards?.xp ? `<span class="quest-reward-item"><i class="fa-solid fa-star"></i> ${quest.rewards.xp} XP</span>` : ''}
                        </div>
                        <div class="quest-actions">
                            <button class="quest-accept-btn" data-quest="${availableQuest.questId}">Accept Quest</button>
                        </div>
                    </div>
                `;
            }
        }
    } else if (tab === 'completed') {
        if (currentMaze.quests.completed.length === 0) {
            html = '<div class="quest-empty-message">No quests completed yet.</div>';
        } else {
            for (const questId of currentMaze.quests.completed) {
                const quest = getQuest(questId);
                if (!quest) continue;

                const questType = getQuestType(quest.type);

                html += `
                    <div class="quest-card" data-quest="${questId}">
                        <div class="quest-card-header">
                            <h4 class="quest-card-title">${quest.name}</h4>
                            <span class="quest-completed-badge"><i class="fa-solid fa-check-circle"></i> Completed</span>
                        </div>
                        <div class="quest-card-description">${quest.description}</div>
                        <div class="quest-card-type"><i class="fa-solid ${questType.icon}"></i> ${questType.name}</div>
                    </div>
                `;
            }
        }
    }

    container.html(html);
}

// =============================================================================
// STATUS EFFECT FUNCTIONS
// =============================================================================

/**
 * Apply a status effect to a target
 * @param {string} target - 'player' or 'enemy'
 * @param {string} effectId - Status effect ID
 * @param {number} duration - Override duration (optional)
 * @returns {boolean} Whether effect was applied
 */
function applyStatusEffect(target, effectId, duration = null) {
    if (!currentTurnBased?.isOpen) return false;

    const effect = getStatusEffect(effectId);
    if (!effect) return false;

    const effects = target === 'player'
        ? currentTurnBased.playerStatusEffects
        : currentTurnBased.enemyStatusEffects;

    // Check if already has this effect
    const existing = effects.find(e => e.effectId === effectId);
    if (existing) {
        // Refresh duration
        existing.turnsRemaining = Math.max(existing.turnsRemaining, duration || effect.duration);
        return true;
    }

    // Add new effect
    effects.push({
        effectId,
        turnsRemaining: duration || effect.duration,
    });

    // Log message
    const targetName = target === 'player' ? 'You' : 'Enemy';
    addTBLogEntry(`${targetName} ${effect.applyMessage}`);

    updateStatusEffectsDisplay();
    return true;
}

/**
 * Remove a status effect from a target
 * @param {string} target - 'player' or 'enemy'
 * @param {string} effectId - Status effect ID to remove
 */
function removeStatusEffect(target, effectId) {
    if (!currentTurnBased?.isOpen) return;

    const effects = target === 'player'
        ? currentTurnBased.playerStatusEffects
        : currentTurnBased.enemyStatusEffects;

    const index = effects.findIndex(e => e.effectId === effectId);
    if (index !== -1) {
        const effect = getStatusEffect(effectId);
        const targetName = target === 'player' ? 'You' : 'Enemy';
        addTBLogEntry(`${targetName} ${effect.expireMessage}`);
        effects.splice(index, 1);
        updateStatusEffectsDisplay();
    }
}

/**
 * Check if target has a specific status effect
 * @param {string} target - 'player' or 'enemy'
 * @param {string} effectId - Status effect ID to check
 * @returns {boolean}
 */
function hasStatusEffect(target, effectId) {
    if (!currentTurnBased?.isOpen) return false;

    const effects = target === 'player'
        ? currentTurnBased.playerStatusEffects
        : currentTurnBased.enemyStatusEffects;

    return effects.some(e => e.effectId === effectId);
}

/**
 * Check if target should skip their turn due to CC effects
 * @param {string} target - 'player' or 'enemy'
 * @returns {boolean}
 */
function shouldSkipTurn(target) {
    if (!currentTurnBased?.isOpen) return false;

    const effects = target === 'player'
        ? currentTurnBased.playerStatusEffects
        : currentTurnBased.enemyStatusEffects;

    for (const eff of effects) {
        const effect = getStatusEffect(eff.effectId);
        if (effect?.skipTurn) {
            const targetName = target === 'player' ? 'You are' : 'Enemy is';
            addTBLogEntry(`${targetName} ${effect.tickMessage}!`);
            return true;
        }
    }

    return false;
}

/**
 * Process status effects at start of a target's turn (DoT, tick durations)
 * @param {string} target - 'player' or 'enemy'
 * @returns {number} Total DoT damage dealt
 */
function processStatusEffects(target) {
    if (!currentTurnBased?.isOpen) return 0;

    const effects = target === 'player'
        ? currentTurnBased.playerStatusEffects
        : currentTurnBased.enemyStatusEffects;

    let totalDotDamage = 0;
    const expiredEffects = [];

    for (const eff of effects) {
        const effect = getStatusEffect(eff.effectId);
        if (!effect) continue;

        // Process DoT damage
        if (effect.type === 'dot' && effect.dotPercent) {
            const maxHP = target === 'player'
                ? currentTurnBased.playerMaxHP
                : currentTurnBased.enemyMaxHP;
            const dotDamage = Math.max(1, Math.floor(maxHP * effect.dotPercent / 100));
            totalDotDamage += dotDamage;

            const targetName = target === 'player' ? 'You take' : 'Enemy takes';
            addTBLogEntry(`${targetName} ${dotDamage} ${effect.name.toLowerCase()} damage!`);
        }

        // Tick duration
        eff.turnsRemaining--;
        if (eff.turnsRemaining <= 0) {
            expiredEffects.push(eff.effectId);
        }
    }

    // Remove expired effects
    for (const effectId of expiredEffects) {
        removeStatusEffect(target, effectId);
    }

    return totalDotDamage;
}

/**
 * Get damage modifiers from status effects
 * @param {string} target - 'player' or 'enemy'
 * @returns {object} { damageBonus, damageReduction }
 */
function getStatusDamageModifiers(target) {
    const modifiers = { damageBonus: 0, damageReduction: 0 };

    if (!currentTurnBased?.isOpen) return modifiers;

    const effects = target === 'player'
        ? currentTurnBased.playerStatusEffects
        : currentTurnBased.enemyStatusEffects;

    for (const eff of effects) {
        const effect = getStatusEffect(eff.effectId);
        if (!effect) continue;

        if (effect.damageBonus) modifiers.damageBonus += effect.damageBonus;
        if (effect.damageReduction && effect.type === 'debuff') {
            // Debuff reduces damage dealt
            modifiers.damageReduction += effect.damageReduction;
        }
    }

    return modifiers;
}

/**
 * Get defense modifiers from status effects (for damage taken)
 * @param {string} target - 'player' or 'enemy'
 * @returns {object} { damageReduction }
 */
function getStatusDefenseModifiers(target) {
    const modifiers = { damageReduction: 0 };

    if (!currentTurnBased?.isOpen) return modifiers;

    const effects = target === 'player'
        ? currentTurnBased.playerStatusEffects
        : currentTurnBased.enemyStatusEffects;

    for (const eff of effects) {
        const effect = getStatusEffect(eff.effectId);
        if (!effect) continue;

        // Buff type damage reduction applies to damage taken
        if (effect.damageReduction && effect.type === 'buff') {
            modifiers.damageReduction += effect.damageReduction;
        }
    }

    return modifiers;
}

/**
 * Clear all status effects (called at combat end)
 */
function clearAllStatusEffects() {
    if (!currentTurnBased) return;
    currentTurnBased.playerStatusEffects = [];
    currentTurnBased.enemyStatusEffects = [];
}

/**
 * Update the status effects display in combat UI
 */
function updateStatusEffectsDisplay() {
    if (!currentTurnBased?.isOpen) return;

    // Player effects
    const playerEffectsHtml = currentTurnBased.playerStatusEffects.map(eff => {
        const effect = getStatusEffect(eff.effectId);
        if (!effect) return '';
        return `<span class="status-effect-icon" style="color: ${effect.color};" title="${effect.name} (${eff.turnsRemaining} turns)">
            <i class="fa-solid ${effect.icon}"></i>
        </span>`;
    }).join('');

    // Enemy effects
    const enemyEffectsHtml = currentTurnBased.enemyStatusEffects.map(eff => {
        const effect = getStatusEffect(eff.effectId);
        if (!effect) return '';
        return `<span class="status-effect-icon" style="color: ${effect.color};" title="${effect.name} (${eff.turnsRemaining} turns)">
            <i class="fa-solid ${effect.icon}"></i>
        </span>`;
    }).join('');

    $('#tb_player_status_effects').html(playerEffectsHtml);
    $('#tb_enemy_status_effects').html(enemyEffectsHtml);
}

/**
 * Execute an enemy ability with status effects and damage
 * @param {object} ability - The ability to execute
 * @returns {object} { damage, appliedEffect }
 */
function executeEnemyAbility(ability) {
    let damage = 0;
    let appliedEffect = null;

    const profile = currentTurnBased.profile;
    const baseAttack = profile.enemyAttack || 10;
    const baseDefense = 5; // Player base defense

    // Calculate base damage with multiplier
    if (ability.damageMultiplier > 0) {
        const attackValue = Math.round(baseAttack * ability.damageMultiplier);
        // Apply enemy status modifiers (e.g., enraged, weakened)
        const enemyMods = getStatusDamageModifiers('enemy');
        let modifiedAttack = attackValue;
        if (enemyMods.damageBonus > 0) {
            modifiedAttack = Math.round(modifiedAttack * (1 + enemyMods.damageBonus / 100));
        }
        if (enemyMods.damageReduction > 0) {
            modifiedAttack = Math.round(modifiedAttack * (1 - enemyMods.damageReduction / 100));
        }

        // Apply player defense modifiers (shielded, etc.)
        const playerDefMods = getStatusDefenseModifiers('player');
        damage = Math.max(1, modifiedAttack - baseDefense);
        if (playerDefMods.damageReduction > 0) {
            damage = Math.round(damage * (1 - playerDefMods.damageReduction / 100));
        }

        // Apply defending bonus
        if (currentTurnBased.isDefending) {
            damage = Math.round(damage * 0.5);
        }

        damage = Math.max(1, damage);
    }

    // Apply self buff if ability has one
    if (ability.selfBuff) {
        applyStatusEffect('enemy', ability.selfBuff);
    }

    // Try to apply status effect to player
    if (ability.statusEffect && ability.statusChance) {
        if (Math.random() * 100 < ability.statusChance) {
            applyStatusEffect('player', ability.statusEffect);
            appliedEffect = ability.statusEffect;
        }
    }

    // Handle lifesteal
    if (ability.lifesteal && damage > 0) {
        const healAmount = Math.round(damage * ability.lifesteal / 100);
        currentTurnBased.enemyHP = Math.min(
            currentTurnBased.enemyMaxHP,
            currentTurnBased.enemyHP + healAmount
        );
        addTBLogEntry(`Enemy heals for ${healAmount}!`);
    }

    return { damage, appliedEffect };
}

/**
 * Trigger a chest encounter - show Open/Ignore buttons
 */
async function triggerChestEncounter(chestData, x, y) {
    currentMaze.isPaused = true;

    // Store pending chest for button handlers
    currentMaze.pendingChest = { chestData, x, y };

    // v1.4.7: Check for mercy unlock (fairness system)
    let isLocked = chestData.type === 'locked';
    let mercyUnlocked = false;
    if (isLocked && currentMaze.inventory.key === 0 && shouldMercyUnlock(currentMaze.profile)) {
        isLocked = false;
        mercyUnlocked = true;
        chestData.mercyUnlocked = true; // Mark so we give locked chest loot
    }

    const hasKey = currentMaze.inventory.key > 0;

    // Get base message
    let baseMessage;
    if (mercyUnlocked) {
        baseMessage = 'The lock on this chest is broken! Lucky you!';
    } else if (isLocked) {
        baseMessage = hasKey ? 'A locked chest! Use a key to open it?' : 'A locked chest! You need a Key to open it.';
    } else {
        baseMessage = 'You found a chest!';
    }

    // Set initial display with base message
    currentMaze.currentMinion = {
        name: isLocked ? 'Locked Chest' : 'Chest',
        imagePath: '',
        message: baseMessage,
    };
    updateMazeHero();

    // Generate LLM message
    const mainStory = currentMaze.profile?.storyConfig?.mainStory || '';
    showGeneratingIndicator(true);

    try {
        const generatedMessage = await generateChestMessage({
            chestType: isLocked ? 'locked' : 'normal',
            baseMessage,
            mainStory,
            hasKey,
        });

        currentMaze.currentMinion.message = generatedMessage;
        updateMazeHero();
    } catch (error) {
        console.error('[MazeMaster] Chest message generation failed:', error);
    } finally {
        showGeneratingIndicator(false);
    }

    // Show buttons
    showChestConfirmation(isLocked, hasKey);
}

/**
 * Show chest confirmation buttons
 */
function showChestConfirmation(isLocked, hasKey) {
    let buttons = '';
    if (isLocked) {
        if (hasKey) {
            buttons = `
                <button id="maze_chest_unlock" class="menu_button maze-confirm-btn">Unlock</button>
                <button id="maze_chest_ignore" class="menu_button maze-confirm-btn">Ignore</button>
            `;
        } else {
            buttons = `
                <button id="maze_chest_ignore" class="menu_button maze-confirm-btn">Continue</button>
            `;
        }
    } else {
        buttons = `
            <button id="maze_chest_open" class="menu_button maze-confirm-btn">Open</button>
            <button id="maze_chest_ignore" class="menu_button maze-confirm-btn">Ignore</button>
        `;
    }

    // Show buttons in popup overlay
    showActionPopup(buttons);

    // Attach handlers
    document.getElementById('maze_chest_open')?.addEventListener('click', handleChestOpen);
    document.getElementById('maze_chest_unlock')?.addEventListener('click', handleChestUnlock);
    document.getElementById('maze_chest_ignore')?.addEventListener('click', handleChestIgnore);
}

/**
 * Handle opening a normal chest
 */
function handleChestOpen() {
    hideActionPopup();

    const { chestData, x, y } = currentMaze.pendingChest || {};
    if (!chestData) return;

    // Mark as opened
    currentMaze.grid[y][x].chest.opened = true;
    renderMazeGrid();

    // Check for mimic
    if (chestData.type === 'mimic') {
        triggerMimicEncounter(x, y);
        return;
    }

    // v1.4.7: If mercy unlocked, give locked chest loot (better rewards)
    if (chestData.mercyUnlocked) {
        openLockedChest(x, y);
        return;
    }

    // Normal chest - give loot
    openNormalChest(x, y);
}

/**
 * Handle unlocking a locked chest
 */
function handleChestUnlock() {
    hideActionPopup();

    const { chestData, x, y } = currentMaze.pendingChest || {};
    if (!chestData) return;

    // Use key
    removeFromInventory('key');

    // Mark as opened
    currentMaze.grid[y][x].chest.opened = true;
    renderMazeGrid();

    // Check for mimic (locked chests can be mimics too)
    if (chestData.type === 'mimic') {
        triggerMimicEncounter(x, y);
        return;
    }

    // Give locked chest loot
    openLockedChest(x, y);
}

/**
 * Handle ignoring a chest
 */
function handleChestIgnore() {
    hideActionPopup();

    // v1.4.7: Track locked chests skipped (for fairness system)
    if (currentMaze?.pendingChest?.chestData?.type === 'locked' && currentMaze.inventory.key === 0) {
        if (currentMaze.fairness) {
            currentMaze.fairness.lockedChestsSkipped++;
            console.log(`[MazeMaster] Fairness: Locked chest skipped (total: ${currentMaze.fairness.lockedChestsSkipped})`);
        }
    }

    currentMaze.pendingChest = null;
    resumeMaze();
}

// =============================================================================
// SAFE ROOM ENCOUNTERS
// =============================================================================

/**
 * Trigger a safe room encounter with Heal/Ignore popup
 */
async function triggerSafeRoomEncounter(x, y) {
    currentMaze.isPaused = true;

    // Store pending safe room for handlers
    currentMaze.pendingSafeRoom = { x, y };

    const profile = currentMaze.profile || {};
    const healPercent = profile.safeRoomHealPercent ?? 100;
    const useLLM = profile.safeRoomUseLLM && profile.enableLLM;
    const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;
    const currentHP = currentMaze.hp.current;
    const needsHealing = currentHP < maxTotal;

    // Base message
    let baseMessage = needsHealing
        ? `A sanctuary of peace and healing. Rest here to restore ${healPercent}% of your health.`
        : 'A sanctuary of peace. You are already at full health.';

    // Set initial display
    currentMaze.currentMinion = {
        name: 'Safe Room',
        imagePath: '',
        message: baseMessage,
    };
    updateMazeHero();

    // Generate LLM message if enabled
    if (useLLM) {
        const mainStory = profile.storyConfig?.mainStory || '';
        showGeneratingIndicator(true);

        try {
            const generatedMessage = await generateSafeRoomMessage({
                baseMessage,
                mainStory,
                needsHealing,
                healPercent,
                currentHP,
                maxHP: maxTotal,
                theme: profile.theme || 'fantasy',
            });

            currentMaze.currentMinion.message = generatedMessage;
            updateMazeHero();
        } catch (error) {
            console.error('[MazeMaster] Safe room message generation failed:', error);
        } finally {
            showGeneratingIndicator(false);
        }
    }

    // Show action buttons
    showSafeRoomConfirmation(needsHealing, healPercent);
}

/**
 * Generate LLM-powered safe room message
 */
async function generateSafeRoomMessage({ baseMessage, mainStory, needsHealing, healPercent, currentHP, maxHP, theme }) {
    const prompt = `You are narrating a dungeon crawler game. The player has found a safe room (a healing sanctuary).
Theme: ${theme}
Story context: ${mainStory || 'A dangerous dungeon adventure'}
Player HP: ${currentHP}/${maxHP}
Needs healing: ${needsHealing ? 'Yes' : 'No (already at full health)'}
Heal amount: ${healPercent}%

Write a brief atmospheric description (2-3 sentences) of this safe haven. Make it match the theme. If they need healing, hint at the restorative nature of the room. Keep it immersive but concise.`;

    try {
        const response = await fetch('/api/openai/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                prompt,
                max_tokens: 150,
                temperature: 0.8,
            }),
        });

        if (response.ok) {
            const data = await response.json();
            return data.choices?.[0]?.text?.trim() || baseMessage;
        }
    } catch (error) {
        console.error('[MazeMaster] LLM safe room message failed:', error);
    }

    return baseMessage;
}

/**
 * Show safe room action buttons
 */
function showSafeRoomConfirmation(needsHealing, healPercent) {
    let buttons = '';

    if (needsHealing) {
        buttons = `
            <button id="maze_saferoom_heal" class="menu_button maze-confirm-btn" style="background: linear-gradient(135deg, #14b8a6, #2dd4bf);">
                <i class="fa-solid fa-heart"></i> Heal (${healPercent}%)
            </button>
            <button id="maze_saferoom_ignore" class="menu_button maze-confirm-btn">Ignore</button>
        `;
    } else {
        buttons = `
            <button id="maze_saferoom_ignore" class="menu_button maze-confirm-btn">Continue</button>
        `;
    }

    showActionPopup(buttons);

    // Attach handlers
    document.getElementById('maze_saferoom_heal')?.addEventListener('click', handleSafeRoomHeal);
    document.getElementById('maze_saferoom_ignore')?.addEventListener('click', handleSafeRoomIgnore);
}

/**
 * Handle using the safe room to heal
 */
async function handleSafeRoomHeal() {
    hideActionPopup();

    const { x, y } = currentMaze.pendingSafeRoom || {};
    if (x === undefined || y === undefined) return;

    const profile = currentMaze.profile || {};
    const healPercent = profile.safeRoomHealPercent ?? 100;

    // Apply healing
    await healPlayer(healPercent, true, 'safeRoom');

    // Mark safe room as exhausted
    if (currentMaze.grid[y]?.[x]?.safeRoom) {
        currentMaze.grid[y][x].safeRoom.exhausted = true;
    }

    // Re-render to remove safe room indicator
    renderMazeGrid();

    addMazeMessage('Safe Room', `You rest and recover ${healPercent}% of your health.`);

    currentMaze.pendingSafeRoom = null;
    resumeMaze();
}

/**
 * Handle ignoring the safe room (can return later)
 */
function handleSafeRoomIgnore() {
    hideActionPopup();

    addMazeMessage('Safe Room', 'You leave the sanctuary undisturbed. You can return later.');

    currentMaze.pendingSafeRoom = null;
    resumeMaze();
}

/**
 * Open a normal chest
 */
async function openNormalChest(x, y) {
    currentMaze.pendingChest = null;
    const profile = currentMaze.profile;
    const chestData = currentMaze.grid[y][x].chest;
    const loot = generateChestLoot(profile, false);

    // v1.6.0: Play chest open sound
    playSound('chest_open');

    // v1.3.2: Add guaranteed items from Find Early
    if (chestData.guaranteedItems && chestData.guaranteedItems.length > 0) {
        for (const item of chestData.guaranteedItems) {
            if (loot[item] !== undefined) {
                loot[item]++;
            } else {
                loot[item] = 1;  // Handle new item types
            }
        }
    }

    // v1.4.1: Add guaranteed floor key for multi-floor progression
    if (chestData.guaranteedFloorKey) {
        loot.floorKey = (loot.floorKey || 0) + 1;
        console.log(`[MazeMaster] Chest at (${x}, ${y}) gave guaranteed floor key`);
    }

    awardLoot(loot);
    showChestLootMessage(loot, "Chest");

    // v1.5.0: Grant XP for opening chest
    await grantXp(getXpReward('normalChest'), 'chest');

    // v1.5.0: Update fetch quest progress for chest and items
    await updateQuestProgress('fetch', 'chest', 1);
    if (loot.key > 0) await updateQuestProgress('fetch', 'key', loot.key);

    // v1.4.7: Update fairness counters
    updateFairnessCounters(loot);

    // Log to session notes
    const lootItems = Object.entries(loot).filter(([k, v]) => v > 0).map(([k, v]) => `${k}x${v}`);
    addSessionNote(`Opened chest: ${lootItems.length > 0 ? lootItems.join(', ') : 'empty'}`, 'Loot');

    // Track stats and fire hook
    await incrementStat('chestsOpened', 1);
    await fireHook('onChestOpen', {
        type: 'normal',
        loot: JSON.stringify(loot),
        x, y
    });
}

/**
 * Open a locked chest
 */
async function openLockedChest(x, y) {
    currentMaze.pendingChest = null;
    const profile = currentMaze.profile;
    const chestData = currentMaze.grid[y][x].chest;
    const loot = generateChestLoot(profile, true);

    // v1.6.0: Play chest unlock sound
    playSound('chest_unlock');

    // v1.3.2: Add guaranteed items from Find Early
    if (chestData.guaranteedItems && chestData.guaranteedItems.length > 0) {
        for (const item of chestData.guaranteedItems) {
            if (loot[item] !== undefined) {
                loot[item]++;
            } else {
                loot[item] = 1;  // Handle new item types
            }
        }
    }

    // v1.4.1: Add guaranteed floor key for multi-floor progression
    if (chestData.guaranteedFloorKey) {
        loot.floorKey = (loot.floorKey || 0) + 1;
        console.log(`[MazeMaster] Locked chest at (${x}, ${y}) gave guaranteed floor key`);
    }

    awardLoot(loot);
    showChestLootMessage(loot, "Locked Chest");

    // v1.5.0: Grant XP for opening locked chest (higher reward)
    await grantXp(getXpReward('lockedChest'), 'lockedChest');

    // v1.5.0: Update fetch quest progress for chest and items
    await updateQuestProgress('fetch', 'chest', 1);
    if (loot.key > 0) await updateQuestProgress('fetch', 'key', loot.key);

    // v1.4.7: Update fairness counters
    updateFairnessCounters(loot);

    // Log to session notes
    const lootItems = Object.entries(loot).filter(([k, v]) => v > 0).map(([k, v]) => `${k}x${v}`);
    addSessionNote(`Opened locked chest: ${lootItems.length > 0 ? lootItems.join(', ') : 'empty'}`, 'Loot');

    // Track stats and fire hook
    await incrementStat('chestsOpened', 1);
    await fireHook('onChestOpen', {
        type: 'locked',
        loot: JSON.stringify(loot),
        x, y
    });
}

/**
 * v1.4.7: Update fairness counters based on loot received
 */
function updateFairnessCounters(loot) {
    if (!currentMaze?.fairness) return;

    const f = currentMaze.fairness;

    // Track key drops
    if (loot.key > 0) {
        f.chestsWithoutKey = 0; // Reset counter
    } else {
        f.chestsWithoutKey++;
    }

    // Track healing drops
    const hasHealing = loot.healingPotion > 0 || loot.greaterHealing > 0 || loot.elixir > 0;
    if (hasHealing) {
        f.chestsWithoutHealing = 0;
        f.lastHealingFoundFloor = currentMaze.currentFloor;
    } else {
        f.chestsWithoutHealing++;
    }
}

/**
 * v1.4.7: Check if a locked chest should be mercy-unlocked
 * Returns true if the chest should be treated as unlocked
 */
function shouldMercyUnlock(profile) {
    if (!currentMaze?.fairness) return false;

    const fairnessConfig = profile?.fairness || {};
    if (fairnessConfig.enabled === false) return false;
    if (fairnessConfig.mercyUnlock === false) return false;

    const f = currentMaze.fairness;
    const mercyThreshold = fairnessConfig.mercyUnlockThreshold || 2;

    // Mercy unlock if player has no keys AND has skipped multiple locked chests
    if (currentMaze.inventory.key === 0 && f.lockedChestsSkipped >= mercyThreshold) {
        console.log(`[MazeMaster] Fairness: Mercy unlock triggered (${f.lockedChestsSkipped} locked chests skipped)`);
        f.lockedChestsSkipped = 0; // Reset counter
        addSessionNote('Lucky break: Found the chest already unlocked!', 'Fairness');
        return true;
    }

    return false;
}

/**
 * Default drop chances for items (locked chance, unlocked chance)
 * Can be overridden by profile settings like profile.chestKeyChance, profile.lockedChestKeyChance
 */
const DEFAULT_DROP_CHANCES = {
    // Core items
    key: { locked: 40, unlocked: 30 },
    strike: { locked: 60, unlocked: 50 },
    stealth: { locked: 30, unlocked: 0 },
    execute: { locked: 5, unlocked: 0 },
    // Exploration items
    floorKey: { locked: 20, unlocked: 10 },
    portalStone: { locked: 15, unlocked: 8 },
    minionBane: { locked: 12, unlocked: 5 },
    mapFragment: { locked: 25, unlocked: 15 },
    timeShard: { locked: 10, unlocked: 5 },
    voidWalk: { locked: 8, unlocked: 3 },
    // HP/Potion items (require hpEnabled)
    healingPotion: { locked: 35, unlocked: 20, requiresHp: true },
    greaterHealing: { locked: 15, unlocked: 8, requiresHp: true },
    elixir: { locked: 5, unlocked: 2, requiresHp: true },
    revivalCharm: { locked: 3, unlocked: 1, requiresHp: true },
    heartCrystal: { locked: 2, unlocked: 0.5, requiresHp: true },
    // Vision items
    torch: { locked: 18, unlocked: 10 },
    lantern: { locked: 8, unlocked: 4 },
    revealScroll: { locked: 6, unlocked: 3 },
    sightPotion: { locked: 4, unlocked: 2 },
    crystalBall: { locked: 5, unlocked: 2 },
    // Equipment items
    ironGuard: { locked: 8, unlocked: 3 },
};

/**
 * Generate loot for a chest
 * Applies difficulty scaling to loot chances
 * v1.9.0: Refactored to dynamically handle all item types
 */
function generateChestLoot(profile, isLocked) {
    // Initialize loot object dynamically from all item profile IDs
    const loot = {};
    const allItemIds = getItemProfileIds();
    for (const itemId of allItemIds) {
        loot[itemId] = 0;
    }

    const min = profile.chestLootMin || 1;
    const max = profile.chestLootMax || 2;
    const itemCount = min + Math.floor(Math.random() * (max - min + 1));

    // Get difficulty scaling for loot
    const difficulty = getDifficultySettings(profile);
    const lootMult = difficulty.chestLootMult || 1.0;

    // Build chances object dynamically from DEFAULT_DROP_CHANCES
    const chances = {};
    for (const [itemId, dropConfig] of Object.entries(DEFAULT_DROP_CHANCES)) {
        // Check if item requires HP to be enabled
        if (dropConfig.requiresHp && profile.hpEnabled === false) {
            chances[itemId] = 0;
            continue;
        }

        // Check for profile-specific overrides (e.g., profile.chestKeyChance, profile.lockedChestKeyChance)
        const capItemId = itemId.charAt(0).toUpperCase() + itemId.slice(1);
        const profileChance = isLocked
            ? (profile[`lockedChest${capItemId}Chance`] ?? dropConfig.locked)
            : (profile[`chest${capItemId}Chance`] ?? dropConfig.unlocked);

        chances[itemId] = profileChance * lootMult;
    }

    // Apply locked bonus multiplier
    if (isLocked) {
        const bonus = 1 + (profile.chestLockedBonusPercent || 50) / 100;
        for (const itemId of Object.keys(chances)) {
            chances[itemId] = Math.min(100, chances[itemId] * bonus);
        }
    }

    // v1.4.7: Apply fairness modifiers (pity system)
    const fairnessConfig = profile.fairness || {};
    if (fairnessConfig.enabled !== false && currentMaze?.fairness) {
        const f = currentMaze.fairness;

        // Key pity: Boost key chance after multiple chests without one
        if (f.chestsWithoutKey >= (fairnessConfig.keyPityThreshold || 3)) {
            const keyBoost = Math.min(50, f.chestsWithoutKey * 15);
            chances.key = Math.min(100, (chances.key || 0) + keyBoost);
            console.log(`[MazeMaster] Fairness: Key pity active (+${keyBoost}% key chance)`);
        }

        // Healing pity: Boost healing when HP is low or haven't found healing recently
        if (profile.hpEnabled !== false && currentMaze.hpEnabled && currentMaze.hp) {
            const hpPercent = currentMaze.hp.current / (currentMaze.hp.max + currentMaze.hp.maxBonus);
            const lowHpThreshold = fairnessConfig.lowHpThreshold || 0.4;

            if (hpPercent <= lowHpThreshold) {
                const healBoost = Math.round((1 - hpPercent) * 40);
                chances.healingPotion = Math.min(100, (chances.healingPotion || 0) + healBoost);
                chances.greaterHealing = Math.min(100, (chances.greaterHealing || 0) + healBoost / 2);
                console.log(`[MazeMaster] Fairness: Low HP pity (+${healBoost}% healing chance)`);
            }

            if (f.chestsWithoutHealing >= (fairnessConfig.healingPityThreshold || 4)) {
                const healStreakBoost = Math.min(30, f.chestsWithoutHealing * 8);
                chances.healingPotion = Math.min(100, (chances.healingPotion || 0) + healStreakBoost);
                console.log(`[MazeMaster] Fairness: Healing drought pity (+${healStreakBoost}%)`);
            }
        }
    }

    // Roll for each item dynamically
    for (let i = 0; i < itemCount; i++) {
        for (const [itemId, chance] of Object.entries(chances)) {
            if (chance > 0 && isItemInPool(itemId, profile) && Math.random() * 100 < chance) {
                loot[itemId]++;
            }
        }
    }

    return loot;
}

/**
 * Award loot to player - dynamically handles all item types
 */
function awardLoot(loot) {
    // Dynamically iterate through all loot items instead of hardcoded checks
    for (const [itemId, count] of Object.entries(loot)) {
        if (count > 0) {
            addToInventory(itemId, count);
        }
    }
}

/**
 * Show a chest message in the hero section
 */
function showChestMessage(message, chestType) {
    currentMaze.currentMinion = {
        name: chestType,
        imagePath: '',
        message: message,
    };
    updateMazeHero();
}

/**
 * Show loot message from a chest - dynamically handles all item types with themed names
 */
function showChestLootMessage(loot, chestType) {
    const items = [];
    const theme = currentMaze.profile?.theme || 'fantasy';

    // Dynamically iterate through all loot items
    for (const [itemId, count] of Object.entries(loot)) {
        if (count > 0) {
            const displayName = getItemDisplayName(itemId, theme);
            // Handle pluralization - special case for words ending in 'ch', 'x', 's'
            const lastChar = displayName.slice(-1).toLowerCase();
            const endsInSibilant = /[chxs]$/.test(displayName.toLowerCase()) || displayName.toLowerCase().endsWith('sh');
            const plural = count > 1 ? (endsInSibilant ? 'es' : 's') : '';
            items.push(`${count} ${displayName}${plural}`);
        }
    }

    const message = items.length > 0
        ? `You found: ${items.join(', ')}!`
        : 'The chest was empty!';

    showChestMessage(message, chestType);
    setTimeout(() => resumeMaze(), 2000);
}

/**
 * Trigger a mimic encounter (random battlebar)
 */
function triggerMimicEncounter(x, y) {
    // Clear pending chest since we've opened it
    currentMaze.pendingChest = null;

    const bbProfiles = getBattlebarProfileNames();
    if (bbProfiles.length > 0) {
        const randomProfile = bbProfiles[Math.floor(Math.random() * bbProfiles.length)];
        currentMaze.pendingEncounter = { type: 'mimic_battlebar', profile: randomProfile };

        // Show mimic message first
        currentMaze.currentMinion = {
            name: 'Mimic!',
            imagePath: '',
            message: 'The chest was a mimic! Prepare to fight!',
        };
        updateMazeHero();

        setTimeout(() => {
            startBattlebar(randomProfile);
        }, 1000);
    } else {
        // No battlebar profiles - just resume
        showChestMessage("The chest was empty... and creepy.", "Mimic");
        setTimeout(() => resumeMaze(), 1500);
    }
}

/**
 * Show action popup overlay with buttons
 * @param {string} buttonsHTML - HTML string of buttons to display
 */
function showActionPopup(buttonsHTML) {
    const popup = document.getElementById('maze_action_popup');
    const buttonsContainer = document.getElementById('maze_action_popup_buttons');

    if (!popup || !buttonsContainer) return;

    buttonsContainer.innerHTML = buttonsHTML;
    popup.style.display = 'flex';

    // Also hide the old confirm area if it exists
    const oldConfirm = document.getElementById('maze_encounter_confirm');
    if (oldConfirm) {
        oldConfirm.style.display = 'none';
        oldConfirm.innerHTML = '';
    }
}

/**
 * Hide action popup overlay
 */
function hideActionPopup() {
    const popup = document.getElementById('maze_action_popup');
    const buttonsContainer = document.getElementById('maze_action_popup_buttons');

    if (popup) {
        popup.style.display = 'none';
    }
    if (buttonsContainer) {
        buttonsContainer.innerHTML = '';
    }

    // Also hide the old confirm area if it exists
    const oldConfirm = document.getElementById('maze_encounter_confirm');
    if (oldConfirm) {
        oldConfirm.style.display = 'none';
        oldConfirm.innerHTML = '';
    }
}

/**
 * Show encounter confirmation buttons
 */
function showEncounterConfirmation(minionId, x, y, encounterType) {
    console.log('[MazeMaster] showEncounterConfirmation called:', { minionId, x, y, encounterType });
    const minion = getMinion(minionId);
    console.log('[MazeMaster] Minion data:', minion);
    const canSlipAway = encounterType !== 'messenger' && encounterType !== 'merchant' && currentMaze.inventory.stealth > 0;

    currentMaze.pendingConfirmation = { type: encounterType, minionId, x, y, canSlipAway };
    console.log('[MazeMaster] Set pendingConfirmation:', currentMaze.pendingConfirmation);

    let buttons = '';
    if (encounterType === 'messenger') {
        buttons = `<button id="maze_confirm_ok" class="menu_button maze-confirm-btn">OK</button>`;
    } else if (encounterType === 'merchant') {
        // Calculate random item count for this merchant
        const merchantConfig = minion.merchantItemCount || { min: 2, max: 4 };
        const itemCount = merchantConfig.min + Math.floor(Math.random() * (merchantConfig.max - merchantConfig.min + 1));

        // Get item pool and select random items
        const poolName = minion.merchantItemPool || 'Common Goods';
        const offeredItems = selectRandomMerchantItems(poolName, itemCount);
        currentMaze.pendingConfirmation.offeredItems = offeredItems;

        // Update message with browse prompt
        currentMaze.currentMinion.message = `Take a look at my wares! I have ${itemCount} items that might interest you...`;
        updateMazeHero();

        buttons = `
            <button id="maze_confirm_browse" class="menu_button maze-confirm-btn maze-accept-btn">Browse Wares</button>
            <button id="maze_confirm_decline" class="menu_button maze-confirm-btn">No Thanks</button>
        `;
    } else {
        // Get appropriate action text based on encounter type
        const actionTexts = {
            'battlebar': 'Fight!',
            'prizewheel': 'Spin!',
            'turnbased': 'Battle!',
            'qte': 'React!',
            'dice': 'Roll!',
            'stealth': 'Sneak!',
            'puzzle': 'Solve!',
            'negotiation': 'Negotiate!',
        };
        const actionText = actionTexts[encounterType] || 'Engage!';
        buttons = `<button id="maze_confirm_action" class="menu_button maze-confirm-btn">${actionText}</button>`;
        if (canSlipAway) {
            buttons += `<button id="maze_confirm_slip" class="menu_button maze-confirm-btn maze-slip-btn">Slip Away</button>`;
        }
    }

    // Show buttons in popup overlay
    showActionPopup(buttons);

    // Attach handlers
    document.getElementById('maze_confirm_ok')?.addEventListener('click', handleConfirmOk);
    document.getElementById('maze_confirm_action')?.addEventListener('click', handleConfirmAction);
    document.getElementById('maze_confirm_slip')?.addEventListener('click', handleConfirmSlipAway);
    document.getElementById('maze_confirm_browse')?.addEventListener('click', handleMerchantBrowse);
    document.getElementById('maze_confirm_decline')?.addEventListener('click', handleMerchantDecline);
}

/**
 * Handle OK confirmation (messenger encounters)
 */
function handleConfirmOk() {
    hideActionPopup();
    currentMaze.pendingConfirmation = null;
    resumeMaze();
}

/**
 * Handle action confirmation (all combat encounter types)
 */
function handleConfirmAction() {
    console.log('[MazeMaster] handleConfirmAction called');
    hideActionPopup();
    const conf = currentMaze.pendingConfirmation;
    console.log('[MazeMaster] pendingConfirmation:', conf);
    if (!conf) {
        console.warn('[MazeMaster] No pending confirmation, returning');
        return;
    }

    const minion = getMinion(conf.minionId);
    console.log('[MazeMaster] Minion for encounter:', conf.minionId, minion);
    console.log('[MazeMaster] Encounter type:', conf.type);
    currentMaze.pendingConfirmation = null;

    // Trigger the actual encounter based on type
    switch (conf.type) {
        case 'battlebar': {
            const bbProfile = getRandomFromArray(minion.battlebarProfiles);
            console.log('[MazeMaster] Battlebar profiles:', minion.battlebarProfiles, '-> selected:', bbProfile);
            if (bbProfile) {
                currentMaze.pendingEncounter = { type: 'battlebar', profile: bbProfile, minionName: minion.name };
                startBattlebar(bbProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No battlebar profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'prizewheel': {
            const wheelProfile = getRandomFromArray(minion.wheelProfiles);
            console.log('[MazeMaster] Wheel profiles:', minion.wheelProfiles, '-> selected:', wheelProfile);
            if (wheelProfile) {
                const wheelResult = loadWheelFromProfile(wheelProfile);
                if (wheelResult.error) {
                    console.warn(`[MazeMaster] Wheel profile "${wheelProfile}" failed to load: ${wheelResult.error}. Resuming maze.`);
                    resumeMaze();
                } else {
                    currentMaze.pendingEncounter = { type: 'wheel', profile: wheelProfile };
                    showWheelModal();
                }
            } else {
                console.warn('[MazeMaster] No wheel profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'turnbased': {
            const tbProfile = getRandomFromArray(minion.turnbasedProfiles);
            console.log('[MazeMaster] Turnbased profiles:', minion.turnbasedProfiles, '-> selected:', tbProfile);
            if (tbProfile) {
                currentMaze.pendingEncounter = { type: 'turnbased', profile: tbProfile, minionName: minion.name };
                console.log('[MazeMaster] Calling startTurnBased with profile:', tbProfile);
                startTurnBased(tbProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No turnbased profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'qte': {
            const qteProfile = getRandomFromArray(minion.qteProfiles);
            console.log('[MazeMaster] QTE profiles:', minion.qteProfiles, '-> selected:', qteProfile);
            if (qteProfile) {
                currentMaze.pendingEncounter = { type: 'qte', profile: qteProfile, minionName: minion.name };
                console.log('[MazeMaster] Calling startQTE with profile:', qteProfile);
                startQTE(qteProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No QTE profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'dice': {
            const diceProfile = getRandomFromArray(minion.diceProfiles);
            console.log('[MazeMaster] Dice profiles:', minion.diceProfiles, '-> selected:', diceProfile);
            if (diceProfile) {
                currentMaze.pendingEncounter = { type: 'dice', profile: diceProfile, minionName: minion.name };
                console.log('[MazeMaster] Calling startDice with profile:', diceProfile);
                startDice(diceProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No dice profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'stealth': {
            const stealthProfile = getRandomFromArray(minion.stealthProfiles);
            console.log('[MazeMaster] Stealth profiles:', minion.stealthProfiles, '-> selected:', stealthProfile);
            if (stealthProfile) {
                currentMaze.pendingEncounter = { type: 'stealth', profile: stealthProfile, minionName: minion.name };
                console.log('[MazeMaster] Calling startStealth with profile:', stealthProfile);
                startStealth(stealthProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No stealth profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'puzzle': {
            const puzzleProfile = getRandomFromArray(minion.puzzleProfiles);
            console.log('[MazeMaster] Puzzle profiles:', minion.puzzleProfiles, '-> selected:', puzzleProfile);
            if (puzzleProfile) {
                currentMaze.pendingEncounter = { type: 'puzzle', profile: puzzleProfile, minionName: minion.name };
                console.log('[MazeMaster] Calling startPuzzle with profile:', puzzleProfile);
                startPuzzle(puzzleProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No puzzle profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'negotiation': {
            const negoProfile = getRandomFromArray(minion.negotiationProfiles);
            console.log('[MazeMaster] Negotiation profiles:', minion.negotiationProfiles, '-> selected:', negoProfile);
            if (negoProfile) {
                currentMaze.pendingEncounter = { type: 'negotiation', profile: negoProfile, minionName: minion.name };
                console.log('[MazeMaster] Calling startNegotiation with profile:', negoProfile);
                startNegotiation(negoProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No negotiation profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        default:
            console.warn(`[MazeMaster] Unknown encounter type: ${conf.type}`);
            resumeMaze();
    }
}

/**
 * Handle slip away (uses stealth to skip encounter)
 */
function handleConfirmSlipAway() {
    hideActionPopup();
    if (currentMaze.inventory.stealth > 0) {
        removeFromInventory('stealth');
        currentMaze.pendingConfirmation = null;
        resumeMaze();
    }
}

/**
 * Handle merchant browse - open merchant modal to select items
 */
function handleMerchantBrowse() {
    const conf = currentMaze.pendingConfirmation;
    if (!conf || conf.type !== 'merchant') return;

    hideActionPopup();

    // Open merchant modal with the offered items
    showMerchantModal(conf.minionId, conf.offeredItems || []);
}

/**
 * Handle merchant decline - skip trade
 */
function handleMerchantDecline() {
    hideActionPopup();
    currentMaze.pendingConfirmation = null;
    resumeMaze();
}

/**
 * Maybe show a random message from the main minion
 */
async function maybeShowMainMinionMessage() {
    const profile = currentMaze.profile;
    if (!profile.mainMinion) return;
    if (!profile.mainMinionRandomChance) return;
    if (!profile.mainMinionRandomMessages || profile.mainMinionRandomMessages.length === 0) return;

    // Roll random chance (0-100)
    if (Math.random() * 100 > profile.mainMinionRandomChance) return;

    const mainMinion = getMinion(profile.mainMinion);
    if (!mainMinion) return;

    const baseMessage = getRandomFromArray(profile.mainMinionRandomMessages);
    if (!baseMessage) return;

    // v2.0.2: Use alias for main minion name
    const displayName = currentMaze.mainMinionAlias || mainMinion.name;

    // Show placeholder immediately
    currentMaze.currentMinion = {
        name: displayName,
        imagePath: mainMinion.imagePath,
        message: '...',
    };
    updateMazeHero();

    // Show generating indicator
    showGeneratingIndicator(true);

    // Generate LLM message
    let message = baseMessage;
    try {
        message = await generateMinionMessage({
            minionName: displayName,
            minionDescription: mainMinion.description,
            baseMessage: baseMessage,
            mainStory: getMainStory(),
            currentMilestone: getCurrentMilestone(),
            minionType: mainMinion.type || 'messenger',
        });
    } catch (error) {
        console.error('[MazeMaster] Random message LLM generation error:', error);
    }

    // Hide generating indicator
    showGeneratingIndicator(false);

    // Update with actual message
    currentMaze.currentMinion.message = message;
    updateMazeHero();
}

/**
 * Check and trigger story milestones based on maze progress
 */
function checkStoryMilestones() {
    const profile = currentMaze.profile;
    if (!profile.storyConfig || !profile.storyConfig.milestones || profile.storyConfig.milestones.length === 0) return;

    // Calculate progress percentage
    const totalCells = currentMaze.size * currentMaze.size;
    const visitedCount = currentMaze.visited.size;
    const percentComplete = Math.floor((visitedCount / totalCells) * 100);

    // Check each milestone
    for (const milestone of profile.storyConfig.milestones) {
        if (percentComplete >= milestone.percent && !currentMaze.shownMilestones.has(milestone.percent)) {
            // Mark as shown
            currentMaze.shownMilestones.add(milestone.percent);

            // Log to session notes
            addSessionNote(`Milestone ${milestone.percent}%: ${milestone.storyUpdate?.substring(0, 50)}...`, 'Story');

            // Show milestone message
            const mainMinion = profile.mainMinion ? getMinion(profile.mainMinion) : null;
            // v2.0.2: Use alias for main minion name
            const displayName = currentMaze.mainMinionAlias || mainMinion?.name || 'Story';
            currentMaze.currentMinion = {
                name: displayName,
                imagePath: mainMinion?.imagePath || '',
                message: milestone.storyUpdate,
            };
            updateMazeHero();

            // Only show one milestone at a time
            return;
        }
    }
}

/**
 * Handle maze loss (from battlebar defeat)
 */
function handleMazeLoss() {
    currentMaze.isVictory = false;
    currentMaze.isPaused = true;

    // Log to session notes
    addSessionNote(`DEFEAT! Adventure ended.`, 'End');

    // Stop stats timer
    stopStatsTimer();

    // Save persistent stats
    savePersistentStats('lose');

    // Record result
    lastResults.maze[currentMaze.profileName] = {
        result: 'lose',
        timestamp: Date.now(),
    };

    // Show loss screen in hero section
    document.getElementById('maze_minion_name').textContent = 'Defeat!';
    addMazeMessage('Defeat!', 'You have been defeated...');

    // Hide minion image on loss
    const minionImg = document.getElementById('maze_minion_img');
    if (minionImg) minionImg.style.display = 'none';

    // Show close button
    const closeBtn = document.getElementById('maze_close_btn');
    if (closeBtn) closeBtn.style.display = '';

    // Execute loss command if exists
    if (currentMaze.profile.loseCommand) {
        executeWithTimeout(currentMaze.profile.loseCommand);
    }

    document.removeEventListener('keydown', handleMazeKeydown, { capture: true });
}

/**
 * Respawn player at start position
 */
function respawnPlayer() {
    currentMaze.playerX = 0;
    currentMaze.playerY = 0;
    currentMaze.isPaused = false;
    currentMaze.pendingEncounter = null;
    renderMazeGrid();
    updateDpadFloorButtons();

    // Show respawn message from main minion
    const profile = currentMaze.profile;
    if (profile.mainMinion) {
        const mainMinion = getMinion(profile.mainMinion);
        if (mainMinion) {
            // v2.0.2: Use alias for main minion name
            const displayName = currentMaze.mainMinionAlias || mainMinion.name;
            currentMaze.currentMinion = {
                name: displayName,
                imagePath: mainMinion.imagePath,
                message: 'Back to the beginning with you!',
            };
            updateMazeHero();
            return;
        }
    }

    // Otherwise show default
    currentMaze.currentMinion = getDefaultMinion();
    updateMazeHero();
}

async function handleMazeWin() {
    currentMaze.isVictory = true;

    // Log to session notes
    addSessionNote(`VICTORY! Maze completed.`, 'End');

    // Stop stats timer
    stopStatsTimer();

    // Save persistent stats
    savePersistentStats('win');

    // Record result
    lastResults.maze[currentMaze.profileName] = {
        result: 'win',
        timestamp: Date.now(),
    };

    // Update UI
    updateMazeHero();
    renderMazeGrid();

    // Show close button
    const closeBtn = document.getElementById('maze_close_btn');
    if (closeBtn) closeBtn.style.display = '';

    // Hide mobile controls
    const controls = document.querySelector('.mazemaster-maze-controls');
    if (controls) controls.style.display = 'none';

    // Remove keyboard listener
    document.removeEventListener('keydown', handleMazeKeydown, { capture: true });

    // Execute win command
    if (currentMaze.profile.winCommand) {
        await executeWithTimeout(currentMaze.profile.winCommand);
    }

    console.log(`[MazeMaster] Maze "${currentMaze.profileName}" completed!`);

    // Auto-close after delay so player can see victory state
    await delay(2500);
    closeMaze();

    // Switch to Game tab in extension panel
    const gameTab = document.querySelector('.mazemaster-tab[data-tab="game"]');
    if (gameTab) gameTab.click();
}

// =============================================================================
// CONFIG PANEL UI
// =============================================================================

function getPanelHtml() {
    const wheelProfiles = getProfileNames();
    const currentWheelProfile = extensionSettings.currentProfile || 'Tutorial - Learn the Wheel';
    const bbProfiles = getBattlebarProfileNames();
    const currentBbProfile = extensionSettings.currentBattlebarProfile || 'Tutorial - Learn Combat';
    const currentBb = getBattlebarProfile(currentBbProfile) || {};
    const mazeProfiles = getMazeProfileNames();
    const currentMazeProfileName = extensionSettings.currentMazeProfile || 'Tutorial - Learn the Basics';
    const currentMazeData = getMazeProfile(currentMazeProfileName) || {};
    const minionsList = getMinionNames();
    const activeGame = extensionSettings.activeGameConfig || 'maze';

    // v1.6.0: Combat Mechanics profiles
    const cmProfiles = getCombatMechanicsProfileNames();
    const currentCmProfile = extensionSettings.currentCombatMechanicsProfile || 'default';
    const currentCm = getCombatMechanicsProfileData(currentCmProfile) || DEFAULT_COMBAT_MECHANICS_PROFILES.default;

    return `
        <div class="mazemaster-panel">
            <div class="mazemaster-panel-header">
                <h2><i class="fa-solid fa-gamepad"></i> MazeMaster</h2>
            </div>
            <div class="mazemaster-tabs">
                <button class="mazemaster-tab active" data-tab="game">Game</button>
                <button class="mazemaster-tab" data-tab="config">Config</button>
                <button class="mazemaster-tab" data-tab="help">Help</button>
            </div>
            <div class="mazemaster-panel-content">
                <!-- GAME TAB -->
                <div class="mazemaster-tab-content active" id="mazemaster-tab-game">
                    <div class="mazemaster-game-launch">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Maze Profile</label>
                            <select id="mazemaster_play_profile" class="mazemaster-select">
                                ${mazeProfiles.length === 0 ? '<option value="">No profiles</option>' : ''}
                                ${mazeProfiles.map(p => `<option value="${escapeHtml(p)}" ${p === currentMazeProfileName ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                            </select>
                        </div>
                        <button id="mazemaster_play_maze" class="menu_button menu_button_primary mazemaster-play-btn">
                            <i class="fa-solid fa-play"></i> Play Maze
                        </button>
                    </div>

                    <!-- Maze Preview Panel -->
                    <div class="mazemaster-section" id="mazemaster_maze_preview">
                        <div class="mazemaster-preview-header">
                            <span class="preview-title" id="preview_title">Select a maze to see details</span>
                        </div>
                        <div class="mazemaster-preview-content" id="preview_content" style="display: none;">
                            <div class="preview-story" id="preview_story"></div>
                            <div class="preview-stats">
                                <div class="stat-row"><span class="stat-label">Theme:</span><span class="stat-value" id="preview_theme"></span></div>
                                <div class="stat-row"><span class="stat-label">Style:</span><span class="stat-value" id="preview_style"></span></div>
                                <div class="stat-row"><span class="stat-label">Difficulty:</span><span class="stat-value" id="preview_difficulty"></span></div>
                                <div class="stat-row"><span class="stat-label">Size:</span><span class="stat-value" id="preview_size"></span></div>
                                <div class="stat-row"><span class="stat-label">HP:</span><span class="stat-value" id="preview_hp"></span></div>
                                <div class="stat-row"><span class="stat-label">Permadeath:</span><span class="stat-value" id="preview_permadeath"></span></div>
                                <div class="stat-row"><span class="stat-label">Combat:</span><span class="stat-value" id="preview_combat"></span></div>
                                <div class="stat-row"><span class="stat-label">Vision:</span><span class="stat-value" id="preview_vision"></span></div>
                            </div>
                            <div class="preview-starting-items" id="preview_starting_items"></div>
                        </div>
                    </div>

                    <!-- LLM Generation Settings -->
                    <div class="mazemaster-section">
                        <label class="mazemaster-label"><i class="fa-solid fa-brain"></i> LLM Message Generation</label>
                        <div class="mazemaster-form-group">
                            <label>Generation Preset</label>
                            <select id="mazemaster_llm_preset" class="mazemaster-select">
                                <option value="">(Use Current)</option>
                                <!-- Presets populated dynamically -->
                            </select>
                        </div>
                        <label class="mazemaster-checkbox-label">
                            <input type="checkbox" id="mazemaster_llm_enabled" ${extensionSettings.llmEnabled !== false ? 'checked' : ''}>
                            Enable LLM message generation
                        </label>
                        <label class="mazemaster-checkbox-label">
                            <input type="checkbox" id="mazemaster_close_chat" ${extensionSettings.closeChatOnStart !== false ? 'checked' : ''}>
                            Close current chat before starting (prevents context bleed)
                        </label>
                    </div>

                    <!-- v2.1.0: Avatar Generation Settings -->
                    <div class="mazemaster-section">
                        <label class="mazemaster-label"><i class="fa-solid fa-image"></i> Avatar Generation</label>
                        <label class="mazemaster-checkbox-label">
                            <input type="checkbox" id="mazemaster_avatar_gen_enabled" ${extensionSettings.avatarGenerationEnabled === true ? 'checked' : ''}>
                            Auto-generate minion avatars (requires SD/image extension)
                        </label>
                        <div class="mazemaster-help-small"><small>Generates portraits for minions without images during maze loading using the /imagine command.</small></div>
                    </div>

                    <!-- D-Pad Settings -->
                    <div class="mazemaster-section">
                        <label class="mazemaster-label"><i class="fa-solid fa-gamepad"></i> D-Pad Controls</label>
                        <label class="mazemaster-checkbox-label">
                            <input type="checkbox" id="mazemaster_dpad_enabled" ${extensionSettings.dpadConfig?.enabled !== false ? 'checked' : ''}>
                            Enable D-Pad controls
                        </label>
                        <label class="mazemaster-checkbox-label">
                            <input type="checkbox" id="mazemaster_dpad_floating" ${extensionSettings.dpadConfig?.floating !== false ? 'checked' : ''}>
                            Floating D-Pad (draggable position)
                        </label>
                        <button id="mazemaster_dpad_reset" class="menu_button" style="margin-top: 6px;">
                            <i class="fa-solid fa-rotate-left"></i> Reset D-Pad Position
                        </button>
                    </div>

                    <!-- Renderer Settings -->
                    <div class="mazemaster-section">
                        <label class="mazemaster-label"><i class="fa-solid fa-cube"></i> Renderer</label>
                        <select id="mazemaster_renderer_type" class="mazemaster-select">
                            <option value="css-grid" ${extensionSettings.rendererType === 'css-grid' ? 'selected' : ''}>Classic (CSS Grid)</option>
                            <option value="isometric" ${(extensionSettings.rendererType || 'isometric') === 'isometric' ? 'selected' : ''}>Isometric 2.5D</option>
                            <option value="canvas" ${extensionSettings.rendererType === 'canvas' ? 'selected' : ''}>Canvas (Experimental)</option>
                        </select>
                        <div class="mazemaster-help-small"><small>Isometric gives a 3D-like view. Requires restart of active maze.</small></div>
                    </div>

                    <!-- Layout Mode -->
                    <div class="mazemaster-section">
                        <label class="mazemaster-label"><i class="fa-solid fa-mobile-screen"></i> Layout Mode</label>
                        <select id="mazemaster_layout_mode" class="mazemaster-select">
                            <option value="auto" ${extensionSettings.layoutMode === 'auto' ? 'selected' : ''} disabled>Auto-detect (disabled)</option>
                            <option value="desktop" ${(extensionSettings.layoutMode || 'desktop') === 'desktop' ? 'selected' : ''}>Desktop (Horizontal)</option>
                            <option value="mobile" ${extensionSettings.layoutMode === 'mobile' ? 'selected' : ''} disabled>Mobile (Vertical) (disabled)</option>
                        </select>
                        <div class="mazemaster-help-small"><small>Mobile layout stacks UI vertically for portrait screens.</small></div>
                    </div>

                    <!-- Saved Games in Game Tab -->
                    <div class="mazemaster-section">
                        <label class="mazemaster-label"><i class="fa-solid fa-floppy-disk"></i> Saved Games</label>
                        <div id="mazemaster_game_tab_saves" class="mazemaster-saved-games-list">
                            <!-- Saved games rendered here -->
                        </div>
                    </div>
                </div>

                <!-- CONFIG TAB -->
                <div class="mazemaster-tab-content" id="mazemaster-tab-config">
                    <!-- Reset Factory Defaults Button -->
                    <div class="mazemaster-section" style="background: #2a1a1a; border: 1px solid #ff6b6b; border-radius: 8px; padding: 10px; margin-bottom: 15px;">
                        <button id="mazemaster_reset_factory" class="menu_button" style="width: 100%; background: #8b0000; color: white;">
                            <i class="fa-solid fa-rotate-left"></i> Update to Latest Profiles (v2.0.5)
                        </button>
                        <div style="font-size: 11px; color: #ff9999; margin-top: 5px; text-align: center;">
                            Clears all profiles and updates to v2.0.5 defaults
                        </div>
                    </div>

                    <!-- Game Selector -->
                    <div class="mazemaster-game-selector">
                        <button id="mazemaster_show_maze" class="menu_button mazemaster-game-btn ${activeGame === 'maze' ? 'active' : ''}">
                            <i class="fa-solid fa-border-all"></i> Maze
                        </button>
                        <button id="mazemaster_show_wheel" class="menu_button mazemaster-game-btn ${activeGame === 'wheel' ? 'active' : ''}">
                            <i class="fa-solid fa-dharmachakra"></i> Wheel
                        </button>
                        <button id="mazemaster_show_combat" class="menu_button mazemaster-game-btn ${activeGame === 'combat' ? 'active' : ''}">
                            <i class="fa-solid fa-khanda"></i> Combat
                        </button>
                        <button id="mazemaster_show_minions" class="menu_button mazemaster-game-btn ${activeGame === 'minions' ? 'active' : ''}">
                            <i class="fa-solid fa-ghost"></i> Minions
                        </button>
                        <button id="mazemaster_show_traps" class="menu_button mazemaster-game-btn ${activeGame === 'traps' ? 'active' : ''}">
                            <i class="fa-solid fa-dungeon"></i> Traps
                        </button>
                    </div>
                    <!-- Second Row: Content -->
                    <div class="mazemaster-game-selector" style="margin-top: 4px;">
                        <button id="mazemaster_show_themes" class="menu_button mazemaster-game-btn ${activeGame === 'themes' ? 'active' : ''}">
                            <i class="fa-solid fa-palette"></i> Themes
                        </button>
                        <button id="mazemaster_show_styles" class="menu_button mazemaster-game-btn ${activeGame === 'styles' ? 'active' : ''}">
                            <i class="fa-solid fa-city"></i> Styles
                        </button>
                        <button id="mazemaster_show_quests" class="menu_button mazemaster-game-btn ${activeGame === 'quests' ? 'active' : ''}">
                            <i class="fa-solid fa-scroll"></i> Quests
                        </button>
                        <button id="mazemaster_show_items" class="menu_button mazemaster-game-btn ${activeGame === 'items' ? 'active' : ''}">
                            <i class="fa-solid fa-wand-sparkles"></i> Items
                        </button>
                        <button id="mazemaster_show_factions" class="menu_button mazemaster-game-btn ${activeGame === 'factions' ? 'active' : ''}">
                            <i class="fa-solid fa-users"></i> Factions
                        </button>
                    </div>
                    <!-- Third Row: Systems -->
                    <div class="mazemaster-game-selector" style="margin-top: 4px;">
                        <button id="mazemaster_show_vision" class="menu_button mazemaster-game-btn ${activeGame === 'vision' ? 'active' : ''}">
                            <i class="fa-solid fa-eye"></i> Vision
                        </button>
                        <button id="mazemaster_show_sound" class="menu_button mazemaster-game-btn ${activeGame === 'sound' ? 'active' : ''}">
                            <i class="fa-solid fa-volume-high"></i> Sound
                        </button>
                    </div>

                    <!-- WHEEL CONFIG -->
                    <div id="mazemaster_wheel_config" class="mazemaster-game-config" style="${activeGame === 'wheel' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Wheel Profile</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_profile_select" class="mazemaster-select">
                                    ${wheelProfiles.length === 0 ? '<option value="">No profiles</option>' : ''}
                                    ${wheelProfiles.map(p => `<option value="${escapeHtml(p)}" ${p === currentWheelProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                </select>
                                <button id="mazemaster_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                                <button id="mazemaster_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                                <button id="mazemaster_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                    <i class="fa-solid fa-pen"></i>
                                </button>
                                <button id="mazemaster_export_btn" class="menu_button menu_button_icon" title="Export Profile">
                                    <i class="fa-solid fa-download"></i>
                                </button>
                                <button id="mazemaster_import_btn" class="menu_button menu_button_icon" title="Import Profile">
                                    <i class="fa-solid fa-upload"></i>
                                </button>
                                <input type="file" id="mazemaster_import_file" accept=".json" style="display: none;">
                                <button id="mazemaster_preview_wheel_btn" class="menu_button menu_button_icon" title="Preview Wheel">
                                    <i class="fa-solid fa-eye"></i>
                                </button>
                            </div>
                        </div>

                        <div class="mazemaster-section mazemaster-profile-settings">
                            <div class="mazemaster-profile-options">
                                <label class="mazemaster-checkbox-label">
                                    <input type="checkbox" id="mazemaster_randomize" ${getProfile(currentWheelProfile)?.randomize ? 'checked' : ''}>
                                    Randomize segment positions
                                </label>
                                <div class="mazemaster-difficulty-row">
                                    <label>Difficulty:</label>
                                    <select id="mazemaster_difficulty" class="mazemaster-select-small">
                                        ${[1,2,3,4,5].map(n => `<option value="${n}" ${(getProfile(currentWheelProfile)?.difficulty || 1) === n ? 'selected' : ''}>${n}</option>`).join('')}
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Segments</label>
                            <div id="mazemaster_segments_list" class="mazemaster-segments-list">
                                <!-- Segments rendered here -->
                            </div>
                            <button id="mazemaster_add_segment_btn" class="menu_button mazemaster-add-btn">
                                <i class="fa-solid fa-plus"></i> Add Segment
                            </button>
                        </div>

                        <div class="mazemaster-section">
                            <button id="mazemaster_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                <i class="fa-solid fa-save"></i> Save Profile
                            </button>
                        </div>

                        <div class="mazemaster-section">
                            <div class="mazemaster-help">
                                <div class="mazemaster-help-title">Usage:</div>
                                <code>/wheel profile="profileName"</code>
                                <div class="mazemaster-help-title">Sizes:</div>
                                <ul>
                                    <li><code>fraction</code> - Normal (1x)</li>
                                    <li><code>halfseg</code> - Half (0.5x)</li>
                                    <li><code>doubleseg</code> - Double (2x)</li>
                                </ul>
                                <small>halfseg count must equal doubleseg count</small>
                            </div>
                        </div>
                    </div>

                    <!-- COMBAT CONFIG (with sub-tabs) -->
                    <div id="mazemaster_combat_config" class="mazemaster-game-config" style="${activeGame === 'combat' ? '' : 'display: none;'}">
                        <!-- Combat Sub-tabs -->
                        <div class="mazemaster-combat-subtabs">
                            <button class="combat-subtab active" data-combat="battlebar">Battlebar</button>
                            <button class="combat-subtab" data-combat="turnbased">Turn-Based</button>
                            <button class="combat-subtab" data-combat="qte">QTE</button>
                            <button class="combat-subtab" data-combat="dice">Dice</button>
                            <button class="combat-subtab" data-combat="stealth">Stealth</button>
                            <button class="combat-subtab" data-combat="puzzle">Puzzle</button>
                            <button class="combat-subtab" data-combat="negotiation">Negotiation</button>
                            <button class="combat-subtab" data-combat="mechanics">Mechanics</button>
                        </div>

                        <!-- BATTLEBAR SUB-TAB -->
                        <div id="combat_battlebar_content" class="combat-content active">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Battlebar Profile</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_bb_profile_select" class="mazemaster-select">
                                    ${bbProfiles.length === 0 ? '<option value="">No profiles</option>' : ''}
                                    ${bbProfiles.map(p => `<option value="${escapeHtml(p)}" ${p === currentBbProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                </select>
                                <button id="mazemaster_bb_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                                <button id="mazemaster_bb_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                                <button id="mazemaster_bb_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                    <i class="fa-solid fa-pen"></i>
                                </button>
                                <button id="mazemaster_bb_export_btn" class="menu_button menu_button_icon" title="Export Profile">
                                    <i class="fa-solid fa-download"></i>
                                </button>
                                <button id="mazemaster_bb_import_btn" class="menu_button menu_button_icon" title="Import Profile">
                                    <i class="fa-solid fa-upload"></i>
                                </button>
                                <input type="file" id="mazemaster_bb_import_file" accept=".json" style="display: none;">
                                <button id="mazemaster_preview_battlebar_btn" class="menu_button menu_button_icon" title="Preview Battlebar">
                                    <i class="fa-solid fa-eye"></i>
                                </button>
                            </div>
                        </div>

                        <div class="mazemaster-section mazemaster-profile-settings">
                            <div class="mazemaster-bb-settings">
                                <div class="mazemaster-bb-row">
                                    <div class="mazemaster-bb-field" style="flex: 2;">
                                        <label>Difficulty <span id="mazemaster_bb_diff_val" style="opacity: 0.7;">(${currentBb.difficulty || 5})</span></label>
                                        <input type="range" id="mazemaster_bb_difficulty" min="1" max="10" value="${currentBb.difficulty || 5}" style="width: 100%;">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Damage</label>
                                        <input type="number" id="mazemaster_bb_damage" min="0" max="100" value="${currentBb.damage || 25}" title="HP damage on loss">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Hits to Win</label>
                                        <input type="number" id="mazemaster_bb_hits" min="1" max="20" value="${currentBb.hitsToWin || 5}">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Misses to Lose</label>
                                        <input type="number" id="mazemaster_bb_misses" min="1" max="20" value="${currentBb.missesToLose || 3}">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Main Title</label>
                            <input type="text" id="mazemaster_bb_main_title" class="mazemaster-input" placeholder="e.g. Boss Battle!" value="${escapeHtml(currentBb.mainTitle || '')}">
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Commands</label>
                            <div class="mazemaster-bb-commands">
                                <div class="mazemaster-bb-command">
                                    <label>On Hit:</label>
                                    <textarea id="mazemaster_bb_hit_cmd" placeholder="/echo Hit!">${escapeHtml(currentBb.hitCommand || '')}</textarea>
                                </div>
                                <div class="mazemaster-bb-command">
                                    <label>On Miss:</label>
                                    <textarea id="mazemaster_bb_miss_cmd" placeholder="/echo Miss!">${escapeHtml(currentBb.missCommand || '')}</textarea>
                                </div>
                                <div class="mazemaster-bb-command">
                                    <label>On Win:</label>
                                    <textarea id="mazemaster_bb_win_cmd" placeholder="/echo Victory!">${escapeHtml(currentBb.winCommand || '')}</textarea>
                                </div>
                                <div class="mazemaster-bb-command">
                                    <label>On Lose:</label>
                                    <textarea id="mazemaster_bb_lose_cmd" placeholder="/echo Defeat!">${escapeHtml(currentBb.loseCommand || '')}</textarea>
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Stages (click image to edit message)</label>
                            <div id="mazemaster_bb_images_list" class="mazemaster-bb-images-list">
                                <!-- Images rendered here -->
                            </div>
                            <button id="mazemaster_bb_add_image_btn" class="menu_button mazemaster-add-btn">
                                <i class="fa-solid fa-plus"></i> Add Image
                            </button>
                            <input type="file" id="mazemaster_bb_image_file" accept="image/*" style="display: none;">
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Item Drops on Win (Maze Only)</label>
                            <div class="mazemaster-row">
                                <label>Key %</label>
                                <input type="number" id="mazemaster_bb_key_drop" class="mazemaster-input-small" min="0" max="100" value="${currentBb.keyDropChance ?? 40}">
                            </div>
                            <div class="mazemaster-row">
                                <label>Strike %</label>
                                <input type="number" id="mazemaster_bb_pow_drop" class="mazemaster-input-small" min="0" max="100" value="${currentBb.strikeDropChance ?? 20}">
                            </div>
                            <div class="mazemaster-row">
                                <label>Stealth %</label>
                                <input type="number" id="mazemaster_bb_stealth_drop" class="mazemaster-input-small" min="0" max="100" value="${currentBb.stealthDropChance ?? 10}">
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <button id="mazemaster_bb_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                <i class="fa-solid fa-save"></i> Save Profile
                            </button>
                        </div>

                        <div class="mazemaster-section">
                            <div class="mazemaster-help">
                                <div class="mazemaster-help-title">Usage:</div>
                                <code>/battlebar profile="profileName"</code>
                                <div class="mazemaster-help-title">Difficulty:</div>
                                <ul>
                                    <li><code>1</code> - Easy (large zone, slow)</li>
                                    <li><code>5</code> - Medium</li>
                                    <li><code>10</code> - Hard (small zone, fast)</li>
                                </ul>
                            </div>
                        </div>
                        </div><!-- End combat_battlebar_content -->

                        <!-- TURN-BASED SUB-TAB -->
                        <div id="combat_turnbased_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Turn-Based Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_tb_profile_select" class="mazemaster-select">
                                        ${getTurnbasedProfileNames().length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${getTurnbasedProfileNames().map(p => `<option value="${escapeHtml(p)}" ${p === extensionSettings.currentTurnbasedProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_tb_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_tb_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_tb_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                    <button id="mazemaster_preview_turnbased_btn" class="menu_button menu_button_icon" title="Preview Turn-Based">
                                        <i class="fa-solid fa-eye"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Display</label>
                                <div class="mazemaster-row">
                                    <label>Title</label>
                                    <input type="text" id="mazemaster_tb_main_title" class="mazemaster-input" placeholder="Combat!" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Enemy Name</label>
                                    <input type="text" id="mazemaster_tb_enemy_name" class="mazemaster-input" placeholder="Enemy" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Description</label>
                                    <textarea id="mazemaster_tb_description" class="mazemaster-input" rows="2" placeholder="A fierce battle awaits..."></textarea>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Combat Stats</label>
                                <div class="mazemaster-combat-grid">
                                    <div class="mazemaster-combat-col">
                                        <strong style="color: #2ecc71;">Player</strong>
                                        <div class="mazemaster-row">
                                            <label>HP</label>
                                            <input type="number" id="mazemaster_tb_player_hp" class="mazemaster-input-small" min="1" max="999" value="100">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Attack</label>
                                            <input type="number" id="mazemaster_tb_player_attack" class="mazemaster-input-small" min="1" max="99" value="15">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Defense</label>
                                            <input type="number" id="mazemaster_tb_player_defense" class="mazemaster-input-small" min="0" max="99" value="5">
                                        </div>
                                    </div>
                                    <div class="mazemaster-combat-col">
                                        <strong style="color: #e74c3c;">Enemy</strong>
                                        <div class="mazemaster-row">
                                            <label>HP</label>
                                            <input type="number" id="mazemaster_tb_enemy_hp" class="mazemaster-input-small" min="1" max="999" value="50">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Attack</label>
                                            <input type="number" id="mazemaster_tb_enemy_attack" class="mazemaster-input-small" min="1" max="99" value="8">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Defense</label>
                                            <input type="number" id="mazemaster_tb_enemy_defense" class="mazemaster-input-small" min="0" max="99" value="2">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Mechanics</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Turn Order</label>
                                            <select id="mazemaster_tb_turn_order" class="mazemaster-select">
                                                <option value="player_first">Player First</option>
                                                <option value="enemy_first">Enemy First</option>
                                                <option value="random">Random</option>
                                            </select>
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Flee Chance %</label>
                                            <input type="number" id="mazemaster_tb_flee_chance" class="mazemaster-input-small" min="0" max="100" value="50">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Crit Chance %</label>
                                            <input type="number" id="mazemaster_tb_crit_chance" class="mazemaster-input-small" min="0" max="100" value="15">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Crit Multiplier</label>
                                            <input type="number" id="mazemaster_tb_crit_mult" class="mazemaster-input-small" min="1" max="5" step="0.1" value="1.5">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="flex: 2;">
                                            <label>Difficulty <span id="mazemaster_tb_diff_val" style="opacity: 0.7;">(5)</span></label>
                                            <input type="range" id="mazemaster_tb_difficulty" min="1" max="10" value="5" style="width: 100%;">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Damage on Loss</label>
                                            <input type="number" id="mazemaster_tb_damage" class="mazemaster-input-small" min="0" max="100" value="15">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Win:</label>
                                        <textarea id="mazemaster_tb_on_win" placeholder="/echo Victory!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Lose:</label>
                                        <textarea id="mazemaster_tb_on_lose" placeholder="/echo Defeat..."></textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Item Drops on Win</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Key %</label>
                                            <input type="number" id="mazemaster_tb_key_drop" class="mazemaster-input-small" min="0" max="100" value="30">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Strike %</label>
                                            <input type="number" id="mazemaster_tb_strike_drop" class="mazemaster-input-small" min="0" max="100" value="15">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Stealth %</label>
                                            <input type="number" id="mazemaster_tb_stealth_drop" class="mazemaster-input-small" min="0" max="100" value="10">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Potion %</label>
                                            <input type="number" id="mazemaster_tb_potion_drop" class="mazemaster-input-small" min="0" max="100" value="25">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_tb_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_turnbased_content -->

                        <!-- QTE SUB-TAB -->
                        <div id="combat_qte_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">QTE Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_qte_profile_select" class="mazemaster-select">
                                        ${getQteProfileNames().length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${getQteProfileNames().map(p => `<option value="${escapeHtml(p)}" ${p === extensionSettings.currentQteProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_qte_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_qte_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_qte_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                    <button id="mazemaster_preview_qte_btn" class="menu_button menu_button_icon" title="Preview QTE">
                                        <i class="fa-solid fa-eye"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Display</label>
                                <div class="mazemaster-row">
                                    <label>Title</label>
                                    <input type="text" id="mazemaster_qte_main_title" class="mazemaster-input" placeholder="Reaction Test" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Description</label>
                                    <textarea id="mazemaster_qte_description" class="mazemaster-input" rows="2" placeholder="Press the keys as they appear!"></textarea>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Sequence Settings</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Min Length</label>
                                            <input type="number" id="mazemaster_qte_seq_min" class="mazemaster-input-small" min="1" max="20" value="3">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Max Length</label>
                                            <input type="number" id="mazemaster_qte_seq_max" class="mazemaster-input-small" min="1" max="20" value="5">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Time Window (ms)</label>
                                            <input type="number" id="mazemaster_qte_time_base" class="mazemaster-input-small" min="500" max="5000" step="100" value="1500">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Min Time (ms)</label>
                                            <input type="number" id="mazemaster_qte_time_min" class="mazemaster-input-small" min="200" max="2000" step="100" value="800">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="flex: 2;">
                                            <label>Difficulty <span id="mazemaster_qte_diff_val" style="opacity: 0.7;">(5)</span></label>
                                            <input type="range" id="mazemaster_qte_difficulty" min="1" max="10" value="5" style="width: 100%;">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Damage on Fail</label>
                                            <input type="number" id="mazemaster_qte_damage" class="mazemaster-input-small" min="0" max="100" value="10">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Perfect Window %</label>
                                            <input type="number" id="mazemaster_qte_perfect" class="mazemaster-input-small" min="10" max="50" value="30">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Allowed Keys</label>
                                <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                                    <label style="display: flex; align-items: center; gap: 4px;"><input type="checkbox" id="mazemaster_qte_key_w" checked> W</label>
                                    <label style="display: flex; align-items: center; gap: 4px;"><input type="checkbox" id="mazemaster_qte_key_a" checked> A</label>
                                    <label style="display: flex; align-items: center; gap: 4px;"><input type="checkbox" id="mazemaster_qte_key_s" checked> S</label>
                                    <label style="display: flex; align-items: center; gap: 4px;"><input type="checkbox" id="mazemaster_qte_key_d" checked> D</label>
                                    <label style="display: flex; align-items: center; gap: 4px;"><input type="checkbox" id="mazemaster_qte_key_space" checked> SPACE</label>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Complete:</label>
                                        <textarea id="mazemaster_qte_on_complete" placeholder="/echo Quick reflexes!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Fail:</label>
                                        <textarea id="mazemaster_qte_on_fail" placeholder="/echo Too slow..."></textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_qte_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_qte_content -->

                        <!-- DICE SUB-TAB -->
                        <div id="combat_dice_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Dice Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_dice_profile_select" class="mazemaster-select">
                                        ${getDiceProfileNames().length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${getDiceProfileNames().map(p => `<option value="${escapeHtml(p)}" ${p === extensionSettings.currentDiceProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_dice_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_dice_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_dice_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                    <button id="mazemaster_preview_dice_btn" class="menu_button menu_button_icon" title="Preview Dice">
                                        <i class="fa-solid fa-eye"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Display</label>
                                <div class="mazemaster-row">
                                    <label>Title</label>
                                    <input type="text" id="mazemaster_dice_main_title" class="mazemaster-input" placeholder="Skill Check" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Description</label>
                                    <textarea id="mazemaster_dice_description" class="mazemaster-input" rows="2" placeholder="Roll to beat the target!"></textarea>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Dice Settings</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Dice Count</label>
                                            <input type="number" id="mazemaster_dice_count" class="mazemaster-input-small" min="1" max="10" value="2">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Dice Type</label>
                                            <select id="mazemaster_dice_type" class="mazemaster-select">
                                                <option value="4">d4</option>
                                                <option value="6" selected>d6</option>
                                                <option value="8">d8</option>
                                                <option value="10">d10</option>
                                                <option value="12">d12</option>
                                                <option value="20">d20</option>
                                                <option value="100">d100</option>
                                            </select>
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Target Number</label>
                                            <input type="number" id="mazemaster_dice_target" class="mazemaster-input-small" min="1" max="100" value="7">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Modifier</label>
                                            <input type="number" id="mazemaster_dice_modifier" class="mazemaster-input-small" min="-20" max="20" value="0">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="flex: 2;">
                                            <label>Difficulty <span id="mazemaster_dice_diff_val" style="opacity: 0.7;">(5)</span></label>
                                            <input type="range" id="mazemaster_dice_difficulty" min="1" max="10" value="5" style="width: 100%;">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Damage on Fail</label>
                                            <input type="number" id="mazemaster_dice_damage" class="mazemaster-input-small" min="0" max="100" value="15">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Rerolls</label>
                                            <input type="number" id="mazemaster_dice_rerolls" class="mazemaster-input-small" min="0" max="5" value="1">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Success:</label>
                                        <textarea id="mazemaster_dice_on_success" placeholder="/echo Success!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Fail:</label>
                                        <textarea id="mazemaster_dice_on_fail" placeholder="/echo Failed the check..."></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Critical:</label>
                                        <textarea id="mazemaster_dice_on_crit" placeholder="/echo Critical success!"></textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_dice_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_dice_content -->

                        <!-- STEALTH SUB-TAB -->
                        <div id="combat_stealth_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Stealth Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_stealth_profile_select" class="mazemaster-select">
                                        ${getStealthProfileNames().length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${getStealthProfileNames().map(p => `<option value="${escapeHtml(p)}" ${p === extensionSettings.currentStealthProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_stealth_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_stealth_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_stealth_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                    <button id="mazemaster_preview_stealth_btn" class="menu_button menu_button_icon" title="Preview Stealth">
                                        <i class="fa-solid fa-eye"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Display</label>
                                <div class="mazemaster-row">
                                    <label>Title</label>
                                    <input type="text" id="mazemaster_stealth_main_title" class="mazemaster-input" placeholder="Sneak Past" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Guard Name</label>
                                    <input type="text" id="mazemaster_stealth_guard_name" class="mazemaster-input" placeholder="Guard" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Description</label>
                                    <textarea id="mazemaster_stealth_description" class="mazemaster-input" rows="2" placeholder="Sneak past without being detected!"></textarea>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Stealth Settings</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Sections</label>
                                            <input type="number" id="mazemaster_stealth_sections" class="mazemaster-input-small" min="1" max="10" value="3" title="Areas to pass through">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Detection Limit</label>
                                            <input type="number" id="mazemaster_stealth_detection_limit" class="mazemaster-input-small" min="50" max="200" value="100" title="Max detection before caught">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Base Detection</label>
                                            <input type="number" id="mazemaster_stealth_base_detection" class="mazemaster-input-small" min="5" max="50" value="15" title="Detection gain when advancing">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Damage on Fail</label>
                                            <input type="number" id="mazemaster_stealth_damage" class="mazemaster-input-small" min="0" max="100" value="20">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="flex: 2;">
                                            <label>Difficulty <span id="mazemaster_stealth_diff_val" style="opacity: 0.7;">(5)</span></label>
                                            <input type="range" id="mazemaster_stealth_difficulty" min="1" max="10" value="5" style="width: 100%;">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Hide Reduction</label>
                                            <input type="number" id="mazemaster_stealth_hide_reduce" class="mazemaster-input-small" min="5" max="30" value="10" title="Detection reduced by Hide">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Distract Max</label>
                                            <input type="number" id="mazemaster_stealth_distract_max" class="mazemaster-input-small" min="10" max="50" value="25" title="Max detection reduced by Distract">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Success:</label>
                                        <textarea id="mazemaster_stealth_on_success" placeholder="/echo You made it past!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Caught:</label>
                                        <textarea id="mazemaster_stealth_on_caught" placeholder="/echo You've been spotted!"></textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_stealth_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_stealth_content -->

                        <!-- PUZZLE SUB-TAB -->
                        <div id="combat_puzzle_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Puzzle Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_puzzle_profile_select" class="mazemaster-select">
                                        ${getPuzzleProfileNames().length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${getPuzzleProfileNames().map(p => `<option value="${escapeHtml(p)}" ${p === extensionSettings.currentPuzzleProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_puzzle_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_puzzle_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_puzzle_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                    <button id="mazemaster_preview_puzzle_btn" class="menu_button menu_button_icon" title="Preview Puzzle">
                                        <i class="fa-solid fa-eye"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Display</label>
                                <div class="mazemaster-row">
                                    <label>Title</label>
                                    <input type="text" id="mazemaster_puzzle_main_title" class="mazemaster-input" placeholder="Memory Puzzle" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Description</label>
                                    <textarea id="mazemaster_puzzle_description" class="mazemaster-input" rows="2" placeholder="Watch the sequence and repeat it!"></textarea>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Puzzle Settings</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Grid Size</label>
                                            <select id="mazemaster_puzzle_grid_size" class="mazemaster-select">
                                                <option value="2">2x2</option>
                                                <option value="3" selected>3x3</option>
                                                <option value="4">4x4</option>
                                                <option value="5">5x5</option>
                                            </select>
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Sequence Length</label>
                                            <input type="number" id="mazemaster_puzzle_seq_length" class="mazemaster-input-small" min="2" max="12" value="4">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Max Mistakes</label>
                                            <input type="number" id="mazemaster_puzzle_max_mistakes" class="mazemaster-input-small" min="1" max="10" value="5">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Hints</label>
                                            <input type="number" id="mazemaster_puzzle_hints" class="mazemaster-input-small" min="0" max="5" value="3">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="flex: 2;">
                                            <label>Difficulty <span id="mazemaster_puzzle_diff_val" style="opacity: 0.7;">(5)</span></label>
                                            <input type="range" id="mazemaster_puzzle_difficulty" min="1" max="10" value="5" style="width: 100%;">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Damage on Fail</label>
                                            <input type="number" id="mazemaster_puzzle_damage" class="mazemaster-input-small" min="0" max="100" value="15">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Time Limit (sec)</label>
                                            <input type="number" id="mazemaster_puzzle_time_limit" class="mazemaster-input-small" min="0" max="300" value="60" title="0 = no limit">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Solve:</label>
                                        <textarea id="mazemaster_puzzle_on_solve" placeholder="/echo Puzzle solved!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Fail:</label>
                                        <textarea id="mazemaster_puzzle_on_fail" placeholder="/echo Too many mistakes..."></textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_puzzle_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_puzzle_content -->

                        <!-- NEGOTIATION SUB-TAB -->
                        <div id="combat_negotiation_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Negotiation Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_negotiation_profile_select" class="mazemaster-select">
                                        ${getNegotiationProfileNames().length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${getNegotiationProfileNames().map(p => `<option value="${escapeHtml(p)}" ${p === extensionSettings.currentNegotiationProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_negotiation_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_negotiation_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_negotiation_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                    <button id="mazemaster_preview_negotiation_btn" class="menu_button menu_button_icon" title="Preview Negotiation">
                                        <i class="fa-solid fa-eye"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Display</label>
                                <div class="mazemaster-row">
                                    <label>Title</label>
                                    <input type="text" id="mazemaster_negotiate_main_title" class="mazemaster-input" placeholder="Negotiation" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>NPC Name</label>
                                    <input type="text" id="mazemaster_negotiate_npc_name" class="mazemaster-input" placeholder="Merchant" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Description</label>
                                    <textarea id="mazemaster_negotiate_description" class="mazemaster-input" rows="2" placeholder="Convince them to help you..."></textarea>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Negotiation Settings</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Favor Target</label>
                                            <input type="number" id="mazemaster_negotiate_favor_target" class="mazemaster-input-small" min="25" max="100" value="75" title="Favor needed to win">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Starting Favor</label>
                                            <input type="number" id="mazemaster_negotiate_starting_favor" class="mazemaster-input-small" min="0" max="75" value="25">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Max Turns</label>
                                            <input type="number" id="mazemaster_negotiate_max_turns" class="mazemaster-input-small" min="3" max="20" value="6">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Damage on Fail</label>
                                            <input type="number" id="mazemaster_negotiate_damage" class="mazemaster-input-small" min="0" max="100" value="10">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="flex: 2;">
                                            <label>Difficulty <span id="mazemaster_negotiate_diff_val" style="opacity: 0.7;">(5)</span></label>
                                            <input type="range" id="mazemaster_negotiate_difficulty" min="1" max="10" value="5" style="width: 100%;">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Persuade Avg</label>
                                            <input type="number" id="mazemaster_negotiate_persuade" class="mazemaster-input-small" min="5" max="30" value="12" title="Average favor from Persuade">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Flatter Avg</label>
                                            <input type="number" id="mazemaster_negotiate_flatter" class="mazemaster-input-small" min="5" max="25" value="10" title="Average favor from Flatter">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">NPC Personality</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Starting Mood</label>
                                            <select id="mazemaster_negotiate_mood" class="mazemaster-select">
                                                <option value="hostile">Hostile (-favor)</option>
                                                <option value="unfriendly" selected>Unfriendly</option>
                                                <option value="neutral">Neutral</option>
                                                <option value="friendly">Friendly (+favor)</option>
                                            </select>
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Intimidate Risk</label>
                                            <select id="mazemaster_negotiate_intimidate" class="mazemaster-select">
                                                <option value="low">Low (safe)</option>
                                                <option value="medium" selected>Medium</option>
                                                <option value="high">High (risky)</option>
                                            </select>
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Bribe Cost</label>
                                            <select id="mazemaster_negotiate_bribe_cost" class="mazemaster-select">
                                                <option value="key">Key</option>
                                                <option value="gold" selected>Gold (10)</option>
                                                <option value="potion">Potion</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Success:</label>
                                        <textarea id="mazemaster_negotiate_on_success" placeholder="/echo They agreed to help!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Fail:</label>
                                        <textarea id="mazemaster_negotiate_on_fail" placeholder="/echo Negotiations broke down..."></textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_negotiate_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_negotiation_content -->

                        <!-- MECHANICS SUB-TAB (v1.6.0) -->
                        <div id="combat_mechanics_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Combat Mechanics Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_cm_profile_select" class="mazemaster-select">
                                        ${cmProfiles.length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${cmProfiles.map(p => `<option value="${escapeHtml(p)}" ${p === currentCmProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_cm_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_cm_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_cm_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                </div>
                            </div>

                            <!-- Combo System -->
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">
                                    <input type="checkbox" id="mazemaster_cm_combo_enabled" ${currentCm.comboEnabled ? 'checked' : ''}>
                                    Combo System
                                </label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Bonus per Hit (%)</label>
                                            <input type="number" id="mazemaster_cm_combo_bonus" min="1" max="25" value="${currentCm.comboBonusPerHit || 5}">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Max Bonus (%)</label>
                                            <input type="number" id="mazemaster_cm_combo_max" min="10" max="100" value="${currentCm.maxComboBonus || 50}">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Decay Turns</label>
                                            <input type="number" id="mazemaster_cm_combo_decay" min="1" max="10" value="${currentCm.comboDecayTurns || 2}">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="display: flex; align-items: center; gap: 8px;">
                                            <input type="checkbox" id="mazemaster_cm_combo_reset_miss" ${currentCm.comboResetOnMiss !== false ? 'checked' : ''}>
                                            <label style="margin: 0;">Reset on Miss</label>
                                        </div>
                                        <div class="mazemaster-bb-field" style="display: flex; align-items: center; gap: 8px;">
                                            <input type="checkbox" id="mazemaster_cm_combo_reset_damage" ${currentCm.comboResetOnDamage ? 'checked' : ''}>
                                            <label style="margin: 0;">Reset on Damage</label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Block System -->
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">
                                    <input type="checkbox" id="mazemaster_cm_block_enabled" ${currentCm.blockEnabled ? 'checked' : ''}>
                                    Block System
                                </label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Damage Reduction (%)</label>
                                            <input type="number" id="mazemaster_cm_block_reduction" min="10" max="100" value="${Math.round((currentCm.blockDamageReduction || 0.5) * 100)}">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Break Threshold</label>
                                            <input type="number" id="mazemaster_cm_block_threshold" min="0" max="100" value="${currentCm.blockBreakThreshold || 0}" title="Damage to break block (0=never)">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Perfect Block (%)</label>
                                            <input type="number" id="mazemaster_cm_perfect_block" min="50" max="100" value="${Math.round((currentCm.perfectBlockReduction || 0.8) * 100)}">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Parry System -->
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">
                                    <input type="checkbox" id="mazemaster_cm_parry_enabled" ${currentCm.parryEnabled ? 'checked' : ''}>
                                    Parry System
                                </label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Window (sec)</label>
                                            <input type="number" id="mazemaster_cm_parry_window" min="0.1" max="2" step="0.1" value="${currentCm.parryWindow || 0.5}">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Counter Multiplier</label>
                                            <input type="number" id="mazemaster_cm_parry_mult" min="1" max="3" step="0.1" value="${currentCm.parryDamageMultiplier || 1.5}">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Stun Duration</label>
                                            <input type="number" id="mazemaster_cm_parry_stun" min="0" max="5" value="${currentCm.parryStunDuration || 1}">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Difficulty</label>
                                            <select id="mazemaster_cm_parry_diff" class="mazemaster-select">
                                                <option value="easy" ${currentCm.parryDifficulty === 'easy' ? 'selected' : ''}>Easy</option>
                                                <option value="normal" ${currentCm.parryDifficulty === 'normal' || !currentCm.parryDifficulty ? 'selected' : ''}>Normal</option>
                                                <option value="hard" ${currentCm.parryDifficulty === 'hard' ? 'selected' : ''}>Hard</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Counter System -->
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">
                                    <input type="checkbox" id="mazemaster_cm_counter_enabled" ${currentCm.counterEnabled !== false ? 'checked' : ''}>
                                    Counter-Attack
                                </label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Damage Bonus (%)</label>
                                            <input type="number" id="mazemaster_cm_counter_bonus" min="0" max="100" value="${currentCm.counterDamageBonus || 25}">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Crit Bonus (%)</label>
                                            <input type="number" id="mazemaster_cm_counter_crit" min="0" max="50" value="${currentCm.counterCritBonus || 15}">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- STScript Hooks -->
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Combo Increase:</label>
                                        <textarea id="mazemaster_cm_on_combo" placeholder="/echo Combo {{comboCount}}x! +{{totalBonus}}% damage">${escapeHtml(currentCm.onComboIncrease || '')}</textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Combo Break:</label>
                                        <textarea id="mazemaster_cm_on_combo_break" placeholder="/echo Combo broken at {{finalCombo}}x!">${escapeHtml(currentCm.onComboBreak || '')}</textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Block Success:</label>
                                        <textarea id="mazemaster_cm_on_block" placeholder="/echo Blocked {{damageBlocked}} damage!">${escapeHtml(currentCm.onBlockSuccess || '')}</textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Parry Success:</label>
                                        <textarea id="mazemaster_cm_on_parry" placeholder="/echo Parried {{enemyName}}! Counter: {{counterDamage}}">${escapeHtml(currentCm.onParrySuccess || '')}</textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Counter Attack:</label>
                                        <textarea id="mazemaster_cm_on_counter" placeholder="/echo Counter hit for {{damage}}!">${escapeHtml(currentCm.onCounterAttack || '')}</textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_cm_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_mechanics_content -->

                    </div><!-- End mazemaster_combat_config -->

                    <!-- MAZE CONFIG -->
                    <div id="mazemaster_maze_config" class="mazemaster-game-config" style="${activeGame === 'maze' ? '' : 'display: none;'}">
                        <!-- Profile Selection -->
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Maze Profile</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_maze_profile_select" class="mazemaster-select">
                                    ${mazeProfiles.length === 0 ? '<option value="">No profiles</option>' : ''}
                                    ${mazeProfiles.map(p => `<option value="${escapeHtml(p)}" ${p === currentMazeProfileName ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                </select>
                                <button id="mazemaster_maze_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                                <button id="mazemaster_maze_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                                <button id="mazemaster_maze_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                    <i class="fa-solid fa-pen"></i>
                                </button>
                            </div>
                        </div>

                        <!-- Grid Size and Difficulty -->
                        <div class="mazemaster-inline-row">
                            <div class="mazemaster-section mazemaster-flex-1">
                                <label class="mazemaster-label">Grid Size</label>
                                <select id="mazemaster_maze_size" class="mazemaster-select">
                                    <option value="5" ${(currentMazeData.gridSize || 10) === 5 ? 'selected' : ''}>5x5</option>
                                    <option value="6" ${(currentMazeData.gridSize || 10) === 6 ? 'selected' : ''}>6x6</option>
                                    <option value="7" ${(currentMazeData.gridSize || 10) === 7 ? 'selected' : ''}>7x7</option>
                                    <option value="8" ${(currentMazeData.gridSize || 10) === 8 ? 'selected' : ''}>8x8</option>
                                    <option value="9" ${(currentMazeData.gridSize || 10) === 9 ? 'selected' : ''}>9x9</option>
                                    <option value="10" ${(currentMazeData.gridSize || 10) === 10 ? 'selected' : ''}>10x10</option>
                                    <option value="11" ${(currentMazeData.gridSize || 10) === 11 ? 'selected' : ''}>11x11</option>
                                    <option value="12" ${(currentMazeData.gridSize || 10) === 12 ? 'selected' : ''}>12x12</option>
                                    <option value="13" ${(currentMazeData.gridSize || 10) === 13 ? 'selected' : ''}>13x13</option>
                                    <option value="14" ${(currentMazeData.gridSize || 10) === 14 ? 'selected' : ''}>14x14</option>
                                    <option value="15" ${(currentMazeData.gridSize || 10) === 15 ? 'selected' : ''}>15x15</option>
                                    <option value="16" ${(currentMazeData.gridSize || 10) === 16 ? 'selected' : ''}>16x16</option>
                                    <option value="17" ${(currentMazeData.gridSize || 10) === 17 ? 'selected' : ''}>17x17</option>
                                    <option value="18" ${(currentMazeData.gridSize || 10) === 18 ? 'selected' : ''}>18x18</option>
                                    <option value="19" ${(currentMazeData.gridSize || 10) === 19 ? 'selected' : ''}>19x19</option>
                                    <option value="20" ${(currentMazeData.gridSize || 10) === 20 ? 'selected' : ''}>20x20</option>
                                </select>
                            </div>
                            <div class="mazemaster-section mazemaster-flex-1">
                                <label class="mazemaster-label">Difficulty</label>
                                <select id="mazemaster_maze_difficulty" class="mazemaster-select">
                                    ${generateDifficultyOptionsHTML(currentMazeData.difficulty || 'normal')}
                                </select>
                            </div>
                        </div>
                        <div class="mazemaster-help-small"><small>Difficulty affects encounter density, trap frequency, loot, and starting inventory</small></div>

                        <div class="mazemaster-flex-row">
                            <div class="mazemaster-section mazemaster-flex-1">
                                <label class="mazemaster-label">Theme</label>
                                <select id="mazemaster_maze_theme" class="mazemaster-select">
                                    ${generateThemeOptionsHTML(currentMazeData.theme || 'fantasy')}
                                </select>
                            </div>
                            <div class="mazemaster-section mazemaster-flex-1">
                                <label class="mazemaster-label">Map Style</label>
                                <select id="mazemaster_maze_mapstyle" class="mazemaster-select">
                                    ${generateMapStyleOptionsHTML(currentMazeData.mapStyle || 'maze')}
                                </select>
                            </div>
                            <div class="mazemaster-section mazemaster-flex-1">
                                <label class="mazemaster-label">Floors</label>
                                <select id="mazemaster_maze_floors" class="mazemaster-select">
                                    <option value="1" ${(currentMazeData.floors || 1) === 1 ? 'selected' : ''}>1 Floor</option>
                                    <option value="2" ${(currentMazeData.floors || 1) === 2 ? 'selected' : ''}>2 Floors</option>
                                    <option value="3" ${(currentMazeData.floors || 1) === 3 ? 'selected' : ''}>3 Floors</option>
                                    <option value="4" ${(currentMazeData.floors || 1) === 4 ? 'selected' : ''}>4 Floors</option>
                                    <option value="5" ${(currentMazeData.floors || 1) === 5 ? 'selected' : ''}>5 Floors</option>
                                </select>
                            </div>
                        </div>
                        <div class="mazemaster-help-small"><small>Theme affects flavor text and item names. Map style changes the generation algorithm. Floors adds vertical navigation with staircases.</small></div>

                        <div class="mazemaster-row" style="margin-top: 8px;">
                            <label style="font-size: 0.85em; color: var(--SmartThemeBodyColor); margin-bottom: 4px; display: block;">Map Visibility</label>
                            <div class="mazemaster-radio-group" style="display: flex; gap: 12px; flex-wrap: wrap;">
                                <label class="mazemaster-radio-label" style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                    <input type="radio" name="mazemaster_map_visibility" value="showAll" ${currentMazeData.mapVisibility === 'showAll' || (!currentMazeData.mapVisibility && currentMazeData.fogOfWar === false) ? 'checked' : ''}>
                                    <span>Show Full</span>
                                </label>
                                <label class="mazemaster-radio-label" style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                    <input type="radio" name="mazemaster_map_visibility" value="fogOfWar" ${currentMazeData.mapVisibility === 'fogOfWar' || (!currentMazeData.mapVisibility && currentMazeData.fogOfWar !== false) ? 'checked' : ''}>
                                    <span>Fog of War</span>
                                </label>
                                <label class="mazemaster-radio-label" style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                    <input type="radio" name="mazemaster_map_visibility" value="hideUnexplored" ${currentMazeData.mapVisibility === 'hideUnexplored' ? 'checked' : ''}>
                                    <span>Hide Unexplored</span>
                                </label>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Minimap Settings -->
                        <div class="mazemaster-collapsible ${getMinimapSettings().enabled ? 'expanded' : ''}">
                            <button class="mazemaster-collapsible-header" data-target="minimap_settings_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Minimap</span>
                                <span class="mazemaster-collapse-hint">(${getMinimapSettings().enabled ? 'enabled' : 'disabled'})</span>
                            </button>
                            <div id="minimap_settings_section" class="mazemaster-collapsible-content" style="display: ${getMinimapSettings().enabled ? 'block' : 'none'};">
                                <div class="mazemaster-section">
                                    <div class="mazemaster-flex-row" style="gap: 10px;">
                                        <div class="mazemaster-section mazemaster-flex-1">
                                            <label class="mazemaster-checkbox-label">
                                                <input type="checkbox" id="mazemaster_minimap_enabled" ${getMinimapSettings().enabled ? 'checked' : ''}>
                                                <span>Enable Minimap</span>
                                            </label>
                                        </div>
                                        <div class="mazemaster-section mazemaster-flex-1">
                                            <label class="mazemaster-label">Position</label>
                                            <select id="mazemaster_minimap_position" class="mazemaster-select">
                                                <option value="top-left" ${getMinimapSettings().position === 'top-left' ? 'selected' : ''}>Top Left</option>
                                                <option value="top-right" ${getMinimapSettings().position === 'top-right' ? 'selected' : ''}>Top Right</option>
                                                <option value="bottom-left" ${getMinimapSettings().position === 'bottom-left' ? 'selected' : ''}>Bottom Left</option>
                                                <option value="bottom-right" ${getMinimapSettings().position === 'bottom-right' ? 'selected' : ''}>Bottom Right</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="mazemaster-flex-row" style="gap: 10px; margin-top: 8px;">
                                        <div class="mazemaster-section mazemaster-flex-1">
                                            <label class="mazemaster-label">Size (px)</label>
                                            <input type="number" id="mazemaster_minimap_size" class="mazemaster-input" value="${getMinimapSettings().size}" min="80" max="300" step="10">
                                        </div>
                                        <div class="mazemaster-section mazemaster-flex-1">
                                            <label class="mazemaster-label">Opacity</label>
                                            <input type="range" id="mazemaster_minimap_opacity" class="mazemaster-range" value="${getMinimapSettings().opacity * 100}" min="20" max="100" step="5">
                                            <span class="mazemaster-range-value">${Math.round(getMinimapSettings().opacity * 100)}%</span>
                                        </div>
                                    </div>
                                    <div class="mazemaster-flex-row" style="gap: 10px; margin-top: 8px;">
                                        <div class="mazemaster-section mazemaster-flex-1">
                                            <label class="mazemaster-checkbox-label">
                                                <input type="checkbox" id="mazemaster_minimap_show_markers" ${getMinimapSettings().showMarkers !== false ? 'checked' : ''}>
                                                <span>Show Markers</span>
                                            </label>
                                        </div>
                                        <div class="mazemaster-section mazemaster-flex-1">
                                            <label class="mazemaster-checkbox-label">
                                                <input type="checkbox" id="mazemaster_minimap_show_minions" ${getMinimapSettings().showMinions !== false ? 'checked' : ''}>
                                                <span>Show Minions</span>
                                            </label>
                                        </div>
                                        <div class="mazemaster-section mazemaster-flex-1">
                                            <label class="mazemaster-checkbox-label">
                                                <input type="checkbox" id="mazemaster_minimap_show_chests" ${getMinimapSettings().showChests !== false ? 'checked' : ''}>
                                                <span>Show Chests</span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="mazemaster-help-small" style="margin-top: 6px;"><small>The minimap shows a bird's eye view of the maze. Click to place markers, or use the toggle button in the maze UI.</small></div>
                                </div>
                            </div>
                        </div>

                        <!-- v1.4.0 BSP Configuration -->
                        <div class="mazemaster-collapsible ${currentMazeData.bspConfig?.zoneCount > 1 || currentMazeData.bspConfig?.secretDensity > 0 ? 'expanded' : ''}">
                            <button class="mazemaster-collapsible-header" data-target="bsp_config_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Zone & Secret Settings</span>
                                <span class="mazemaster-collapse-hint">(BSP dungeon generation)</span>
                            </button>
                            <div id="bsp_config_section" class="mazemaster-collapsible-content" style="display: ${currentMazeData.bspConfig?.zoneCount > 1 || currentMazeData.bspConfig?.secretDensity > 0 ? 'block' : 'none'};">
                                <div class="mazemaster-flex-row" style="gap: 10px;">
                                    <div class="mazemaster-section mazemaster-flex-1">
                                        <label class="mazemaster-label">Zone Count</label>
                                        <select id="mazemaster_bsp_zone_count" class="mazemaster-select">
                                            <option value="1" ${(currentMazeData.bspConfig?.zoneCount || 1) === 1 ? 'selected' : ''}>1 (No zones)</option>
                                            <option value="2" ${(currentMazeData.bspConfig?.zoneCount || 1) === 2 ? 'selected' : ''}>2 Zones</option>
                                            <option value="3" ${(currentMazeData.bspConfig?.zoneCount || 1) === 3 ? 'selected' : ''}>3 Zones</option>
                                            <option value="4" ${(currentMazeData.bspConfig?.zoneCount || 1) === 4 ? 'selected' : ''}>4 Zones</option>
                                            <option value="5" ${(currentMazeData.bspConfig?.zoneCount || 1) === 5 ? 'selected' : ''}>5 Zones</option>
                                        </select>
                                    </div>
                                    <div class="mazemaster-section mazemaster-flex-1">
                                        <label class="mazemaster-label">Secret Passages</label>
                                        <select id="mazemaster_bsp_secret_density" class="mazemaster-select">
                                            <option value="0" ${(currentMazeData.bspConfig?.secretDensity || 0) === 0 ? 'selected' : ''}>None</option>
                                            <option value="0.02" ${(currentMazeData.bspConfig?.secretDensity || 0) == 0.02 ? 'selected' : ''}>Low (2%)</option>
                                            <option value="0.05" ${(currentMazeData.bspConfig?.secretDensity || 0) == 0.05 ? 'selected' : ''}>Medium (5%)</option>
                                            <option value="0.08" ${(currentMazeData.bspConfig?.secretDensity || 0) == 0.08 ? 'selected' : ''}>High (8%)</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="mazemaster-flex-row" style="gap: 10px; margin-top: 8px;">
                                    <div class="mazemaster-section mazemaster-flex-1">
                                        <label class="mazemaster-checkbox-label">
                                            <input type="checkbox" id="mazemaster_bsp_zones_require_clear" ${currentMazeData.bspConfig?.zonesRequireClear !== false ? 'checked' : ''}>
                                            <span>Zones require room clearing</span>
                                        </label>
                                    </div>
                                    <div class="mazemaster-section mazemaster-flex-1">
                                        <label class="mazemaster-checkbox-label">
                                            <input type="checkbox" id="mazemaster_bsp_secret_hints" ${currentMazeData.bspConfig?.secretHints !== false ? 'checked' : ''}>
                                            <span>Show secret hints</span>
                                        </label>
                                    </div>
                                </div>
                                <div class="mazemaster-flex-row" style="gap: 10px; margin-top: 8px;">
                                    <div class="mazemaster-section mazemaster-flex-1">
                                        <label class="mazemaster-checkbox-label">
                                            <input type="checkbox" id="mazemaster_bsp_floor_scaling" ${currentMazeData.bspConfig?.floorComplexityScaling !== false ? 'checked' : ''}>
                                            <span>Scale complexity per floor</span>
                                        </label>
                                    </div>
                                </div>
                                <div class="mazemaster-help-small" style="margin-top: 6px;"><small>Zones create Metroidvania-style progression. Clear rooms to unlock the next zone. Secrets are hidden passages found by bumping walls.</small></div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Teleport Portals -->
                        <div class="mazemaster-collapsible ${(currentMazeData.portals && currentMazeData.portals.length > 0) ? 'expanded' : ''}">
                            <button class="mazemaster-collapsible-header" data-target="portals_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Teleport Portals</span>
                                <span class="mazemaster-collapse-hint">(${(currentMazeData.portals || []).length} portal pairs)</span>
                            </button>
                            <div id="portals_section" class="mazemaster-collapsible-content" style="display: ${(currentMazeData.portals && currentMazeData.portals.length > 0) ? 'block' : 'none'};">
                                <div class="mazemaster-section">
                                    <div class="mazemaster-help-small"><small>Add portals that teleport the player between two points. Leave coordinates blank for random placement.</small></div>
                                    <div id="mazemaster_portals_list" class="mazemaster-portals-list">
                                        ${(currentMazeData.portals || []).map((portal, idx) => `
                                            <div class="mazemaster-portal-item" data-portal-index="${idx}">
                                                <div class="portal-header">
                                                    <span class="portal-color" style="background: ${portal.color || '#9b59b6'}"></span>
                                                    <span class="portal-name">${escapeHtml(portal.id || 'Portal ' + (idx + 1))}</span>
                                                    <button class="menu_button remove-portal-btn" data-index="${idx}" title="Remove Portal">
                                                        <i class="fa-solid fa-trash"></i>
                                                    </button>
                                                </div>
                                                <div class="portal-details">
                                                    <div class="portal-row">
                                                        <label>ID:</label>
                                                        <input type="text" class="portal-id mazemaster-input" value="${escapeHtml(portal.id || '')}" placeholder="portal1">
                                                    </div>
                                                    <div class="portal-row">
                                                        <label>Color:</label>
                                                        <input type="color" class="portal-color-input" value="${portal.color || '#9b59b6'}">
                                                    </div>
                                                    <div class="portal-row">
                                                        <label>Bidirectional:</label>
                                                        <input type="checkbox" class="portal-bidirectional" ${portal.bidirectional !== false ? 'checked' : ''}>
                                                    </div>
                                                    <div class="portal-row coords-row">
                                                        <span>Start: X</span>
                                                        <input type="number" class="portal-start-x mazemaster-input" value="${portal.startX ?? ''}" placeholder="auto" min="0">
                                                        <span>Y</span>
                                                        <input type="number" class="portal-start-y mazemaster-input" value="${portal.startY ?? ''}" placeholder="auto" min="0">
                                                    </div>
                                                    <div class="portal-row coords-row">
                                                        <span>End: X</span>
                                                        <input type="number" class="portal-end-x mazemaster-input" value="${portal.endX ?? ''}" placeholder="auto" min="0">
                                                        <span>Y</span>
                                                        <input type="number" class="portal-end-y mazemaster-input" value="${portal.endY ?? ''}" placeholder="auto" min="0">
                                                    </div>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                    <button id="mazemaster_add_portal_btn" class="menu_button">
                                        <i class="fa-solid fa-plus"></i> Add Portal Pair
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Objectives -->
                        <div class="mazemaster-collapsible ${(currentMazeData.objectives && currentMazeData.objectives.length > 0) ? 'expanded' : ''}">
                            <button class="mazemaster-collapsible-header" data-target="objectives_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Objectives</span>
                                <span class="mazemaster-collapse-hint">(${(currentMazeData.objectives || []).length} objectives)</span>
                            </button>
                            <div id="objectives_section" class="mazemaster-collapsible-content" style="display: ${(currentMazeData.objectives && currentMazeData.objectives.length > 0) ? 'block' : 'none'};">
                                <div class="mazemaster-section">
                                    <div class="mazemaster-help-small"><small>Define objectives the player must complete. Required objectives must be done before exiting.</small></div>
                                    <div id="mazemaster_objectives_list" class="mazemaster-objectives-list">
                                        ${(currentMazeData.objectives || []).map((obj, idx) => `
                                            <div class="mazemaster-objective-item" data-objective-index="${idx}">
                                                <div class="objective-config-header">
                                                    <span class="objective-name">${escapeHtml(obj.description || obj.id || 'Objective ' + (idx + 1))}</span>
                                                    <button class="menu_button remove-objective-btn" data-index="${idx}" title="Remove Objective">
                                                        <i class="fa-solid fa-trash"></i>
                                                    </button>
                                                </div>
                                                <div class="objective-config-details">
                                                    <div class="objective-config-row">
                                                        <label>ID:</label>
                                                        <input type="text" class="objective-id mazemaster-input" value="${escapeHtml(obj.id || '')}" placeholder="obj1">
                                                    </div>
                                                    <div class="objective-config-row">
                                                        <label>Type:</label>
                                                        <select class="objective-type mazemaster-select">
                                                            <option value="collect" ${obj.type === 'collect' ? 'selected' : ''}>Collect Item</option>
                                                            <option value="defeat" ${obj.type === 'defeat' ? 'selected' : ''}>Defeat Minion</option>
                                                            <option value="explore" ${obj.type === 'explore' ? 'selected' : ''}>Explore %</option>
                                                        </select>
                                                    </div>
                                                    <div class="objective-config-row objective-target-row" style="display: ${obj.type !== 'explore' ? 'flex' : 'none'};">
                                                        <label>Target:</label>
                                                        <input type="text" class="objective-target mazemaster-input" value="${escapeHtml(obj.target || '')}" placeholder="${obj.type === 'collect' ? 'key, strike, stealth...' : 'minion ID'}">
                                                    </div>
                                                    <div class="objective-config-row">
                                                        <label>Count:</label>
                                                        <input type="number" class="objective-count mazemaster-input" value="${obj.count || 1}" min="1" placeholder="${obj.type === 'explore' ? '% to explore' : 'amount'}">
                                                    </div>
                                                    <div class="objective-config-row">
                                                        <label>Description:</label>
                                                        <input type="text" class="objective-description mazemaster-input" value="${escapeHtml(obj.description || '')}" placeholder="Find 3 Keys">
                                                    </div>
                                                    <div class="objective-config-row">
                                                        <label>Required:</label>
                                                        <input type="checkbox" class="objective-required" ${obj.required ? 'checked' : ''}>
                                                    </div>
                                                    <div class="objective-config-row">
                                                        <label>Reward Script:</label>
                                                        <input type="text" class="objective-reward mazemaster-input" value="${escapeHtml(obj.reward || '')}" placeholder="/echo Objective complete!">
                                                    </div>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                    <button id="mazemaster_add_objective_btn" class="menu_button">
                                        <i class="fa-solid fa-plus"></i> Add Objective
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Main Minion -->
                        <div class="mazemaster-collapsible ${currentMazeData.mainMinion ? 'expanded' : ''}">
                            <button class="mazemaster-collapsible-header" data-target="main_minion_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Main Minion</span>
                                <span class="mazemaster-collapse-hint">(narrator/boss)</span>
                            </button>
                            <div id="main_minion_section" class="mazemaster-collapsible-content" style="display: ${currentMazeData.mainMinion ? 'block' : 'none'};">
                                <div class="mazemaster-section">
                                    <select id="mazemaster_maze_main_minion" class="mazemaster-select">
                                        <option value="">None</option>
                                        ${minionsList.map(id => {
                                            const m = getMinion(id);
                                            return `<option value="${escapeHtml(id)}" ${currentMazeData.mainMinion === id ? 'selected' : ''}>${escapeHtml(m?.name || id)}</option>`;
                                        }).join('')}
                                    </select>
                                    <div class="mazemaster-help-small"><small>The main minion narrates the maze and guards the exit</small></div>
                                </div>

                                <div id="mazemaster_main_minion_settings" class="mazemaster-subsection" style="display: ${currentMazeData.mainMinion ? 'block' : 'none'};">
                                    <div class="mazemaster-section">
                                        <label class="mazemaster-label">Intro Message</label>
                                        <input type="text" id="mazemaster_maze_intro_message" class="mazemaster-input" placeholder="Welcome to my maze..." value="${escapeHtml(currentMazeData.mainMinionIntroMessage || '')}">
                                    </div>

                                    <div class="mazemaster-inline-row">
                                        <div class="mazemaster-section mazemaster-flex-1">
                                            <label class="mazemaster-label">Random Msg %</label>
                                            <input type="number" id="mazemaster_maze_random_chance" class="mazemaster-input" min="0" max="100" value="${currentMazeData.mainMinionRandomChance || 15}">
                                        </div>
                                    </div>

                                    <div class="mazemaster-section">
                                        <label class="mazemaster-label">Random Messages (one per line)</label>
                                        <textarea id="mazemaster_maze_random_messages" class="mazemaster-textarea" rows="2" placeholder="You're still here?&#10;Getting lost yet?">${escapeHtml((currentMazeData.mainMinionRandomMessages || []).join('\n'))}</textarea>
                                    </div>

                                    <div class="mazemaster-section">
                                        <label class="mazemaster-label">Exit Encounter</label>
                                        <div class="mazemaster-help-small"><small>What happens when the player reaches the exit</small></div>
                                        <select id="mazemaster_maze_exit_type" class="mazemaster-select">
                                            <option value="messenger" ${(currentMazeData.mainMinionExitType || 'messenger') === 'messenger' ? 'selected' : ''}>Message Only (no challenge)</option>
                                            <option value="battlebar" ${currentMazeData.mainMinionExitType === 'battlebar' ? 'selected' : ''}>Battlebar Fight</option>
                                            <option value="prizewheel" ${currentMazeData.mainMinionExitType === 'prizewheel' ? 'selected' : ''}>Prize Wheel</option>
                                            <option value="turnbased" ${currentMazeData.mainMinionExitType === 'turnbased' ? 'selected' : ''}>Turn-Based Combat</option>
                                            <option value="qte" ${currentMazeData.mainMinionExitType === 'qte' ? 'selected' : ''}>QTE Combat</option>
                                            <option value="dice" ${currentMazeData.mainMinionExitType === 'dice' ? 'selected' : ''}>Dice Combat</option>
                                            <option value="stealth" ${currentMazeData.mainMinionExitType === 'stealth' ? 'selected' : ''}>Stealth</option>
                                            <option value="puzzle" ${currentMazeData.mainMinionExitType === 'puzzle' ? 'selected' : ''}>Puzzle</option>
                                            <option value="negotiation" ${currentMazeData.mainMinionExitType === 'negotiation' ? 'selected' : ''}>Negotiation</option>
                                        </select>
                                    </div>

                                    <div id="mazemaster_exit_profile_section" class="mazemaster-section" style="display: ${currentMazeData.mainMinionExitType && currentMazeData.mainMinionExitType !== 'messenger' ? 'block' : 'none'};">
                                        <label class="mazemaster-label">Exit Game Profile</label>
                                        <div class="mazemaster-help-small"><small>Which Battlebar/Wheel profile to use for the exit boss</small></div>
                                        <select id="mazemaster_maze_exit_profile" class="mazemaster-select">
                                            <option value="">Select...</option>
                                        </select>
                                    </div>

                                    <div class="mazemaster-section">
                                        <button id="mazemaster_maze_story_btn" class="menu_button">
                                            <i class="fa-solid fa-book"></i> Story Milestones
                                        </button>
                                        <div class="mazemaster-help-small"><small>Configure story text shown as player progresses</small></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- v2.1.0 COLLAPSIBLE: Avatar Generation -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="avatar_gen_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Avatar Generation</span>
                                <span class="mazemaster-collapse-hint">(auto-generate minion images)</span>
                            </button>
                            <div id="avatar_gen_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-section">
                                    <div class="mazemaster-help-small"><small>Select minions to auto-generate avatars for during maze loading. Requires SD/image extension enabled in global settings.</small></div>
                                    <div id="mazemaster_avatar_minion_list" class="mazemaster-avatar-minion-list">
                                        <!-- Populated dynamically -->
                                    </div>
                                    <button id="mazemaster_avatar_gen_refresh" class="menu_button" style="margin-top: 8px;">
                                        <i class="fa-solid fa-sync"></i> Refresh Minion List
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Encounters -->
                        <div class="mazemaster-collapsible expanded">
                            <button class="mazemaster-collapsible-header" data-target="encounters_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Encounters</span>
                                <span class="mazemaster-collapse-hint">(minions & traps)</span>
                            </button>
                            <div id="encounters_section" class="mazemaster-collapsible-content" style="display: block;">
                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Minion Encounters</label>
                                    <div id="mazemaster_maze_encounters_list" class="mazemaster-encounters-list">
                                        <!-- Encounter rows rendered here -->
                                    </div>
                                    <button id="mazemaster_add_encounter_btn" class="menu_button mazemaster-add-btn">
                                        <i class="fa-solid fa-plus"></i> Add Minion
                                    </button>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Trap Tiles</label>
                                    <div id="mazemaster_maze_traps_list" class="mazemaster-encounters-list">
                                        <!-- Trap encounter rows rendered here -->
                                    </div>
                                    <button id="mazemaster_add_trap_encounter_btn" class="menu_button mazemaster-add-btn">
                                        <i class="fa-solid fa-plus"></i> Add Trap
                                    </button>
                                </div>

                                <div class="mazemaster-section">
                                    <button id="mazemaster_intelligent_distribute" class="menu_button mazemaster-distribute-btn">
                                        <i class="fa-solid fa-wand-magic-sparkles"></i> Intelligent Distribute
                                    </button>
                                    <div class="mazemaster-help-small">
                                        <small>Auto-sets tile percentages based on minion types</small>
                                    </div>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">On Battlebar Loss</label>
                                    <select id="mazemaster_maze_loss_action" class="mazemaster-select">
                                        <option value="continue" ${(currentMazeData.onBattlebarLoss || 'continue') === 'continue' ? 'selected' : ''}>Continue (skip encounter)</option>
                                        <option value="respawn" ${currentMazeData.onBattlebarLoss === 'respawn' ? 'selected' : ''}>Respawn at Start</option>
                                        <option value="gameover" ${currentMazeData.onBattlebarLoss === 'gameover' ? 'selected' : ''}>Game Over</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Quests -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="quests_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Quests</span>
                            </button>
                            <div id="quests_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Quest Pool</label>
                                    <div class="mazemaster-help-small" style="margin-bottom: 8px;">
                                        <small>Quests that can appear in this maze. Each quest has a % chance to be active.</small>
                                    </div>
                                    <div id="mazemaster_maze_quests_list" class="mazemaster-encounters-list">
                                        <!-- Quest pool rows rendered here -->
                                    </div>
                                    <button id="mazemaster_add_quest_pool_btn" class="menu_button mazemaster-add-btn">
                                        <i class="fa-solid fa-plus"></i> Add Quest
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Chests & Loot -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="chests_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Chests & Loot</span>
                            </button>
                            <div id="chests_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Chest Image</label>
                                    <div class="mazemaster-row" style="gap: 10px; align-items: center;">
                                        <div class="mazemaster-chest-preview" style="width: 50px; height: 50px; border-radius: 5px; overflow: hidden; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;">
                                            ${currentMazeData.chestImage ? `<img id="mazemaster_chest_preview_img" src="${getExtensionImagePath(currentMazeData.chestImage)}" style="width: 100%; height: 100%; object-fit: cover;">` : '<i id="mazemaster_chest_preview_icon" class="fa-solid fa-box" style="color: #888;"></i>'}
                                        </div>
                                        <button id="mazemaster_chest_image_btn" class="menu_button menu_button_icon" title="Upload Chest Image">
                                            <i class="fa-solid fa-upload"></i>
                                        </button>
                                        <input type="file" id="mazemaster_chest_image_file" accept="image/*" style="display: none;">
                                        <small style="color: #888;">Custom chest appearance</small>
                                    </div>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Chest Distribution</label>
                                    <div class="mazemaster-grid-2col">
                                        <div class="mazemaster-row">
                                            <label>Chest Tiles %</label>
                                            <input type="number" id="mazemaster_maze_chest_percent" class="mazemaster-input-small" min="0" max="50" value="${currentMazeData.chestTilePercent || 10}">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Locked %</label>
                                            <input type="number" id="mazemaster_maze_locked_percent" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.chestLockedPercent || 30}">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Locked Bonus %</label>
                                            <input type="number" id="mazemaster_maze_locked_bonus" class="mazemaster-input-small" min="0" max="200" value="${currentMazeData.chestLockedBonusPercent || 50}">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Mimic %</label>
                                            <input type="number" id="mazemaster_maze_mimic_percent" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.chestMimicPercent || 15}">
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Loot per Chest</label>
                                    <div class="mazemaster-row">
                                        <input type="number" id="mazemaster_maze_loot_min" class="mazemaster-input-small" min="1" max="10" value="${currentMazeData.chestLootMin || 1}" style="width:50px">
                                        <span>to</span>
                                        <input type="number" id="mazemaster_maze_loot_max" class="mazemaster-input-small" min="1" max="10" value="${currentMazeData.chestLootMax || 2}" style="width:50px">
                                        <span>items</span>
                                    </div>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Regular Chest Loot %</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label>Key</label><input type="number" id="mazemaster_maze_chest_key" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.chestKeyChance || 30}"></div>
                                        <div class="mazemaster-row"><label>Strike</label><input type="number" id="mazemaster_maze_chest_pow" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.chestStrikeChance || 50}"></div>
                                        <div class="mazemaster-row"><label>Stealth</label><input type="number" id="mazemaster_maze_chest_stealth" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.chestStealthChance || 0}"></div>
                                        <div class="mazemaster-row"><label>Execute</label><input type="number" id="mazemaster_maze_chest_execute" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.chestExecuteChance || 0}"></div>
                                    </div>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Locked Chest Loot %</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label>Key</label><input type="number" id="mazemaster_maze_locked_key" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.lockedChestKeyChance || 40}"></div>
                                        <div class="mazemaster-row"><label>Strike</label><input type="number" id="mazemaster_maze_locked_pow" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.lockedChestStrikeChance || 60}"></div>
                                        <div class="mazemaster-row"><label>Stealth</label><input type="number" id="mazemaster_maze_locked_stealth" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.lockedChestStealthChance || 30}"></div>
                                        <div class="mazemaster-row"><label>Execute</label><input type="number" id="mazemaster_maze_locked_execute" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.lockedChestExecuteChance || 5}"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Victory & Loss -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="victory_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Victory & Loss</span>
                            </button>
                            <div id="victory_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Victory Message</label>
                                    <input type="text" id="mazemaster_maze_win_message" class="mazemaster-input" placeholder="You escaped the maze!" value="${escapeHtml(currentMazeData.winMessage || '')}">
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Victory Image</label>
                                    <div class="mazemaster-maze-win-image-row">
                                        <div class="mazemaster-maze-win-image-preview">
                                            ${currentMazeData.winImage ? `<img id="maze_win_image_preview" src="${escapeHtml(currentMazeData.winImage)}" alt="Victory">` : '<div id="maze_win_image_preview" class="no-image">No image</div>'}
                                        </div>
                                        <button id="mazemaster_maze_win_image_btn" class="menu_button">
                                            <i class="fa-solid fa-upload"></i> Upload
                                        </button>
                                    </div>
                                    <input type="file" id="mazemaster_maze_win_image_file" accept="image/*" style="display: none;">
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Win Command</label>
                                    <textarea id="mazemaster_maze_win_cmd" class="mazemaster-textarea" rows="2" placeholder="/echo Victory!">${escapeHtml(currentMazeData.winCommand || '')}</textarea>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Lose Command</label>
                                    <textarea id="mazemaster_maze_lose_cmd" class="mazemaster-textarea" rows="2" placeholder="/echo Defeated...">${escapeHtml(currentMazeData.loseCommand || '')}</textarea>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Starting Inventory -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="starting_inv_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Starting Inventory</span>
                            </button>
                            <div id="starting_inv_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-section">
                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor);">Keys</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-key" style="color:#f1c40f;"></i> Key</label><input type="number" id="mazemaster_start_key" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.key || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-dungeon" style="color:#9b59b6;"></i> Floor Key</label><input type="number" id="mazemaster_start_floorKey" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.floorKey || 0}"></div>
                                    </div>
                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 8px;">Combat Items</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-bolt" style="color:#e74c3c;"></i> Strike</label><input type="number" id="mazemaster_start_strike" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.strike || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-user-ninja" style="color:#3498db;"></i> Stealth</label><input type="number" id="mazemaster_start_stealth" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.stealth || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-skull" style="color:#8e44ad;"></i> Execute</label><input type="number" id="mazemaster_start_execute" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.execute || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-crosshairs" style="color:#e67e22;"></i> Minion Bane</label><input type="number" id="mazemaster_start_minionBane" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.minionBane || 0}"></div>
                                    </div>
                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 8px;">Exploration Items</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-portal-enter" style="color:#9b59b6;"></i> Portal Stone</label><input type="number" id="mazemaster_start_portalStone" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.portalStone || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-map" style="color:#27ae60;"></i> Map Fragment</label><input type="number" id="mazemaster_start_mapFragment" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.mapFragment || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-ghost" style="color:#1abc9c;"></i> Void Walk</label><input type="number" id="mazemaster_start_voidWalk" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.voidWalk || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-clock-rotate-left" style="color:#3498db;"></i> Time Shard</label><input type="number" id="mazemaster_start_timeShard" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.timeShard || 0}"></div>
                                    </div>
                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 8px;">HP Items</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-flask" style="color:#e74c3c;"></i> Potion</label><input type="number" id="mazemaster_start_healingPotion" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.healingPotion || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-flask" style="color:#9b59b6;"></i> Greater</label><input type="number" id="mazemaster_start_greaterHealing" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.greaterHealing || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-vial" style="color:#f1c40f;"></i> Elixir</label><input type="number" id="mazemaster_start_elixir" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.elixir || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-heart-circle-plus" style="color:#e91e63;"></i> Revival</label><input type="number" id="mazemaster_start_revivalCharm" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.revivalCharm || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-gem" style="color:#e91e63;"></i> Heart Crystal</label><input type="number" id="mazemaster_start_heartCrystal" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.heartCrystal || 0}"></div>
                                    </div>
                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 8px;">Vision Items</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-fire" style="color:#e67e22;"></i> Torch</label><input type="number" id="mazemaster_start_torch" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.torch || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-regular fa-lightbulb" style="color:#f1c40f;"></i> Lantern</label><input type="number" id="mazemaster_start_lantern" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.lantern || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-scroll" style="color:#3498db;"></i> Reveal Scroll</label><input type="number" id="mazemaster_start_revealScroll" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.revealScroll || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-eye" style="color:#9b59b6;"></i> Sight Potion</label><input type="number" id="mazemaster_start_sightPotion" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.sightPotion || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-crystal-ball" style="color:#1abc9c;"></i> Crystal Ball</label><input type="number" id="mazemaster_start_crystalBall" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.crystalBall || 0}"></div>
                                    </div>
                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 8px;">Equipment - Weapons</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-sword" style="color:#8B4513;"></i> Rusty Sword</label><input type="number" id="mazemaster_start_weapon_rusty_sword" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.weapon_rusty_sword || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-sword" style="color:#708090;"></i> Iron Sword</label><input type="number" id="mazemaster_start_weapon_iron_sword" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.weapon_iron_sword || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-sword" style="color:#C0C0C0;"></i> Steel Blade</label><input type="number" id="mazemaster_start_weapon_steel_blade" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.weapon_steel_blade || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-sword" style="color:#9b59b6;"></i> Enchanted Blade</label><input type="number" id="mazemaster_start_weapon_enchanted_blade" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.weapon_enchanted_blade || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-khanda" style="color:#2c3e50;"></i> Shadow Dagger</label><input type="number" id="mazemaster_start_weapon_shadow_dagger" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.weapon_shadow_dagger || 0}"></div>
                                    </div>
                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 8px;">Equipment - Armor</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-vest" style="color:#8B4513;"></i> Leather Armor</label><input type="number" id="mazemaster_start_armor_leather" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.armor_leather || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-shield" style="color:#708090;"></i> Chainmail</label><input type="number" id="mazemaster_start_armor_chainmail" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.armor_chainmail || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-shield-halved" style="color:#C0C0C0;"></i> Plate Armor</label><input type="number" id="mazemaster_start_armor_plate" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.armor_plate || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-shield-halved" style="color:#7f8c8d;"></i> Iron Guard</label><input type="number" id="mazemaster_start_ironGuard" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.ironGuard || 0}"></div>
                                    </div>
                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 8px;">Equipment - Accessories</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-ring" style="color:#e74c3c;"></i> Ring of Power</label><input type="number" id="mazemaster_start_accessory_ring_power" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.accessory_ring_power || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-gem" style="color:#3498db;"></i> Amulet of Protection</label><input type="number" id="mazemaster_start_accessory_amulet_protection" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.accessory_amulet_protection || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-clover" style="color:#27ae60;"></i> Lucky Charm</label><input type="number" id="mazemaster_start_accessory_lucky_charm" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.accessory_lucky_charm || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-droplet" style="color:#8e44ad;"></i> Vampiric Pendant</label><input type="number" id="mazemaster_start_accessory_vampiric_pendant" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.accessory_vampiric_pendant || 0}"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Find Early Items -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="find_early_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Find Early Items</span>
                            </button>
                            <div id="find_early_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-help-small"><small>Guarantee items in chests near the starting position. Great for ensuring vision or healing items are available early.</small></div>
                                <div class="mazemaster-section">
                                    <div class="mazemaster-grid-3col" style="margin-bottom: 8px;">
                                        <div class="mazemaster-row"><label>Search Radius</label><input type="number" id="mazemaster_findearly_radius" class="mazemaster-input-small" min="1" max="10" value="${currentMazeData.findEarly?.radius || 4}" title="Manhattan distance from start to search for chests"></div>
                                        <div class="mazemaster-row"><label>Items/Chest</label><input type="number" id="mazemaster_findearly_perchest" class="mazemaster-input-small" min="1" max="5" value="${currentMazeData.findEarly?.itemsPerChest || 1}" title="Max guaranteed items per chest"></div>
                                        <div></div>
                                    </div>
                                    <label class="mazemaster-label">Items to Place Near Start</label>
                                    <div id="mazemaster_findearly_items_container" class="mazemaster-grid-5col" style="gap: 4px;">
                                        <!-- v1.9.0: Dynamically generated from item profiles -->
                                        ${generateFindEarlyCheckboxesHTML(currentMazeData.findEarly?.items || [])}
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Item Pool (v1.8.0) -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="item_pool_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span><i class="fa-solid fa-box-open"></i> Item Pool</span>
                            </button>
                            <div id="item_pool_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-help-small"><small>Restrict which items can drop from chests and combat. STScript commands (/mazeitem) bypass this filter.</small></div>
                                <div class="mazemaster-section">
                                    <div class="mazemaster-row" style="margin-bottom: 8px;">
                                        <label style="display: flex; align-items: center; gap: 8px;">
                                            <input type="checkbox" id="mazemaster_itempool_enabled" ${currentMazeData.itemPool?.enabled ? 'checked' : ''}>
                                            <span>Enable Item Pool Restrictions</span>
                                        </label>
                                    </div>
                                    <div id="mazemaster_itempool_items" style="display: ${currentMazeData.itemPool?.enabled ? 'block' : 'none'};">
                                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                                            <button id="mazemaster_itempool_all" class="menu_button menu_button_icon" type="button" title="Select All"><i class="fa-solid fa-check-double"></i></button>
                                            <button id="mazemaster_itempool_none" class="menu_button menu_button_icon" type="button" title="Clear All"><i class="fa-solid fa-xmark"></i></button>
                                            <button id="mazemaster_itempool_core" class="menu_button menu_button_icon" type="button" title="Core Items Only"><i class="fa-solid fa-star"></i></button>
                                        </div>
                                        <label class="mazemaster-label" style="font-size: 0.8em; color: var(--SmartThemeEmColor);">Keys & Combat</label>
                                        <div class="mazemaster-grid-4col" style="gap: 4px; margin-bottom: 8px;">
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="key" ${currentMazeData.itemPool?.items?.includes('key') ? 'checked' : ''}><i class="fa-solid fa-key" style="color:#f1c40f;"></i> Key</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="floorKey" ${currentMazeData.itemPool?.items?.includes('floorKey') ? 'checked' : ''}><i class="fa-solid fa-dungeon" style="color:#9b59b6;"></i> Floor Key</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="strike" ${currentMazeData.itemPool?.items?.includes('strike') ? 'checked' : ''}><i class="fa-solid fa-bolt" style="color:#e67e22;"></i> Strike</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="stealth" ${currentMazeData.itemPool?.items?.includes('stealth') ? 'checked' : ''}><i class="fa-solid fa-user-ninja" style="color:#2ecc71;"></i> Stealth</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="execute" ${currentMazeData.itemPool?.items?.includes('execute') ? 'checked' : ''}><i class="fa-solid fa-skull" style="color:#e74c3c;"></i> Execute</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="minionBane" ${currentMazeData.itemPool?.items?.includes('minionBane') ? 'checked' : ''}><i class="fa-solid fa-ghost" style="color:#8e44ad;"></i> Minion Bane</label>
                                        </div>
                                        <label class="mazemaster-label" style="font-size: 0.8em; color: var(--SmartThemeEmColor);">Exploration</label>
                                        <div class="mazemaster-grid-4col" style="gap: 4px; margin-bottom: 8px;">
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="portalStone" ${currentMazeData.itemPool?.items?.includes('portalStone') ? 'checked' : ''}><i class="fa-solid fa-door-open" style="color:#3498db;"></i> Portal Stone</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="mapFragment" ${currentMazeData.itemPool?.items?.includes('mapFragment') ? 'checked' : ''}><i class="fa-solid fa-map" style="color:#1abc9c;"></i> Map Fragment</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="voidWalk" ${currentMazeData.itemPool?.items?.includes('voidWalk') ? 'checked' : ''}><i class="fa-solid fa-cloud" style="color:#95a5a6;"></i> Void Walk</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="timeShard" ${currentMazeData.itemPool?.items?.includes('timeShard') ? 'checked' : ''}><i class="fa-solid fa-hourglass-half" style="color:#f39c12;"></i> Time Shard</label>
                                        </div>
                                        <label class="mazemaster-label" style="font-size: 0.8em; color: var(--SmartThemeEmColor);">HP & Healing</label>
                                        <div class="mazemaster-grid-4col" style="gap: 4px; margin-bottom: 8px;">
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="healingPotion" ${currentMazeData.itemPool?.items?.includes('healingPotion') ? 'checked' : ''}><i class="fa-solid fa-flask" style="color:#e74c3c;"></i> Healing</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="greaterHealing" ${currentMazeData.itemPool?.items?.includes('greaterHealing') ? 'checked' : ''}><i class="fa-solid fa-flask" style="color:#9b59b6;"></i> Greater</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="elixir" ${currentMazeData.itemPool?.items?.includes('elixir') ? 'checked' : ''}><i class="fa-solid fa-flask" style="color:#f1c40f;"></i> Elixir</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="revivalCharm" ${currentMazeData.itemPool?.items?.includes('revivalCharm') ? 'checked' : ''}><i class="fa-solid fa-heart-pulse" style="color:#e74c3c;"></i> Revival</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="heartCrystal" ${currentMazeData.itemPool?.items?.includes('heartCrystal') ? 'checked' : ''}><i class="fa-solid fa-heart" style="color:#e74c3c;"></i> Heart Crystal</label>
                                        </div>
                                        <label class="mazemaster-label" style="font-size: 0.8em; color: var(--SmartThemeEmColor);">Vision</label>
                                        <div class="mazemaster-grid-4col" style="gap: 4px; margin-bottom: 8px;">
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="torch" ${currentMazeData.itemPool?.items?.includes('torch') ? 'checked' : ''}><i class="fa-solid fa-fire" style="color:#f39c12;"></i> Torch</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="lantern" ${currentMazeData.itemPool?.items?.includes('lantern') ? 'checked' : ''}><i class="fa-solid fa-lightbulb" style="color:#f1c40f;"></i> Lantern</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="revealScroll" ${currentMazeData.itemPool?.items?.includes('revealScroll') ? 'checked' : ''}><i class="fa-solid fa-scroll" style="color:#9b59b6;"></i> Reveal Scroll</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="sightPotion" ${currentMazeData.itemPool?.items?.includes('sightPotion') ? 'checked' : ''}><i class="fa-solid fa-eye" style="color:#1abc9c;"></i> Sight Potion</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="crystalBall" ${currentMazeData.itemPool?.items?.includes('crystalBall') ? 'checked' : ''}><i class="fa-solid fa-circle" style="color:#8e44ad;"></i> Crystal Ball</label>
                                        </div>
                                        <label class="mazemaster-label" style="font-size: 0.8em; color: var(--SmartThemeEmColor);">Weapons</label>
                                        <div class="mazemaster-grid-4col" style="gap: 4px; margin-bottom: 8px;">
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="weapon_rusty_sword" ${currentMazeData.itemPool?.items?.includes('weapon_rusty_sword') ? 'checked' : ''}><i class="fa-solid fa-sword" style="color:#95a5a6;"></i> Rusty Sword</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="weapon_iron_sword" ${currentMazeData.itemPool?.items?.includes('weapon_iron_sword') ? 'checked' : ''}><i class="fa-solid fa-sword" style="color:#7f8c8d;"></i> Iron Sword</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="weapon_steel_blade" ${currentMazeData.itemPool?.items?.includes('weapon_steel_blade') ? 'checked' : ''}><i class="fa-solid fa-sword" style="color:#3498db;"></i> Steel Blade</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="weapon_enchanted_blade" ${currentMazeData.itemPool?.items?.includes('weapon_enchanted_blade') ? 'checked' : ''}><i class="fa-solid fa-sword" style="color:#9b59b6;"></i> Enchanted Blade</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="weapon_shadow_dagger" ${currentMazeData.itemPool?.items?.includes('weapon_shadow_dagger') ? 'checked' : ''}><i class="fa-solid fa-khanda" style="color:#2c3e50;"></i> Shadow Dagger</label>
                                        </div>
                                        <label class="mazemaster-label" style="font-size: 0.8em; color: var(--SmartThemeEmColor);">Armor</label>
                                        <div class="mazemaster-grid-4col" style="gap: 4px; margin-bottom: 8px;">
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="armor_leather" ${currentMazeData.itemPool?.items?.includes('armor_leather') ? 'checked' : ''}><i class="fa-solid fa-vest" style="color:#8b4513;"></i> Leather Armor</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="armor_chainmail" ${currentMazeData.itemPool?.items?.includes('armor_chainmail') ? 'checked' : ''}><i class="fa-solid fa-shield" style="color:#7f8c8d;"></i> Chainmail</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="armor_plate" ${currentMazeData.itemPool?.items?.includes('armor_plate') ? 'checked' : ''}><i class="fa-solid fa-shield-halved" style="color:#3498db;"></i> Plate Armor</label>
                                        </div>
                                        <label class="mazemaster-label" style="font-size: 0.8em; color: var(--SmartThemeEmColor);">Accessories</label>
                                        <div class="mazemaster-grid-4col" style="gap: 4px;">
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="accessory_ring_power" ${currentMazeData.itemPool?.items?.includes('accessory_ring_power') ? 'checked' : ''}><i class="fa-solid fa-ring" style="color:#e74c3c;"></i> Ring of Power</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="accessory_amulet_protection" ${currentMazeData.itemPool?.items?.includes('accessory_amulet_protection') ? 'checked' : ''}><i class="fa-solid fa-gem" style="color:#3498db;"></i> Amulet of Protection</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="accessory_lucky_charm" ${currentMazeData.itemPool?.items?.includes('accessory_lucky_charm') ? 'checked' : ''}><i class="fa-solid fa-clover" style="color:#27ae60;"></i> Lucky Charm</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="accessory_vampiric_pendant" ${currentMazeData.itemPool?.items?.includes('accessory_vampiric_pendant') ? 'checked' : ''}><i class="fa-solid fa-droplet" style="color:#8e44ad;"></i> Vampiric Pendant</label>
                                            <label class="mazemaster-checkbox-label"><input type="checkbox" data-pool-item="ironGuard" ${currentMazeData.itemPool?.items?.includes('ironGuard') ? 'checked' : ''}><i class="fa-solid fa-shield-halved" style="color:#7f8c8d;"></i> Iron Guard</label>
                                        </div>
                                        <div id="mazemaster_itempool_custom" style="margin-top: 8px;">
                                            <!-- Custom items dynamically populated -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: HP System Settings -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="hp_settings_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>HP System Settings</span>
                            </button>
                            <div id="hp_settings_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-section">
                                    <div class="mazemaster-row" style="margin-bottom: 8px;">
                                        <label style="display: flex; align-items: center; gap: 8px;">
                                            <input type="checkbox" id="mazemaster_hp_enabled" ${currentMazeData.hpEnabled !== false ? 'checked' : ''}>
                                            <span>Enable HP System</span>
                                        </label>
                                    </div>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label>Max HP</label><input type="number" id="mazemaster_hp_max" class="mazemaster-input-small" min="1" max="999" value="${currentMazeData.maxHP || 100}"></div>
                                        <div class="mazemaster-row"><label>Dmg Mult</label><input type="number" id="mazemaster_hp_battlebar_mult" class="mazemaster-input-small" min="0" max="10" step="0.1" value="${currentMazeData.battlebarDamageMultiplier ?? 1.0}" title="Multiplier for battlebar damage"></div>
                                        <div class="mazemaster-row"><label>Diff Mult</label><input type="number" id="mazemaster_hp_battlebar_diff" class="mazemaster-input-small" min="0.1" max="3" step="0.1" value="${currentMazeData.battlebarDifficultyMultiplier ?? 1.0}" title="Multiplier for battlebar difficulty (speed/zone size)"></div>
                                        <div class="mazemaster-row"><label>Respawn HP%</label><input type="number" id="mazemaster_hp_respawn" class="mazemaster-input-small" min="1" max="100" value="${currentMazeData.respawnHPPercent || 50}"></div>
                                    </div>
                                    <div class="mazemaster-row" style="margin-top: 8px;">
                                        <label>On Death</label>
                                        <select id="mazemaster_hp_ondeath" class="mazemaster-select" style="width: auto;">
                                            <option value="respawn" ${(currentMazeData.onDeath || 'respawn') === 'respawn' ? 'selected' : ''}>Respawn at Start (100% HP)</option>
                                            <option value="respawnPenalty" ${(currentMazeData.onDeath || 'respawn') === 'respawnPenalty' ? 'selected' : ''}>Respawn at Start (Penalty HP%)</option>
                                            <option value="gameover" ${(currentMazeData.onDeath || 'respawn') === 'gameover' ? 'selected' : ''}>Game Over</option>
                                        </select>
                                    </div>

                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 12px;">Safe Rooms</label>
                                    <div class="mazemaster-grid-3col">
                                        <div class="mazemaster-row"><label>Count/Floor</label><input type="number" id="mazemaster_saferoom_count" class="mazemaster-input-small" min="0" max="20" value="${currentMazeData.safeRoomCount ?? 3}"></div>
                                        <div class="mazemaster-row"><label>Heal %</label><input type="number" id="mazemaster_saferoom_heal" class="mazemaster-input-small" min="1" max="100" value="${currentMazeData.safeRoomHealPercent ?? 100}"></div>
                                        <div class="mazemaster-row">
                                            <label style="display: flex; align-items: center; gap: 4px;">
                                                <input type="checkbox" id="mazemaster_saferoom_llm" ${currentMazeData.safeRoomUseLLM ? 'checked' : ''}>
                                                <span>LLM Messages</span>
                                            </label>
                                        </div>
                                    </div>

                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 12px;">LLM Enhancement</label>
                                    <div class="mazemaster-row" style="margin-bottom: 4px;">
                                        <label style="display: flex; align-items: center; gap: 8px;">
                                            <input type="checkbox" id="mazemaster_llm_enhance_rooms" ${currentMazeData.llmEnhanceRooms !== false ? 'checked' : ''}>
                                            <span>Enhance Room Descriptions</span>
                                        </label>
                                        <small style="color: var(--SmartThemeEmColor); margin-left: 24px;">LLM generates unique descriptions on first entry</small>
                                    </div>
                                    <div class="mazemaster-row" style="margin-bottom: 4px;">
                                        <label>Max Response Tokens</label>
                                        <input type="number" id="mazemaster_llm_max_tokens" class="mazemaster-input-small" min="50" max="500" value="${currentMazeData.llmMaxTokens ?? 250}">
                                        <small style="color: var(--SmartThemeEmColor); margin-left: 8px;">Max length for LLM chat responses</small>
                                    </div>

                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 12px;">Rest Mechanic</label>
                                    <div class="mazemaster-row" style="margin-bottom: 4px;">
                                        <label style="display: flex; align-items: center; gap: 8px;">
                                            <input type="checkbox" id="mazemaster_rest_enabled" ${currentMazeData.restEnabled !== false ? 'checked' : ''}>
                                            <span>Enable Rest Button</span>
                                        </label>
                                    </div>
                                    <div class="mazemaster-grid-3col">
                                        <div class="mazemaster-row"><label>Heal %</label><input type="number" id="mazemaster_rest_heal" class="mazemaster-input-small" min="1" max="100" value="${currentMazeData.restHealPercent ?? 20}"></div>
                                        <div class="mazemaster-row"><label>Cooldown (turns)</label><input type="number" id="mazemaster_rest_cooldown" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.restCooldown ?? 3}"></div>
                                        <div class="mazemaster-row"><label>Interrupt %</label><input type="number" id="mazemaster_rest_interrupt" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.restInterruptChance ?? 0}"></div>
                                    </div>
                                    <div class="mazemaster-row" style="margin-top: 4px;">
                                        <label>Interrupt Script <small>(empty = random encounter)</small></label>
                                        <input type="text" id="mazemaster_rest_interrupt_script" class="mazemaster-input" value="${escapeHtml(currentMazeData.restInterruptScript || '')}" placeholder="/echo You were ambushed!">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: STScript Hooks -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="hooks_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>STScript Hooks</span>
                                <span class="mazemaster-collapse-hint">(advanced)</span>
                            </button>
                            <div id="hooks_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-help-small"><small>Run STScript commands when events occur. Use {{variable}} placeholders for event data.</small></div>

                                <div class="mazemaster-hooks-group">
                                    <label class="mazemaster-hooks-label">Movement</label>
                                    <div class="mazemaster-hooks-items">
                                        <div class="hook-item">
                                            <label>On Move</label>
                                            <input type="text" id="mazemaster_hook_onMove" class="mazemaster-input" value="${escapeHtml(currentMazeData.onMove || '')}" placeholder="{{x}}, {{y}}, {{direction}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Milestone</label>
                                            <input type="text" id="mazemaster_hook_onMilestone" class="mazemaster-input" value="${escapeHtml(currentMazeData.onMilestone || '')}" placeholder="{{percentage}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Explore Complete</label>
                                            <input type="text" id="mazemaster_hook_onExploreComplete" class="mazemaster-input" value="${escapeHtml(currentMazeData.onExploreComplete || '')}" placeholder="Fires at 100%">
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-hooks-group">
                                    <label class="mazemaster-hooks-label">Items</label>
                                    <div class="mazemaster-hooks-items">
                                        <div class="hook-item">
                                            <label>On Item Add</label>
                                            <input type="text" id="mazemaster_hook_onItemAdd" class="mazemaster-input" value="${escapeHtml(currentMazeData.onItemAdd || '')}" placeholder="{{item}}, {{count}}, {{total}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Item Remove</label>
                                            <input type="text" id="mazemaster_hook_onItemRemove" class="mazemaster-input" value="${escapeHtml(currentMazeData.onItemRemove || '')}" placeholder="{{item}}, {{count}}, {{remaining}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Chest Open</label>
                                            <input type="text" id="mazemaster_hook_onChestOpen" class="mazemaster-input" value="${escapeHtml(currentMazeData.onChestOpen || '')}" placeholder="{{type}}, {{loot}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Trade</label>
                                            <input type="text" id="mazemaster_hook_onTrade" class="mazemaster-input" value="${escapeHtml(currentMazeData.onTrade || '')}" placeholder="{{given}}, {{received}}">
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-hooks-group">
                                    <label class="mazemaster-hooks-label">Special Tiles</label>
                                    <div class="mazemaster-hooks-items">
                                        <div class="hook-item">
                                            <label>On Enemy Move</label>
                                            <input type="text" id="mazemaster_hook_onEnemyMove" class="mazemaster-input" value="${escapeHtml(currentMazeData.onEnemyMove || '')}" placeholder="{{minionId}}, {{fromX}}, {{fromY}}, {{toX}}, {{toY}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Teleport</label>
                                            <input type="text" id="mazemaster_hook_onTeleport" class="mazemaster-input" value="${escapeHtml(currentMazeData.onTeleport || '')}" placeholder="{{portalId}}, {{fromX}}, {{fromY}}, {{toX}}, {{toY}}">
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-hooks-group">
                                    <label class="mazemaster-hooks-label">Objectives</label>
                                    <div class="mazemaster-hooks-items">
                                        <div class="hook-item">
                                            <label>On Progress</label>
                                            <input type="text" id="mazemaster_hook_onObjectiveProgress" class="mazemaster-input" value="${escapeHtml(currentMazeData.onObjectiveProgress || '')}" placeholder="{{objectiveId}}, {{current}}, {{target}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Complete</label>
                                            <input type="text" id="mazemaster_hook_onObjectiveComplete" class="mazemaster-input" value="${escapeHtml(currentMazeData.onObjectiveComplete || '')}" placeholder="{{objectiveId}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On All Complete</label>
                                            <input type="text" id="mazemaster_hook_onAllObjectivesComplete" class="mazemaster-input" value="${escapeHtml(currentMazeData.onAllObjectivesComplete || '')}" placeholder="All required done">
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-hooks-group">
                                    <label class="mazemaster-hooks-label">Stats</label>
                                    <div class="mazemaster-hooks-items">
                                        <div class="hook-item">
                                            <label>On Stat Update</label>
                                            <input type="text" id="mazemaster_hook_onStatUpdate" class="mazemaster-input" value="${escapeHtml(currentMazeData.onStatUpdate || '')}" placeholder="{{statName}}, {{value}}">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Save Button -->
                        <div class="mazemaster-section">
                            <button id="mazemaster_maze_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                <i class="fa-solid fa-save"></i> Save Profile
                            </button>
                        </div>

                        <!-- Saved Games -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="saved_games_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Saved Games</span>
                            </button>
                            <div id="saved_games_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div id="mazemaster_saved_games_list" class="mazemaster-saved-games-list">
                                    <!-- Saved games rendered here -->
                                </div>
                            </div>
                        </div>

                        <!-- Usage Help -->
                        <div class="mazemaster-section">
                            <div class="mazemaster-help">
                                <div class="mazemaster-help-title">Usage:</div>
                                <code>/maze profile="profileName"</code>
                            </div>
                        </div>
                    </div>

                    <!-- MINIONS CONFIG -->
                    <div id="mazemaster_minions_config" class="mazemaster-game-config" style="${activeGame === 'minions' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Minion Profile</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_minion_profile_select" class="mazemaster-select">
                                    <option value="">-- Show All Minions --</option>
                                    ${Object.keys(extensionSettings.minionProfiles || {}).map(p => `<option value="${escapeHtml(p)}">${escapeHtml(p)}</option>`).join('')}
                                </select>
                                <button id="mazemaster_minion_profile_save_btn" class="menu_button menu_button_icon" title="Save Current as Profile">
                                    <i class="fa-solid fa-floppy-disk"></i>
                                </button>
                                <button id="mazemaster_minion_profile_load_btn" class="menu_button menu_button_icon" title="Load Profile">
                                    <i class="fa-solid fa-folder-open"></i>
                                </button>
                                <button id="mazemaster_minion_profile_delete_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                            </div>
                            <div class="mazemaster-help-small"><small>Save/load sets of minions as profiles</small></div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Minions</label>
                            <div id="mazemaster_minions_list" class="mazemaster-minions-list">
                                <!-- Minions rendered here -->
                            </div>
                            <button id="mazemaster_add_minion_btn" class="menu_button mazemaster-add-btn">
                                <i class="fa-solid fa-plus"></i> Add Minion
                            </button>
                            <input type="file" id="mazemaster_minion_image_file" accept="image/*" style="display: none;">
                        </div>

                        <div class="mazemaster-section">
                            <div class="mazemaster-help">
                                <div class="mazemaster-help-title">Usage:</div>
                                <code>/mazeminion name="MinionName" message="Hello!"</code>
                                <p><small>Sets the minion display in an active maze game.</small></p>
                            </div>
                        </div>
                    </div>

                    <!-- TRAPS CONFIG -->
                    <div id="mazemaster_traps_config" class="mazemaster-game-config" style="${activeGame === 'traps' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Trap Profile</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_trap_profile_select" class="mazemaster-select">
                                    <option value="">(Current Traps)</option>
                                    ${Object.keys(extensionSettings.trapProfiles || {}).map(p => `<option value="${escapeHtml(p)}">${escapeHtml(p)}</option>`).join('')}
                                </select>
                                <button id="mazemaster_trap_profile_save_btn" class="menu_button menu_button_icon" title="Save Current as Profile">
                                    <i class="fa-solid fa-floppy-disk"></i>
                                </button>
                                <button id="mazemaster_trap_profile_load_btn" class="menu_button menu_button_icon" title="Load Profile">
                                    <i class="fa-solid fa-folder-open"></i>
                                </button>
                                <button id="mazemaster_trap_profile_delete_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                            </div>
                            <div class="mazemaster-help-small"><small>Save/load sets of traps as profiles</small></div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Traps</label>
                            <div id="mazemaster_traps_list" class="mazemaster-traps-list">
                                <!-- Traps rendered here -->
                            </div>
                            <button id="mazemaster_add_trap_btn" class="menu_button mazemaster-add-btn">
                                <i class="fa-solid fa-plus"></i> Add Trap
                            </button>
                            <input type="file" id="mazemaster_trap_image_file" accept="image/*" style="display: none;">
                        </div>

                        <div class="mazemaster-section">
                            <div class="mazemaster-help">
                                <div class="mazemaster-help-title">Traps:</div>
                                <p><small>Traps can be placed on maze tiles. When a player steps on a trap, it shows the image/message and runs the script.</small></p>
                                <p><small>Add traps to maze profiles in the Maze tab under "Trap Tiles".</small></p>
                            </div>
                        </div>
                    </div>

                    <!-- THEMES CONFIG -->
                    <div id="mazemaster_themes_config" class="mazemaster-game-config" style="${activeGame === 'themes' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Custom Theme</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_theme_profile_select" class="mazemaster-select">
                                    <option value="">(New Theme)</option>
                                    ${getCustomThemeNames().map(p => {
                                        const theme = getCustomTheme(p);
                                        const displayName = (theme && theme.displayName) ? theme.displayName : p;
                                        const isDefault = DEFAULT_THEME_PROFILES[p] && !(extensionSettings.customThemes || {})[p];
                                        const label = isDefault ? `${displayName} (Default)` : displayName;
                                        return `<option value="${escapeHtml(p)}">${escapeHtml(label)}</option>`;
                                    }).join('')}
                                </select>
                                <button id="mazemaster_theme_new_btn" class="menu_button menu_button_icon" title="New Theme">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                                <button id="mazemaster_theme_delete_btn" class="menu_button menu_button_icon" title="Delete Theme">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                                <button id="mazemaster_theme_save_btn" class="menu_button menu_button_icon" title="Save Theme">
                                    <i class="fa-solid fa-floppy-disk"></i>
                                </button>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Basic Info</label>
                            <div class="mazemaster-form-group">
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Theme ID</label>
                                    <input type="text" id="mazemaster_theme_name" class="mazemaster-input" placeholder="my-horror" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Display Name</label>
                                    <input type="text" id="mazemaster_theme_display" class="mazemaster-input" placeholder="My Horror Theme" style="flex: 1;">
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Atmosphere (for LLM)</label>
                            <div class="mazemaster-form-group">
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Tags</label>
                                    <input type="text" id="mazemaster_theme_tags" class="mazemaster-input" placeholder="dark, gothic, supernatural, dread" style="flex: 1;">
                                </div>
                                <small style="color: var(--SmartThemeEmColor); margin-left: 108px;">Comma-separated mood tags passed to LLM</small>
                                <div class="mazemaster-row" style="margin-top: 8px;">
                                    <label style="width: 100px;">Description</label>
                                    <textarea id="mazemaster_theme_atmosphere" class="mazemaster-textarea" rows="2" placeholder="A pervasive sense of dread hangs in the air..." style="flex: 1;"></textarea>
                                </div>
                                <small style="color: var(--SmartThemeEmColor); margin-left: 108px;">Atmospheric description passed to LLM for room generation</small>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Room Name Adjectives</label>
                            <div class="mazemaster-form-group">
                                <input type="text" id="mazemaster_theme_adjectives" class="mazemaster-input" placeholder="Haunted, Cursed, Blood-Stained, Rotting, Whispering">
                                <small style="color: var(--SmartThemeEmColor);">30% chance to appear in procedurally generated room names</small>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Room Types (for BSP generation)</label>
                            <div class="mazemaster-form-group">
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Small (≤4)</label>
                                    <input type="text" id="mazemaster_theme_rooms_small" class="mazemaster-input" placeholder="closet, cell, alcove" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Medium (≤9)</label>
                                    <input type="text" id="mazemaster_theme_rooms_medium" class="mazemaster-input" placeholder="morgue, ritual-room, nursery" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Large (>9)</label>
                                    <input type="text" id="mazemaster_theme_rooms_large" class="mazemaster-input" placeholder="cathedral, asylum-ward, crypt" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Special</label>
                                    <input type="text" id="mazemaster_theme_rooms_special" class="mazemaster-input" placeholder="elder-shrine, boss-lair" style="flex: 1;">
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Flavor Messages</label>
                            <div class="mazemaster-form-group">
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Chest Find</label>
                                    <input type="text" id="mazemaster_theme_flavor_chest" class="mazemaster-input" placeholder="You find a decrepit chest..." style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Trap Trigger</label>
                                    <input type="text" id="mazemaster_theme_flavor_trap" class="mazemaster-input" placeholder="A hidden danger springs forth!" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Victory</label>
                                    <input type="text" id="mazemaster_theme_flavor_victory" class="mazemaster-input" placeholder="You emerge victorious!" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Defeat</label>
                                    <input type="text" id="mazemaster_theme_flavor_defeat" class="mazemaster-input" placeholder="Darkness claims you..." style="flex: 1;">
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Theme Colors</label>
                            <div class="mazemaster-form-group">
                                <div class="mazemaster-row">
                                    <label>Primary</label>
                                    <input type="color" id="mazemaster_theme_color_primary" value="#8b0000">
                                    <label style="margin-left: 16px;">Secondary</label>
                                    <input type="color" id="mazemaster_theme_color_secondary" value="#2d1f1f">
                                    <label style="margin-left: 16px;">Accent</label>
                                    <input type="color" id="mazemaster_theme_color_accent" value="#ff4444">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- STYLES CONFIG -->
                    <div id="mazemaster_styles_config" class="mazemaster-game-config" style="${activeGame === 'styles' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Custom Map Style</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_style_profile_select" class="mazemaster-select">
                                    <option value="">(New Style)</option>
                                    ${getCustomStyleNames().map(p => {
                                        const style = getCustomStyle(p);
                                        const displayName = (style && style.displayName) ? style.displayName : p;
                                        const isDefault = DEFAULT_STYLE_PROFILES[p] && !(extensionSettings.customStyles || {})[p];
                                        const label = isDefault ? `${displayName} (Default)` : displayName;
                                        return `<option value="${escapeHtml(p)}">${escapeHtml(label)}</option>`;
                                    }).join('')}
                                </select>
                                <button id="mazemaster_style_new_btn" class="menu_button menu_button_icon" title="New Style">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                                <button id="mazemaster_style_delete_btn" class="menu_button menu_button_icon" title="Delete Style">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                                <button id="mazemaster_style_save_btn" class="menu_button menu_button_icon" title="Save Style">
                                    <i class="fa-solid fa-floppy-disk"></i>
                                </button>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Basic Info</label>
                            <div class="mazemaster-form-group">
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Style ID</label>
                                    <input type="text" id="mazemaster_style_name" class="mazemaster-input" placeholder="haunted-house" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 100px;">Display Name</label>
                                    <input type="text" id="mazemaster_style_display" class="mazemaster-input" placeholder="Haunted House" style="flex: 1;">
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">BSP Generation Rules</label>
                            <div class="mazemaster-form-group">
                                <div class="mazemaster-row">
                                    <label style="width: 120px;">Min Room Size</label>
                                    <input type="number" id="mazemaster_style_bsp_minroom" class="mazemaster-input-small" min="2" max="5" value="2">
                                    <label style="width: 120px; margin-left: 16px;">Max Room Size</label>
                                    <input type="number" id="mazemaster_style_bsp_maxroom" class="mazemaster-input-small" min="2" max="8" value="5">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 120px;">Corridor Width</label>
                                    <input type="number" id="mazemaster_style_bsp_corridor" class="mazemaster-input-small" min="1" max="3" value="1">
                                    <label style="width: 120px; margin-left: 16px;">Room Padding</label>
                                    <input type="number" id="mazemaster_style_bsp_padding" class="mazemaster-input-small" min="0" max="3" value="1">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 120px;">Min Split Size</label>
                                    <input type="number" id="mazemaster_style_bsp_minsplit" class="mazemaster-input-small" min="3" max="8" value="4">
                                    <label style="width: 120px; margin-left: 16px;">Split Variance</label>
                                    <input type="number" id="mazemaster_style_bsp_variance" class="mazemaster-input-small" min="0" max="0.5" step="0.05" value="0.3">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 120px;">Extra Connections</label>
                                    <input type="number" id="mazemaster_style_bsp_connections" class="mazemaster-input-small" min="0" max="1" step="0.1" value="0.1">
                                    <label style="width: 120px; margin-left: 16px;">Branch Chance</label>
                                    <input type="number" id="mazemaster_style_bsp_branch" class="mazemaster-input-small" min="0" max="1" step="0.1" value="0.3">
                                </div>
                                <div class="mazemaster-row" style="margin-top: 8px;">
                                    <label class="mazemaster-checkbox-label">
                                        <input type="checkbox" id="mazemaster_style_bsp_grid">
                                        Grid Alignment (City-style)
                                    </label>
                                    <label class="mazemaster-checkbox-label" style="margin-left: 16px;">
                                        <input type="checkbox" id="mazemaster_style_bsp_winding">
                                        Winding Corridors (Organic)
                                    </label>
                                    <label class="mazemaster-checkbox-label" style="margin-left: 16px;">
                                        <input type="checkbox" id="mazemaster_style_bsp_modular">
                                        Modular Rooms (Spaceship)
                                    </label>
                                    <label class="mazemaster-checkbox-label" style="margin-left: 16px;">
                                        <input type="checkbox" id="mazemaster_style_bsp_square">
                                        Prefer Square Rooms
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Common Room Names (2 exits)</label>
                            <div class="mazemaster-form-group">
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Prefixes</label>
                                    <input type="text" id="mazemaster_style_common_prefixes" class="mazemaster-input" placeholder="Dusty, Narrow, Dim, Long" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Nouns</label>
                                    <input type="text" id="mazemaster_style_common_nouns" class="mazemaster-input" placeholder="Corridor, Passage, Hallway, Path" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Descriptions</label>
                                    <textarea id="mazemaster_style_common_desc" class="mazemaster-textarea" rows="2" placeholder="One description per line..." style="flex: 1;"></textarea>
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Junction Room Names (3+ exits)</label>
                            <div class="mazemaster-form-group">
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Prefixes</label>
                                    <input type="text" id="mazemaster_style_junction_prefixes" class="mazemaster-input" placeholder="Central, Open, Wide" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Nouns</label>
                                    <input type="text" id="mazemaster_style_junction_nouns" class="mazemaster-input" placeholder="Hub, Crossroads, Junction" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Descriptions</label>
                                    <textarea id="mazemaster_style_junction_desc" class="mazemaster-textarea" rows="2" placeholder="One description per line..." style="flex: 1;"></textarea>
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Dead End Room Names (1 exit)</label>
                            <div class="mazemaster-form-group">
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Prefixes</label>
                                    <input type="text" id="mazemaster_style_deadend_prefixes" class="mazemaster-input" placeholder="Cramped, Forgotten, Hidden" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Nouns</label>
                                    <input type="text" id="mazemaster_style_deadend_nouns" class="mazemaster-input" placeholder="Alcove, Nook, Corner" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Descriptions</label>
                                    <textarea id="mazemaster_style_deadend_desc" class="mazemaster-textarea" rows="2" placeholder="One description per line..." style="flex: 1;"></textarea>
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Special Room Names</label>
                            <div class="mazemaster-form-group">
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Start</label>
                                    <input type="text" id="mazemaster_style_start_names" class="mazemaster-input" placeholder="Entry Point, Starting Chamber" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Staircase</label>
                                    <input type="text" id="mazemaster_style_staircase_names" class="mazemaster-input" placeholder="Spiral Stairs, Stone Steps" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Portal</label>
                                    <input type="text" id="mazemaster_style_portal_names" class="mazemaster-input" placeholder="Teleport Pad, Warp Gate" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Chest</label>
                                    <input type="text" id="mazemaster_style_chest_names" class="mazemaster-input" placeholder="Treasury, Storage Room" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Minion</label>
                                    <input type="text" id="mazemaster_style_minion_names" class="mazemaster-input" placeholder="Guard Post, Monster Den" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Trap</label>
                                    <input type="text" id="mazemaster_style_trap_names" class="mazemaster-input" placeholder="Danger Zone, Trapped Area" style="flex: 1;">
                                </div>
                                <div class="mazemaster-row">
                                    <label style="width: 80px;">Exit</label>
                                    <input type="text" id="mazemaster_style_exit_names" class="mazemaster-input" placeholder="Exit Gate, Final Door" style="flex: 1;">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- QUESTS CONFIG -->
                    <div id="mazemaster_quests_config" class="mazemaster-game-config" style="${activeGame === 'quests' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Quest Profile</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_quest_profile_select" class="mazemaster-select">
                                    <option value="">(Default Quests)</option>
                                    ${getQuestProfileNames().map(p => `<option value="${escapeHtml(p)}">${escapeHtml(p)}</option>`).join('')}
                                </select>
                                <button id="mazemaster_quest_profile_new_btn" class="menu_button menu_button_icon" title="New Profile">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                                <button id="mazemaster_quest_profile_delete_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                                <button id="mazemaster_quest_profile_save_btn" class="menu_button menu_button_icon" title="Save Profile">
                                    <i class="fa-solid fa-floppy-disk"></i>
                                </button>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Quest Templates</label>
                            <p style="color: #888; font-size: 12px; margin: 0 0 8px 0;">Define quests that can be added to maze profiles</p>
                            <button id="mazemaster_quest_add_btn" class="menu_button" style="margin-bottom: 12px;">
                                <i class="fa-solid fa-plus"></i> Add Quest
                            </button>
                            <div id="mazemaster_quest_list" class="mazemaster-quest-template-list">
                                <!-- Quest templates populated here -->
                            </div>
                        </div>
                    </div>

                    <!-- ITEMS CONFIG (v1.6.0) -->
                    <div id="mazemaster_items_config" class="mazemaster-game-config" style="${activeGame === 'items' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label"><i class="fa-solid fa-wand-sparkles"></i> Custom Item Builder</label>
                            <p style="color: #888; font-size: 12px; margin: 0 0 8px 0;">Create custom consumables, equipment, and quest items</p>
                            <div class="mazemaster-profile-row" style="margin-bottom: 12px;">
                                <button id="mazemaster_item_add_btn" class="menu_button">
                                    <i class="fa-solid fa-plus"></i> Add Item
                                </button>
                                <button id="mazemaster_items_export_btn" class="menu_button menu_button_icon" title="Export Items">
                                    <i class="fa-solid fa-download"></i>
                                </button>
                                <button id="mazemaster_items_import_btn" class="menu_button menu_button_icon" title="Import Items">
                                    <i class="fa-solid fa-upload"></i>
                                </button>
                                <input type="file" id="mazemaster_items_import_file" accept=".json" style="display: none;">
                            </div>
                        </div>

                        <!-- Item Editor Panel (hidden by default) -->
                        <div id="mazemaster_item_editor" class="mazemaster-section mazemaster-item-editor" style="display: none;">
                            <input type="hidden" id="mazemaster_item_edit_id" value="">
                            <div class="mazemaster-bb-settings">
                                <div class="mazemaster-bb-row">
                                    <div class="mazemaster-bb-field" style="flex: 2;">
                                        <label>Name</label>
                                        <input type="text" id="mazemaster_item_name" class="mazemaster-input" placeholder="Fire Scroll">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Type</label>
                                        <select id="mazemaster_item_type" class="mazemaster-select">
                                            <option value="key">Key</option>
                                            <option value="potion">Potion</option>
                                            <option value="equipment">Equipment (Armor)</option>
                                            <option value="special">Special (Combat)</option>
                                            <option value="exploration">Exploration</option>
                                            <option value="vision">Vision</option>
                                            <option value="boost">HP Boost</option>
                                            <option value="consumable">Consumable</option>
                                            <option value="quest">Quest Item</option>
                                        </select>
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Rarity</label>
                                        <select id="mazemaster_item_rarity" class="mazemaster-select">
                                            <option value="common">Common</option>
                                            <option value="uncommon">Uncommon</option>
                                            <option value="rare">Rare</option>
                                            <option value="epic">Epic</option>
                                            <option value="legendary">Legendary</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="mazemaster-bb-row">
                                    <div class="mazemaster-bb-field">
                                        <label>Icon (FontAwesome)</label>
                                        <input type="text" id="mazemaster_item_icon" class="mazemaster-input" placeholder="fa-fire" value="fa-box">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Subtype</label>
                                        <select id="mazemaster_item_subtype" class="mazemaster-select">
                                            <option value="">None</option>
                                            <option value="weapon">Weapon</option>
                                            <option value="armor">Armor</option>
                                            <option value="accessory">Accessory</option>
                                        </select>
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Loot Weight</label>
                                        <input type="number" id="mazemaster_item_loot_weight" class="mazemaster-input" min="1" max="100" value="20">
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-bb-field" style="margin-top: 8px;">
                                <label>Description</label>
                                <textarea id="mazemaster_item_description" class="mazemaster-textarea" placeholder="Deals fire damage to an enemy"></textarea>
                            </div>

                            <!-- Equipment Stats (shown only for equipment type) -->
                            <div id="mazemaster_item_equip_stats" class="mazemaster-bb-settings" style="margin-top: 8px;">
                                <label class="mazemaster-label">Equipment Stats</label>
                                <div class="mazemaster-bb-row">
                                    <div class="mazemaster-bb-field">
                                        <label>Attack</label>
                                        <input type="number" id="mazemaster_item_attack" class="mazemaster-input" min="0" max="100" value="0">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Defense</label>
                                        <input type="number" id="mazemaster_item_defense" class="mazemaster-input" min="0" max="100" value="0">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Crit Bonus %</label>
                                        <input type="number" id="mazemaster_item_crit" class="mazemaster-input" min="0" max="50" value="0">
                                    </div>
                                </div>
                            </div>

                            <!-- v1.7.0: Equipment Armor/Shield Settings -->
                            <div id="mazemaster_item_armor_settings" class="mazemaster-bb-settings" style="margin-top: 8px; display: none;">
                                <label class="mazemaster-label">Armor Settings (v1.7.0)</label>
                                <div class="mazemaster-bb-row">
                                    <div class="mazemaster-bb-field">
                                        <label>Charges</label>
                                        <input type="number" id="mazemaster_item_charges" class="mazemaster-input" min="1" max="99" value="3">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Absorb %</label>
                                        <input type="number" id="mazemaster_item_absorb_percent" class="mazemaster-input" min="1" max="100" value="100">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label style="display: flex; align-items: center; gap: 5px;">
                                            <input type="checkbox" id="mazemaster_item_auto_use" checked> Auto-Use
                                        </label>
                                    </div>
                                </div>
                                <div class="mazemaster-bb-row">
                                    <label class="mazemaster-label" style="margin-bottom: 4px;">Triggers:</label>
                                    <label style="display: flex; align-items: center; gap: 5px; margin-right: 15px;">
                                        <input type="checkbox" id="mazemaster_item_trigger_combat" checked> Combat
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" id="mazemaster_item_trigger_trap" checked> Traps
                                    </label>
                                </div>
                            </div>

                            <!-- v1.7.0: Potion Settings -->
                            <div id="mazemaster_item_potion_settings" class="mazemaster-bb-settings" style="margin-top: 8px; display: none;">
                                <label class="mazemaster-label">Potion Settings (v1.7.0)</label>
                                <div class="mazemaster-bb-row">
                                    <div class="mazemaster-bb-field">
                                        <label>Heal Amount</label>
                                        <input type="number" id="mazemaster_item_heal_amount" class="mazemaster-input" min="1" max="100" value="25">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label style="display: flex; align-items: center; gap: 5px;">
                                            <input type="checkbox" id="mazemaster_item_heal_is_percent" checked> Is Percent
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <!-- v1.7.0: Vision Settings -->
                            <div id="mazemaster_item_vision_settings" class="mazemaster-bb-settings" style="margin-top: 8px; display: none;">
                                <label class="mazemaster-label">Vision Settings (v1.7.0)</label>
                                <div class="mazemaster-bb-row">
                                    <div class="mazemaster-bb-field">
                                        <label>Visibility Bonus</label>
                                        <input type="number" id="mazemaster_item_visibility_bonus" class="mazemaster-input" min="1" max="10" value="1">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Duration (moves)</label>
                                        <input type="number" id="mazemaster_item_duration" class="mazemaster-input" min="0" max="99" value="0" placeholder="0 = permanent">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label style="display: flex; align-items: center; gap: 5px;">
                                            <input type="checkbox" id="mazemaster_item_is_passive"> Passive
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <!-- v1.7.0: Theme Aliases -->
                            <div id="mazemaster_item_aliases_section" class="mazemaster-bb-settings" style="margin-top: 8px;">
                                <label class="mazemaster-label">Theme Aliases (v1.7.0)</label>
                                <p style="font-size: 11px; color: #888; margin: 4px 0 8px;">Display different item names based on maze theme</p>
                                <div class="mazemaster-aliases-grid" style="display: grid; grid-template-columns: 100px 1fr; gap: 4px 8px;">
                                    <label>Fantasy:</label>
                                    <input type="text" id="mazemaster_item_alias_fantasy" class="mazemaster-input" placeholder="Iron Key">
                                    <label>Horror:</label>
                                    <input type="text" id="mazemaster_item_alias_horror" class="mazemaster-input" placeholder="Cursed Key">
                                    <label>Sci-Fi:</label>
                                    <input type="text" id="mazemaster_item_alias_scifi" class="mazemaster-input" placeholder="Access Card">
                                    <label>Action:</label>
                                    <input type="text" id="mazemaster_item_alias_action" class="mazemaster-input" placeholder="Master Key">
                                    <label>Cyberpunk:</label>
                                    <input type="text" id="mazemaster_item_alias_cyberpunk" class="mazemaster-input" placeholder="Access Chip">
                                    <label>Western:</label>
                                    <input type="text" id="mazemaster_item_alias_western" class="mazemaster-input" placeholder="Skeleton Key">
                                    <label>Noir:</label>
                                    <input type="text" id="mazemaster_item_alias_noir" class="mazemaster-input" placeholder="Lockpick">
                                    <label>Post-Apoc:</label>
                                    <input type="text" id="mazemaster_item_alias_postapoc" class="mazemaster-input" placeholder="Vault Key">
                                    <label>Comedy:</label>
                                    <input type="text" id="mazemaster_item_alias_comedy" class="mazemaster-input" placeholder="Big Key">
                                </div>
                            </div>

                            <!-- Effects Section -->
                            <div class="mazemaster-section" style="margin-top: 12px;">
                                <label class="mazemaster-label">Effects</label>
                                <div id="mazemaster_item_effects_list" class="mazemaster-effects-list">
                                    <!-- Effects added dynamically -->
                                </div>
                                <button id="mazemaster_item_add_effect_btn" class="menu_button menu_button_icon" style="margin-top: 8px;">
                                    <i class="fa-solid fa-plus"></i> Add Effect
                                </button>
                            </div>

                            <!-- Loot Sources -->
                            <div class="mazemaster-bb-settings" style="margin-top: 8px;">
                                <label class="mazemaster-label">Loot Sources</label>
                                <div class="mazemaster-bb-row" style="gap: 15px;">
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" id="mazemaster_item_source_chest" checked> Chests
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" id="mazemaster_item_source_combat"> Combat
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" id="mazemaster_item_source_shop"> Shop
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" id="mazemaster_item_source_quest"> Quest
                                    </label>
                                </div>
                            </div>

                            <!-- STScript Hooks -->
                            <div class="mazemaster-section" style="margin-top: 12px;">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Use:</label>
                                        <textarea id="mazemaster_item_on_use" placeholder="/echo Used {{itemName}}!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Equip:</label>
                                        <textarea id="mazemaster_item_on_equip" placeholder="/echo Equipped {{itemName}}"></textarea>
                                    </div>
                                </div>
                            </div>

                            <!-- Save/Cancel Buttons -->
                            <div class="mazemaster-profile-row" style="margin-top: 12px;">
                                <button id="mazemaster_item_save_btn" class="menu_button menu_button_primary">
                                    <i class="fa-solid fa-save"></i> Save Item
                                </button>
                                <button id="mazemaster_item_cancel_btn" class="menu_button">
                                    <i class="fa-solid fa-times"></i> Cancel
                                </button>
                            </div>
                        </div>

                        <!-- v1.7.0: Default Items Browser -->
                        <div class="mazemaster-section">
                            <label class="mazemaster-label"><i class="fa-solid fa-box-open"></i> Built-in Items (22)</label>
                            <p style="font-size: 11px; color: #888; margin: 4px 0 8px;">Click to view/customize. Customizations are saved as overrides.</p>
                            <div id="mazemaster_default_items_list" class="mazemaster-items-list" style="max-height: 200px; overflow-y: auto;">
                                <!-- Default items populated by renderDefaultItemsList() -->
                            </div>
                        </div>

                        <!-- Items List -->
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Custom Items (${Object.keys(extensionSettings.customItems || {}).length})</label>
                            <div id="mazemaster_items_list" class="mazemaster-items-list">
                                <!-- Custom items populated by renderCustomItemsList() -->
                            </div>
                        </div>
                    </div>

                    <!-- FACTIONS CONFIG (v1.6.0) -->
                    <div id="mazemaster_factions_config" class="mazemaster-game-config" style="${activeGame === 'factions' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label"><i class="fa-solid fa-users"></i> Faction Profiles</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_faction_profile_select" class="mazemaster-select">
                                    <option value="">(Default Factions)</option>
                                </select>
                                <button id="mazemaster_faction_profile_new_btn" class="menu_button menu_button_icon" title="New Profile">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                                <button id="mazemaster_faction_profile_delete_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                                <button id="mazemaster_faction_profile_save_btn" class="menu_button menu_button_icon" title="Save Profile">
                                    <i class="fa-solid fa-floppy-disk"></i>
                                </button>
                            </div>
                        </div>
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Factions</label>
                            <p style="color: #888; font-size: 12px; margin: 0 0 8px 0;">Define factions and reputation tiers</p>
                            <button id="mazemaster_faction_add_btn" class="menu_button" style="margin-bottom: 12px;">
                                <i class="fa-solid fa-plus"></i> Add Faction
                            </button>
                            <div id="mazemaster_factions_list" class="mazemaster-factions-list">
                                <!-- Factions populated here -->
                            </div>
                        </div>
                    </div>

                    <!-- VISION CONFIG (v1.6.0) -->
                    <div id="mazemaster_vision_config" class="mazemaster-game-config" style="${activeGame === 'vision' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label"><i class="fa-solid fa-eye"></i> Vision Profiles</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_vision_profile_select" class="mazemaster-select">
                                    <option value="">(Default Vision)</option>
                                </select>
                                <button id="mazemaster_vision_profile_new_btn" class="menu_button menu_button_icon" title="New Profile">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                                <button id="mazemaster_vision_profile_delete_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                                <button id="mazemaster_vision_profile_save_btn" class="menu_button menu_button_icon" title="Save Profile">
                                    <i class="fa-solid fa-floppy-disk"></i>
                                </button>
                            </div>
                        </div>
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Visibility Settings</label>
                            <div class="mazemaster-row">
                                <label>Base Visibility</label>
                                <input type="number" id="mazemaster_vision_base" class="mazemaster-input" min="1" max="10" value="1">
                            </div>
                            <div class="mazemaster-row">
                                <label>Torch Bonus</label>
                                <input type="number" id="mazemaster_vision_torch" class="mazemaster-input" min="0" max="10" value="2">
                            </div>
                            <div class="mazemaster-row">
                                <label>Torch Duration (moves)</label>
                                <input type="number" id="mazemaster_vision_torch_duration" class="mazemaster-input" min="1" max="20" value="3">
                            </div>
                            <div class="mazemaster-row">
                                <label>Lantern Bonus</label>
                                <input type="number" id="mazemaster_vision_lantern" class="mazemaster-input" min="0" max="10" value="1">
                            </div>
                        </div>
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Ambient Light Modifiers</label>
                            <div class="mazemaster-row">
                                <label>Dark</label>
                                <input type="number" id="mazemaster_vision_dark" class="mazemaster-input" min="-5" max="0" value="-1">
                            </div>
                            <div class="mazemaster-row">
                                <label>Dim</label>
                                <input type="number" id="mazemaster_vision_dim" class="mazemaster-input" min="-5" max="5" value="0">
                            </div>
                            <div class="mazemaster-row">
                                <label>Bright</label>
                                <input type="number" id="mazemaster_vision_bright" class="mazemaster-input" min="0" max="5" value="1">
                            </div>
                        </div>
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">STScript Hooks</label>
                            <div class="mazemaster-row">
                                <label>On Vision Change</label>
                                <input type="text" id="mazemaster_vision_hook_change" class="mazemaster-input" placeholder="/echo Vision changed">
                            </div>
                            <div class="mazemaster-row">
                                <label>On Light Change</label>
                                <input type="text" id="mazemaster_vision_hook_light" class="mazemaster-input" placeholder="/echo Light changed">
                            </div>
                        </div>
                    </div>

                    <!-- SOUND CONFIG (v1.6.0) -->
                    <div id="mazemaster_sound_config" class="mazemaster-game-config" style="${activeGame === 'sound' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label"><i class="fa-solid fa-volume-high"></i> Sound Settings</label>
                            <label class="mazemaster-checkbox-label">
                                <input type="checkbox" id="mazemaster_sound_enabled" checked> Enable Sound Effects
                            </label>
                            <div class="mazemaster-row">
                                <label>Master Volume</label>
                                <input type="range" id="mazemaster_sound_master" class="mazemaster-range" min="0" max="100" value="80">
                                <span id="mazemaster_sound_master_value">80%</span>
                            </div>
                        </div>
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Category Volumes</label>
                            <div class="mazemaster-row">
                                <label>Combat</label>
                                <input type="range" id="mazemaster_sound_combat" class="mazemaster-range" min="0" max="100" value="80">
                                <span id="mazemaster_sound_combat_value">80%</span>
                            </div>
                            <div class="mazemaster-row">
                                <label>UI</label>
                                <input type="range" id="mazemaster_sound_ui" class="mazemaster-range" min="0" max="100" value="60">
                                <span id="mazemaster_sound_ui_value">60%</span>
                            </div>
                            <div class="mazemaster-row">
                                <label>Ambient</label>
                                <input type="range" id="mazemaster_sound_ambient" class="mazemaster-range" min="0" max="100" value="40">
                                <span id="mazemaster_sound_ambient_value">40%</span>
                            </div>
                        </div>
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Sound Profile</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_sound_profile_select" class="mazemaster-select">
                                    <option value="">(Default Sounds)</option>
                                </select>
                                <button id="mazemaster_sound_profile_new_btn" class="menu_button menu_button_icon" title="New Profile">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                                <button id="mazemaster_sound_profile_delete_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Custom Sounds</label>
                            <p style="color: #888; font-size: 12px; margin: 0 0 8px 0;">Define custom sound effects for events</p>
                            <button id="mazemaster_sound_add_btn" class="menu_button" style="margin-bottom: 12px;">
                                <i class="fa-solid fa-plus"></i> Add Sound
                            </button>
                            <div id="mazemaster_sounds_list" class="mazemaster-sounds-list">
                                <!-- Custom sounds populated here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- HELP TAB -->
                <div class="mazemaster-tab-content" id="mazemaster-tab-help">
                    <!-- Help Sub-tabs -->
                    <div class="mazemaster-help-subtabs">
                        <button class="help-subtab active" data-help="commands">
                            <i class="fa-solid fa-terminal"></i> Commands
                        </button>
                        <button class="help-subtab" data-help="macros">
                            <i class="fa-solid fa-dice"></i> Macros
                        </button>
                        <button class="help-subtab" data-help="hooks">
                            <i class="fa-solid fa-bolt"></i> STScript Hooks
                        </button>
                    </div>

                    <!-- COMMANDS SUB-TAB -->
                    <div id="help_commands_content" class="help-content active">
                        <div class="mazemaster-help-reference">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label"><i class="fa-solid fa-gamepad"></i> Game Commands</label>
                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title">Wheel &amp; Battlebar</div>
                                    <div class="mazemaster-command-list">
                                        <div class="mazemaster-command">
                                            <code>/wheel [profile="name"]</code>
                                            <span>Open the wheel using specified or current profile</span>
                                        </div>
                                        <div class="mazemaster-command">
                                            <code>/battlebar [profile="name"]</code>
                                            <span>Start a battlebar challenge (difficulty 1-10)</span>
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title">Maze Controls</div>
                                    <div class="mazemaster-command-list">
                                        <div class="mazemaster-command">
                                            <code>/maze [profile="name"]</code>
                                            <span>Start a maze using the specified or current profile</span>
                                        </div>
                                        <div class="mazemaster-command">
                                            <code>/mazeminion [name="x"] [message="x"]</code>
                                            <span>Set minion display in active maze</span>
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title">Maze Info</div>
                                    <div class="mazemaster-command-list">
                                        <div class="mazemaster-command">
                                            <code>/mazestats</code>
                                            <span>Returns maze statistics as JSON (moves, encounters, chests, etc.)</span>
                                        </div>
                                        <div class="mazemaster-command">
                                            <code>/mazeexplore</code>
                                            <span>Returns exploration percentage (0-100)</span>
                                        </div>
                                        <div class="mazemaster-command">
                                            <code>/mazeobjective [id="name"]</code>
                                            <span>Get objective progress (all or specific by ID)</span>
                                        </div>
                                        <div class="mazemaster-command">
                                            <code>/mazefloor</code>
                                            <span>Returns current/total floor info as JSON</span>
                                        </div>
                                        <div class="mazemaster-command">
                                            <code>/mazepersonastats [persona="x"]</code>
                                            <span>Get maze stats for a persona (current if omitted)</span>
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title">Maze Settings</div>
                                    <div class="mazemaster-command-list">
                                        <div class="mazemaster-command">
                                            <code>/mazedifficulty [tier="x"]</code>
                                            <span>Get/set difficulty (easy/normal/hard/nightmare)</span>
                                        </div>
                                        <div class="mazemaster-command">
                                            <code>/mazetheme [theme="x"]</code>
                                            <span>Get/set theme (fantasy/horror/scifi/action)</span>
                                        </div>
                                        <div class="mazemaster-command">
                                            <code>/mazemapstyle [style="x"]</code>
                                            <span>Get/set map style (maze/dungeon/city/forest/spaceship)</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label"><i class="fa-solid fa-heart"></i> HP System</label>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-command">
                                        <code>/mazehp [set=N]</code>
                                        <span>Get HP status as JSON, or set HP to value</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazeheal [amount=N] [percent=true]</code>
                                        <span>Heal player (absolute or % of max)</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazedamage [amount=N] [source="x"]</code>
                                        <span>Deal damage with optional source for hooks</span>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label"><i class="fa-solid fa-box-open"></i> Inventory</label>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-command">
                                        <code>/mazeitem action="add" item="x" [amount=N]</code>
                                        <span>Add item(s) to inventory by name or number</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazeitem action="remove" item="x" [amount=N]</code>
                                        <span>Remove item(s) from inventory</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazeitem action="list"</code>
                                        <span>List all available items with IDs</span>
                                    </div>
                                </div>
                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title">Item Reference</div>
                                    <div class="mazemaster-command-list">
                                        <div class="mazemaster-item-ref"><span class="item-num">1-4</span> <strong>Core:</strong> key, stealth, strike, execute</div>
                                        <div class="mazemaster-item-ref"><span class="item-num">5-10</span> <strong>Special:</strong> floorKey, portalStone, minionBane, mapFragment, timeShard, voidWalk</div>
                                        <div class="mazemaster-item-ref"><span class="item-num">11-15</span> <strong>HP:</strong> healingPotion (25%), greaterHealing (50%), elixir (100%), revivalCharm, heartCrystal (+10 max)</div>
                                        <div class="mazemaster-item-ref"><span class="item-num">16-20</span> <strong>Vision:</strong> torch (+2 for 3 moves), lantern (+1 passive), revealScroll (full floor), sightPotion (+1 perm), crystalBall (show minions)</div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label"><i class="fa-solid fa-swords"></i> Combat Modes</label>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-command">
                                        <code>/turnbased [profile="name"]</code>
                                        <span>Start turn-based combat encounter</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/qte [profile="name"]</code>
                                        <span>Start Quick-Time Event challenge</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/dice [profile="name"]</code>
                                        <span>Start dice roll challenge</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/stealth [profile="name"]</code>
                                        <span>Start stealth encounter</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/puzzle [profile="name"]</code>
                                        <span>Start puzzle/sequence challenge</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/negotiate [profile="name"]</code>
                                        <span>Start negotiation encounter</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- MACROS SUB-TAB -->
                    <div id="help_macros_content" class="help-content">
                        <div class="mazemaster-help-reference">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label"><i class="fa-solid fa-dice"></i> MazeMaster Macros</label>
                                <p class="mazemaster-help-intro">Macros are processed in STScript hooks before execution. Use them to add randomness to your hooks.</p>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title">Dice Roll Macro</div>
                                    <div class="mazemaster-macro-doc">
                                        <code class="macro-syntax">{{roll:XdY+Z}}</code>
                                        <p>Rolls X dice with Y sides and adds Z modifier. Standard dice notation.</p>
                                        <div class="mazemaster-examples">
                                            <div class="example-title">Examples:</div>
                                            <div class="example"><code>{{roll:1d6}}</code> - Roll one 6-sided die (1-6)</div>
                                            <div class="example"><code>{{roll:2d6}}</code> - Roll two 6-sided dice (2-12)</div>
                                            <div class="example"><code>{{roll:1d20}}</code> - Roll one 20-sided die (1-20)</div>
                                            <div class="example"><code>{{roll:2d6+3}}</code> - Roll 2d6 and add 3 (5-15)</div>
                                            <div class="example"><code>{{roll:1d8-2}}</code> - Roll 1d8 and subtract 2 (-1 to 6)</div>
                                            <div class="example"><code>{{roll:3d10+5}}</code> - Roll 3d10 and add 5 (8-35)</div>
                                        </div>
                                        <div class="example-usage">
                                            <div class="example-title">In Hook:</div>
                                            <code>/echo Dealt {{roll:2d6+3}} damage!</code>
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title">Random Number Macro</div>
                                    <div class="mazemaster-macro-doc">
                                        <code class="macro-syntax">{{random:MIN:MAX}}</code>
                                        <p>Generates a random integer between MIN and MAX (inclusive).</p>
                                        <div class="mazemaster-examples">
                                            <div class="example-title">Examples:</div>
                                            <div class="example"><code>{{random:1:10}}</code> - Random 1-10</div>
                                            <div class="example"><code>{{random:50:100}}</code> - Random 50-100</div>
                                            <div class="example"><code>{{random:1:100}}</code> - Random 1-100</div>
                                            <div class="example"><code>{{random:0:1}}</code> - Coin flip (0 or 1)</div>
                                        </div>
                                        <div class="example-usage">
                                            <div class="example-title">In Hook:</div>
                                            <code>/echo Found {{random:10:50}} gold coins!</code>
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title">Template Variables</div>
                                    <div class="mazemaster-macro-doc">
                                        <code class="macro-syntax">{{variableName}}</code>
                                        <p>Hooks receive context-specific variables that are substituted before execution.</p>
                                        <div class="mazemaster-examples">
                                            <div class="example-title">Common Variables:</div>
                                            <div class="example"><code>{{x}}</code>, <code>{{y}}</code> - Player coordinates</div>
                                            <div class="example"><code>{{direction}}</code> - Movement direction</div>
                                            <div class="example"><code>{{amount}}</code> - Damage/heal amount</div>
                                            <div class="example"><code>{{source}}</code> - What caused the event</div>
                                            <div class="example"><code>{{hp}}</code>, <code>{{maxHp}}</code> - Current/max HP</div>
                                            <div class="example"><code>{{item}}</code> - Item name</div>
                                            <div class="example"><code>{{floor}}</code> - Current floor number</div>
                                        </div>
                                        <p class="note">See the Hooks tab for complete variable lists per hook.</p>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title">Combining Macros</div>
                                    <div class="mazemaster-macro-doc">
                                        <p>You can combine macros with variables and use multiple macros in one hook:</p>
                                        <div class="mazemaster-examples">
                                            <div class="example-title">Advanced Examples:</div>
                                            <div class="example"><code>/echo {{source}} deals {{roll:2d6}} damage!</code></div>
                                            <div class="example"><code>/setvar key=loot value={{random:1:100}}</code></div>
                                            <div class="example"><code>/echo Roll: {{roll:1d20}} | Gold: {{random:10:50}}</code></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- STSCRIPT HOOKS SUB-TAB -->
                    <div id="help_hooks_content" class="help-content">
                        <div class="mazemaster-help-reference">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label"><i class="fa-solid fa-bolt"></i> STScript Hooks</label>
                                <p class="mazemaster-help-intro">Hooks are STScript commands that fire on game events. Configure them in maze profile settings. Variables in <code>{{braces}}</code> are automatically substituted.</p>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title"><i class="fa-solid fa-shoe-prints"></i> Movement Hooks</div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onMove</code></div>
                                        <div class="hook-desc">Fires each time the player moves to a new cell.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{x}}</code> - New X coordinate,
                                            <code>{{y}}</code> - New Y coordinate,
                                            <code>{{direction}}</code> - Direction moved (up/down/left/right)
                                        </div>
                                        <div class="hook-example"><code>/echo Moved {{direction}} to ({{x}}, {{y}})</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onTeleport</code></div>
                                        <div class="hook-desc">Fires when player teleports via portal or item.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{x}}</code> - Destination X,
                                            <code>{{y}}</code> - Destination Y,
                                            <code>{{source}}</code> - Teleport source (portal/portalStone)
                                        </div>
                                        <div class="hook-example"><code>/echo Warped to ({{x}}, {{y}}) via {{source}}!</code></div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title"><i class="fa-solid fa-heart"></i> HP System Hooks</div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onDamage</code></div>
                                        <div class="hook-desc">Fires when player takes damage.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{amount}}</code> - Damage taken,
                                            <code>{{source}}</code> - Damage source,
                                            <code>{{hp}}</code> - HP after damage,
                                            <code>{{maxHp}}</code> - Maximum HP
                                        </div>
                                        <div class="hook-example"><code>/echo Took {{amount}} damage from {{source}}! HP: {{hp}}/{{maxHp}}</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onHeal</code></div>
                                        <div class="hook-desc">Fires when player is healed.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{amount}}</code> - HP restored,
                                            <code>{{source}}</code> - Heal source,
                                            <code>{{hp}}</code> - HP after heal,
                                            <code>{{maxHp}}</code> - Maximum HP
                                        </div>
                                        <div class="hook-example"><code>/echo Healed {{amount}} HP! Now at {{hp}}/{{maxHp}}</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onPlayerDeath</code></div>
                                        <div class="hook-desc">Fires when HP reaches 0.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{source}}</code> - What killed the player
                                        </div>
                                        <div class="hook-example"><code>/echo Defeated by {{source}}...</code></div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title"><i class="fa-solid fa-box-open"></i> Item Hooks</div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onItemAdd</code></div>
                                        <div class="hook-desc">Fires when item is added to inventory.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{item}}</code> - Item ID,
                                            <code>{{count}}</code> - Amount added,
                                            <code>{{total}}</code> - New total
                                        </div>
                                        <div class="hook-example"><code>/echo Found {{count}}x {{item}}! (Total: {{total}})</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onItemRemove</code></div>
                                        <div class="hook-desc">Fires when item is removed or used.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{item}}</code> - Item ID,
                                            <code>{{count}}</code> - Amount removed,
                                            <code>{{total}}</code> - Remaining total
                                        </div>
                                        <div class="hook-example"><code>/echo Used {{item}}! ({{total}} left)</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onChestOpen</code></div>
                                        <div class="hook-desc">Fires when opening a chest.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{x}}</code> - Chest X,
                                            <code>{{y}}</code> - Chest Y,
                                            <code>{{loot}}</code> - What was found
                                        </div>
                                        <div class="hook-example"><code>/echo Opened chest at ({{x}},{{y}}) - Found {{loot}}!</code></div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title"><i class="fa-solid fa-shield"></i> Equipment Hooks</div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onEquip</code></div>
                                        <div class="hook-desc">Fires when equipping an item.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{itemId}}</code> - Equipment ID,
                                            <code>{{name}}</code> - Item name,
                                            <code>{{slot}}</code> - Slot (weapon/armor/accessory),
                                            <code>{{attack}}</code> - Attack bonus,
                                            <code>{{defense}}</code> - Defense bonus
                                        </div>
                                        <div class="hook-example"><code>/echo Equipped {{name}} (+{{attack}} ATK)</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onUnequip</code></div>
                                        <div class="hook-desc">Fires when unequipping an item.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{itemId}}</code>, <code>{{name}}</code>, <code>{{slot}}</code>
                                        </div>
                                        <div class="hook-example"><code>/echo Removed {{name}} from {{slot}}</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onEquipmentFound</code></div>
                                        <div class="hook-desc">Fires when equipment drops from combat.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{itemId}}</code>, <code>{{name}}</code>, <code>{{slot}}</code>,
                                            <code>{{rarity}}</code> - common/uncommon/rare/epic/legendary
                                        </div>
                                        <div class="hook-example"><code>/echo Found {{rarity}} {{name}}!</code></div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title"><i class="fa-solid fa-star"></i> Progression Hooks</div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onXpGain</code></div>
                                        <div class="hook-desc">Fires when XP is gained.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{amount}}</code> - XP gained,
                                            <code>{{source}}</code> - Source (combat/quest/etc),
                                            <code>{{totalXp}}</code> - Total XP,
                                            <code>{{level}}</code> - Current level
                                        </div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onLevelUp</code></div>
                                        <div class="hook-desc">Fires when player levels up.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{newLevel}}</code> - New level,
                                            <code>{{skillPointsAvailable}}</code> - Available skill points,
                                            <code>{{stats}}</code> - Player stats
                                        </div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onSkillLearn</code></div>
                                        <div class="hook-desc">Fires when learning a skill.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{skillId}}</code>, <code>{{skillName}}</code>, <code>{{rank}}</code>, <code>{{tree}}</code>
                                        </div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onSkillUse</code></div>
                                        <div class="hook-desc">Fires when using a skill.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{skillId}}</code>, <code>{{skillName}}</code>, <code>{{rank}}</code>, <code>{{effect}}</code>
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title"><i class="fa-solid fa-bullseye"></i> Objective Hooks</div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onObjectiveProgress</code></div>
                                        <div class="hook-desc">Fires when progress is made on an objective.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{objectiveId}}</code> - Objective ID,
                                            <code>{{current}}</code> - Current progress,
                                            <code>{{target}}</code> - Target value
                                        </div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onObjectiveComplete</code></div>
                                        <div class="hook-desc">Fires when an objective is completed.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{objectiveId}}</code> - Completed objective ID
                                        </div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onAllObjectivesComplete</code></div>
                                        <div class="hook-desc">Fires when all objectives are completed.</div>
                                        <div class="hook-vars"><strong>Variables:</strong> None</div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onExploreComplete</code></div>
                                        <div class="hook-desc">Fires when 100% exploration is reached.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{percentage}}</code> - Always 100
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title"><i class="fa-solid fa-skull"></i> Enemy Hooks</div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onEnemyMove</code></div>
                                        <div class="hook-desc">Fires when a minion moves.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{minionId}}</code> - Minion identifier,
                                            <code>{{x}}</code> - New X,
                                            <code>{{y}}</code> - New Y,
                                            <code>{{state}}</code> - AI state (patrol/suspicious/alerted/chasing)
                                        </div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onMinionAlert</code></div>
                                        <div class="hook-desc">Fires when a minion becomes alerted.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{minionId}}</code>, <code>{{x}}</code>, <code>{{y}}</code>,
                                            <code>{{alertLevel}}</code> - New alert level
                                        </div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onRoomClear</code></div>
                                        <div class="hook-desc">Fires when a room is cleared of enemies.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{roomId}}</code>, <code>{{roomType}}</code>, <code>{{x}}</code>, <code>{{y}}</code>
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title"><i class="fa-solid fa-map"></i> Zone &amp; Quest Hooks</div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onZoneUnlock</code></div>
                                        <div class="hook-desc">Fires when a zone is unlocked.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{zoneId}}</code>, <code>{{zoneName}}</code>
                                        </div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onSecretFound</code></div>
                                        <div class="hook-desc">Fires when a secret passage is discovered.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{x}}</code>, <code>{{y}}</code>, <code>{{direction}}</code>
                                        </div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onQuestComplete</code></div>
                                        <div class="hook-desc">Fires when a quest is completed.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{questId}}</code>, <code>{{questName}}</code>
                                        </div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onQuestProgression</code></div>
                                        <div class="hook-desc">Fires when quest progress is made.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{questId}}</code>, <code>{{step}}</code>, <code>{{totalSteps}}</code>
                                        </div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onStatUpdate</code></div>
                                        <div class="hook-desc">Fires when any stat is updated.</div>
                                        <div class="hook-vars">
                                            <strong>Variables:</strong>
                                            <code>{{statName}}</code> - Name of stat,
                                            <code>{{value}}</code> - New value
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-help-category">
                                    <div class="mazemaster-help-title"><i class="fa-solid fa-swords"></i> Combat Mode Hooks</div>
                                    <p class="hook-section-note">These hooks are defined in combat profiles (Turn-based, QTE, etc.):</p>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onTurnStart</code></div>
                                        <div class="hook-desc">Fires at the start of each combat turn.</div>
                                        <div class="hook-vars"><strong>Variables:</strong> <code>{{turn}}</code> - Turn number</div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onAttack</code></div>
                                        <div class="hook-desc">Fires when player attacks.</div>
                                        <div class="hook-vars"><strong>Variables:</strong> <code>{{attacker}}</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onDefend</code></div>
                                        <div class="hook-desc">Fires when player defends.</div>
                                        <div class="hook-vars"><strong>Variables:</strong> <code>{{defender}}</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onPlayerHit</code></div>
                                        <div class="hook-desc">Fires when player successfully hits enemy.</div>
                                        <div class="hook-vars"><strong>Variables:</strong> <code>{{damage}}</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onEnemyHit</code></div>
                                        <div class="hook-desc">Fires when enemy hits player.</div>
                                        <div class="hook-vars"><strong>Variables:</strong> <code>{{enemy}}</code>, <code>{{damage}}</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onWin</code></div>
                                        <div class="hook-desc">Fires when combat is won.</div>
                                        <div class="hook-vars"><strong>Variables:</strong> None (use to grant rewards)</div>
                                        <div class="hook-example"><code>/mazeitem action="add" item="key" | /mazeheal amount=20</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onLose</code></div>
                                        <div class="hook-desc">Fires when combat is lost.</div>
                                        <div class="hook-vars"><strong>Variables:</strong> None (use for penalties)</div>
                                        <div class="hook-example"><code>/mazedamage amount=10 | /echo Defeated...</code></div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onFlee</code></div>
                                        <div class="hook-desc">Fires when player flees combat.</div>
                                        <div class="hook-vars"><strong>Variables:</strong> None</div>
                                    </div>
                                    <div class="mazemaster-hook-doc">
                                        <div class="hook-name"><code>onItem</code></div>
                                        <div class="hook-desc">Fires when player uses item in combat.</div>
                                        <div class="hook-vars"><strong>Variables:</strong> <code>{{item}}</code></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mazemaster-section mazemaster-version-info">
                        <label class="mazemaster-label"><i class="fa-solid fa-circle-info"></i> Version Info</label>
                        <div class="mazemaster-help">
                            <p><strong>MazeMaster v1.8.0</strong></p>
                            <p><small>HP System, Combat Modes, Multi-floor Dungeons, STScript Hooks, Dice/Random Macros, Equipment System, XP &amp; Leveling, Skills, Quests</small></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <style>
            .mazemaster-panel {
                display: flex;
                flex-direction: column;
                height: 100%;
            }

            .mazemaster-panel-header {
                padding: 10px 15px;
                border-bottom: 1px solid var(--SmartThemeBorderColor, #555);
            }

            .mazemaster-panel-header h2 {
                margin: 0;
                font-size: 1.2em;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .mazemaster-tabs {
                display: flex;
                border-bottom: 1px solid var(--SmartThemeBorderColor, #555);
                padding: 0 10px;
            }

            .mazemaster-tab {
                padding: 8px 16px;
                background: transparent;
                border: none;
                border-bottom: 2px solid transparent;
                cursor: pointer;
                color: var(--SmartThemeBodyColor);
                font-size: 0.9em;
            }

            .mazemaster-tab:hover {
                background: rgba(255, 255, 255, 0.05);
            }

            .mazemaster-tab.active {
                border-bottom-color: var(--SmartThemeQuoteColor, #4a7c59);
                color: var(--SmartThemeQuoteColor, #4a7c59);
            }

            .mazemaster-panel-content {
                flex: 1;
                overflow-y: auto;
                padding: 15px;
            }

            .mazemaster-tab-content {
                display: none;
            }

            .mazemaster-tab-content.active {
                display: block;
            }

            /* Combat sub-tabs */
            .mazemaster-combat-subtabs {
                display: flex;
                gap: 4px;
                margin-bottom: 12px;
                flex-wrap: wrap;
                padding-bottom: 10px;
                border-bottom: 1px solid var(--SmartThemeBorderColor, #444);
            }

            .combat-subtab {
                padding: 6px 12px;
                background: var(--SmartThemeBlurTintColor, rgba(0,0,0,0.3));
                border: 1px solid var(--SmartThemeBorderColor, #555);
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor);
                transition: all 0.15s ease;
            }

            .combat-subtab:hover {
                background: rgba(255, 255, 255, 0.1);
            }

            .combat-subtab.active {
                background: var(--SmartThemeQuoteColor, #4a7c59);
                color: var(--SmartThemeBodyColor);
                border-color: var(--SmartThemeQuoteColor, #4a7c59);
            }

            .combat-content {
                display: none;
            }

            .combat-content.active {
                display: block;
            }

            /* Help Sub-tabs (same pattern as combat) */
            .mazemaster-help-subtabs {
                display: flex;
                gap: 4px;
                margin-bottom: 12px;
                flex-wrap: wrap;
                padding-bottom: 10px;
                border-bottom: 1px solid var(--SmartThemeBorderColor, #444);
            }

            .help-subtab {
                padding: 6px 12px;
                background: var(--SmartThemeBlurTintColor, rgba(0,0,0,0.3));
                border: 1px solid var(--SmartThemeBorderColor, #555);
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor);
                transition: all 0.15s ease;
            }

            .help-subtab:hover {
                background: rgba(255, 255, 255, 0.1);
            }

            .help-subtab.active {
                background: var(--SmartThemeQuoteColor, #4a7c59);
                color: var(--SmartThemeBodyColor);
                border-color: var(--SmartThemeQuoteColor, #4a7c59);
            }

            .help-subtab i {
                margin-right: 4px;
            }

            .help-content {
                display: none;
            }

            .help-content.active {
                display: block;
            }

            /* Hook Documentation Styles */
            .mazemaster-help-intro {
                margin-bottom: 15px;
                padding: 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 6px;
                font-size: 0.9em;
                color: #aaa;
            }

            .mazemaster-hook-doc {
                background: rgba(0, 0, 0, 0.15);
                padding: 10px;
                margin-bottom: 8px;
                border-radius: 4px;
                border-left: 3px solid var(--SmartThemeQuoteColor, #4a7c59);
            }

            .hook-name code {
                font-size: 1em;
                color: #f1c40f;
                background: rgba(0, 0, 0, 0.3);
                padding: 3px 8px;
                border-radius: 4px;
            }

            .hook-desc {
                margin: 6px 0;
                font-size: 0.9em;
                color: #ccc;
            }

            .hook-vars {
                font-size: 0.85em;
                color: #aaa;
                margin: 6px 0;
            }

            .hook-vars code {
                background: rgba(0, 0, 0, 0.3);
                padding: 1px 5px;
                border-radius: 3px;
                color: #e8c170;
                font-size: 0.9em;
            }

            .hook-example {
                margin-top: 6px;
                padding: 6px 10px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 4px;
            }

            .hook-example code {
                color: #7bed9f;
                font-size: 0.85em;
            }

            .hook-section-note {
                font-size: 0.85em;
                color: #888;
                margin-bottom: 10px;
                font-style: italic;
            }

            /* Macro Documentation Styles */
            .mazemaster-macro-doc {
                background: rgba(0, 0, 0, 0.15);
                padding: 12px;
                margin-bottom: 10px;
                border-radius: 6px;
            }

            .macro-syntax {
                display: block;
                font-size: 1.1em;
                color: #f1c40f;
                background: rgba(0, 0, 0, 0.4);
                padding: 8px 12px;
                border-radius: 4px;
                margin-bottom: 8px;
            }

            .mazemaster-examples {
                margin: 10px 0;
                padding: 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
            }

            .example-title {
                font-weight: 600;
                color: #aaa;
                margin-bottom: 6px;
                font-size: 0.85em;
            }

            .example {
                padding: 3px 0;
                font-size: 0.9em;
            }

            .example code {
                background: rgba(0, 0, 0, 0.3);
                padding: 2px 6px;
                border-radius: 3px;
                color: #e8c170;
            }

            .example-usage {
                margin-top: 10px;
                padding: 8px 10px;
                background: rgba(74, 124, 89, 0.2);
                border-radius: 4px;
                border-left: 3px solid var(--SmartThemeQuoteColor, #4a7c59);
            }

            .example-usage code {
                color: #7bed9f;
            }

            .note {
                color: #888;
                font-size: 0.85em;
                font-style: italic;
            }

            .mazemaster-version-info {
                margin-top: 15px;
                padding-top: 15px;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
            }

            .mazemaster-section {
                margin-bottom: 15px;
            }

            /* Maze Preview Panel Styles */
            #mazemaster_maze_preview {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                padding: 12px;
                margin-top: 10px;
            }
            .mazemaster-preview-header {
                margin-bottom: 8px;
            }
            .preview-title {
                font-weight: bold;
                color: #f1c40f;
                font-size: 1.05em;
            }
            .preview-story {
                font-style: italic;
                color: #aaa;
                margin-bottom: 10px;
                line-height: 1.4;
                padding: 8px;
                background: rgba(0,0,0,0.2);
                border-radius: 4px;
                border-left: 3px solid #f1c40f;
            }
            .preview-stats {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 6px;
            }
            .preview-stats .stat-row {
                display: flex;
                gap: 8px;
            }
            .preview-stats .stat-label {
                color: #888;
                font-size: 0.85em;
            }
            .preview-stats .stat-value {
                color: #fff;
                font-weight: bold;
                font-size: 0.85em;
            }
            .preview-starting-items {
                margin-top: 8px;
                padding-top: 8px;
                border-top: 1px solid rgba(255,255,255,0.1);
                color: #9b59b6;
                font-size: 0.85em;
            }

            .mazemaster-label {
                display: block;
                font-weight: bold;
                margin-bottom: 5px;
                font-size: 0.9em;
            }

            .mazemaster-profile-row {
                display: flex;
                gap: 5px;
            }

            .mazemaster-profile-row select {
                flex: 1;
            }

            .mazemaster-select {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-segments-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
                margin-bottom: 10px;
                max-height: 300px;
                overflow-y: auto;
            }

            .mazemaster-segment-item {
                background: rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                padding: 10px;
            }

            .mazemaster-segment-row {
                display: flex;
                gap: 8px;
                margin-bottom: 8px;
                align-items: center;
            }

            .mazemaster-segment-row:last-child {
                margin-bottom: 0;
            }

            .mazemaster-segment-field {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 2px;
            }

            .mazemaster-segment-field label {
                font-size: 0.7em;
                opacity: 0.7;
            }

            .mazemaster-segment-field input:not([type="checkbox"]),
            .mazemaster-segment-field select,
            .mazemaster-segment-field textarea {
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 5px 8px;
                color: var(--SmartThemeBodyColor);
                font-size: 0.85em;
            }

            .mazemaster-segment-field textarea {
                min-height: 40px;
                resize: vertical;
                font-family: monospace;
            }

            .mazemaster-segment-field.small {
                flex: 0 0 80px;
            }

            .mazemaster-segment-field.tiny {
                flex: 0 0 100px;
                overflow: visible;
            }

            .mazemaster-segment-checkbox {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 0.85em;
                cursor: pointer;
                white-space: nowrap;
                padding: 5px;
                margin: 0;
            }

            .mazemaster-segment-checkbox input[type="checkbox"] {
                width: 18px;
                height: 18px;
                min-width: 18px;
                min-height: 18px;
                cursor: pointer;
                pointer-events: auto;
                margin: 0;
                flex-shrink: 0;
            }

            .mazemaster-profile-settings {
                background: rgba(0, 0, 0, 0.15);
                padding: 10px;
                border-radius: 5px;
            }

            .mazemaster-profile-options {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .mazemaster-checkbox-label {
                display: flex;
                align-items: center;
                gap: 8px;
                cursor: pointer;
                font-size: 0.9em;
            }

            .mazemaster-checkbox-label input[type="checkbox"] {
                width: 16px;
                height: 16px;
                cursor: pointer;
            }

            .mazemaster-difficulty-row {
                display: flex;
                align-items: center;
                gap: 10px;
                font-size: 0.9em;
            }

            .mazemaster-select-small {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 4px 8px;
                color: var(--SmartThemeBodyColor);
                width: 60px;
            }

            .mazemaster-segment-delete {
                padding: 5px 8px;
            }

            .mazemaster-add-btn,
            .mazemaster-save-btn {
                width: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 5px;
            }

            .mazemaster-distribute-btn {
                width: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                background: linear-gradient(135deg, #9b59b6, #8e44ad) !important;
                color: #fff !important;
            }

            .mazemaster-distribute-btn:hover {
                background: linear-gradient(135deg, #8e44ad, #7d3c98) !important;
            }

            .mazemaster-help-small {
                margin-top: 5px;
                color: #888;
                text-align: center;
            }

            /* Help Tab Styles */
            .mazemaster-help-reference {
                padding: 5px;
            }

            .mazemaster-help-category {
                margin-bottom: 16px;
                padding: 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 6px;
            }

            .mazemaster-help-category .mazemaster-help-title {
                font-weight: 600;
                margin-bottom: 8px;
                color: var(--SmartThemeQuoteColor, #4a7c59);
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                padding-bottom: 5px;
            }

            .mazemaster-command-list {
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .mazemaster-command {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: baseline;
                padding: 4px 0;
            }

            .mazemaster-command code {
                background: rgba(0, 0, 0, 0.3);
                padding: 3px 8px;
                border-radius: 4px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 0.85em;
                color: #e8c170;
                white-space: nowrap;
            }

            .mazemaster-command span {
                color: #aaa;
                font-size: 0.85em;
            }

            .mazemaster-item-ref {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 3px 0;
                font-size: 0.85em;
            }

            .mazemaster-item-ref .item-num {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 20px;
                height: 20px;
                background: var(--SmartThemeQuoteColor, #4a7c59);
                border-radius: 4px;
                font-weight: bold;
                font-size: 0.8em;
            }

            .mazemaster-item-ref code {
                background: rgba(0, 0, 0, 0.3);
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Consolas', 'Monaco', monospace;
                color: #e8c170;
            }

            .mazemaster-hooks-list {
                margin: 8px 0;
                padding-left: 20px;
            }

            .mazemaster-hooks-list li {
                margin: 4px 0;
                font-size: 0.85em;
            }

            .mazemaster-hooks-list code {
                background: rgba(0, 0, 0, 0.3);
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Consolas', 'Monaco', monospace;
                color: #e8c170;
            }

            .menu_button_primary {
                background: var(--SmartThemeQuoteColor, #4a7c59) !important;
            }

            .mazemaster-help {
                background: rgba(0, 0, 0, 0.2);
                padding: 10px;
                border-radius: 5px;
                font-size: 0.85em;
            }

            .mazemaster-help-title {
                font-weight: bold;
                margin-bottom: 5px;
                margin-top: 10px;
            }

            .mazemaster-help-title:first-child {
                margin-top: 0;
            }

            .mazemaster-help code {
                background: rgba(0, 0, 0, 0.3);
                padding: 2px 6px;
                border-radius: 3px;
                font-family: monospace;
                font-size: 0.9em;
            }

            .mazemaster-help ul {
                margin: 5px 0;
                padding-left: 20px;
            }

            .mazemaster-help li {
                margin: 3px 0;
            }

            .mazemaster-help small {
                opacity: 0.7;
                display: block;
                margin-top: 5px;
            }

            .mazemaster-empty-state {
                text-align: center;
                padding: 15px;
                opacity: 0.6;
            }

            /* Game Selector */
            .mazemaster-game-selector {
                display: flex;
                gap: 10px;
                margin-bottom: 15px;
            }

            .mazemaster-game-btn {
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                padding: 10px;
                border-radius: 5px;
                transition: all 0.2s;
            }

            .mazemaster-game-btn.active {
                background: var(--SmartThemeQuoteColor, #4a7c59) !important;
                color: white;
            }

            .mazemaster-game-config {
                animation: fadeIn 0.2s ease;
            }

            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }

            /* Battlebar Styles */
            .mazemaster-bb-settings {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .mazemaster-bb-row {
                display: flex;
                gap: 10px;
            }

            .mazemaster-bb-field {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .mazemaster-bb-field label {
                font-size: 0.8em;
                opacity: 0.8;
            }

            .mazemaster-bb-field input,
            .mazemaster-bb-field select {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-bb-commands {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .mazemaster-bb-command {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .mazemaster-bb-command label {
                font-size: 0.85em;
                font-weight: bold;
            }

            .mazemaster-bb-command textarea {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 8px;
                color: var(--SmartThemeBodyColor);
                font-family: monospace;
                font-size: 0.85em;
                min-height: 40px;
                resize: vertical;
            }

            .mazemaster-bb-images-list {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 10px;
            }

            .mazemaster-input {
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 8px 10px;
                color: var(--SmartThemeBodyColor, #fff);
                font-size: 1em;
            }

            .mazemaster-input::placeholder {
                color: var(--SmartThemeBodyColor, #888);
                opacity: 0.6;
            }

            .mazemaster-bb-image-item {
                position: relative;
                width: 120px;
                display: flex;
                flex-direction: column;
                border-radius: 5px;
                overflow: hidden;
                border: 2px solid var(--SmartThemeBorderColor, #444);
                cursor: pointer;
                background: rgba(0, 0, 0, 0.2);
            }

            .mazemaster-bb-image-item:hover {
                border-color: var(--SmartThemeQuoteColor, #888);
            }

            .mazemaster-bb-image-item img {
                width: 100%;
                height: 80px;
                object-fit: cover;
            }

            .mazemaster-bb-image-item .bb-image-index {
                position: absolute;
                top: 2px;
                left: 2px;
                background: rgba(0, 0, 0, 0.7);
                color: white;
                font-size: 0.7em;
                padding: 2px 5px;
                border-radius: 3px;
            }

            .mazemaster-bb-image-item .bb-image-message {
                padding: 4px 6px;
                font-size: 0.7em;
                color: var(--SmartThemeBodyColor, #aaa);
                text-align: center;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                max-height: 20px;
            }

            .mazemaster-bb-image-item .bb-image-delete {
                position: absolute;
                top: 2px;
                right: 2px;
                background: rgba(231, 76, 60, 0.9);
                color: white;
                border: none;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0.7em;
            }

            .mazemaster-bb-image-item .bb-image-delete:hover {
                background: #c0392b;
            }

            /* Game Tab Styles */
            .mazemaster-game-launch {
                display: flex;
                flex-direction: column;
                gap: 15px;
                padding: 10px 0;
            }

            .mazemaster-play-btn {
                width: 100%;
                padding: 15px 20px;
                font-size: 1.2em;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
            }

            /* Maze Config Styles */
            .mazemaster-textarea {
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 8px 10px;
                color: var(--SmartThemeBodyColor, #fff);
                font-family: monospace;
                font-size: 0.9em;
                min-height: 60px;
                resize: vertical;
            }

            .mazemaster-maze-win-image-row {
                display: flex;
                gap: 10px;
                align-items: flex-start;
            }

            .mazemaster-maze-win-image-preview {
                width: 80px;
                height: 80px;
                border-radius: 5px;
                border: 2px solid var(--SmartThemeBorderColor, #444);
                overflow: hidden;
                background: rgba(0, 0, 0, 0.2);
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .mazemaster-maze-win-image-preview img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .mazemaster-maze-win-image-preview .no-image {
                font-size: 0.7em;
                opacity: 0.5;
                text-align: center;
            }

            /* Maze Subsection Styles */
            .mazemaster-subsection {
                background: rgba(0, 0, 0, 0.15);
                border-left: 3px solid var(--SmartThemeQuoteColor, #666);
                padding: 10px;
                margin: 10px 0;
                border-radius: 0 5px 5px 0;
            }

            /* Encounters List Styles */
            .mazemaster-encounters-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
                margin-bottom: 10px;
            }

            .mazemaster-encounter-row {
                display: flex;
                gap: 8px;
                align-items: center;
            }

            .mazemaster-encounter-row select {
                flex: 1;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-encounter-row input[type="number"] {
                width: 60px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
                text-align: center;
            }

            .mazemaster-encounter-row .encounter-remove-btn {
                padding: 5px 8px;
            }

            /* Maze Cell Minion Indicators */
            .maze-cell.has-minion:not(.hidden)::before {
                content: '?';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.7em;
                color: #f39c12;
                font-weight: bold;
                z-index: 1;
            }

            .maze-cell.minion-triggered:not(.hidden)::before {
                content: '\\2713';
                color: #27ae60;
            }

            /* Moving Minion Indicators */
            .maze-cell.minion-moving:not(.hidden):not(.minion-triggered)::before {
                animation: minion-move-pulse 0.8s ease-in-out infinite;
            }

            .maze-cell.minion-chase:not(.hidden):not(.minion-triggered)::before {
                content: '\\f06d';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                color: #e74c3c;
            }

            .maze-cell.minion-patrol:not(.hidden):not(.minion-triggered)::before {
                content: '\\f554';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                color: #9b59b6;
            }

            /* v1.5.0: Enhanced Minion AI Alert States */
            .maze-cell.minion-suspicious:not(.hidden):not(.minion-triggered)::before {
                content: '?';
                font-family: inherit;
                font-weight: bold;
                color: #f39c12;
                animation: minion-suspicious-pulse 1s ease-in-out infinite;
            }

            .maze-cell.minion-alerted:not(.hidden):not(.minion-triggered)::before {
                content: '!';
                font-family: inherit;
                font-weight: bold;
                color: #e74c3c;
                animation: minion-alert-flash 0.5s ease-in-out infinite;
            }

            .maze-cell.minion-arriving:not(.hidden)::before {
                animation: minion-arrive 0.2s ease-out forwards;
            }

            @keyframes minion-suspicious-pulse {
                0%, 100% {
                    transform: translate(-50%, -50%) scale(1);
                    opacity: 0.8;
                }
                50% {
                    transform: translate(-50%, -50%) scale(1.2);
                    opacity: 1;
                }
            }

            @keyframes minion-alert-flash {
                0%, 100% {
                    transform: translate(-50%, -50%);
                    opacity: 1;
                }
                50% {
                    transform: translate(-50%, -50%);
                    opacity: 0.5;
                }
            }

            @keyframes minion-arrive {
                0% {
                    transform: translate(-50%, -50%) scale(0.5);
                    opacity: 0;
                }
                100% {
                    transform: translate(-50%, -50%) scale(1);
                    opacity: 1;
                }
            }

            @keyframes minion-move-pulse {
                0%, 100% {
                    transform: translate(-50%, -50%) scale(1);
                    opacity: 1;
                }
                50% {
                    transform: translate(-50%, -50%) scale(1.15);
                    opacity: 0.8;
                }
            }

            /* Maze Cell Chest Indicators */
            .maze-cell.has-chest:not(.hidden)::before {
                content: '\\f187';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.6em;
                color: #f39c12;
                z-index: 1;
            }

            .maze-cell.chest-locked:not(.hidden)::before {
                color: #95a5a6;
            }

            .maze-cell.chest-opened:not(.hidden)::before {
                color: #666;
                opacity: 0.5;
            }

            /* Hide default icon when custom chest image is used */
            .maze-cell.has-custom-chest::before {
                display: none !important;
            }

            /* Maze Cell Trap Indicators */
            .maze-cell.has-trap:not(.hidden)::before {
                content: '\\f6e2';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.6em;
                color: #e74c3c;
                z-index: 1;
            }

            .maze-cell.trap-triggered:not(.hidden)::before {
                color: #666;
                opacity: 0.5;
            }

            /* Safe Room Indicators */
            .maze-cell.safe-room:not(.hidden) {
                background: radial-gradient(circle, rgba(45, 212, 191, 0.4), transparent 70%);
            }

            .maze-cell.safe-room:not(.hidden)::before {
                content: '\\f004';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.6em;
                color: #2dd4bf;
                z-index: 1;
                animation: saferoom-pulse 2s ease-in-out infinite;
                text-shadow: 0 0 8px rgba(45, 212, 191, 0.8);
            }

            @keyframes saferoom-pulse {
                0%, 100% { opacity: 0.7; transform: translate(-50%, -50%) scale(1); }
                50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            }

            /* Portal Indicators */
            .maze-cell.has-portal:not(.hidden)::before {
                content: '\\f111';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.7em;
                color: var(--portal-color, #9b59b6);
                z-index: 1;
                animation: portal-pulse 1.2s ease-in-out infinite;
                text-shadow: 0 0 8px var(--portal-color, #9b59b6);
            }

            .maze-cell.portal-exit-only:not(.hidden)::before {
                opacity: 0.5;
                animation: none;
            }

            .maze-cell.portal-flash {
                animation: teleport-flash 0.3s ease-out;
            }

            @keyframes portal-pulse {
                0%, 100% {
                    opacity: 0.7;
                    transform: translate(-50%, -50%) scale(1);
                }
                50% {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(1.2);
                }
            }

            @keyframes teleport-flash {
                0% {
                    background: rgba(155, 89, 182, 0.8);
                    box-shadow: 0 0 20px rgba(155, 89, 182, 0.8);
                }
                100% {
                    background: rgba(0, 0, 0, 0.4);
                    box-shadow: none;
                }
            }

            /* Staircase Indicators (v1.2.0) */
            .maze-cell.has-staircase:not(.hidden)::before {
                content: '\\f54b';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.8em;
                color: #3498db;
                z-index: 1;
                text-shadow: 0 0 4px rgba(52, 152, 219, 0.6);
            }

            .maze-cell.staircase-up:not(.hidden)::before {
                content: '\\f148';
                color: #27ae60;
                text-shadow: 0 0 4px rgba(39, 174, 96, 0.6);
            }

            .maze-cell.staircase-down:not(.hidden)::before {
                content: '\\f149';
                color: #e67e22;
                text-shadow: 0 0 4px rgba(230, 126, 34, 0.6);
            }

            .maze-cell.staircase-locked:not(.hidden)::after {
                content: '\\f023';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                top: 2px;
                right: 2px;
                font-size: 0.45em;
                color: #e74c3c;
                z-index: 2;
            }

            /* Inventory Display */
            .mazemaster-maze-inventory {
                display: flex;
                justify-content: center;
                gap: 12px;
                padding: 6px 12px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 6px;
                margin-bottom: 8px;
            }

            .inventory-item {
                display: flex;
                align-items: center;
                gap: 4px;
                font-size: 0.85em;
                color: #fff;
            }

            .inventory-item i { font-size: 0.9em; }
            .inventory-item i.fa-key { color: #f1c40f; }
            .inventory-item i.fa-user-ninja { color: #9b59b6; }
            .inventory-item i.fa-bolt { color: #e74c3c; }
            .inventory-item.execute i.fa-star { color: #ffd700; text-shadow: 0 0 5px #ffd700; }
            .inventory-item.execute { font-weight: bold; }

            /* Encounter Confirmation Buttons */
            .maze-confirm-buttons {
                margin-top: 8px;
                display: flex;
                gap: 8px;
                justify-content: center;
            }

            .maze-confirm-btn {
                padding: 8px 16px;
                font-size: 0.9em;
                font-weight: bold;
                border-radius: 6px;
                background: linear-gradient(to bottom, #3498db, #2980b9);
                color: #fff;
                border: 2px solid #5dade2;
                box-shadow: 0 2px 8px rgba(52, 152, 219, 0.4);
                transition: all 0.2s;
            }

            .maze-confirm-btn:hover {
                background: linear-gradient(to bottom, #5dade2, #3498db);
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(52, 152, 219, 0.6);
            }

            .maze-slip-btn {
                background: linear-gradient(to bottom, #9b59b6, #8e44ad);
                border-color: #bb8fce;
                box-shadow: 0 2px 8px rgba(155, 89, 182, 0.4);
            }

            .maze-slip-btn:hover {
                background: linear-gradient(to bottom, #bb8fce, #9b59b6);
                box-shadow: 0 4px 12px rgba(155, 89, 182, 0.6);
            }

            .maze-accept-btn {
                background: linear-gradient(to bottom, #27ae60, #1e8449);
                border-color: #58d68d;
                box-shadow: 0 2px 8px rgba(39, 174, 96, 0.4);
            }

            .maze-accept-btn:hover {
                background: linear-gradient(to bottom, #58d68d, #27ae60);
                box-shadow: 0 4px 12px rgba(39, 174, 96, 0.6);
            }

            /* Battlebar Action Buttons */
            .mazemaster-bb-action-buttons {
                display: flex;
                gap: 10px;
                justify-content: center;
                flex-wrap: wrap;
                width: 100%;
                max-width: 400px;
            }

            .mazemaster-bb-strike-btn,
            .mazemaster-bb-execute-btn {
                flex: 1;
                min-width: 120px;
                max-width: 180px;
                padding: 12px 15px;
                font-size: 1em;
                border-radius: 10px;
                cursor: pointer;
                font-weight: bold;
                border: none;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                transition: transform 0.1s, box-shadow 0.1s;
            }

            .mazemaster-bb-strike-btn {
                background: linear-gradient(to bottom, #e74c3c, #c0392b);
                color: #fff;
                box-shadow: 0 4px 10px rgba(231, 76, 60, 0.3);
            }

            .mazemaster-bb-strike-btn:hover {
                background: linear-gradient(to bottom, #c0392b, #a93226);
                transform: scale(1.02);
            }

            .mazemaster-bb-execute-btn {
                background: linear-gradient(135deg, #ffd700, #ffaa00);
                color: #000;
                text-shadow: 0 1px 0 rgba(255,255,255,0.5);
                box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            }

            .mazemaster-bb-execute-btn:hover {
                background: linear-gradient(135deg, #ffea00, #ffc400);
                box-shadow: 0 4px 20px rgba(255, 215, 0, 0.6);
                transform: scale(1.02);
            }

            /* Encounter Percent Label */
            .encounter-percent-label {
                font-size: 0.9em;
                color: #888;
            }

            .encounter-percent-input {
                width: 50px;
            }

            /* Small input for config rows */
            .mazemaster-input-small {
                width: 60px;
                padding: 4px 8px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                color: var(--SmartThemeBodyColor);
            }

            /* Grid layout for config rows */
            .mazemaster-row {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 6px;
            }

            .mazemaster-row label {
                min-width: 90px;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor);
                opacity: 0.9;
            }

            /* Two-column grid for percentage fields */
            .mazemaster-grid-2col {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px 16px;
            }

            .mazemaster-grid-2col .mazemaster-row {
                margin-bottom: 0;
            }

            .mazemaster-grid-2col .mazemaster-row label {
                min-width: 80px;
            }

            /* Three-column grid for loot percentages */
            .mazemaster-grid-3col {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }

            .mazemaster-grid-3col .mazemaster-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 4px;
                margin-bottom: 0;
            }

            .mazemaster-grid-3col .mazemaster-row label {
                min-width: auto;
                font-size: 0.8em;
                opacity: 0.8;
            }

            .mazemaster-grid-3col .mazemaster-input-small {
                width: 100%;
            }

            /* 4-column grid */
            .mazemaster-grid-4col {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 8px;
            }

            .mazemaster-grid-4col .mazemaster-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 2px;
                margin-bottom: 0;
            }

            .mazemaster-grid-4col .mazemaster-row label {
                min-width: auto;
                font-size: 0.75em;
                opacity: 0.8;
            }

            .mazemaster-grid-4col .mazemaster-input-small {
                width: 100%;
            }

            /* 5-column grid (for Find Early checkboxes) */
            .mazemaster-grid-5col {
                display: grid;
                grid-template-columns: repeat(5, 1fr);
                gap: 6px;
            }

            .mazemaster-checkbox-label {
                display: flex;
                align-items: center;
                gap: 4px;
                font-size: 0.8em;
                padding: 4px 6px;
                background: rgba(0, 0, 0, 0.15);
                border-radius: 4px;
                cursor: pointer;
                transition: background 0.2s;
            }

            .mazemaster-checkbox-label:hover {
                background: rgba(0, 0, 0, 0.25);
            }

            .mazemaster-checkbox-label input[type="checkbox"] {
                margin: 0;
            }

            /* Collapsible Sections */
            .mazemaster-collapsible {
                margin-bottom: 8px;
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 6px;
                overflow: hidden;
            }

            .mazemaster-collapsible-header {
                width: 100%;
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 10px 12px;
                background: rgba(0, 0, 0, 0.2);
                border: none;
                cursor: pointer;
                text-align: left;
                font-size: 0.95em;
                font-weight: 500;
                color: inherit;
                transition: background 0.2s;
            }

            .mazemaster-collapsible-header:hover {
                background: rgba(0, 0, 0, 0.3);
            }

            .mazemaster-collapse-icon {
                font-size: 0.8em;
                transition: transform 0.2s;
            }

            .mazemaster-collapsible.expanded .mazemaster-collapse-icon {
                transform: rotate(90deg);
            }

            .mazemaster-collapse-hint {
                font-size: 0.8em;
                opacity: 0.6;
                margin-left: auto;
            }

            .mazemaster-collapsible-content {
                padding: 12px;
                border-top: 1px solid var(--SmartThemeBorderColor, #444);
                background: rgba(0, 0, 0, 0.1);
            }

            .mazemaster-collapsible-content .mazemaster-section:last-child {
                margin-bottom: 0;
            }

            /* Portal Config List */
            .mazemaster-portals-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
                margin-bottom: 10px;
            }

            .mazemaster-portal-item {
                background: rgba(0, 0, 0, 0.2);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 6px;
                overflow: hidden;
            }

            .mazemaster-portal-item .portal-header {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 10px;
                background: rgba(0, 0, 0, 0.2);
                border-bottom: 1px solid var(--SmartThemeBorderColor, #444);
            }

            .mazemaster-portal-item .portal-color {
                width: 16px;
                height: 16px;
                border-radius: 50%;
                flex-shrink: 0;
            }

            .mazemaster-portal-item .portal-name {
                flex: 1;
                font-weight: 500;
            }

            .mazemaster-portal-item .portal-details {
                padding: 10px;
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .mazemaster-portal-item .portal-row {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .mazemaster-portal-item .portal-row label {
                width: 90px;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor, #ccc);
            }

            .mazemaster-portal-item .portal-row input[type="text"],
            .mazemaster-portal-item .portal-row input[type="number"] {
                flex: 1;
                max-width: 80px;
            }

            .mazemaster-portal-item .coords-row {
                gap: 4px;
            }

            .mazemaster-portal-item .coords-row span {
                font-size: 0.8em;
                color: var(--SmartThemeBodyColor, #999);
            }

            .mazemaster-portal-item .coords-row input {
                width: 50px !important;
                max-width: 50px !important;
            }

            .mazemaster-portal-item .portal-color-input {
                width: 32px;
                height: 24px;
                padding: 0;
                border: 1px solid var(--SmartThemeBorderColor, #444);
                cursor: pointer;
            }

            .mazemaster-portal-item .remove-portal-btn {
                padding: 4px 8px;
                font-size: 0.8em;
            }

            /* Objectives Config List */
            .mazemaster-objectives-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
                margin-bottom: 10px;
            }

            .mazemaster-objective-item {
                background: rgba(0, 0, 0, 0.2);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 6px;
                overflow: hidden;
            }

            .mazemaster-objective-item .objective-config-header {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 10px;
                background: rgba(0, 0, 0, 0.2);
                border-bottom: 1px solid var(--SmartThemeBorderColor, #444);
            }

            .mazemaster-objective-item .objective-name {
                flex: 1;
                font-weight: 500;
            }

            .mazemaster-objective-item .objective-config-details {
                padding: 10px;
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .mazemaster-objective-item .objective-config-row {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .mazemaster-objective-item .objective-config-row label {
                width: 100px;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor, #ccc);
            }

            .mazemaster-objective-item .objective-config-row input[type="text"],
            .mazemaster-objective-item .objective-config-row input[type="number"],
            .mazemaster-objective-item .objective-config-row select {
                flex: 1;
            }

            .mazemaster-objective-item .remove-objective-btn {
                padding: 4px 8px;
                font-size: 0.8em;
            }

            /* STScript Hooks Config */
            .mazemaster-hooks-group {
                margin-top: 12px;
            }

            .mazemaster-hooks-group:first-of-type {
                margin-top: 8px;
            }

            .mazemaster-hooks-label {
                display: block;
                font-size: 0.85em;
                font-weight: 500;
                color: #3498db;
                margin-bottom: 6px;
                padding-bottom: 4px;
                border-bottom: 1px solid rgba(52, 152, 219, 0.3);
            }

            .mazemaster-hooks-items {
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .mazemaster-hooks-items .hook-item {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .mazemaster-hooks-items .hook-item > label {
                width: 120px;
                flex-shrink: 0;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor, #ccc);
            }

            .mazemaster-hooks-items .hook-item input {
                flex: 1;
            }

            /* Inline row */
            .mazemaster-inline-row {
                display: flex;
                gap: 12px;
            }

            .mazemaster-flex-1 {
                flex: 1;
            }

            /* Saved Games */
            .mazemaster-saved-games-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .mazemaster-saved-game {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
            }

            .mazemaster-saved-game-info {
                display: flex;
                flex-direction: column;
                gap: 2px;
            }

            .mazemaster-saved-game-name {
                font-weight: 500;
            }

            .mazemaster-saved-game-details {
                font-size: 0.8em;
                opacity: 0.7;
            }

            .mazemaster-saved-game-actions {
                display: flex;
                gap: 6px;
            }

            .mazemaster-no-saves {
                text-align: center;
                opacity: 0.6;
                padding: 12px;
                font-style: italic;
            }

            /* Side-by-side sections */
            .mazemaster-section-row {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 16px;
            }

            .mazemaster-section-row .mazemaster-section {
                margin-bottom: 0;
            }

            /* Minions Config Styles */
            .mazemaster-minions-list {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-bottom: 10px;
            }

            .mazemaster-minion-card {
                display: flex;
                gap: 10px;
                align-items: center;
                padding: 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                border: 1px solid var(--SmartThemeBorderColor, #444);
            }

            .mazemaster-minion-card .minion-image {
                width: 50px;
                height: 50px;
                border-radius: 5px;
                overflow: hidden;
                background: rgba(0, 0, 0, 0.3);
                flex-shrink: 0;
                position: relative;
                cursor: pointer;
            }

            .mazemaster-minion-card .minion-image img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .mazemaster-minion-card .minion-image:hover {
                outline: 2px solid var(--SmartThemeQuoteColor, #e74c3c);
                outline-offset: 2px;
            }

            .mazemaster-minion-card .minion-image::after {
                content: '\\f030';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                bottom: 2px;
                right: 2px;
                font-size: 10px;
                color: white;
                background: rgba(0, 0, 0, 0.6);
                padding: 2px 4px;
                border-radius: 3px;
                opacity: 0;
                transition: opacity 0.2s;
            }

            .mazemaster-minion-card .minion-image:hover::after {
                opacity: 1;
            }

            .mazemaster-minion-card .minion-info {
                flex: 1;
            }

            .mazemaster-minion-card .minion-row {
                display: flex;
                gap: 8px;
                margin-bottom: 8px;
            }

            .mazemaster-minion-card .minion-name-input {
                flex: 1;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-minion-card .minion-type-select {
                width: 110px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-minion-card .minion-profiles {
                margin-top: 8px;
            }

            .mazemaster-minion-card .minion-profiles label {
                display: block;
                font-size: 0.85em;
                color: var(--SmartThemeQuoteColor);
                margin-bottom: 4px;
            }

            .mazemaster-minion-card .minion-profiles select {
                width: 100%;
                min-height: 60px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 4px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-minion-card .minion-profiles textarea {
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
                resize: vertical;
            }

            .mazemaster-minion-card .merchant-range-row {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .mazemaster-minion-card .merchant-range-row span {
                color: var(--SmartThemeBodyColor);
                opacity: 0.8;
            }

            .mazemaster-minion-card .minion-encounter-script {
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid var(--SmartThemeBorderColor, #333);
            }

            .mazemaster-minion-card .minion-encounter-script label {
                display: block;
                font-size: 0.85em;
                color: var(--SmartThemeQuoteColor);
                margin-bottom: 4px;
            }

            .mazemaster-minion-card .minion-encounter-script textarea {
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
                resize: vertical;
                font-family: monospace;
            }

            .mazemaster-minion-card .minion-delete-btn {
                padding: 5px 8px;
                flex-shrink: 0;
                align-self: flex-start;
            }

            /* Minion Movement Settings */
            .mazemaster-minion-card .minion-movement-settings {
                margin-top: 8px;
                padding-top: 8px;
                border-top: 1px solid var(--SmartThemeBorderColor, #444);
            }

            .mazemaster-minion-card .minion-movement-settings > label {
                display: block;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor, #999);
                margin-bottom: 4px;
            }

            .mazemaster-minion-card .movement-row {
                display: flex;
                gap: 8px;
                margin-bottom: 6px;
            }

            .mazemaster-minion-card .minion-movement-type {
                flex: 1;
            }

            .mazemaster-minion-card .movement-params {
                display: flex;
                gap: 12px;
                flex-wrap: wrap;
            }

            .mazemaster-minion-card .movement-param {
                display: flex;
                align-items: center;
                gap: 4px;
                font-size: 0.85em;
            }

            .mazemaster-minion-card .movement-param span {
                color: var(--SmartThemeBodyColor, #999);
            }

            .mazemaster-minion-card .movement-param input {
                width: 50px;
            }

            /* TRAP CARD STYLES */
            .mazemaster-traps-list {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-bottom: 10px;
                max-height: 400px;
                overflow-y: auto;
            }

            .mazemaster-trap-card {
                display: flex;
                gap: 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 8px;
                padding: 10px;
                align-items: flex-start;
            }

            .mazemaster-trap-card .trap-image {
                width: 80px;
                height: 80px;
                flex-shrink: 0;
                border-radius: 6px;
                overflow: hidden;
                background: rgba(0, 0, 0, 0.3);
                position: relative;
                cursor: pointer;
            }

            .mazemaster-trap-card .trap-image img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .mazemaster-trap-card .trap-image:hover {
                outline: 2px solid var(--SmartThemeQuoteColor, #e74c3c);
                outline-offset: 2px;
            }

            .mazemaster-trap-card .trap-image::after {
                content: '\\f030';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                bottom: 4px;
                right: 4px;
                font-size: 12px;
                color: white;
                background: rgba(0, 0, 0, 0.6);
                padding: 3px 5px;
                border-radius: 3px;
                opacity: 0;
                transition: opacity 0.2s;
            }

            .mazemaster-trap-card .trap-image:hover::after {
                opacity: 1;
            }

            .mazemaster-trap-card .trap-no-image {
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                color: var(--SmartThemeBodyColor);
                opacity: 0.5;
                font-size: 24px;
            }

            .mazemaster-trap-card .trap-info {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .mazemaster-trap-card .trap-row {
                display: flex;
                gap: 8px;
            }

            .mazemaster-trap-card .trap-name-input {
                flex: 1;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-trap-card .trap-message-row,
            .mazemaster-trap-card .trap-script-row {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .mazemaster-trap-card .trap-message-row label,
            .mazemaster-trap-card .trap-script-row label {
                font-size: 0.75em;
                opacity: 0.7;
            }

            .mazemaster-trap-card .trap-message-input,
            .mazemaster-trap-card .trap-script-input {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
                resize: vertical;
                font-family: inherit;
            }

            .mazemaster-trap-card .trap-delete-btn {
                padding: 5px 8px;
                flex-shrink: 0;
                align-self: flex-start;
            }

            /* QUEST TEMPLATE STYLES (v1.5.0) */
            .mazemaster-quest-template-list {
                display: flex;
                flex-direction: column;
                gap: 10px;
                max-height: 400px;
                overflow-y: auto;
            }

            .mazemaster-quest-template-card {
                background: rgba(0, 0, 0, 0.2);
                border: 1px solid #444;
                border-radius: 8px;
                padding: 12px;
            }

            .mazemaster-quest-template-card:hover {
                border-color: #e91e63;
            }

            .quest-template-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
            }

            .quest-template-title {
                display: flex;
                align-items: center;
                gap: 8px;
                color: #fff;
                font-weight: bold;
            }

            .quest-template-title i {
                color: #e91e63;
            }

            .quest-default-badge {
                font-size: 10px;
                background: rgba(233, 30, 99, 0.2);
                color: #e91e63;
                padding: 2px 6px;
                border-radius: 8px;
                font-weight: normal;
            }

            .quest-template-actions {
                display: flex;
                gap: 4px;
            }

            .quest-template-info {
                display: flex;
                gap: 12px;
                margin-bottom: 6px;
                font-size: 12px;
            }

            .quest-template-type {
                color: #888;
            }

            .quest-template-objective {
                color: #aaa;
            }

            .quest-template-reward {
                color: #f1c40f;
            }

            .quest-template-reward i {
                margin-right: 4px;
            }

            .quest-template-description {
                font-size: 12px;
                color: #888;
                font-style: italic;
            }

            /* Quest Editor Dialog */
            .mazemaster-quest-editor-dialog {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 10100;
            }

            .mazemaster-quest-editor-backdrop {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
            }

            .mazemaster-quest-editor-content {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--SmartThemeBlurTintColor, #1a1a2e);
                border: 2px solid #e91e63;
                border-radius: 12px;
                width: 90%;
                max-width: 500px;
                max-height: 80vh;
                overflow-y: auto;
            }

            .mazemaster-quest-editor-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 16px;
                border-bottom: 1px solid rgba(233, 30, 99, 0.3);
                background: rgba(233, 30, 99, 0.1);
                border-radius: 10px 10px 0 0;
            }

            .mazemaster-quest-editor-header h3 {
                margin: 0;
                color: #e91e63;
                font-size: 16px;
            }

            .quest-editor-close {
                background: none;
                border: none;
                color: #888;
                font-size: 24px;
                cursor: pointer;
                padding: 0;
                width: 28px;
                height: 28px;
            }

            .quest-editor-close:hover {
                color: #e91e63;
            }

            .mazemaster-quest-editor-body {
                padding: 16px;
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            .mazemaster-quest-editor-footer {
                padding: 12px 16px;
                border-top: 1px solid #333;
                display: flex;
                justify-content: flex-end;
                gap: 8px;
            }

            /* v1.6.0: Custom Items List Styles */
            .mazemaster-items-list,
            .mazemaster-factions-list,
            .mazemaster-sounds-list {
                display: flex;
                flex-direction: column;
                gap: 10px;
                max-height: 400px;
                overflow-y: auto;
            }

            .mazemaster-item-card,
            .mazemaster-faction-card {
                background: rgba(0, 0, 0, 0.2);
                border: 1px solid #444;
                border-radius: 8px;
                padding: 12px;
            }

            .mazemaster-item-card:hover,
            .mazemaster-faction-card:hover {
                border-color: #9c27b0;
            }

            .mazemaster-item-header,
            .mazemaster-faction-header {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 6px;
            }

            .mazemaster-item-name,
            .mazemaster-faction-name {
                color: #fff;
                font-weight: bold;
            }

            .mazemaster-item-type {
                color: #888;
                font-size: 12px;
            }

            .mazemaster-item-desc,
            .mazemaster-faction-desc {
                font-size: 12px;
                color: #888;
                margin-bottom: 8px;
            }

            .mazemaster-item-actions,
            .mazemaster-faction-actions {
                display: flex;
                gap: 4px;
                justify-content: flex-end;
            }

            /* v1.6.0: Item Editor Styles */
            .mazemaster-item-editor {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid #9c27b0;
                border-radius: 8px;
                padding: 15px;
            }

            .mazemaster-effects-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .mazemaster-effect-row {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
            }

            .mazemaster-effect-row select,
            .mazemaster-effect-row input {
                padding: 4px;
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid #555;
                border-radius: 4px;
                color: #fff;
            }

            /* v1.6.0: Vision/Sound slider styles */
            .mazemaster-range {
                flex: 1;
                accent-color: #9c27b0;
            }

            /* v1.6.0: Minimap Styles */
            .mazemaster-minimap {
                position: absolute;
                z-index: 100;
                background: rgba(0, 0, 0, 0.8);
                border: 2px solid #9c27b0;
                border-radius: 8px;
                overflow: hidden;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            }

            .mazemaster-minimap-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 5px 10px;
                background: rgba(156, 39, 176, 0.3);
                font-size: 12px;
                color: #fff;
            }

            .mazemaster-minimap-header span {
                display: flex;
                align-items: center;
                gap: 5px;
            }

            .mazemaster-minimap-btn {
                background: none;
                border: none;
                color: #fff;
                cursor: pointer;
                padding: 2px 6px;
                font-size: 11px;
                opacity: 0.7;
            }

            .mazemaster-minimap-btn:hover {
                opacity: 1;
            }

            #mazemaster_minimap_canvas {
                display: block;
            }

            /* Story Milestones Modal */
            .mazemaster-story-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            }

            .mazemaster-story-modal-content {
                background: var(--SmartThemeBlurTintColor, #1a1a1a);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 10px;
                padding: 20px;
                width: 90%;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
            }

            .mazemaster-story-modal-content h3 {
                margin: 0 0 15px 0;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .mazemaster-story-textarea {
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 8px;
                color: var(--SmartThemeBodyColor);
                resize: vertical;
                font-family: inherit;
            }

            .mazemaster-milestones-list {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-bottom: 10px;
                max-height: 200px;
                overflow-y: auto;
            }

            .mazemaster-milestone-row {
                display: flex;
                gap: 10px;
                align-items: flex-start;
                background: rgba(0, 0, 0, 0.2);
                padding: 10px;
                border-radius: 6px;
            }

            .milestone-percent {
                display: flex;
                align-items: center;
                gap: 4px;
                flex-shrink: 0;
            }

            .milestone-percent-input {
                width: 50px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px;
                color: var(--SmartThemeBodyColor);
                text-align: center;
            }

            .milestone-text-input {
                flex: 1;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px;
                color: var(--SmartThemeBodyColor);
                resize: vertical;
                font-family: inherit;
            }

            .mazemaster-story-modal-buttons {
                display: flex;
                gap: 10px;
                justify-content: flex-end;
                margin-top: 15px;
            }
        </style>
    `;
}

function updateProfileSettings() {
    const profileName = document.getElementById('mazemaster_profile_select')?.value;
    const profile = getProfile(profileName);

    const randomizeCheckbox = document.getElementById('mazemaster_randomize');
    if (randomizeCheckbox) {
        randomizeCheckbox.checked = profile?.randomize || false;
    }

    const difficultySelect = document.getElementById('mazemaster_difficulty');
    if (difficultySelect) {
        difficultySelect.value = profile?.difficulty || 1;
    }
}

function renderSegmentsList() {
    const list = document.getElementById('mazemaster_segments_list');
    if (!list) return;

    const profileName = document.getElementById('mazemaster_profile_select')?.value;
    const profile = getProfile(profileName);
    const segments = profile?.segments || [];

    if (segments.length === 0) {
        list.innerHTML = '<div class="mazemaster-empty-state">No segments. Click "Add Segment" to create one.</div>';
        return;
    }

    list.innerHTML = segments.map((seg, index) => `
        <div class="mazemaster-segment-item" data-index="${index}">
            <div class="mazemaster-segment-row">
                <div class="mazemaster-segment-field small">
                    <label>Trigger</label>
                    <input type="text" class="seg-trigger" value="${escapeHtml(seg.trigger || '')}" placeholder="com1">
                </div>
                <div class="mazemaster-segment-field">
                    <label>Display Text</label>
                    <input type="text" class="seg-text" value="${escapeHtml(seg.text || '')}" placeholder="Prize name">
                </div>
                <div class="mazemaster-segment-field small">
                    <label>Size</label>
                    <select class="seg-size">
                        ${SIZE_OPTIONS.map(s => `<option value="${s}" ${seg.size === s ? 'selected' : ''}>${s}</option>`).join('')}
                    </select>
                </div>
                <button class="menu_button menu_button_icon mazemaster-segment-delete" title="Delete">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
            <div class="mazemaster-segment-row">
                <div class="mazemaster-segment-field">
                    <label>STScript Command</label>
                    <textarea class="seg-command" placeholder="/echo You won!">${escapeHtml(seg.command || '')}</textarea>
                </div>
                <div class="mazemaster-segment-field tiny">
                    <label>&nbsp;</label>
                    <label class="mazemaster-segment-checkbox">
                        <input type="checkbox" class="seg-respin" ${seg.respin ? 'checked' : ''}>
                        Respin
                    </label>
                </div>
            </div>
        </div>
    `).join('');

    // Add delete handlers
    list.querySelectorAll('.mazemaster-segment-delete').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.target.closest('.mazemaster-segment-item').remove();
        });
    });
}

function collectSegmentsFromUI() {
    const items = document.querySelectorAll('.mazemaster-segment-item');
    const segments = [];

    items.forEach(item => {
        const trigger = item.querySelector('.seg-trigger').value.trim();
        const text = item.querySelector('.seg-text').value.trim();
        const command = item.querySelector('.seg-command').value.trim();
        const size = item.querySelector('.seg-size').value;
        const respin = item.querySelector('.seg-respin').checked;

        if (trigger || text) {
            segments.push({ trigger, text, command, size, respin });
        }
    });

    return segments;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text || '';
    return div.innerHTML;
}

function exportProfile(profileName) {
    const profile = getProfile(profileName);
    if (!profile) {
        alert(`Profile "${profileName}" not found`);
        return;
    }

    const exportData = {
        name: profileName,
        profile: profile,
        exportedAt: new Date().toISOString(),
        version: '1.0',
    };

    const jsonStr = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `mazemaster-${profileName}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    console.log(`[MazeMaster] Exported profile "${profileName}"`);
}

function importProfile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);

                if (!data.profile || !data.name) {
                    reject(new Error('Invalid profile format: missing name or profile data'));
                    return;
                }

                let profileName = data.name;

                // If profile already exists, ask for new name
                if (extensionSettings.profiles[profileName]) {
                    const newName = prompt(`Profile "${profileName}" already exists. Enter a new name:`, `${profileName}_imported`);
                    if (!newName || !newName.trim()) {
                        reject(new Error('Import cancelled'));
                        return;
                    }
                    profileName = newName.trim();
                }

                // Validate profile structure
                const profile = data.profile;
                if (!profile.segments || !Array.isArray(profile.segments)) {
                    profile.segments = [];
                }
                if (typeof profile.randomize !== 'boolean') {
                    profile.randomize = false;
                }
                if (typeof profile.difficulty !== 'number' || profile.difficulty < 1 || profile.difficulty > 5) {
                    profile.difficulty = 1;
                }

                // Save the imported profile
                extensionSettings.profiles[profileName] = profile;
                extensionSettings.currentProfile = profileName;
                saveSettingsDebounced();

                console.log(`[MazeMaster] Imported profile "${profileName}":`, profile);
                resolve(profileName);
            } catch (err) {
                reject(new Error(`Failed to parse JSON: ${err.message}`));
            }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsText(file);
    });
}

// =============================================================================
// BATTLEBAR UI HELPERS
// =============================================================================

function updateBattlebarSettings() {
    const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
    const profile = getBattlebarProfile(profileName) || {};

    const difficultySlider = document.getElementById('mazemaster_bb_difficulty');
    const difficultyVal = document.getElementById('mazemaster_bb_diff_val');
    if (difficultySlider) {
        // Convert legacy 1-5 to new 1-10 scale
        let diff = profile.difficulty || 5;
        if (diff <= 5 && BATTLEBAR_DIFFICULTY_LEGACY[diff]) {
            diff = BATTLEBAR_DIFFICULTY_LEGACY[diff];
        }
        difficultySlider.value = diff;
        if (difficultyVal) difficultyVal.textContent = `(${diff})`;
    }

    const damageInput = document.getElementById('mazemaster_bb_damage');
    if (damageInput) damageInput.value = profile.damage || 25;

    const hitsInput = document.getElementById('mazemaster_bb_hits');
    if (hitsInput) hitsInput.value = profile.hitsToWin || 5;

    const missesInput = document.getElementById('mazemaster_bb_misses');
    if (missesInput) missesInput.value = profile.missesToLose || 3;

    const hitCmd = document.getElementById('mazemaster_bb_hit_cmd');
    if (hitCmd) hitCmd.value = profile.hitCommand || '';

    const missCmd = document.getElementById('mazemaster_bb_miss_cmd');
    if (missCmd) missCmd.value = profile.missCommand || '';

    const winCmd = document.getElementById('mazemaster_bb_win_cmd');
    if (winCmd) winCmd.value = profile.winCommand || '';

    const loseCmd = document.getElementById('mazemaster_bb_lose_cmd');
    if (loseCmd) loseCmd.value = profile.loseCommand || '';

    const mainTitle = document.getElementById('mazemaster_bb_main_title');
    if (mainTitle) mainTitle.value = profile.mainTitle || '';
}

function renderBattlebarImages() {
    const list = document.getElementById('mazemaster_bb_images_list');
    if (!list) return;

    const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
    if (!profileName) {
        list.innerHTML = '<div class="mazemaster-empty-state">Select or create a profile first.</div>';
        return;
    }

    const profile = getBattlebarProfile(profileName) || {};
    const images = profile.images || [];

    if (images.length === 0) {
        list.innerHTML = '<div class="mazemaster-empty-state">No stages. Add images to create stages.</div>';
        return;
    }

    list.innerHTML = images.map((img, index) => `
        <div class="mazemaster-bb-image-item" data-index="${index}" title="Click to edit stage message">
            <img src="/${img.path}" alt="${escapeHtml(img.stageMessage || '')}">
            <span class="bb-image-index">${index}</span>
            <div class="bb-image-message">${escapeHtml(img.stageMessage || '(no message)')}</div>
            <button class="bb-image-delete" title="Delete">
                <i class="fa-solid fa-times"></i>
            </button>
        </div>
    `).join('');

    // Add click handler to edit stage message
    list.querySelectorAll('.mazemaster-bb-image-item').forEach(item => {
        item.addEventListener('click', async (e) => {
            // Don't trigger if clicking delete button
            if (e.target.closest('.bb-image-delete')) return;

            const index = parseInt(item.dataset.index);
            const profile = getBattlebarProfile(profileName) || {};
            const images = profile.images || [];
            const currentMessage = images[index]?.stageMessage || '';

            const newMessage = await callGenericPopup(
                `Stage ${index} Message:`,
                POPUP_TYPE.INPUT,
                currentMessage
            );

            if (newMessage !== null && newMessage !== undefined) {
                images[index].stageMessage = newMessage;
                saveBattlebarProfile(profileName, profile);
                renderBattlebarImages();
            }
        });
    });

    // Add delete handlers
    list.querySelectorAll('.bb-image-delete').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const item = e.target.closest('.mazemaster-bb-image-item');
            const index = parseInt(item.dataset.index);

            const confirmed = await callGenericPopup(`Delete stage ${index}?`, POPUP_TYPE.CONFIRM);
            if (!confirmed) return;

            const profile = getBattlebarProfile(profileName) || {};
            profile.images = (profile.images || []).filter((_, i) => i !== index);
            saveBattlebarProfile(profileName, profile);
            renderBattlebarImages();
        });
    });
}

function collectBattlebarDataFromUI() {
    const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
    const existingProfile = getBattlebarProfile(profileName) || {};

    return {
        difficulty: parseInt(document.getElementById('mazemaster_bb_difficulty')?.value) || 5,
        damage: parseInt(document.getElementById('mazemaster_bb_damage')?.value) || 25,
        hitsToWin: parseInt(document.getElementById('mazemaster_bb_hits')?.value) || 5,
        missesToLose: parseInt(document.getElementById('mazemaster_bb_misses')?.value) || 3,
        mainTitle: document.getElementById('mazemaster_bb_main_title')?.value || '',
        hitCommand: document.getElementById('mazemaster_bb_hit_cmd')?.value || '',
        missCommand: document.getElementById('mazemaster_bb_miss_cmd')?.value || '',
        winCommand: document.getElementById('mazemaster_bb_win_cmd')?.value || '',
        loseCommand: document.getElementById('mazemaster_bb_lose_cmd')?.value || '',
        // Preserve images with their stageMessages (edited via click)
        images: existingProfile.images || [],
        // Item drops (maze only)
        keyDropChance: parseInt(document.getElementById('mazemaster_bb_key_drop')?.value) ?? 40,
        strikeDropChance: parseInt(document.getElementById('mazemaster_bb_pow_drop')?.value) ?? 20,
        stealthDropChance: parseInt(document.getElementById('mazemaster_bb_stealth_drop')?.value) ?? 10,
    };
}

function exportBattlebarProfile(profileName) {
    const profile = getBattlebarProfile(profileName);
    if (!profile) {
        alert(`Battlebar profile "${profileName}" not found`);
        return;
    }

    const exportData = {
        name: profileName,
        type: 'battlebar',
        profile: profile,
        exportedAt: new Date().toISOString(),
        version: '1.0',
    };

    const jsonStr = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `mazemaster-battlebar-${profileName}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    console.log(`[MazeMaster] Exported battlebar profile "${profileName}"`);
}

function importBattlebarProfile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);

                if (!data.profile || !data.name) {
                    reject(new Error('Invalid profile format: missing name or profile data'));
                    return;
                }

                let profileName = data.name;

                if (extensionSettings.battlebarProfiles[profileName]) {
                    const newName = prompt(`Battlebar profile "${profileName}" already exists. Enter a new name:`, `${profileName}_imported`);
                    if (!newName || !newName.trim()) {
                        reject(new Error('Import cancelled'));
                        return;
                    }
                    profileName = newName.trim();
                }

                saveBattlebarProfile(profileName, data.profile);
                extensionSettings.currentBattlebarProfile = profileName;
                saveSettingsDebounced();

                console.log(`[MazeMaster] Imported battlebar profile "${profileName}":`, data.profile);
                resolve(profileName);
            } catch (err) {
                reject(new Error(`Failed to parse JSON: ${err.message}`));
            }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsText(file);
    });
}

async function uploadBattlebarImage(file, profileName) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const base64 = e.target.result.split(',')[1];
                const ext = file.name.split('.').pop().toLowerCase();
                const timestamp = Date.now();
                const filename = `battlebar_${profileName}_${timestamp}`;

                const response = await fetch('/api/images/upload', {
                    method: 'POST',
                    headers: getRequestHeaders(),
                    body: JSON.stringify({
                        image: base64,
                        ch_name: 'MazeMaster',
                        filename: filename,
                        format: ext,
                    }),
                });

                if (response.ok) {
                    resolve(`user/images/MazeMaster/${filename}.${ext}`);
                } else {
                    const error = await response.json().catch(() => ({}));
                    reject(new Error(error.error || 'Upload failed'));
                }
            } catch (err) {
                reject(err);
            }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(file);
    });
}

// =============================================================================
// MAZE UI HELPERS
// =============================================================================

function updateMazeSettings() {
    const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
    const profile = getMazeProfile(profileName) || {};

    const sizeSelect = document.getElementById('mazemaster_maze_size');
    if (sizeSelect) sizeSelect.value = profile.gridSize || 10;

    // Set floors dropdown
    const floorsSelect = document.getElementById('mazemaster_maze_floors');
    if (floorsSelect) floorsSelect.value = profile.floors || 1;

    // Set difficulty dropdown
    const difficultySelect = document.getElementById('mazemaster_maze_difficulty');
    if (difficultySelect) difficultySelect.value = profile.difficulty || 'normal';

    // Set theme dropdown
    const themeSelect = document.getElementById('mazemaster_maze_theme');
    if (themeSelect) themeSelect.value = profile.theme || 'fantasy';

    // Set map style dropdown
    const mapStyleSelect = document.getElementById('mazemaster_maze_mapstyle');
    if (mapStyleSelect) mapStyleSelect.value = profile.mapStyle || 'maze';

    const winCmd = document.getElementById('mazemaster_maze_win_cmd');
    if (winCmd) winCmd.value = profile.winCommand || '';

    const loseCmd = document.getElementById('mazemaster_maze_lose_cmd');
    if (loseCmd) loseCmd.value = profile.loseCommand || '';

    const winMessage = document.getElementById('mazemaster_maze_win_message');
    if (winMessage) winMessage.value = profile.winMessage || '';

    // Main minion settings - repopulate options first
    const mainMinionSelect = document.getElementById('mazemaster_maze_main_minion');
    if (mainMinionSelect) {
        const minionNames = getMinionNames();
        mainMinionSelect.innerHTML = '<option value="">None</option>' +
            minionNames.map(id => {
                const m = getMinion(id);
                return `<option value="${escapeHtml(id)}" ${profile.mainMinion === id ? 'selected' : ''}>${escapeHtml(m?.name || id)}</option>`;
            }).join('');
    }

    const mainMinionSettings = document.getElementById('mazemaster_main_minion_settings');
    if (mainMinionSettings) mainMinionSettings.style.display = profile.mainMinion ? 'block' : 'none';

    const introMessage = document.getElementById('mazemaster_maze_intro_message');
    if (introMessage) introMessage.value = profile.mainMinionIntroMessage || '';

    const randomChance = document.getElementById('mazemaster_maze_random_chance');
    if (randomChance) randomChance.value = profile.mainMinionRandomChance || 15;

    const randomMessages = document.getElementById('mazemaster_maze_random_messages');
    if (randomMessages) randomMessages.value = (profile.mainMinionRandomMessages || []).join('\n');

    const exitType = document.getElementById('mazemaster_maze_exit_type');
    if (exitType) exitType.value = profile.mainMinionExitType || 'messenger';

    // Update exit profile dropdown
    updateExitProfileDropdown(profile.mainMinionExitType || 'messenger', profile.mainMinionExitProfile);

    // Loss action
    const lossAction = document.getElementById('mazemaster_maze_loss_action');
    if (lossAction) lossAction.value = profile.onBattlebarLoss || 'continue';

    // Update win image preview
    const previewContainer = document.querySelector('.mazemaster-maze-win-image-preview');
    if (previewContainer) {
        if (profile.winImage) {
            previewContainer.innerHTML = `<img id="maze_win_image_preview" src="${profile.winImage}" alt="Victory">`;
        } else {
            previewContainer.innerHTML = '<div id="maze_win_image_preview" class="no-image">No image</div>';
        }
    }

    // Chest distribution settings
    const chestPercent = document.getElementById('mazemaster_maze_chest_percent');
    if (chestPercent) chestPercent.value = profile.chestTilePercent || 10;

    const lockedPercent = document.getElementById('mazemaster_maze_locked_percent');
    if (lockedPercent) lockedPercent.value = profile.chestLockedPercent || 30;

    const lockedBonus = document.getElementById('mazemaster_maze_locked_bonus');
    if (lockedBonus) lockedBonus.value = profile.chestLockedBonusPercent || 50;

    const mimicPercent = document.getElementById('mazemaster_maze_mimic_percent');
    if (mimicPercent) mimicPercent.value = profile.chestMimicPercent || 15;

    // Loot per chest
    const lootMin = document.getElementById('mazemaster_maze_loot_min');
    if (lootMin) lootMin.value = profile.chestLootMin || 1;

    const lootMax = document.getElementById('mazemaster_maze_loot_max');
    if (lootMax) lootMax.value = profile.chestLootMax || 2;

    // Regular chest loot chances
    const chestKey = document.getElementById('mazemaster_maze_chest_key');
    if (chestKey) chestKey.value = profile.chestKeyChance || 30;

    const chestPow = document.getElementById('mazemaster_maze_chest_pow');
    if (chestPow) chestPow.value = profile.chestStrikeChance || 50;

    const chestStealth = document.getElementById('mazemaster_maze_chest_stealth');
    if (chestStealth) chestStealth.value = profile.chestStealthChance || 0;

    const chestExecute = document.getElementById('mazemaster_maze_chest_execute');
    if (chestExecute) chestExecute.value = profile.chestExecuteChance || 0;

    // Locked chest loot chances
    const lockedKey = document.getElementById('mazemaster_maze_locked_key');
    if (lockedKey) lockedKey.value = profile.lockedChestKeyChance || 40;

    const lockedPow = document.getElementById('mazemaster_maze_locked_pow');
    if (lockedPow) lockedPow.value = profile.lockedChestStrikeChance || 60;

    const lockedStealth = document.getElementById('mazemaster_maze_locked_stealth');
    if (lockedStealth) lockedStealth.value = profile.lockedChestStealthChance || 30;

    const lockedExecute = document.getElementById('mazemaster_maze_locked_execute');
    if (lockedExecute) lockedExecute.value = profile.lockedChestExecuteChance || 5;

    // Starting inventory - use defaults if empty/zero
    let startInv = profile.startingInventory || {};

    // If startingInventory is empty/zero and we have defaults, use them
    const isEmptyInventory = !startInv.key && !startInv.stealth && !startInv.strike && !startInv.execute;
    if (isEmptyInventory && DEFAULT_MAZE_PROFILE[profileName]?.startingInventory) {
        startInv = DEFAULT_MAZE_PROFILE[profileName].startingInventory;
        profile.startingInventory = JSON.parse(JSON.stringify(startInv));
        saveSettingsDebounced();
    }

    // Keys
    const startKey = document.getElementById('mazemaster_start_key');
    if (startKey) startKey.value = startInv.key || 0;
    const startFloorKey = document.getElementById('mazemaster_start_floorKey');
    if (startFloorKey) startFloorKey.value = startInv.floorKey || 0;

    // Combat items
    const startStrike = document.getElementById('mazemaster_start_strike');
    if (startStrike) startStrike.value = startInv.strike || 0;
    const startStealth = document.getElementById('mazemaster_start_stealth');
    if (startStealth) startStealth.value = startInv.stealth || 0;
    const startExecute = document.getElementById('mazemaster_start_execute');
    if (startExecute) startExecute.value = startInv.execute || 0;
    const startMinionBane = document.getElementById('mazemaster_start_minionBane');
    if (startMinionBane) startMinionBane.value = startInv.minionBane || 0;

    // Exploration items
    const startPortalStone = document.getElementById('mazemaster_start_portalStone');
    if (startPortalStone) startPortalStone.value = startInv.portalStone || 0;
    const startMapFragment = document.getElementById('mazemaster_start_mapFragment');
    if (startMapFragment) startMapFragment.value = startInv.mapFragment || 0;
    const startVoidWalk = document.getElementById('mazemaster_start_voidWalk');
    if (startVoidWalk) startVoidWalk.value = startInv.voidWalk || 0;
    const startTimeShard = document.getElementById('mazemaster_start_timeShard');
    if (startTimeShard) startTimeShard.value = startInv.timeShard || 0;

    // HP items
    const startHealingPotion = document.getElementById('mazemaster_start_healingPotion');
    if (startHealingPotion) startHealingPotion.value = startInv.healingPotion || 0;
    const startGreaterHealing = document.getElementById('mazemaster_start_greaterHealing');
    if (startGreaterHealing) startGreaterHealing.value = startInv.greaterHealing || 0;
    const startElixir = document.getElementById('mazemaster_start_elixir');
    if (startElixir) startElixir.value = startInv.elixir || 0;
    const startRevivalCharm = document.getElementById('mazemaster_start_revivalCharm');
    if (startRevivalCharm) startRevivalCharm.value = startInv.revivalCharm || 0;
    const startHeartCrystal = document.getElementById('mazemaster_start_heartCrystal');
    if (startHeartCrystal) startHeartCrystal.value = startInv.heartCrystal || 0;

    // Vision items
    const startTorch = document.getElementById('mazemaster_start_torch');
    if (startTorch) startTorch.value = startInv.torch || 0;
    const startLantern = document.getElementById('mazemaster_start_lantern');
    if (startLantern) startLantern.value = startInv.lantern || 0;
    const startRevealScroll = document.getElementById('mazemaster_start_revealScroll');
    if (startRevealScroll) startRevealScroll.value = startInv.revealScroll || 0;
    const startSightPotion = document.getElementById('mazemaster_start_sightPotion');
    if (startSightPotion) startSightPotion.value = startInv.sightPotion || 0;
    const startCrystalBall = document.getElementById('mazemaster_start_crystalBall');
    if (startCrystalBall) startCrystalBall.value = startInv.crystalBall || 0;

    // Equipment - Weapons
    const startWeaponRustySword = document.getElementById('mazemaster_start_weapon_rusty_sword');
    if (startWeaponRustySword) startWeaponRustySword.value = startInv.weapon_rusty_sword || 0;
    const startWeaponIronSword = document.getElementById('mazemaster_start_weapon_iron_sword');
    if (startWeaponIronSword) startWeaponIronSword.value = startInv.weapon_iron_sword || 0;
    const startWeaponSteelBlade = document.getElementById('mazemaster_start_weapon_steel_blade');
    if (startWeaponSteelBlade) startWeaponSteelBlade.value = startInv.weapon_steel_blade || 0;
    const startWeaponEnchantedBlade = document.getElementById('mazemaster_start_weapon_enchanted_blade');
    if (startWeaponEnchantedBlade) startWeaponEnchantedBlade.value = startInv.weapon_enchanted_blade || 0;
    const startWeaponShadowDagger = document.getElementById('mazemaster_start_weapon_shadow_dagger');
    if (startWeaponShadowDagger) startWeaponShadowDagger.value = startInv.weapon_shadow_dagger || 0;

    // Equipment - Armor
    const startArmorLeather = document.getElementById('mazemaster_start_armor_leather');
    if (startArmorLeather) startArmorLeather.value = startInv.armor_leather || 0;
    const startArmorChainmail = document.getElementById('mazemaster_start_armor_chainmail');
    if (startArmorChainmail) startArmorChainmail.value = startInv.armor_chainmail || 0;
    const startArmorPlate = document.getElementById('mazemaster_start_armor_plate');
    if (startArmorPlate) startArmorPlate.value = startInv.armor_plate || 0;
    const startIronGuard = document.getElementById('mazemaster_start_ironGuard');
    if (startIronGuard) startIronGuard.value = startInv.ironGuard || 0;

    // Equipment - Accessories
    const startAccessoryRingPower = document.getElementById('mazemaster_start_accessory_ring_power');
    if (startAccessoryRingPower) startAccessoryRingPower.value = startInv.accessory_ring_power || 0;
    const startAccessoryAmuletProtection = document.getElementById('mazemaster_start_accessory_amulet_protection');
    if (startAccessoryAmuletProtection) startAccessoryAmuletProtection.value = startInv.accessory_amulet_protection || 0;
    const startAccessoryLuckyCharm = document.getElementById('mazemaster_start_accessory_lucky_charm');
    if (startAccessoryLuckyCharm) startAccessoryLuckyCharm.value = startInv.accessory_lucky_charm || 0;
    const startAccessoryVampiricPendant = document.getElementById('mazemaster_start_accessory_vampiric_pendant');
    if (startAccessoryVampiricPendant) startAccessoryVampiricPendant.value = startInv.accessory_vampiric_pendant || 0;

    // HP System settings
    const hpEnabled = document.getElementById('mazemaster_hp_enabled');
    if (hpEnabled) hpEnabled.checked = profile.hpEnabled !== false;

    const maxHP = document.getElementById('mazemaster_hp_max');
    if (maxHP) maxHP.value = profile.maxHP || 100;

    const bbDamageMult = document.getElementById('mazemaster_hp_battlebar_mult');
    if (bbDamageMult) bbDamageMult.value = profile.battlebarDamageMultiplier ?? 1.0;

    const bbDiffMult = document.getElementById('mazemaster_hp_battlebar_diff');
    if (bbDiffMult) bbDiffMult.value = profile.battlebarDifficultyMultiplier ?? 1.0;

    const respawnHP = document.getElementById('mazemaster_hp_respawn');
    if (respawnHP) respawnHP.value = profile.respawnHPPercent || 50;

    const onDeath = document.getElementById('mazemaster_hp_ondeath');
    if (onDeath) onDeath.value = profile.onDeath || 'respawn';

    // Safe room settings
    const safeRoomCount = document.getElementById('mazemaster_safe_room_count');
    if (safeRoomCount) safeRoomCount.value = profile.safeRoomCount ?? 3;

    const safeRoomHeal = document.getElementById('mazemaster_safe_room_heal');
    if (safeRoomHeal) safeRoomHeal.value = profile.safeRoomHealPercent ?? 100;

    const safeRoomLLM = document.getElementById('mazemaster_safe_room_llm');
    if (safeRoomLLM) safeRoomLLM.checked = profile.safeRoomUseLLM || false;

    // LLM Enhancement settings
    const llmEnhanceRooms = document.getElementById('mazemaster_llm_enhance_rooms');
    if (llmEnhanceRooms) llmEnhanceRooms.checked = profile.llmEnhanceRooms !== false;

    const llmMaxTokens = document.getElementById('mazemaster_llm_max_tokens');
    if (llmMaxTokens) llmMaxTokens.value = profile.llmMaxTokens ?? 250;

    // Rest settings
    const restEnabled = document.getElementById('mazemaster_rest_enabled');
    if (restEnabled) restEnabled.checked = profile.restEnabled !== false;

    const restHeal = document.getElementById('mazemaster_rest_heal');
    if (restHeal) restHeal.value = profile.restHealPercent || 20;

    const restCooldown = document.getElementById('mazemaster_rest_cooldown');
    if (restCooldown) restCooldown.value = profile.restCooldown ?? 3;

    const restInterrupt = document.getElementById('mazemaster_rest_interrupt');
    if (restInterrupt) restInterrupt.value = profile.restInterruptChance ?? 15;

    // Map visibility radio buttons
    const mapVis = profile.mapVisibility || 'fogOfWar';
    const visRadio = document.querySelector(`input[name="mazemaster_map_visibility"][value="${mapVis}"]`);
    if (visRadio) visRadio.checked = true;

    // Render encounters list - use defaults from DEFAULT_MAZE_PROFILE if empty
    let minionEncounters = profile.minionEncounters || [];
    let trapEncounters = profile.trapEncounters || [];
    let questPool = profile.questPool || [];

    // If encounters are empty and we have defaults for this profile, use them
    if (minionEncounters.length === 0 && DEFAULT_MAZE_PROFILE[profileName]?.minionEncounters) {
        minionEncounters = DEFAULT_MAZE_PROFILE[profileName].minionEncounters;
        // Also update the profile so it persists
        profile.minionEncounters = JSON.parse(JSON.stringify(minionEncounters));
        saveSettingsDebounced();
    }
    if (trapEncounters.length === 0 && DEFAULT_MAZE_PROFILE[profileName]?.trapEncounters) {
        trapEncounters = DEFAULT_MAZE_PROFILE[profileName].trapEncounters;
        // Also update the profile so it persists
        profile.trapEncounters = JSON.parse(JSON.stringify(trapEncounters));
        saveSettingsDebounced();
    }

    renderMazeEncountersList(minionEncounters);
    renderMazeTrapEncountersList(trapEncounters);
    renderMazeQuestPoolList(questPool);
    // v2.1.0: Render avatar generation minion list
    renderAvatarMinionList(profileName);

    // Find Early settings (v1.3.2)
    const findEarly = profile.findEarly || {};
    const findEarlyRadius = document.getElementById('mazemaster_findearly_radius');
    if (findEarlyRadius) findEarlyRadius.value = findEarly.radius || 4;

    const findEarlyPerChest = document.getElementById('mazemaster_findearly_perchest');
    if (findEarlyPerChest) findEarlyPerChest.value = findEarly.itemsPerChest || 1;

    // Set checkboxes for Find Early items - dynamically iterate all item profiles
    const findEarlyItems = findEarly.items || [];
    const allItemIds = getItemProfileIds();
    for (const itemId of allItemIds) {
        const checkbox = document.getElementById(`mazemaster_findearly_${itemId}`);
        if (checkbox) checkbox.checked = findEarlyItems.includes(itemId);
    }

    // v1.8.0: Item Pool settings
    const itemPool = profile.itemPool || {};
    const itemPoolEnabled = document.getElementById('mazemaster_itempool_enabled');
    const itemPoolItemsDiv = document.getElementById('mazemaster_itempool_items');
    if (itemPoolEnabled) {
        itemPoolEnabled.checked = itemPool.enabled || false;
    }
    if (itemPoolItemsDiv) {
        itemPoolItemsDiv.style.display = itemPool.enabled ? 'block' : 'none';
    }
    // Set checkboxes for Item Pool items
    const poolItems = itemPool.items || [];
    document.querySelectorAll('#mazemaster_itempool_items input[data-pool-item]').forEach(cb => {
        cb.checked = poolItems.includes(cb.dataset.poolItem);
    });

    // v1.9.2: Render custom items in item pool
    renderCustomItemsInItemPool();
}

function updateExitProfileDropdown(exitType, selectedProfile) {
    const profileSection = document.getElementById('mazemaster_exit_profile_section');
    const profileSelect = document.getElementById('mazemaster_maze_exit_profile');

    if (!profileSection || !profileSelect) return;

    if (exitType === 'messenger') {
        profileSection.style.display = 'none';
        return;
    }

    profileSection.style.display = 'block';

    // Populate with appropriate profiles based on exit type
    let profiles = [];
    switch (exitType) {
        case 'battlebar':
            profiles = getBattlebarProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_BATTLEBAR_PROFILES);
            break;
        case 'prizewheel':
            profiles = getProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_WHEEL_PROFILES);
            break;
        case 'turnbased':
            profiles = getTurnbasedProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_TURNBASED_PROFILES);
            break;
        case 'qte':
            profiles = getQteProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_QTE_PROFILES);
            break;
        case 'dice':
            profiles = getDiceProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_DICE_PROFILES);
            break;
        case 'stealth':
            profiles = getStealthProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_STEALTH_PROFILES);
            break;
        case 'puzzle':
            profiles = getPuzzleProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_PUZZLE_PROFILES);
            break;
        case 'negotiation':
            profiles = getNegotiationProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_NEGOTIATION_PROFILES);
            break;
    }

    profileSelect.innerHTML = '<option value="">Select...</option>' +
        profiles.map(p => `<option value="${escapeHtml(p)}" ${p === selectedProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('');
}

function renderMazeEncountersList(encounters) {
    const list = document.getElementById('mazemaster_maze_encounters_list');
    if (!list) return;

    const minionNames = getMinionNames();

    if (encounters.length === 0) {
        list.innerHTML = '<div class="mazemaster-empty-state" style="font-size: 0.85em;">No encounters. Minions will be randomly placed in the maze.</div>';
        return;
    }

    list.innerHTML = encounters.map((enc, index) => {
        const minion = getMinion(enc.minionId);
        return `
            <div class="mazemaster-encounter-row" data-index="${index}">
                <select class="encounter-minion-select">
                    ${minionNames.map(id => {
                        const m = getMinion(id);
                        return `<option value="${escapeHtml(id)}" ${enc.minionId === id ? 'selected' : ''}>${escapeHtml(m?.name || id)}</option>`;
                    }).join('')}
                </select>
                <input type="number" class="encounter-percent-input" min="1" max="100" value="${enc.percent || 5}" placeholder="%">
                <span class="encounter-percent-label">%</span>
                <button class="menu_button menu_button_icon encounter-remove-btn" title="Remove">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
        `;
    }).join('');

    // Add event handlers
    list.querySelectorAll('.mazemaster-encounter-row').forEach(row => {
        const index = parseInt(row.dataset.index);

        row.querySelector('.encounter-minion-select')?.addEventListener('change', () => {
            // Will be saved when Save Profile is clicked
        });

        row.querySelector('.encounter-percent-input')?.addEventListener('change', () => {
            // Will be saved when Save Profile is clicked
        });

        row.querySelector('.encounter-remove-btn')?.addEventListener('click', () => {
            row.remove();
        });
    });
}

function renderMazeTrapEncountersList(trapEncounters) {
    const list = document.getElementById('mazemaster_maze_traps_list');
    if (!list) return;

    const trapNames = getTrapNames();

    if (trapEncounters.length === 0) {
        list.innerHTML = '<div class="mazemaster-empty-state" style="font-size: 0.85em;">No traps. Add traps to place trap tiles in the maze.</div>';
        return;
    }

    list.innerHTML = trapEncounters.map((enc, index) => {
        const trap = getTrap(enc.trapId);
        return `
            <div class="mazemaster-encounter-row mazemaster-trap-encounter-row" data-index="${index}">
                <select class="trap-encounter-select">
                    ${trapNames.map(id => {
                        const t = getTrap(id);
                        return `<option value="${escapeHtml(id)}" ${enc.trapId === id ? 'selected' : ''}>${escapeHtml(t?.name || id)}</option>`;
                    }).join('')}
                </select>
                <input type="number" class="trap-encounter-percent-input" min="1" max="100" value="${enc.percent || 5}" placeholder="%">
                <span class="encounter-percent-label">%</span>
                <button class="menu_button menu_button_icon trap-encounter-remove-btn" title="Remove">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
        `;
    }).join('');

    // Add event handlers
    list.querySelectorAll('.mazemaster-trap-encounter-row').forEach(row => {
        row.querySelector('.trap-encounter-remove-btn')?.addEventListener('click', () => {
            row.remove();
        });
    });
}

/**
 * Render quest pool list in maze profile
 */
function renderMazeQuestPoolList(questPool) {
    const list = document.getElementById('mazemaster_maze_quests_list');
    if (!list) return;

    const allQuests = getAllQuests();
    const questIds = Object.keys(allQuests);

    if (!questPool || questPool.length === 0) {
        list.innerHTML = '<div class="mazemaster-empty-state" style="font-size: 0.85em;">No quests. Quests from the pool will be offered to players.</div>';
        return;
    }

    list.innerHTML = questPool.map((entry, index) => {
        const quest = getQuest(entry.questId);
        return `
            <div class="mazemaster-encounter-row mazemaster-quest-pool-row" data-index="${index}">
                <select class="quest-pool-select">
                    <option value="">Select Quest</option>
                    ${questIds.map(id => {
                        const q = allQuests[id];
                        return `<option value="${escapeHtml(id)}" ${entry.questId === id ? 'selected' : ''}>${escapeHtml(q?.name || id)}</option>`;
                    }).join('')}
                </select>
                <input type="number" class="quest-pool-chance-input" min="1" max="100" value="${entry.chance || 50}" placeholder="%">
                <span class="encounter-percent-label">%</span>
                <button class="menu_button menu_button_icon quest-pool-remove-btn" title="Remove">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
        `;
    }).join('');

    // Add event handlers
    list.querySelectorAll('.mazemaster-quest-pool-row').forEach(row => {
        row.querySelector('.quest-pool-remove-btn')?.addEventListener('click', () => {
            row.remove();
        });
    });
}

/**
 * v2.1.0: Render avatar generation minion list in maze profile editor
 * Shows all minions used in the profile with checkboxes for avatar generation
 */
function renderAvatarMinionList(profileName) {
    const list = document.getElementById('mazemaster_avatar_minion_list');
    if (!list) return;

    const profile = getMazeProfile(profileName);
    if (!profile) {
        list.innerHTML = '<div class="mazemaster-empty-state" style="font-size: 0.85em;">No profile selected.</div>';
        return;
    }

    // Collect all minions used in this profile
    const minionIds = new Set();

    // Add main minion
    if (profile.mainMinion) {
        minionIds.add(profile.mainMinion);
    }

    // Add minions from encounters
    if (profile.minionEncounters) {
        profile.minionEncounters.forEach(enc => {
            if (enc.minionId) minionIds.add(enc.minionId);
        });
    }

    if (minionIds.size === 0) {
        list.innerHTML = '<div class="mazemaster-empty-state" style="font-size: 0.85em;">No minions in this profile. Add a main minion or encounters first.</div>';
        return;
    }

    // Get currently selected minions for avatar generation
    const selectedMinions = profile.avatarGenerationMinions || [];

    // Render minion list with checkboxes
    list.innerHTML = Array.from(minionIds).map(minionId => {
        const minion = getMinion(minionId);
        if (!minion) return '';

        const hasAvatar = !!minion.imagePath;
        const isSelected = selectedMinions.includes(minionId);
        const isMainMinion = minionId === profile.mainMinion;

        return `
            <div class="mazemaster-avatar-minion-row" data-minion-id="${escapeHtml(minionId)}">
                <label class="mazemaster-checkbox-label" style="display: flex; align-items: center; gap: 8px; margin: 4px 0;">
                    <input type="checkbox" class="avatar-gen-checkbox" ${isSelected ? 'checked' : ''} ${hasAvatar ? 'disabled' : ''}>
                    <span class="avatar-minion-name">${escapeHtml(minion.name)}${isMainMinion ? ' (Main)' : ''}</span>
                    ${hasAvatar
                        ? '<span class="avatar-status" style="color: var(--SmartThemeQuoteColor, #4caf50); font-size: 0.8em;"><i class="fa-solid fa-check-circle"></i> Has Avatar</span>'
                        : '<span class="avatar-status" style="color: var(--SmartThemeEmColor, #999); font-size: 0.8em;"><i class="fa-regular fa-image"></i> No Avatar</span>'
                    }
                </label>
            </div>
        `;
    }).join('');

    // Add event handlers for checkboxes
    list.querySelectorAll('.avatar-gen-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
            // Selections will be saved when Save Profile is clicked
        });
    });
}

/**
 * v2.1.0: Collect avatar generation minions from UI
 */
function collectAvatarMinionSelections() {
    const list = document.getElementById('mazemaster_avatar_minion_list');
    if (!list) return [];

    const selected = [];
    list.querySelectorAll('.mazemaster-avatar-minion-row').forEach(row => {
        const checkbox = row.querySelector('.avatar-gen-checkbox');
        const minionId = row.dataset.minionId;
        if (checkbox && checkbox.checked && minionId) {
            selected.push(minionId);
        }
    });

    return selected;
}

function collectMazeDataFromUI() {
    const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
    const existingProfile = getMazeProfile(profileName) || {};

    // Collect encounters from the list (now using percent)
    const encounterRows = document.querySelectorAll('#mazemaster_maze_encounters_list .mazemaster-encounter-row');
    const minionEncounters = [];
    encounterRows.forEach(row => {
        const minionId = row.querySelector('.encounter-minion-select')?.value;
        const percent = parseInt(row.querySelector('.encounter-percent-input')?.value) || 5;
        if (minionId) {
            minionEncounters.push({ minionId, percent });
        }
    });

    // Collect trap encounters from the list
    const trapEncounterRows = document.querySelectorAll('#mazemaster_maze_traps_list .mazemaster-trap-encounter-row');
    const trapEncounters = [];
    trapEncounterRows.forEach(row => {
        const trapId = row.querySelector('.trap-encounter-select')?.value;
        const percent = parseInt(row.querySelector('.trap-encounter-percent-input')?.value) || 5;
        if (trapId) {
            trapEncounters.push({ trapId, percent });
        }
    });

    // Collect quest pool from the list
    const questPoolRows = document.querySelectorAll('#mazemaster_maze_quests_list .mazemaster-quest-pool-row');
    const questPool = [];
    questPoolRows.forEach(row => {
        const questId = row.querySelector('.quest-pool-select')?.value;
        const chance = parseInt(row.querySelector('.quest-pool-chance-input')?.value) || 50;
        if (questId) {
            questPool.push({ questId, chance });
        }
    });

    // Collect random messages
    const randomMessagesText = document.getElementById('mazemaster_maze_random_messages')?.value || '';
    const mainMinionRandomMessages = randomMessagesText.split('\n').filter(m => m.trim());

    return {
        gridSize: parseInt(document.getElementById('mazemaster_maze_size')?.value) || 10,
        difficulty: document.getElementById('mazemaster_maze_difficulty')?.value || 'normal',
        theme: document.getElementById('mazemaster_maze_theme')?.value || 'fantasy',
        mapStyle: document.getElementById('mazemaster_maze_mapstyle')?.value || 'maze',
        floors: parseInt(document.getElementById('mazemaster_maze_floors')?.value) || 1,
        mapVisibility: document.querySelector('input[name="mazemaster_map_visibility"]:checked')?.value || 'fogOfWar',
        winCommand: document.getElementById('mazemaster_maze_win_cmd')?.value || '',
        loseCommand: document.getElementById('mazemaster_maze_lose_cmd')?.value || '',
        winMessage: document.getElementById('mazemaster_maze_win_message')?.value || '',
        winImage: existingProfile.winImage || '',
        chestImage: existingProfile.chestImage || '',
        // Main minion settings
        mainMinion: document.getElementById('mazemaster_maze_main_minion')?.value || '',
        mainMinionIntroMessage: document.getElementById('mazemaster_maze_intro_message')?.value || '',
        mainMinionRandomChance: parseInt(document.getElementById('mazemaster_maze_random_chance')?.value) || 15,
        mainMinionRandomMessages: mainMinionRandomMessages,
        mainMinionExitType: document.getElementById('mazemaster_maze_exit_type')?.value || 'messenger',
        mainMinionExitProfile: document.getElementById('mazemaster_maze_exit_profile')?.value || '',
        // Encounters (percent-based)
        minionEncounters: minionEncounters,
        trapEncounters: trapEncounters,
        questPool: questPool,
        // Loss behavior
        onBattlebarLoss: document.getElementById('mazemaster_maze_loss_action')?.value || 'continue',
        // Chest settings
        chestTilePercent: parseInt(document.getElementById('mazemaster_maze_chest_percent')?.value) || 10,
        chestLockedPercent: parseInt(document.getElementById('mazemaster_maze_locked_percent')?.value) || 30,
        chestLockedBonusPercent: parseInt(document.getElementById('mazemaster_maze_locked_bonus')?.value) || 50,
        chestMimicPercent: parseInt(document.getElementById('mazemaster_maze_mimic_percent')?.value) || 15,
        chestLootMin: parseInt(document.getElementById('mazemaster_maze_loot_min')?.value) || 1,
        chestLootMax: parseInt(document.getElementById('mazemaster_maze_loot_max')?.value) || 2,
        chestKeyChance: parseInt(document.getElementById('mazemaster_maze_chest_key')?.value) || 30,
        chestStrikeChance: parseInt(document.getElementById('mazemaster_maze_chest_pow')?.value) || 50,
        chestStealthChance: parseInt(document.getElementById('mazemaster_maze_chest_stealth')?.value) || 0,
        chestExecuteChance: parseInt(document.getElementById('mazemaster_maze_chest_execute')?.value) || 0,
        lockedChestKeyChance: parseInt(document.getElementById('mazemaster_maze_locked_key')?.value) || 40,
        lockedChestStrikeChance: parseInt(document.getElementById('mazemaster_maze_locked_pow')?.value) || 60,
        lockedChestStealthChance: parseInt(document.getElementById('mazemaster_maze_locked_stealth')?.value) || 30,
        lockedChestExecuteChance: parseInt(document.getElementById('mazemaster_maze_locked_execute')?.value) || 5,
        // Starting inventory - all 22 items
        startingInventory: {
            // Keys
            key: parseInt(document.getElementById('mazemaster_start_key')?.value) || 0,
            floorKey: parseInt(document.getElementById('mazemaster_start_floorKey')?.value) || 0,
            // Combat items
            strike: parseInt(document.getElementById('mazemaster_start_strike')?.value) || 0,
            stealth: parseInt(document.getElementById('mazemaster_start_stealth')?.value) || 0,
            execute: parseInt(document.getElementById('mazemaster_start_execute')?.value) || 0,
            minionBane: parseInt(document.getElementById('mazemaster_start_minionBane')?.value) || 0,
            // Exploration items
            portalStone: parseInt(document.getElementById('mazemaster_start_portalStone')?.value) || 0,
            mapFragment: parseInt(document.getElementById('mazemaster_start_mapFragment')?.value) || 0,
            voidWalk: parseInt(document.getElementById('mazemaster_start_voidWalk')?.value) || 0,
            timeShard: parseInt(document.getElementById('mazemaster_start_timeShard')?.value) || 0,
            // HP items
            healingPotion: parseInt(document.getElementById('mazemaster_start_healingPotion')?.value) || 0,
            greaterHealing: parseInt(document.getElementById('mazemaster_start_greaterHealing')?.value) || 0,
            elixir: parseInt(document.getElementById('mazemaster_start_elixir')?.value) || 0,
            revivalCharm: parseInt(document.getElementById('mazemaster_start_revivalCharm')?.value) || 0,
            heartCrystal: parseInt(document.getElementById('mazemaster_start_heartCrystal')?.value) || 0,
            // Vision items
            torch: parseInt(document.getElementById('mazemaster_start_torch')?.value) || 0,
            lantern: parseInt(document.getElementById('mazemaster_start_lantern')?.value) || 0,
            revealScroll: parseInt(document.getElementById('mazemaster_start_revealScroll')?.value) || 0,
            sightPotion: parseInt(document.getElementById('mazemaster_start_sightPotion')?.value) || 0,
            crystalBall: parseInt(document.getElementById('mazemaster_start_crystalBall')?.value) || 0,
            // Equipment - Weapons
            weapon_rusty_sword: parseInt(document.getElementById('mazemaster_start_weapon_rusty_sword')?.value) || 0,
            weapon_iron_sword: parseInt(document.getElementById('mazemaster_start_weapon_iron_sword')?.value) || 0,
            weapon_steel_blade: parseInt(document.getElementById('mazemaster_start_weapon_steel_blade')?.value) || 0,
            weapon_enchanted_blade: parseInt(document.getElementById('mazemaster_start_weapon_enchanted_blade')?.value) || 0,
            weapon_shadow_dagger: parseInt(document.getElementById('mazemaster_start_weapon_shadow_dagger')?.value) || 0,
            // Equipment - Armor
            armor_leather: parseInt(document.getElementById('mazemaster_start_armor_leather')?.value) || 0,
            armor_chainmail: parseInt(document.getElementById('mazemaster_start_armor_chainmail')?.value) || 0,
            armor_plate: parseInt(document.getElementById('mazemaster_start_armor_plate')?.value) || 0,
            ironGuard: parseInt(document.getElementById('mazemaster_start_ironGuard')?.value) || 0,
            // Equipment - Accessories
            accessory_ring_power: parseInt(document.getElementById('mazemaster_start_accessory_ring_power')?.value) || 0,
            accessory_amulet_protection: parseInt(document.getElementById('mazemaster_start_accessory_amulet_protection')?.value) || 0,
            accessory_lucky_charm: parseInt(document.getElementById('mazemaster_start_accessory_lucky_charm')?.value) || 0,
            accessory_vampiric_pendant: parseInt(document.getElementById('mazemaster_start_accessory_vampiric_pendant')?.value) || 0,
        },
        // HP System settings
        hpEnabled: document.getElementById('mazemaster_hp_enabled')?.checked !== false,
        maxHP: parseInt(document.getElementById('mazemaster_hp_max')?.value) || 100,
        battlebarDamageMultiplier: parseFloat(document.getElementById('mazemaster_hp_battlebar_mult')?.value) || 1.0,
        battlebarDifficultyMultiplier: parseFloat(document.getElementById('mazemaster_hp_battlebar_diff')?.value) || 1.0,
        respawnHPPercent: parseInt(document.getElementById('mazemaster_hp_respawn')?.value) || 50,
        onDeath: document.getElementById('mazemaster_hp_ondeath')?.value || 'respawn',
        // Safe room settings
        safeRoomCount: parseInt(document.getElementById('mazemaster_saferoom_count')?.value) ?? 3,
        safeRoomHealPercent: parseInt(document.getElementById('mazemaster_saferoom_heal')?.value) ?? 100,
        safeRoomUseLLM: document.getElementById('mazemaster_saferoom_llm')?.checked || false,
        // LLM Enhancement settings
        llmEnhanceRooms: document.getElementById('mazemaster_llm_enhance_rooms')?.checked !== false,
        llmMaxTokens: parseInt(document.getElementById('mazemaster_llm_max_tokens')?.value) || 250,
        // Rest mechanic settings
        restEnabled: document.getElementById('mazemaster_rest_enabled')?.checked !== false,
        restHealPercent: parseInt(document.getElementById('mazemaster_rest_heal')?.value) ?? 20,
        restCooldown: parseInt(document.getElementById('mazemaster_rest_cooldown')?.value) ?? 3,
        restInterruptChance: parseInt(document.getElementById('mazemaster_rest_interrupt')?.value) ?? 0,
        restInterruptScript: document.getElementById('mazemaster_rest_interrupt_script')?.value || '',
        // Portals
        portals: collectPortalsFromUI(),
        // v1.4.0 BSP Configuration
        bspConfig: {
            zoneCount: parseInt(document.getElementById('mazemaster_bsp_zone_count')?.value) || 1,
            secretDensity: parseFloat(document.getElementById('mazemaster_bsp_secret_density')?.value) || 0,
            zonesRequireClear: document.getElementById('mazemaster_bsp_zones_require_clear')?.checked !== false,
            secretHints: document.getElementById('mazemaster_bsp_secret_hints')?.checked !== false,
            floorComplexityScaling: document.getElementById('mazemaster_bsp_floor_scaling')?.checked !== false,
        },
        // Objectives
        objectives: collectObjectivesFromUI(),
        // STScript Hooks
        onMove: document.getElementById('mazemaster_hook_onMove')?.value || '',
        onMilestone: document.getElementById('mazemaster_hook_onMilestone')?.value || '',
        onExploreComplete: document.getElementById('mazemaster_hook_onExploreComplete')?.value || '',
        onItemAdd: document.getElementById('mazemaster_hook_onItemAdd')?.value || '',
        onItemRemove: document.getElementById('mazemaster_hook_onItemRemove')?.value || '',
        onChestOpen: document.getElementById('mazemaster_hook_onChestOpen')?.value || '',
        onTrade: document.getElementById('mazemaster_hook_onTrade')?.value || '',
        onEnemyMove: document.getElementById('mazemaster_hook_onEnemyMove')?.value || '',
        onTeleport: document.getElementById('mazemaster_hook_onTeleport')?.value || '',
        onObjectiveProgress: document.getElementById('mazemaster_hook_onObjectiveProgress')?.value || '',
        onObjectiveComplete: document.getElementById('mazemaster_hook_onObjectiveComplete')?.value || '',
        onAllObjectivesComplete: document.getElementById('mazemaster_hook_onAllObjectivesComplete')?.value || '',
        onStatUpdate: document.getElementById('mazemaster_hook_onStatUpdate')?.value || '',
        // Preserve story config
        storyConfig: existingProfile.storyConfig || { mainStory: '', milestones: [] },
        // Find Early items (v1.3.2)
        findEarly: collectFindEarlyFromUI(),
        // v1.8.0: Item Pool restrictions
        itemPool: collectItemPoolFromUI(),
        // v2.1.0: Avatar generation minions
        avatarGenerationMinions: collectAvatarMinionSelections(),
    };
}

/**
 * Collect Find Early configuration from UI checkboxes
 * v1.9.0: Refactored to dynamically collect from all item profiles
 */
function collectFindEarlyFromUI() {
    const radius = parseInt(document.getElementById('mazemaster_findearly_radius')?.value) || 4;
    const itemsPerChest = parseInt(document.getElementById('mazemaster_findearly_perchest')?.value) || 1;

    // Dynamically collect checked items from all item profiles
    const items = [];
    const allItemIds = getItemProfileIds();

    for (const itemId of allItemIds) {
        const checkbox = document.getElementById(`mazemaster_findearly_${itemId}`);
        if (checkbox?.checked) {
            items.push(itemId);
        }
    }

    // Only return findEarly config if items are selected
    if (items.length === 0) {
        return null;
    }

    return { radius, items, itemsPerChest };
}

/**
 * Collect Item Pool configuration from UI checkboxes (v1.8.0)
 * @returns {Object|null} Item pool config or null if disabled
 */
function collectItemPoolFromUI() {
    const enabled = document.getElementById('mazemaster_itempool_enabled')?.checked || false;

    // Collect checked items from data-pool-item attributes
    const items = [];
    document.querySelectorAll('#mazemaster_itempool_items input[data-pool-item]:checked').forEach(cb => {
        items.push(cb.dataset.poolItem);
    });

    // Return pool config (always include even if disabled for schema consistency)
    return {
        enabled: enabled,
        items: items,
    };
}

/**
 * Collect portal configuration from the UI
 */
function collectPortalsFromUI() {
    const portals = [];
    const portalItems = document.querySelectorAll('#mazemaster_portals_list .mazemaster-portal-item');

    portalItems.forEach((item) => {
        const id = item.querySelector('.portal-id')?.value?.trim() || '';
        const color = item.querySelector('.portal-color-input')?.value || '#9b59b6';
        const bidirectional = item.querySelector('.portal-bidirectional')?.checked ?? true;

        const startXInput = item.querySelector('.portal-start-x')?.value;
        const startYInput = item.querySelector('.portal-start-y')?.value;
        const endXInput = item.querySelector('.portal-end-x')?.value;
        const endYInput = item.querySelector('.portal-end-y')?.value;

        portals.push({
            id: id || `portal_${portals.length + 1}`,
            color: color,
            bidirectional: bidirectional,
            startX: startXInput !== '' ? parseInt(startXInput) : null,
            startY: startYInput !== '' ? parseInt(startYInput) : null,
            endX: endXInput !== '' ? parseInt(endXInput) : null,
            endY: endYInput !== '' ? parseInt(endYInput) : null,
        });
    });

    return portals;
}

/**
 * Collect objectives configuration from the UI
 */
function collectObjectivesFromUI() {
    const objectives = [];
    const objectiveItems = document.querySelectorAll('#mazemaster_objectives_list .mazemaster-objective-item');

    objectiveItems.forEach((item, idx) => {
        const id = item.querySelector('.objective-id')?.value?.trim() || `obj_${idx + 1}`;
        const type = item.querySelector('.objective-type')?.value || 'collect';
        const target = item.querySelector('.objective-target')?.value?.trim() || '';
        const count = parseInt(item.querySelector('.objective-count')?.value) || 1;
        const description = item.querySelector('.objective-description')?.value?.trim() || '';
        const required = item.querySelector('.objective-required')?.checked ?? true;
        const reward = item.querySelector('.objective-reward')?.value?.trim() || '';

        objectives.push({
            id,
            type,
            target: type === 'explore' ? null : target,
            count,
            description: description || `${type === 'collect' ? 'Collect' : type === 'defeat' ? 'Defeat' : 'Explore'} ${count}${type === 'explore' ? '%' : ' ' + target}`,
            required,
            reward,
        });
    });

    return objectives;
}

/**
 * Crop an image file to a square (center crop)
 * @param {File} file - The image file to crop
 * @returns {Promise<Blob>} - The cropped image as a Blob
 */
async function cropToSquare(file) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);

        img.onload = () => {
            URL.revokeObjectURL(url);

            const size = Math.min(img.width, img.height);
            const offsetX = (img.width - size) / 2;
            const offsetY = (img.height - size) / 2;

            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;

            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, offsetX, offsetY, size, size, 0, 0, size, size);

            canvas.toBlob((blob) => {
                if (blob) {
                    resolve(blob);
                } else {
                    reject(new Error('Failed to create cropped image'));
                }
            }, file.type || 'image/png');
        };

        img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error('Failed to load image'));
        };

        img.src = url;
    });
}

async function uploadImage(file, filenamePrefix) {
    // First crop the image to square
    let imageBlob;
    try {
        imageBlob = await cropToSquare(file);
    } catch (err) {
        console.warn('[MazeMaster] Could not crop image, using original:', err);
        imageBlob = file;
    }

    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const base64 = e.target.result.split(',')[1];
                const ext = file.name.split('.').pop().toLowerCase();
                const timestamp = Date.now();
                const filename = `${filenamePrefix}_${timestamp}`;

                const response = await fetch('/api/images/upload', {
                    method: 'POST',
                    headers: getRequestHeaders(),
                    body: JSON.stringify({
                        image: base64,
                        ch_name: 'MazeMaster',
                        filename: filename,
                        format: ext,
                    }),
                });

                if (response.ok) {
                    resolve(`user/images/MazeMaster/${filename}.${ext}`);
                } else {
                    const error = await response.json().catch(() => ({}));
                    reject(new Error(error.error || 'Upload failed'));
                }
            } catch (err) {
                reject(err);
            }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(imageBlob);
    });
}

// =============================================================================
// MINIONS UI HELPERS
// =============================================================================

function renderMinionsList() {
    const list = document.getElementById('mazemaster_minions_list');
    if (!list) return;

    // Get selected minion profile to filter the list
    const profileSelect = document.getElementById('mazemaster_minion_profile_select');
    const selectedProfile = profileSelect?.value || '';

    let minionIds = getMinionNames();

    // Filter by selected profile if one is selected
    if (selectedProfile && extensionSettings.minionProfiles?.[selectedProfile]) {
        const profile = extensionSettings.minionProfiles[selectedProfile];
        // Check if it's the new format (array of minion IDs) or old format (full minion objects)
        if (Array.isArray(profile.minions)) {
            // New format: { minions: ['id1', 'id2'] }
            minionIds = minionIds.filter(id => profile.minions.includes(id));
        } else if (typeof profile === 'object' && !profile.minions) {
            // Old format: { 'fantasy_herald': {...}, 'fantasy_guardian': {...} }
            const profileMinions = Object.keys(profile);
            minionIds = minionIds.filter(id => profileMinions.includes(id));
        }
    }

    if (minionIds.length === 0) {
        const message = selectedProfile
            ? `No minions in profile "${selectedProfile}". Select a different profile or add minions.`
            : 'No minions. Add minions for use in the maze game.';
        list.innerHTML = `<div class="mazemaster-empty-state">${message}</div>`;
        return;
    }

    // Get available profiles for dropdowns
    const battlebarProfileNames = getBattlebarProfileNames();
    const wheelProfileNames = getProfileNames();
    const turnbasedProfileNames = getTurnbasedProfileNames();
    const qteProfileNames = getQteProfileNames();
    const diceProfileNames = getDiceProfileNames();
    const stealthProfileNames = getStealthProfileNames();
    const puzzleProfileNames = getPuzzleProfileNames();
    const negotiationProfileNames = getNegotiationProfileNames();

    list.innerHTML = minionIds.map(id => {
        const minion = getMinion(id);
        if (!minion) {
            console.warn(`[MazeMaster] Minion "${id}" not found, skipping`);
            return '';
        }
        const minionType = minion.type || 'messenger';
        const battlebarProfiles = minion.battlebarProfiles || [];
        const wheelProfiles = minion.wheelProfiles || [];
        const turnbasedProfiles = minion.turnbasedProfiles || [];
        const qteProfiles = minion.qteProfiles || [];
        const diceProfiles = minion.diceProfiles || [];
        const stealthProfiles = minion.stealthProfiles || [];
        const puzzleProfiles = minion.puzzleProfiles || [];
        const negotiationProfiles = minion.negotiationProfiles || [];
        const messages = minion.messages || [];
        const encounterScript = minion.encounterScript || '';
        const merchantItemCount = minion.merchantItemCount || { min: 1, max: 3 };
        const merchantItemPool = minion.merchantItemPool || 'Common Goods';
        const merchantPoolNames = Object.keys(extensionSettings.merchantItemPools || DEFAULT_MERCHANT_ITEM_POOLS);
        const movement = minion.movement || { type: 'stationary', patrolRadius: 3, chaseRange: 5, speed: 1 };

        return `
            <div class="mazemaster-minion-card" data-id="${escapeHtml(id)}">
                <div class="minion-image">
                    ${minion.imagePath ? `<img src="${escapeHtml(getExtensionImagePath(minion.imagePath))}" alt="${escapeHtml(minion.name)}">` : ''}
                </div>
                <div class="minion-info">
                    <div class="minion-row">
                        <input type="text" class="minion-name-input" value="${escapeHtml(minion.name)}" placeholder="Minion name">
                        <select class="minion-type-select">
                            <option value="messenger" ${minionType === 'messenger' ? 'selected' : ''}>Messenger</option>
                            <option value="battlebar" ${minionType === 'battlebar' ? 'selected' : ''}>Battlebar</option>
                            <option value="prizewheel" ${minionType === 'prizewheel' ? 'selected' : ''}>PrizeWheel</option>
                            <option value="merchant" ${minionType === 'merchant' ? 'selected' : ''}>Merchant</option>
                            <option value="turnbased" ${minionType === 'turnbased' ? 'selected' : ''}>Turn-Based Combat</option>
                            <option value="qte" ${minionType === 'qte' ? 'selected' : ''}>QTE Combat</option>
                            <option value="dice" ${minionType === 'dice' ? 'selected' : ''}>Dice Combat</option>
                            <option value="stealth" ${minionType === 'stealth' ? 'selected' : ''}>Stealth</option>
                            <option value="puzzle" ${minionType === 'puzzle' ? 'selected' : ''}>Puzzle</option>
                            <option value="negotiation" ${minionType === 'negotiation' ? 'selected' : ''}>Negotiation</option>
                        </select>
                    </div>
                    <div class="minion-profiles battlebar-profiles" style="display: ${minionType === 'battlebar' ? 'block' : 'none'};">
                        <label>Battlebar Profiles:</label>
                        <select multiple class="minion-battlebar-select">
                            ${battlebarProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${battlebarProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles wheel-profiles" style="display: ${minionType === 'prizewheel' ? 'block' : 'none'};">
                        <label>Wheel Profiles:</label>
                        <select multiple class="minion-wheel-select">
                            ${wheelProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${wheelProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles messenger-messages" style="display: ${minionType === 'messenger' ? 'block' : 'none'};">
                        <label>Messages (one per line):</label>
                        <textarea class="minion-messages-input" rows="2" placeholder="Hello traveler!&#10;Beware the maze...">${escapeHtml(messages.join('\n'))}</textarea>
                    </div>
                    <div class="minion-profiles merchant-settings" style="display: ${minionType === 'merchant' ? 'block' : 'none'};">
                        <label>Item Pool:</label>
                        <select class="merchant-pool-select">
                            ${merchantPoolNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${merchantItemPool === name ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                        <label>Items Offered (random range):</label>
                        <div class="merchant-range-row">
                            <input type="number" class="merchant-min-input mazemaster-input-small" min="1" max="10" value="${merchantItemCount.min}">
                            <span>to</span>
                            <input type="number" class="merchant-max-input mazemaster-input-small" min="1" max="10" value="${merchantItemCount.max}">
                            <span>items</span>
                        </div>
                    </div>
                    <div class="minion-profiles turnbased-profiles" style="display: ${minionType === 'turnbased' ? 'block' : 'none'};">
                        <label>Turn-Based Profiles:</label>
                        <select multiple class="minion-turnbased-select">
                            ${turnbasedProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${turnbasedProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles qte-profiles" style="display: ${minionType === 'qte' ? 'block' : 'none'};">
                        <label>QTE Profiles:</label>
                        <select multiple class="minion-qte-select">
                            ${qteProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${qteProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles dice-profiles" style="display: ${minionType === 'dice' ? 'block' : 'none'};">
                        <label>Dice Profiles:</label>
                        <select multiple class="minion-dice-select">
                            ${diceProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${diceProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles stealth-profiles" style="display: ${minionType === 'stealth' ? 'block' : 'none'};">
                        <label>Stealth Profiles:</label>
                        <select multiple class="minion-stealth-select">
                            ${stealthProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${stealthProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles puzzle-profiles" style="display: ${minionType === 'puzzle' ? 'block' : 'none'};">
                        <label>Puzzle Profiles:</label>
                        <select multiple class="minion-puzzle-select">
                            ${puzzleProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${puzzleProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles negotiation-profiles" style="display: ${minionType === 'negotiation' ? 'block' : 'none'};">
                        <label>Negotiation Profiles:</label>
                        <select multiple class="minion-negotiation-select">
                            ${negotiationProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${negotiationProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-encounter-script">
                        <label>Encounter Script (STScript):</label>
                        <textarea class="minion-script-input" rows="2" placeholder="/echo Custom action on encounter...">${escapeHtml(encounterScript)}</textarea>
                    </div>
                    <div class="minion-movement-settings">
                        <label>Maze Movement:</label>
                        <div class="movement-row">
                            <select class="minion-movement-type">
                                <option value="stationary" ${movement.type === 'stationary' ? 'selected' : ''}>Stationary</option>
                                <option value="patrol" ${movement.type === 'patrol' ? 'selected' : ''}>Patrol</option>
                                <option value="chase" ${movement.type === 'chase' ? 'selected' : ''}>Chase Player</option>
                            </select>
                        </div>
                        <div class="movement-params" style="display: ${movement.type !== 'stationary' ? 'flex' : 'none'};">
                            <div class="movement-param patrol-param" style="display: ${movement.type === 'patrol' ? 'flex' : 'none'};">
                                <span>Radius:</span>
                                <input type="number" class="minion-patrol-radius mazemaster-input-small" min="1" max="10" value="${movement.patrolRadius || 3}">
                            </div>
                            <div class="movement-param chase-param" style="display: ${movement.type === 'chase' ? 'flex' : 'none'};">
                                <span>Range:</span>
                                <input type="number" class="minion-chase-range mazemaster-input-small" min="1" max="20" value="${movement.chaseRange || 5}">
                            </div>
                            <div class="movement-param">
                                <span>Speed:</span>
                                <input type="number" class="minion-movement-speed mazemaster-input-small" min="1" max="5" value="${movement.speed || 1}" title="Moves every N player moves">
                            </div>
                        </div>
                        <div class="enhanced-ai-settings" style="margin-top: 8px; display: ${movement.type !== 'stationary' ? 'block' : 'none'};">
                            <label style="font-size: 0.85em; color: #888; margin-bottom: 4px;">Enhanced AI (v1.5.0):</label>
                            <div class="enhanced-ai-toggles" style="display: flex; flex-wrap: wrap; gap: 8px;">
                                <label class="checkbox-inline" style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                    <input type="checkbox" class="minion-enhanced-ai" ${movement.enhancedAI !== false ? 'checked' : ''}>
                                    <span>Enhanced AI</span>
                                </label>
                                <label class="checkbox-inline" style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                    <input type="checkbox" class="minion-pathfinding" ${movement.usePathfinding !== false ? 'checked' : ''}>
                                    <span>A* Pathfinding</span>
                                </label>
                                <label class="checkbox-inline" style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                    <input type="checkbox" class="minion-alert-pack" ${movement.alertPack !== false ? 'checked' : ''}>
                                    <span>Alert Pack</span>
                                </label>
                            </div>
                            <div class="enhanced-ai-params" style="display: flex; gap: 8px; margin-top: 4px;">
                                <div class="movement-param">
                                    <span>Detection:</span>
                                    <input type="number" class="minion-detection-range mazemaster-input-small" min="1" max="10" value="${movement.detectionRange || 3}" title="Detection range in tiles">
                                </div>
                                <div class="movement-param">
                                    <span>Chase Timeout:</span>
                                    <input type="number" class="minion-chase-timeout mazemaster-input-small" min="1" max="20" value="${movement.chaseDuration || 10}" title="Turns before giving up chase">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <button class="menu_button menu_button_icon minion-delete-btn" title="Delete Minion">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
        `;
    }).join('');

    // Add event handlers
    list.querySelectorAll('.mazemaster-minion-card').forEach(card => {
        const minionId = card.dataset.id;

        // Name input change
        const nameInput = card.querySelector('.minion-name-input');
        if (nameInput) {
            nameInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.name = nameInput.value.trim() || 'Unknown';
                    saveMinion(minionId, minion);
                }
            });
        }

        // Type select change
        const typeSelect = card.querySelector('.minion-type-select');
        if (typeSelect) {
            typeSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.type = typeSelect.value;
                    saveMinion(minionId, minion);

                    // Toggle visibility of profile sections based on type
                    const sections = {
                        battlebar: card.querySelector('.battlebar-profiles'),
                        prizewheel: card.querySelector('.wheel-profiles'),
                        messenger: card.querySelector('.messenger-messages'),
                        merchant: card.querySelector('.merchant-settings'),
                        turnbased: card.querySelector('.turnbased-profiles'),
                        qte: card.querySelector('.qte-profiles'),
                        dice: card.querySelector('.dice-profiles'),
                        stealth: card.querySelector('.stealth-profiles'),
                        puzzle: card.querySelector('.puzzle-profiles'),
                        negotiation: card.querySelector('.negotiation-profiles'),
                    };

                    for (const [type, section] of Object.entries(sections)) {
                        if (section) section.style.display = minion.type === type ? 'block' : 'none';
                    }
                }
            });
        }

        // Battlebar profiles select
        const battlebarSelect = card.querySelector('.minion-battlebar-select');
        if (battlebarSelect) {
            battlebarSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.battlebarProfiles = Array.from(battlebarSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Wheel profiles select
        const wheelSelect = card.querySelector('.minion-wheel-select');
        if (wheelSelect) {
            wheelSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.wheelProfiles = Array.from(wheelSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Turn-based profiles select
        const turnbasedSelect = card.querySelector('.minion-turnbased-select');
        if (turnbasedSelect) {
            turnbasedSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.turnbasedProfiles = Array.from(turnbasedSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // QTE profiles select
        const qteSelect = card.querySelector('.minion-qte-select');
        if (qteSelect) {
            qteSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.qteProfiles = Array.from(qteSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Dice profiles select
        const diceSelect = card.querySelector('.minion-dice-select');
        if (diceSelect) {
            diceSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.diceProfiles = Array.from(diceSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Stealth profiles select
        const stealthSelect = card.querySelector('.minion-stealth-select');
        if (stealthSelect) {
            stealthSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.stealthProfiles = Array.from(stealthSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Puzzle profiles select
        const puzzleSelect = card.querySelector('.minion-puzzle-select');
        if (puzzleSelect) {
            puzzleSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.puzzleProfiles = Array.from(puzzleSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Negotiation profiles select
        const negotiationSelect = card.querySelector('.minion-negotiation-select');
        if (negotiationSelect) {
            negotiationSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.negotiationProfiles = Array.from(negotiationSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Messenger messages textarea
        const messagesInput = card.querySelector('.minion-messages-input');
        if (messagesInput) {
            messagesInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.messages = messagesInput.value.split('\n').filter(m => m.trim());
                    saveMinion(minionId, minion);
                }
            });
        }

        // Merchant settings
        const merchantPoolSelect = card.querySelector('.merchant-pool-select');
        const merchantMinInput = card.querySelector('.merchant-min-input');
        const merchantMaxInput = card.querySelector('.merchant-max-input');
        if (merchantPoolSelect) {
            merchantPoolSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.merchantItemPool = merchantPoolSelect.value;
                    saveMinion(minionId, minion);
                }
            });
        }
        if (merchantMinInput) {
            merchantMinInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.merchantItemCount = minion.merchantItemCount || { min: 1, max: 3 };
                    minion.merchantItemCount.min = parseInt(merchantMinInput.value) || 1;
                    saveMinion(minionId, minion);
                }
            });
        }
        if (merchantMaxInput) {
            merchantMaxInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.merchantItemCount = minion.merchantItemCount || { min: 1, max: 3 };
                    minion.merchantItemCount.max = parseInt(merchantMaxInput.value) || 3;
                    saveMinion(minionId, minion);
                }
            });
        }

        // Encounter script textarea
        const scriptInput = card.querySelector('.minion-script-input');
        if (scriptInput) {
            scriptInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.encounterScript = scriptInput.value;
                    saveMinion(minionId, minion);
                }
            });
        }

        // Movement settings
        const movementTypeSelect = card.querySelector('.minion-movement-type');
        const movementParams = card.querySelector('.movement-params');
        const patrolParams = card.querySelector('.patrol-param');
        const chaseParams = card.querySelector('.chase-param');
        const patrolRadiusInput = card.querySelector('.minion-patrol-radius');
        const chaseRangeInput = card.querySelector('.minion-chase-range');
        const movementSpeedInput = card.querySelector('.minion-movement-speed');

        const enhancedAISettings = card.querySelector('.enhanced-ai-settings');

        if (movementTypeSelect) {
            movementTypeSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || { type: 'stationary', patrolRadius: 3, chaseRange: 5, speed: 1 };
                    minion.movement.type = movementTypeSelect.value;
                    saveMinion(minionId, minion);

                    // Show/hide params based on type
                    if (movementParams) {
                        movementParams.style.display = movementTypeSelect.value !== 'stationary' ? 'flex' : 'none';
                    }
                    if (patrolParams) {
                        patrolParams.style.display = movementTypeSelect.value === 'patrol' ? 'flex' : 'none';
                    }
                    if (chaseParams) {
                        chaseParams.style.display = movementTypeSelect.value === 'chase' ? 'flex' : 'none';
                    }
                    // v1.5.0: Show/hide enhanced AI settings
                    if (enhancedAISettings) {
                        enhancedAISettings.style.display = movementTypeSelect.value !== 'stationary' ? 'block' : 'none';
                    }
                }
            });
        }

        if (patrolRadiusInput) {
            patrolRadiusInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || { type: 'patrol', patrolRadius: 3, chaseRange: 5, speed: 1 };
                    minion.movement.patrolRadius = parseInt(patrolRadiusInput.value) || 3;
                    saveMinion(minionId, minion);
                }
            });
        }

        if (chaseRangeInput) {
            chaseRangeInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || { type: 'chase', patrolRadius: 3, chaseRange: 5, speed: 1 };
                    minion.movement.chaseRange = parseInt(chaseRangeInput.value) || 5;
                    saveMinion(minionId, minion);
                }
            });
        }

        if (movementSpeedInput) {
            movementSpeedInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || { type: 'stationary', patrolRadius: 3, chaseRange: 5, speed: 1 };
                    minion.movement.speed = parseInt(movementSpeedInput.value) || 1;
                    saveMinion(minionId, minion);
                }
            });
        }

        // v1.5.0: Enhanced AI settings handlers
        const enhancedAICheckbox = card.querySelector('.minion-enhanced-ai');
        const pathfindingCheckbox = card.querySelector('.minion-pathfinding');
        const alertPackCheckbox = card.querySelector('.minion-alert-pack');
        const detectionRangeInput = card.querySelector('.minion-detection-range');
        const chaseTimeoutInput = card.querySelector('.minion-chase-timeout');

        if (enhancedAICheckbox) {
            enhancedAICheckbox.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || {};
                    minion.movement.enhancedAI = enhancedAICheckbox.checked;
                    saveMinion(minionId, minion);
                }
            });
        }

        if (pathfindingCheckbox) {
            pathfindingCheckbox.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || {};
                    minion.movement.usePathfinding = pathfindingCheckbox.checked;
                    saveMinion(minionId, minion);
                }
            });
        }

        if (alertPackCheckbox) {
            alertPackCheckbox.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || {};
                    minion.movement.alertPack = alertPackCheckbox.checked;
                    saveMinion(minionId, minion);
                }
            });
        }

        if (detectionRangeInput) {
            detectionRangeInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || {};
                    minion.movement.detectionRange = parseInt(detectionRangeInput.value) || 3;
                    saveMinion(minionId, minion);
                }
            });
        }

        if (chaseTimeoutInput) {
            chaseTimeoutInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || {};
                    minion.movement.chaseDuration = parseInt(chaseTimeoutInput.value) || 10;
                    saveMinion(minionId, minion);
                }
            });
        }

        // Minion image click-to-edit
        const minionImageDiv = card.querySelector('.minion-image');
        if (minionImageDiv) {
            minionImageDiv.style.cursor = 'pointer';
            minionImageDiv.title = 'Click to change image';
            minionImageDiv.addEventListener('click', () => {
                // Create a temporary file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.style.display = 'none';
                document.body.appendChild(fileInput);

                fileInput.addEventListener('change', async (e) => {
                    const file = e.target.files?.[0];
                    if (!file) {
                        document.body.removeChild(fileInput);
                        return;
                    }

                    try {
                        const imagePath = await uploadImage(file, minionId);
                        const minion = getMinion(minionId);
                        if (minion) {
                            minion.imagePath = imagePath;
                            saveMinion(minionId, minion);
                            renderMinionsList();
                        }
                    } catch (err) {
                        console.error('[MazeMaster] Image upload failed:', err);
                        alert(`Image upload failed: ${err.message}`);
                    }

                    document.body.removeChild(fileInput);
                });

                fileInput.click();
            });
        }

        // Delete button
        const deleteBtn = card.querySelector('.minion-delete-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', async () => {
                const minion = getMinion(minionId);
                const confirmed = await callGenericPopup(`Delete minion "${minion?.name || minionId}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteMinion(minionId);
                    renderMinionsList();
                }
            });
        }
    });
}

function renderTrapsList() {
    const list = document.getElementById('mazemaster_traps_list');
    if (!list) return;

    const trapIds = getTrapNames();

    if (trapIds.length === 0) {
        list.innerHTML = '<div class="mazemaster-empty-state">No traps. Add traps for use in maze profiles.</div>';
        return;
    }

    list.innerHTML = trapIds.map(id => {
        const trap = getTrap(id);
        const avoidChance = trap.avoidChance ?? 0;
        return `
            <div class="mazemaster-trap-card" data-id="${escapeHtml(id)}">
                <div class="trap-image">
                    ${trap.imagePath ? `<img src="${escapeHtml(getExtensionImagePath(trap.imagePath))}" alt="${escapeHtml(trap.name)}">` : '<div class="trap-no-image"><i class="fa-solid fa-dungeon"></i></div>'}
                </div>
                <div class="trap-info">
                    <div class="trap-row">
                        <input type="text" class="trap-name-input mazemaster-input" value="${escapeHtml(trap.name)}" placeholder="Trap name">
                    </div>
                    <div class="trap-message-row">
                        <label>Message:</label>
                        <textarea class="trap-message-input" rows="2" placeholder="You triggered a trap!">${escapeHtml(trap.message || '')}</textarea>
                    </div>
                    <div class="trap-script-row">
                        <label>Script (STScript):</label>
                        <textarea class="trap-script-input" rows="2" placeholder="/echo Trap triggered! | /mazedamage 25">${escapeHtml(trap.script || '')}</textarea>
                    </div>
                    <div class="trap-avoid-row" style="display: flex; gap: 8px; align-items: center; margin-top: 4px;">
                        <label style="white-space: nowrap;">Avoid %:</label>
                        <input type="number" class="trap-avoid-input mazemaster-input" value="${avoidChance}" min="0" max="100" style="width: 60px;">
                        <input type="text" class="trap-avoid-message-input mazemaster-input" value="${escapeHtml(trap.avoidMessage || '')}" placeholder="Message when avoided" style="flex: 1;">
                    </div>
                    <div class="trap-avoid-script-row" style="margin-top: 4px;">
                        <label>Avoid Script (STScript):</label>
                        <textarea class="trap-avoid-script-input" rows="1" placeholder="/echo {{user}} dodged the trap!">${escapeHtml(trap.avoidScript || '')}</textarea>
                    </div>
                </div>
                <button class="menu_button menu_button_icon trap-delete-btn" title="Delete Trap">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
        `;
    }).join('');

    // Add event handlers
    list.querySelectorAll('.mazemaster-trap-card').forEach(card => {
        const trapId = card.dataset.id;

        // Name input change
        const nameInput = card.querySelector('.trap-name-input');
        if (nameInput) {
            nameInput.addEventListener('change', () => {
                const trap = getTrap(trapId);
                if (trap) {
                    trap.name = nameInput.value.trim() || 'Unknown Trap';
                    saveTrap(trapId, trap);
                }
            });
        }

        // Message textarea change
        const messageInput = card.querySelector('.trap-message-input');
        if (messageInput) {
            messageInput.addEventListener('change', () => {
                const trap = getTrap(trapId);
                if (trap) {
                    trap.message = messageInput.value;
                    saveTrap(trapId, trap);
                }
            });
        }

        // Script textarea change
        const scriptInput = card.querySelector('.trap-script-input');
        if (scriptInput) {
            scriptInput.addEventListener('change', () => {
                const trap = getTrap(trapId);
                if (trap) {
                    trap.script = scriptInput.value;
                    saveTrap(trapId, trap);
                }
            });
        }

        // Avoid chance input change
        const avoidInput = card.querySelector('.trap-avoid-input');
        if (avoidInput) {
            avoidInput.addEventListener('change', () => {
                const trap = getTrap(trapId);
                if (trap) {
                    trap.avoidChance = Math.max(0, Math.min(100, parseInt(avoidInput.value) || 0));
                    saveTrap(trapId, trap);
                }
            });
        }

        // Avoid message input change
        const avoidMessageInput = card.querySelector('.trap-avoid-message-input');
        if (avoidMessageInput) {
            avoidMessageInput.addEventListener('change', () => {
                const trap = getTrap(trapId);
                if (trap) {
                    trap.avoidMessage = avoidMessageInput.value;
                    saveTrap(trapId, trap);
                }
            });
        }

        // Avoid script input change
        const avoidScriptInput = card.querySelector('.trap-avoid-script-input');
        if (avoidScriptInput) {
            avoidScriptInput.addEventListener('change', () => {
                const trap = getTrap(trapId);
                if (trap) {
                    trap.avoidScript = avoidScriptInput.value;
                    saveTrap(trapId, trap);
                }
            });
        }

        // Trap image click-to-edit
        const trapImageDiv = card.querySelector('.trap-image');
        if (trapImageDiv) {
            trapImageDiv.style.cursor = 'pointer';
            trapImageDiv.title = 'Click to change image';
            trapImageDiv.addEventListener('click', () => {
                // Create a temporary file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.style.display = 'none';
                document.body.appendChild(fileInput);

                fileInput.addEventListener('change', async (e) => {
                    const file = e.target.files?.[0];
                    if (!file) {
                        document.body.removeChild(fileInput);
                        return;
                    }

                    try {
                        const imagePath = await uploadImage(file, trapId);
                        const trap = getTrap(trapId);
                        if (trap) {
                            trap.imagePath = imagePath;
                            saveTrap(trapId, trap);
                            renderTrapsList();
                        }
                    } catch (err) {
                        console.error('[MazeMaster] Image upload failed:', err);
                        alert(`Image upload failed: ${err.message}`);
                    }

                    document.body.removeChild(fileInput);
                });

                fileInput.click();
            });
        }

        // Delete button
        const deleteBtn = card.querySelector('.trap-delete-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', async () => {
                const trap = getTrap(trapId);
                const confirmed = await callGenericPopup(`Delete trap "${trap?.name || trapId}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteTrap(trapId);
                    renderTrapsList();
                }
            });
        }
    });
}

function initUI(retryCount = 0) {
    console.log('[MazeMaster] initUI called (attempt ' + (retryCount + 1) + ')');

    // Check if drawer already exists (prevent duplicates)
    const existingDrawer = document.getElementById('mazemaster-button');
    if (existingDrawer) {
        console.log('[MazeMaster] Drawer already exists, skipping insertion');
        setupEventHandlers();
        renderSegmentsList();
        renderMinionsList();
        renderTrapsList();
        updateMazeSettings();
        if (extensionSettings.activeGameConfig === 'battlebar') {
            renderBattlebarImages();
        }
        return;
    }

    // Check if extensions button exists yet
    const extensionsButton = document.getElementById('extensions-settings-button');
    if (!extensionsButton) {
        if (retryCount < 10) {
            console.log('[MazeMaster] extensions-settings-button not found, retrying in 500ms...');
            setTimeout(() => initUI(retryCount + 1), 500);
            return;
        } else {
            console.error('[MazeMaster] extensions-settings-button NOT FOUND after 10 retries!');
            return;
        }
    }

    let panelHtml;
    try {
        panelHtml = getPanelHtml();
        console.log('[MazeMaster] getPanelHtml succeeded');
    } catch (e) {
        console.error('[MazeMaster] getPanelHtml FAILED:', e);
        panelHtml = '<div>Error loading panel</div>';
    }

    const drawerWrapper = document.createElement('div');
    drawerWrapper.id = 'mazemaster-button';
    drawerWrapper.className = 'drawer';
    drawerWrapper.innerHTML = `
        <div class="drawer-toggle drawer-header">
            <div class="drawer-icon fa-solid fa-dharmachakra fa-fw closedIcon" title="MazeMaster"></div>
        </div>
        <div id="mazemaster_drawer" class="drawer-content closedDrawer">
            ${panelHtml}
        </div>
    `;

    extensionsButton.after(drawerWrapper);
    console.log('[MazeMaster] Drawer inserted after extensions button');

    // Set up drawer toggle click handler directly (more reliable than copying from another drawer)
    const drawerToggle = drawerWrapper.querySelector('.drawer-toggle');
    if (drawerToggle && window.jQuery) {
        const $ = window.jQuery;
        $(drawerToggle).on('click', async function() {
            const icon = $(this).find('.drawer-icon');
            const drawer = $(this).parent().find('.drawer-content');
            const drawerWasOpenAlready = drawer.hasClass('openDrawer');

            if (!drawerWasOpenAlready) {
                // Close other open drawers (except pinned ones)
                $('.openDrawer:not(.pinnedOpen)').removeClass('openDrawer').addClass('closedDrawer');
                $('.openIcon:not(.drawerPinnedOpen)').removeClass('openIcon').addClass('closedIcon');
            }

            // Toggle this drawer
            icon.toggleClass('openIcon closedIcon');
            drawer.toggleClass('openDrawer closedDrawer');
        });
    }

    setupEventHandlers();
    renderSegmentsList();
    renderMinionsList();
    renderTrapsList();
    updateMazeSettings();

    // If battlebar config is active, render images
    if (extensionSettings.activeGameConfig === 'battlebar') {
        renderBattlebarImages();
    }
}

/**
 * Handle Intelligent Distribute button - auto-set tile percentages
 * Defaults: Trap 5%, Chest 15%, Minions distributed (messenger high, merchant low)
 */
function handleIntelligentDistribute() {
    // Set chest tiles to 15%
    const chestPercentInput = document.getElementById('mazemaster_maze_chest_percent');
    if (chestPercentInput) chestPercentInput.value = '15';

    // Get current minion encounters
    const encountersList = document.getElementById('mazemaster_maze_encounters_list');
    const encounterRows = encountersList?.querySelectorAll('.mazemaster-encounter-row') || [];

    // Calculate minion percentages based on type
    // Remaining after chests (15%) and traps (5%) = 80%
    // Reserve ~15% for empty/movement space
    // Available for minions: ~65% (but we'll use what's configured)

    // Type priority weights (higher = more tiles)
    const typeWeights = {
        'messenger': 10,    // Highest priority - most common
        'prizewheel': 6,    // Medium-high
        'battlebar': 4,     // Medium
        'merchant': 1,      // Lowest - rarest
    };

    // Calculate total weight and assign percentages
    let totalWeight = 0;
    const minionTypes = [];

    encounterRows.forEach(row => {
        const minionId = row.getAttribute('data-minion-id');
        if (!minionId) return;

        const minion = getMinion(minionId);
        const type = minion?.type || 'battlebar';
        const weight = typeWeights[type] || 4;
        totalWeight += weight;
        minionTypes.push({ row, type, weight });
    });

    // Distribute remaining percentage (after traps 5%, chests 15% = 20% used)
    // Available: 80%, but leave some empty space
    const minionTotalPercent = 60; // 60% for minions, 20% empty

    if (totalWeight > 0) {
        minionTypes.forEach(({ row, weight }) => {
            const percent = Math.round((weight / totalWeight) * minionTotalPercent);
            const percentInput = row.querySelector('.encounter-percent-input');
            if (percentInput) {
                percentInput.value = percent;
            }
        });
    }

    // Set trap tiles to 5%
    const trapsList = document.getElementById('mazemaster_maze_traps_list');
    const trapRows = trapsList?.querySelectorAll('.mazemaster-encounter-row') || [];

    if (trapRows.length > 0) {
        // Distribute 5% across trap types
        const trapPercent = Math.floor(5 / trapRows.length);
        trapRows.forEach(row => {
            const percentInput = row.querySelector('.encounter-percent-input');
            if (percentInput) {
                percentInput.value = trapPercent || 1;
            }
        });
    }

    // Save the profile with new values and refresh UI
    const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
    if (profileName) {
        const profileData = collectMazeDataFromUI();
        saveMazeProfile(profileName, profileData);
        loadMazeProfileSettings(); // Refresh the UI to show saved values
    }

    console.log('[MazeMaster] Intelligent Distribute applied: Chests 15%, Traps 5%, Minions distributed');
}

/**
 * Save current maze progress
 */
function saveMazeProgress() {
    if (!currentMaze.isOpen || !currentMaze.profileName) {
        console.warn('[MazeMaster] No active maze to save');
        return false;
    }

    // Create serializable state (avoiding circular references)
    const saveState = {
        profileName: currentMaze.profileName,
        size: currentMaze.size,
        playerX: currentMaze.playerX,
        playerY: currentMaze.playerY,
        exitX: currentMaze.exitX,
        exitY: currentMaze.exitY,
        visited: Array.from(currentMaze.visited),
        inventory: { ...currentMaze.inventory },
        exitEncounterDone: currentMaze.exitEncounterDone,
        shownMilestones: Array.from(currentMaze.shownMilestones || []),
        // v1.2.0: Multi-floor support
        currentFloor: currentMaze.currentFloor || 0,
        totalFloors: currentMaze.totalFloors || 1,
        floors: (currentMaze.floors || [currentMaze.grid]).map(floor =>
            floor.map(row => row.map(cell => ({
                walls: cell.walls,
                visited: cell.visited,
                minion: cell.minion,
                trap: cell.trap,
                chest: cell.chest,
                staircase: cell.staircase,
                roomInfo: cell.roomInfo,  // v1.2.1: Room name/description
                safeRoom: cell.safeRoom,  // v1.3.0: Safe room state
            })))
        ),
        // Serialize grid with only essential data (for backwards compat, same as floors[currentFloor])
        grid: currentMaze.grid.map(row => row.map(cell => ({
            walls: cell.walls,
            visited: cell.visited,
            minion: cell.minion,
            trap: cell.trap,
            chest: cell.chest,
            staircase: cell.staircase,
            roomInfo: cell.roomInfo,  // v1.2.1: Room name/description
            safeRoom: cell.safeRoom,  // v1.3.0: Safe room state
        }))),
        // v1.2.1: Persistent message log
        messageLog: currentMaze.messageLog || [],
        // v2.x: In-game chat history
        chatHistory: currentMaze.chatHistory || [],
        // v1.3.0: HP System
        hpEnabled: currentMaze.hpEnabled,
        hp: currentMaze.hp ? { ...currentMaze.hp } : null,
        restCooldown: currentMaze.restCooldown || 0,
        // v1.4.6: Session Notes
        sessionNotes: currentMaze.sessionNotes || '',
        // v1.4.7: Fairness System
        fairness: currentMaze.fairness || {},
        // v1.4.8: LLM Enhanced Room Descriptions
        enhancedRooms: currentMaze.enhancedRooms || {},
        // v2.0.2: LLM-enhanced main minion alias
        mainMinionOriginalName: currentMaze.mainMinionOriginalName || null,
        mainMinionAlias: currentMaze.mainMinionAlias || null,
        // v1.5.0: Equipment System
        equipment: currentMaze.equipment ? {
            weapon: currentMaze.equipment.weapon?.id || null,
            armor: currentMaze.equipment.armor?.id || null,
            accessory: currentMaze.equipment.accessory?.id || null,
        } : null,
        equipmentInventory: currentMaze.equipmentInventory || [],
        // v1.5.0: Character Progression
        character: currentMaze.character ? {
            level: currentMaze.character.level,
            xp: currentMaze.character.xp,
            xpToNextLevel: currentMaze.character.xpToNextLevel,
            skillPoints: currentMaze.character.skillPoints,
            lastExplorationMilestone: currentMaze.character.lastExplorationMilestone,
        } : null,
        // v1.5.0: Skills System
        skills: currentMaze.skills ? {
            learned: { ...currentMaze.skills.learned },
            cooldowns: { ...currentMaze.skills.cooldowns },
            activeEffects: [...currentMaze.skills.activeEffects],
            abilityBar: [...currentMaze.skills.abilityBar],
        } : null,
        // v1.5.0: Quest System
        quests: currentMaze.quests ? {
            active: currentMaze.quests.active.map(q => ({
                questId: q.questId,
                progress: q.progress,
                accepted: q.accepted,
            })),
            available: currentMaze.quests.available.map(q => ({
                questId: q.questId,
                offered: q.offered,
            })),
            completed: [...currentMaze.quests.completed],
            maxActive: currentMaze.quests.maxActive,
        } : null,
        timestamp: Date.now(),
    };

    extensionSettings.savedMazes[currentMaze.profileName] = saveState;
    saveSettingsDebounced();

    console.log(`[MazeMaster] Maze progress saved for "${currentMaze.profileName}"`);
    return true;
}

/**
 * Load saved maze progress
 */
function loadMazeProgress(profileName) {
    const saveState = extensionSettings.savedMazes?.[profileName];
    if (!saveState) {
        console.warn(`[MazeMaster] No saved game for "${profileName}"`);
        return false;
    }

    const profile = getMazeProfile(profileName);
    if (!profile) {
        console.error(`[MazeMaster] Profile "${profileName}" no longer exists`);
        return false;
    }

    // v1.2.0: Restore multi-floor state
    const totalFloors = saveState.totalFloors || 1;
    const currentFloor = saveState.currentFloor || 0;

    // Restore all floors (backwards compatible with single-floor saves)
    let floors;
    if (saveState.floors && saveState.floors.length > 0) {
        floors = saveState.floors.map(floor =>
            floor.map(row => row.map(cell => ({
                walls: cell.walls,
                visited: cell.visited,
                minion: cell.minion,
                trap: cell.trap,
                chest: cell.chest,
                staircase: cell.staircase,
                roomInfo: cell.roomInfo,  // v1.2.1: Room name/description
                safeRoom: cell.safeRoom,  // v1.3.0: Safe room state
            })))
        );
    } else {
        // Old save format - single floor
        floors = [saveState.grid.map(row => row.map(cell => ({
            walls: cell.walls,
            visited: cell.visited,
            minion: cell.minion,
            trap: cell.trap,
            chest: cell.chest,
            staircase: cell.staircase,
            roomInfo: cell.roomInfo,  // v1.2.1: Room name/description
            safeRoom: cell.safeRoom,  // v1.3.0: Safe room state
        })))];
    }

    // Current grid is the current floor
    const grid = floors[currentFloor];

    // Determine initial minion display
    let initialMinion = getDefaultMinion();
    const mainMinion = profile.mainMinion ? getMinion(profile.mainMinion) : null;
    // v2.0.2: Restore alias from saved state
    const savedAlias = saveState.mainMinionAlias || mainMinion?.name;
    if (mainMinion) {
        initialMinion = {
            name: savedAlias || mainMinion.name,
            imagePath: mainMinion.imagePath,
            message: 'Continuing your journey...',
        };
    }

    // Restore state
    currentMaze = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        grid: grid,
        size: saveState.size,
        playerX: saveState.playerX,
        playerY: saveState.playerY,
        exitX: saveState.exitX,
        exitY: saveState.exitY,
        visited: new Set(saveState.visited),
        isVictory: false,
        currentMinion: initialMinion,
        isPaused: false,
        pendingEncounter: null,
        exitEncounterDone: saveState.exitEncounterDone,
        pendingConfirmation: null,
        pendingChest: null,
        inventory: {
            key: 0, stealth: 0, strike: 0, execute: 0,
            floorKey: 0, portalStone: 0, minionBane: 0, mapFragment: 0, timeShard: 0, voidWalk: 0,
            // v1.3.0 HP items
            healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, heartCrystal: 0,
            ...saveState.inventory  // Overlay saved values
        },
        shownMilestones: new Set(saveState.shownMilestones || []),
        // v1.2.0: Multi-floor state
        currentFloor: currentFloor,
        totalFloors: totalFloors,
        floors: floors,
        voidWalkActive: false,
        // v1.2.1: Persistent message log
        messageLog: saveState.messageLog || [],
        // v2.x: In-game chat history
        chatHistory: saveState.chatHistory || [],
        chatEnabled: true,
        // v1.3.0: HP System
        hpEnabled: saveState.hpEnabled ?? (profile.hpEnabled !== false),
        hp: saveState.hp ? {
            current: saveState.hp.current ?? initHP(profile).current,
            max: saveState.hp.max ?? initHP(profile).max,
            maxBonus: saveState.hp.maxBonus ?? 0,
            reviveCharges: saveState.hp.reviveCharges ?? 0,
        } : initHP(profile),
        restCooldown: saveState.restCooldown || 0,
        // v1.4.6: Session Notes
        sessionNotes: saveState.sessionNotes || '',
        // v1.4.7: Fairness System
        fairness: saveState.fairness || {
            chestsWithoutKey: 0,
            combatLossStreak: 0,
            chestsWithoutHealing: 0,
            lockedChestsSkipped: 0,
            lastHealingFoundFloor: 0,
        },
        // v1.4.8: LLM Enhanced Room Descriptions
        enhancedRooms: saveState.enhancedRooms || {},
        // v2.0.2: LLM-enhanced main minion alias
        mainMinionOriginalName: saveState.mainMinionOriginalName || mainMinion?.name || null,
        mainMinionAlias: saveState.mainMinionAlias || mainMinion?.name || null,
        // v1.5.0: Equipment System
        equipment: {
            weapon: saveState.equipment?.weapon ? getEquipment(saveState.equipment.weapon) : null,
            armor: saveState.equipment?.armor ? getEquipment(saveState.equipment.armor) : null,
            accessory: saveState.equipment?.accessory ? getEquipment(saveState.equipment.accessory) : null,
        },
        equipmentInventory: saveState.equipmentInventory || [],
        // v1.5.0: Character Progression
        character: saveState.character ? {
            level: saveState.character.level ?? 1,
            xp: saveState.character.xp ?? 0,
            xpToNextLevel: saveState.character.xpToNextLevel ?? 100,
            skillPoints: saveState.character.skillPoints ?? 0,
            lastExplorationMilestone: saveState.character.lastExplorationMilestone ?? 0,
        } : {
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            skillPoints: 0,
            lastExplorationMilestone: 0,
        },
        // v1.5.0: Skills System
        skills: saveState.skills ? {
            learned: { ...(saveState.skills.learned || {}) },
            cooldowns: { ...(saveState.skills.cooldowns || {}) },
            activeEffects: [...(saveState.skills.activeEffects || [])],
            abilityBar: [...(saveState.skills.abilityBar || [])],
        } : {
            learned: {},
            cooldowns: {},
            activeEffects: [],
            abilityBar: [],
        },
        // v1.5.0: Quest System
        quests: saveState.quests ? {
            active: (saveState.quests.active || []).map(q => ({
                questId: q.questId,
                progress: q.progress || 0,
                accepted: q.accepted ?? true,
            })),
            available: (saveState.quests.available || []).map(q => ({
                questId: q.questId,
                offered: q.offered ?? true,
            })),
            completed: [...(saveState.quests.completed || [])],
            maxActive: saveState.quests.maxActive ?? 3,
        } : initializeQuestState(),
    };

    // Sanity check: ensure current HP doesn't exceed max
    if (currentMaze.hp) {
        const maxTotal = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
        if (currentMaze.hp.current > maxTotal) {
            console.log(`[MazeMaster] Clamping HP from ${currentMaze.hp.current} to ${maxTotal}`);
            currentMaze.hp.current = maxTotal;
        }
    }

    showMazeModal();
    renderMazeGrid();
    updatePlayerPosition(false); // Set initial position without animation
    renderMessageLog();  // Render saved messages first
    updateMazeHero();
    initChatInput();  // v2.x: Initialize in-game chat input
    updateInventoryDisplay();
    updateHPDisplay();  // v1.3.0: Restore HP display
    updateRestButton(); // v1.3.0: Restore rest button state
    updateEquipmentDisplay(); // v1.5.0: Restore equipment display

    // v1.2.0: Update floor UI
    updateFloorIndicator();
    updateDpadFloorButtons();

    document.addEventListener('keydown', handleMazeKeydown, { capture: true });

    // v2.0.5: Check for any pending level-ups after loading save
    setTimeout(async () => {
        const result = await checkForLevelUp();
        if (result.levelsGained > 0) {
            console.log(`[MazeMaster] Processed ${result.levelsGained} pending level-up(s) after save load`);
        }
    }, 500);

    console.log(`[MazeMaster] Loaded saved maze "${profileName}" (floor ${currentFloor + 1}/${totalFloors})`);
    return true;
}

/**
 * Delete saved maze
 */
function deleteSavedMaze(profileName) {
    if (extensionSettings.savedMazes?.[profileName]) {
        delete extensionSettings.savedMazes[profileName];
        saveSettingsDebounced();
        console.log(`[MazeMaster] Deleted saved maze "${profileName}"`);
        return true;
    }
    return false;
}

/**
 * Get list of saved maze profile names
 */
function getSavedMazeNames() {
    return Object.keys(extensionSettings.savedMazes || {});
}

/**
 * Render the saved games list in the config panel and game tab
 */
function renderSavedGamesList() {
    // Render to both config panel and game tab
    const listIds = ['mazemaster_saved_games_list', 'mazemaster_game_tab_saves'];

    const savedNames = getSavedMazeNames();

    for (const listId of listIds) {
        const list = document.getElementById(listId);
        if (!list) continue;

        if (savedNames.length === 0) {
            list.innerHTML = '<div class="mazemaster-no-saves">No saved games</div>';
            continue;
        }

        list.innerHTML = savedNames.map(name => {
            const save = extensionSettings.savedMazes[name];
            const date = new Date(save.timestamp);
            const progress = save.visited ? Math.round((save.visited.length / (save.size * save.size)) * 100) : 0;

            return `
                <div class="mazemaster-saved-game" data-profile="${escapeHtml(name)}">
                    <div class="mazemaster-saved-game-info">
                        <div class="mazemaster-saved-game-name">${escapeHtml(name)}</div>
                        <div class="mazemaster-saved-game-details">${progress}% explored - ${date.toLocaleDateString()}</div>
                    </div>
                    <div class="mazemaster-saved-game-actions">
                        <button class="menu_button menu_button_icon saved-game-load" title="Resume">
                            <i class="fa-solid fa-play"></i>
                        </button>
                        <button class="menu_button menu_button_icon saved-game-delete" title="Delete">
                            <i class="fa-solid fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        }).join('');

        // Attach handlers
        list.querySelectorAll('.mazemaster-saved-game').forEach(item => {
            const profileName = item.dataset.profile;

            item.querySelector('.saved-game-load')?.addEventListener('click', () => {
                loadMazeProgress(profileName);
            });

            item.querySelector('.saved-game-delete')?.addEventListener('click', async () => {
                const confirmed = await callGenericPopup(`Delete saved game "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteSavedMaze(profileName);
                    renderSavedGamesList();
                }
            });
        });
    }
}

/**
 * Populate the LLM preset dropdown with available presets
 */
function populateLLMPresetDropdown() {
    const dropdown = document.getElementById('mazemaster_llm_preset');
    if (!dropdown) return;

    // Clear existing options except the first "(Use Current)" option
    dropdown.innerHTML = '<option value="">(Use Current)</option>';

    // Try to get presets from the preset manager
    try {
        if (typeof getPresetManager === 'function') {
            const presetManager = getPresetManager();
            if (presetManager && typeof presetManager.getAllPresets === 'function') {
                const presets = presetManager.getAllPresets();
                presets.forEach(preset => {
                    const option = document.createElement('option');
                    option.value = preset;
                    option.textContent = preset;
                    if (preset === extensionSettings.llmPreset) {
                        option.selected = true;
                    }
                    dropdown.appendChild(option);
                });
                console.log(`[MazeMaster] Populated LLM preset dropdown with ${presets.length} presets`);
            }
        }
    } catch (error) {
        console.warn('[MazeMaster] Could not populate LLM presets:', error);
    }
}

/**
 * Show Story Milestones modal for configuring maze story
 */
async function showStoryMilestonesModal() {
    const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
    if (!profileName) {
        alert('Please create a maze profile first');
        return;
    }

    const profile = getMazeProfile(profileName) || {};
    const storyConfig = profile.storyConfig || { mainStory: '', milestones: [] };

    // Create modal HTML
    const modalHtml = `
        <div id="mazemaster_story_modal" class="mazemaster-story-modal">
            <div class="mazemaster-story-modal-content">
                <h3><i class="fa-solid fa-book"></i> Story Milestones</h3>

                <div class="mazemaster-section">
                    <label class="mazemaster-label">Main Story</label>
                    <textarea id="story_main_text" class="mazemaster-story-textarea" rows="4"
                        placeholder="The maze stretches before you, filled with danger and mystery...">${escapeHtml(storyConfig.mainStory || '')}</textarea>
                </div>

                <div class="mazemaster-section">
                    <label class="mazemaster-label">Milestones</label>
                    <div id="story_milestones_list" class="mazemaster-milestones-list">
                        <!-- Milestones rendered here -->
                    </div>
                    <button id="story_add_milestone_btn" class="menu_button mazemaster-add-btn">
                        <i class="fa-solid fa-plus"></i> Add Milestone
                    </button>
                </div>

                <div class="mazemaster-story-modal-buttons">
                    <button id="story_save_btn" class="menu_button menu_button_primary">
                        <i class="fa-solid fa-save"></i> Save
                    </button>
                    <button id="story_cancel_btn" class="menu_button">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;

    // Add modal to body
    const modalWrapper = document.createElement('div');
    modalWrapper.innerHTML = modalHtml;
    document.body.appendChild(modalWrapper.firstElementChild);

    const modal = document.getElementById('mazemaster_story_modal');
    const milestonesList = document.getElementById('story_milestones_list');

    // Render milestones
    function renderMilestones() {
        if (storyConfig.milestones.length === 0) {
            milestonesList.innerHTML = '<div class="mazemaster-empty-state">No milestones. Add milestones to show story updates at specific progress points.</div>';
            return;
        }

        milestonesList.innerHTML = storyConfig.milestones.map((m, index) => `
            <div class="mazemaster-milestone-row" data-index="${index}">
                <div class="milestone-percent">
                    <input type="number" class="milestone-percent-input" min="1" max="99" value="${m.percent || 25}" placeholder="%">
                    <span>%</span>
                </div>
                <textarea class="milestone-text-input" rows="2" placeholder="Story update at this point...">${escapeHtml(m.storyUpdate || '')}</textarea>
                <button class="menu_button menu_button_icon milestone-remove-btn" title="Remove">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
        `).join('');

        // Add remove handlers
        milestonesList.querySelectorAll('.milestone-remove-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const row = e.target.closest('.mazemaster-milestone-row');
                const index = parseInt(row.dataset.index);
                storyConfig.milestones.splice(index, 1);
                renderMilestones();
            });
        });
    }

    renderMilestones();

    // Add milestone button
    document.getElementById('story_add_milestone_btn')?.addEventListener('click', () => {
        storyConfig.milestones.push({ percent: 50, storyUpdate: '' });
        renderMilestones();
    });

    // Save button
    document.getElementById('story_save_btn')?.addEventListener('click', () => {
        // Collect data from modal
        storyConfig.mainStory = document.getElementById('story_main_text')?.value || '';

        // Collect milestones from inputs
        const milestoneRows = milestonesList.querySelectorAll('.mazemaster-milestone-row');
        storyConfig.milestones = [];
        milestoneRows.forEach(row => {
            const percent = parseInt(row.querySelector('.milestone-percent-input')?.value) || 25;
            const storyUpdate = row.querySelector('.milestone-text-input')?.value || '';
            if (storyUpdate.trim()) {
                storyConfig.milestones.push({ percent, storyUpdate });
            }
        });

        // Sort by percent
        storyConfig.milestones.sort((a, b) => a.percent - b.percent);

        // Save to profile
        profile.storyConfig = storyConfig;
        saveMazeProfile(profileName, profile);

        // Close modal
        modal.remove();
        alert('Story milestones saved!');
    });

    // Cancel button
    document.getElementById('story_cancel_btn')?.addEventListener('click', () => {
        modal.remove();
    });

    // Close on background click
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });
}

function setupEventHandlers() {
    // Profile select change
    const profileSelect = document.getElementById('mazemaster_profile_select');
    if (profileSelect) {
        profileSelect.addEventListener('change', (e) => {
            extensionSettings.currentProfile = e.target.value;
            saveSettingsDebounced();
            updateProfileSettings();
            renderSegmentsList();
        });
    }

    // New profile button
    const newProfileBtn = document.getElementById('mazemaster_new_profile_btn');
    if (newProfileBtn) {
        newProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new wheel profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.profiles[trimmed]) {
                    extensionSettings.profiles[trimmed] = { segments: [], randomize: false, difficulty: 1 };
                    extensionSettings.currentProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                } else {
                    await callGenericPopup(`Profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Delete profile button
    const deleteProfileBtn = document.getElementById('mazemaster_delete_profile_btn');
    if (deleteProfileBtn) {
        deleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete wheel profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteProfile(profileName);
                    refreshPanel();
                }
            }
        });
    }

    // Rename profile button
    const renameProfileBtn = document.getElementById('mazemaster_rename_profile_btn');
    if (renameProfileBtn) {
        renameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.profiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.profiles[trimmed] = extensionSettings.profiles[oldName];
                delete extensionSettings.profiles[oldName];
                extensionSettings.currentProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
            }
        });
    }

    // Export profile button
    const exportBtn = document.getElementById('mazemaster_export_btn');
    if (exportBtn) {
        exportBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_profile_select')?.value;
            if (!profileName) {
                alert('No profile selected to export');
                return;
            }
            exportProfile(profileName);
        });
    }

    // Import profile button
    const importBtn = document.getElementById('mazemaster_import_btn');
    const importFile = document.getElementById('mazemaster_import_file');
    if (importBtn && importFile) {
        importBtn.addEventListener('click', () => {
            importFile.click();
        });

        importFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            try {
                const profileName = await importProfile(file);
                alert(`Profile "${profileName}" imported successfully!`);
                refreshPanel();
            } catch (err) {
                alert(`Import failed: ${err.message}`);
            }

            // Reset file input
            importFile.value = '';
        });
    }

    // Add segment button
    const addSegmentBtn = document.getElementById('mazemaster_add_segment_btn');
    if (addSegmentBtn) {
        addSegmentBtn.addEventListener('click', () => {
            const list = document.getElementById('mazemaster_segments_list');
            if (!list) return;

            const emptyState = list.querySelector('.mazemaster-empty-state');
            if (emptyState) emptyState.remove();

            const index = list.querySelectorAll('.mazemaster-segment-item').length;
            const newItem = document.createElement('div');
            newItem.className = 'mazemaster-segment-item';
            newItem.dataset.index = index;
            newItem.innerHTML = `
                <div class="mazemaster-segment-row">
                    <div class="mazemaster-segment-field small">
                        <label>Trigger</label>
                        <input type="text" class="seg-trigger" value="com${index + 1}" placeholder="com1">
                    </div>
                    <div class="mazemaster-segment-field">
                        <label>Display Text</label>
                        <input type="text" class="seg-text" value="" placeholder="Prize name">
                    </div>
                    <div class="mazemaster-segment-field small">
                        <label>Size</label>
                        <select class="seg-size">
                            ${SIZE_OPTIONS.map(s => `<option value="${s}" ${s === 'fraction' ? 'selected' : ''}>${s}</option>`).join('')}
                        </select>
                    </div>
                    <button class="menu_button menu_button_icon mazemaster-segment-delete" title="Delete">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
                <div class="mazemaster-segment-row">
                    <div class="mazemaster-segment-field">
                        <label>STScript Command</label>
                        <textarea class="seg-command" placeholder="/echo You won!"></textarea>
                    </div>
                    <div class="mazemaster-segment-field tiny">
                        <label>&nbsp;</label>
                        <label class="mazemaster-segment-checkbox">
                            <input type="checkbox" class="seg-respin">
                            Respin
                        </label>
                    </div>
                </div>
            `;

            newItem.querySelector('.mazemaster-segment-delete').addEventListener('click', () => {
                newItem.remove();
            });

            list.appendChild(newItem);
        });
    }

    // Save button
    const saveBtn = document.getElementById('mazemaster_save_btn');
    if (saveBtn) {
        saveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_profile_select')?.value;
            if (!profileName) {
                alert('Please create a profile first');
                return;
            }

            const segments = collectSegmentsFromUI();
            const randomize = document.getElementById('mazemaster_randomize')?.checked || false;
            const difficulty = parseInt(document.getElementById('mazemaster_difficulty')?.value) || 1;

            // Validate wheel balance
            if (segments.length === 0) {
                alert('Error: Wheel must have at least one segment');
                return;
            }

            const halfCount = segments.filter(s => s.size === 'halfseg').length;
            const doubleCount = segments.filter(s => s.size === 'doubleseg').length;
            if (halfCount !== doubleCount) {
                alert(`Error: Wheel unbalanced!\n\n${halfCount} halfseg(s) ≠ ${doubleCount} doubleseg(s)\n\nFor every halfseg, you need a doubleseg to balance the wheel.`);
                return;
            }

            saveProfile(profileName, segments, randomize, difficulty);
            console.log(`[MazeMaster] Saved profile "${profileName}":`, { segments, randomize, difficulty });
            alert(`Profile "${profileName}" saved!`);
        });
    }

    // Preview Wheel button
    const previewWheelBtn = document.getElementById('mazemaster_preview_wheel_btn');
    if (previewWheelBtn) {
        previewWheelBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_profile_select')?.value;
            if (!profileName) {
                alert('Please select or create a wheel profile first');
                return;
            }

            // Load the profile and show the wheel
            const result = loadWheelFromProfile(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
                return;
            }

            const validation = validateWheelBalance();
            if (!validation.valid) {
                alert(`Error: ${validation.error}`);
                return;
            }

            showWheelModal();
        });
    }

    // Preview Battlebar button
    const previewBattlebarBtn = document.getElementById('mazemaster_preview_battlebar_btn');
    if (previewBattlebarBtn) {
        previewBattlebarBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
            if (!profileName) {
                alert('Please select or create a battlebar profile first');
                return;
            }

            const result = startBattlebar(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
                return;
            }
        });
    }

    // =========================================================================
    // GAME SELECTOR HANDLERS
    // =========================================================================

    const showWheelBtn = document.getElementById('mazemaster_show_wheel');
    const showCombatBtn = document.getElementById('mazemaster_show_combat');
    const showMazeBtn = document.getElementById('mazemaster_show_maze');
    const showMinionsBtn = document.getElementById('mazemaster_show_minions');
    const showTrapsBtn = document.getElementById('mazemaster_show_traps');
    const showThemesBtn = document.getElementById('mazemaster_show_themes');
    const showStylesBtn = document.getElementById('mazemaster_show_styles');
    const showQuestsBtn = document.getElementById('mazemaster_show_quests');
    // v1.6.0: New config tabs
    const showItemsBtn = document.getElementById('mazemaster_show_items');
    const showFactionsBtn = document.getElementById('mazemaster_show_factions');
    const showVisionBtn = document.getElementById('mazemaster_show_vision');
    const showSoundBtn = document.getElementById('mazemaster_show_sound');

    const wheelConfig = document.getElementById('mazemaster_wheel_config');
    const combatConfig = document.getElementById('mazemaster_combat_config');
    const mazeConfig = document.getElementById('mazemaster_maze_config');
    const minionsConfig = document.getElementById('mazemaster_minions_config');
    const trapsConfig = document.getElementById('mazemaster_traps_config');
    const themesConfig = document.getElementById('mazemaster_themes_config');
    const stylesConfig = document.getElementById('mazemaster_styles_config');
    const questsConfig = document.getElementById('mazemaster_quests_config');
    // v1.6.0: New config containers
    const itemsConfig = document.getElementById('mazemaster_items_config');
    const factionsConfig = document.getElementById('mazemaster_factions_config');
    const visionConfig = document.getElementById('mazemaster_vision_config');
    const soundConfig = document.getElementById('mazemaster_sound_config');

    function setActiveGameConfig(configType) {
        // Map 'battlebar' to 'combat' for backward compatibility
        if (configType === 'battlebar') configType = 'combat';

        extensionSettings.activeGameConfig = configType;
        saveSettingsDebounced();

        // Update button states
        showWheelBtn?.classList.toggle('active', configType === 'wheel');
        showCombatBtn?.classList.toggle('active', configType === 'combat');
        showMazeBtn?.classList.toggle('active', configType === 'maze');
        showMinionsBtn?.classList.toggle('active', configType === 'minions');
        showTrapsBtn?.classList.toggle('active', configType === 'traps');
        showThemesBtn?.classList.toggle('active', configType === 'themes');
        showStylesBtn?.classList.toggle('active', configType === 'styles');
        showQuestsBtn?.classList.toggle('active', configType === 'quests');
        // v1.6.0: New tabs
        showItemsBtn?.classList.toggle('active', configType === 'items');
        showFactionsBtn?.classList.toggle('active', configType === 'factions');
        showVisionBtn?.classList.toggle('active', configType === 'vision');
        showSoundBtn?.classList.toggle('active', configType === 'sound');

        // Update config visibility
        if (wheelConfig) wheelConfig.style.display = configType === 'wheel' ? 'block' : 'none';
        if (combatConfig) combatConfig.style.display = configType === 'combat' ? 'block' : 'none';
        if (mazeConfig) mazeConfig.style.display = configType === 'maze' ? 'block' : 'none';
        if (minionsConfig) minionsConfig.style.display = configType === 'minions' ? 'block' : 'none';
        if (trapsConfig) trapsConfig.style.display = configType === 'traps' ? 'block' : 'none';
        if (themesConfig) themesConfig.style.display = configType === 'themes' ? 'block' : 'none';
        if (stylesConfig) stylesConfig.style.display = configType === 'styles' ? 'block' : 'none';
        if (questsConfig) questsConfig.style.display = configType === 'quests' ? 'block' : 'none';
        // v1.6.0: New configs
        if (itemsConfig) itemsConfig.style.display = configType === 'items' ? 'block' : 'none';
        if (factionsConfig) factionsConfig.style.display = configType === 'factions' ? 'block' : 'none';
        if (visionConfig) visionConfig.style.display = configType === 'vision' ? 'block' : 'none';
        if (soundConfig) soundConfig.style.display = configType === 'sound' ? 'block' : 'none';

        // Render content if needed
        if (configType === 'combat') renderBattlebarImages();
        if (configType === 'minions') renderMinionsList();
        if (configType === 'traps') renderTrapsList();
        if (configType === 'themes') populateThemeProfileSelect();
        if (configType === 'styles') populateStyleProfileSelect();
        if (configType === 'quests') renderQuestTemplateList();
        // v1.6.0: Render new tab content
        if (configType === 'items') { renderCustomItemsList(); renderCustomItemsInItemPool(); }
        if (configType === 'factions') renderFactionsList();
        if (configType === 'vision') renderVisionSettings();
        if (configType === 'sound') renderSoundSettings();
    }

    if (showWheelBtn) showWheelBtn.addEventListener('click', () => setActiveGameConfig('wheel'));
    if (showCombatBtn) showCombatBtn.addEventListener('click', () => setActiveGameConfig('combat'));
    if (showMazeBtn) showMazeBtn.addEventListener('click', () => setActiveGameConfig('maze'));
    if (showMinionsBtn) showMinionsBtn.addEventListener('click', () => setActiveGameConfig('minions'));
    if (showTrapsBtn) showTrapsBtn.addEventListener('click', () => setActiveGameConfig('traps'));
    if (showThemesBtn) showThemesBtn.addEventListener('click', () => setActiveGameConfig('themes'));
    if (showStylesBtn) showStylesBtn.addEventListener('click', () => setActiveGameConfig('styles'));
    if (showQuestsBtn) showQuestsBtn.addEventListener('click', () => setActiveGameConfig('quests'));
    // v1.6.0: New tab handlers
    if (showItemsBtn) showItemsBtn.addEventListener('click', () => setActiveGameConfig('items'));
    if (showFactionsBtn) showFactionsBtn.addEventListener('click', () => setActiveGameConfig('factions'));
    if (showVisionBtn) showVisionBtn.addEventListener('click', () => setActiveGameConfig('vision'));
    if (showSoundBtn) showSoundBtn.addEventListener('click', () => setActiveGameConfig('sound'));

    // Combat sub-tab switching
    document.querySelectorAll('.combat-subtab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.combat-subtab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.combat-content').forEach(c => c.classList.remove('active'));
            tab.classList.add('active');
            const target = tab.dataset.combat;
            document.getElementById(`combat_${target}_content`)?.classList.add('active');

            // Render content if switching to battlebar
            if (target === 'battlebar') {
                renderBattlebarImages();
            }
        });
    });

    // Help sub-tab handlers
    document.querySelectorAll('.help-subtab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.help-subtab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.help-content').forEach(c => c.classList.remove('active'));
            tab.classList.add('active');
            const target = tab.dataset.help;
            document.getElementById(`help_${target}_content`)?.classList.add('active');
        });
    });

    // TAB HANDLERS
    // =========================================================================
    const tabs = document.querySelectorAll('.mazemaster-tab');
    const tabContents = document.querySelectorAll('.mazemaster-tab-content');

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const targetTab = tab.dataset.tab;

            // Update tab buttons
            tabs.forEach(t => t.classList.toggle('active', t === tab));

            // Update tab content
            tabContents.forEach(content => {
                const isTarget = content.id === `mazemaster-tab-${targetTab}`;
                content.classList.toggle('active', isTarget);
            });
        });
    });

    // CUSTOM THEMES TAB HANDLERS
    // =========================================================================
    const themeProfileSelect = document.getElementById('mazemaster_theme_profile_select');
    if (themeProfileSelect) {
        themeProfileSelect.addEventListener('change', (e) => {
            if (e.target.value) {
                loadThemeToUI(e.target.value);
            } else {
                clearThemeForm();
            }
        });
    }

    const themeNewBtn = document.getElementById('mazemaster_theme_new_btn');
    if (themeNewBtn) {
        themeNewBtn.addEventListener('click', () => {
            clearThemeForm();
            if (themeProfileSelect) themeProfileSelect.value = '';
        });
    }

    const themeSaveBtn = document.getElementById('mazemaster_theme_save_btn');
    if (themeSaveBtn) {
        themeSaveBtn.addEventListener('click', () => {
            const data = collectThemeFromUI();
            if (!data.name) {
                toastr.error('Theme name is required');
                return;
            }
            saveCustomTheme(data.name, data);
            populateThemeProfileSelect();
            if (themeProfileSelect) themeProfileSelect.value = data.name;
            toastr.success(`Theme "${data.displayName || data.name}" saved`);
            // Refresh maze config to show new theme in dropdown
            renderConfigPanel();
        });
    }

    const themeDeleteBtn = document.getElementById('mazemaster_theme_delete_btn');
    if (themeDeleteBtn) {
        themeDeleteBtn.addEventListener('click', () => {
            const name = themeProfileSelect?.value;
            if (!name) {
                toastr.warning('Select a theme to delete');
                return;
            }
            const theme = getCustomTheme(name);
            if (confirm(`Delete theme "${theme?.displayName || name}"?`)) {
                deleteCustomTheme(name);
                clearThemeForm();
                populateThemeProfileSelect();
                toastr.info(`Theme "${theme?.displayName || name}" deleted`);
                renderConfigPanel();
            }
        });
    }

    // CUSTOM STYLES TAB HANDLERS
    // =========================================================================
    const styleProfileSelect = document.getElementById('mazemaster_style_profile_select');
    if (styleProfileSelect) {
        styleProfileSelect.addEventListener('change', (e) => {
            if (e.target.value) {
                loadStyleToUI(e.target.value);
            } else {
                clearStyleForm();
            }
        });
    }

    const styleNewBtn = document.getElementById('mazemaster_style_new_btn');
    if (styleNewBtn) {
        styleNewBtn.addEventListener('click', () => {
            clearStyleForm();
            if (styleProfileSelect) styleProfileSelect.value = '';
        });
    }

    const styleSaveBtn = document.getElementById('mazemaster_style_save_btn');
    if (styleSaveBtn) {
        styleSaveBtn.addEventListener('click', () => {
            const data = collectStyleFromUI();
            if (!data.name) {
                toastr.error('Style name is required');
                return;
            }
            saveCustomStyle(data.name, data);
            populateStyleProfileSelect();
            if (styleProfileSelect) styleProfileSelect.value = data.name;
            toastr.success(`Style "${data.displayName || data.name}" saved`);
            // Refresh maze config to show new style in dropdown
            renderConfigPanel();
        });
    }

    const styleDeleteBtn = document.getElementById('mazemaster_style_delete_btn');
    if (styleDeleteBtn) {
        styleDeleteBtn.addEventListener('click', () => {
            const name = styleProfileSelect?.value;
            if (!name) {
                toastr.warning('Select a style to delete');
                return;
            }
            const style = getCustomStyle(name);
            if (confirm(`Delete style "${style?.displayName || name}"?`)) {
                deleteCustomStyle(name);
                clearStyleForm();
                populateStyleProfileSelect();
                toastr.info(`Style "${style?.displayName || name}" deleted`);
                renderConfigPanel();
            }
        });
    }

    // PLAY MAZE BUTTON
    // =========================================================================
    const playMazeBtn = document.getElementById('mazemaster_play_maze');
    if (playMazeBtn) {
        playMazeBtn.addEventListener('click', async () => {
            const profileSelect = document.getElementById('mazemaster_play_profile');
            const profileName = profileSelect?.value || extensionSettings.currentMazeProfile || 'Tutorial - Learn the Basics';

            // Close current chat to prevent LLM from absorbing chat context
            try {
                await executeSlashCommandsWithOptions('/closechat');
            } catch (e) {
                // Chat may already be closed or not exist
                console.log('[MazeMaster] No active chat to close');
            }

            startMaze(profileName);
        });
    }

    // MAZE PROFILE PREVIEW
    // =========================================================================
    function updateMazePreview() {
        const profileSelect = document.getElementById('mazemaster_play_profile');
        const profileName = profileSelect?.value;
        if (!profileName) return;

        const profile = getMazeProfileWithDefaults(profileName);
        if (!profile) return;

        const capitalize = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1) : '';

        document.getElementById('preview_title').textContent = profileName;
        document.getElementById('preview_story').textContent = profile.storyConfig?.mainStory || 'No story available';
        document.getElementById('preview_theme').textContent = capitalize(profile.theme);
        document.getElementById('preview_style').textContent = capitalize(profile.mapStyle);
        document.getElementById('preview_difficulty').textContent = capitalize(profile.difficulty);
        document.getElementById('preview_size').textContent = `${profile.gridSize}x${profile.gridSize} × ${profile.floors} floor${profile.floors > 1 ? 's' : ''}`;
        document.getElementById('preview_hp').textContent = profile.hpEnabled ? `${profile.maxHP} HP` : 'Disabled';
        document.getElementById('preview_permadeath').textContent = profile.permadeathEnabled ? 'Yes' : 'No';
        document.getElementById('preview_combat').textContent = capitalize(profile.combatMechanicsProfile || 'default');
        document.getElementById('preview_vision').textContent = capitalize(profile.visionProfile || 'default');

        // Build starting items summary - show ALL items with non-zero counts
        const inv = profile.startingInventory || {};
        const items = [];

        // Item display name mappings
        const itemNames = {
            key: 'Key', floorKey: 'Floor Key', strike: 'Strike', stealth: 'Stealth', execute: 'Execute',
            minionBane: 'Minion Bane', portalStone: 'Portal Stone', mapFragment: 'Map', voidWalk: 'Void Walk',
            timeShard: 'Time Shard', healingPotion: 'Potion', greaterHealing: 'Greater', elixir: 'Elixir',
            revivalCharm: 'Revival', heartCrystal: 'Heart Crystal', ironGuard: 'Iron Guard',
            torch: 'Torch', lantern: 'Lantern', revealScroll: 'Reveal', sightPotion: 'Sight', crystalBall: 'Crystal Ball',
            weapon_rusty_sword: 'Rusty Sword', weapon_iron_sword: 'Iron Sword', weapon_steel_blade: 'Steel Blade',
            weapon_enchanted_blade: 'Enchanted Blade', weapon_shadow_dagger: 'Shadow Dagger',
            armor_leather: 'Leather Armor', armor_chainmail: 'Chainmail', armor_plate: 'Plate Armor',
            accessory_ring_power: 'Ring of Power', accessory_amulet_protection: 'Amulet',
            accessory_lucky_charm: 'Lucky Charm', accessory_vampiric_pendant: 'Vampiric Pendant'
        };

        // Iterate through all inventory items
        for (const [itemId, count] of Object.entries(inv)) {
            if (count && count > 0) {
                const name = itemNames[itemId] || itemId;
                items.push(`${count} ${name}${count > 1 && !name.endsWith('s') ? 's' : ''}`);
            }
        }

        document.getElementById('preview_starting_items').textContent =
            items.length ? `Starting: ${items.join(', ')}` : 'No starting items';

        document.getElementById('preview_content').style.display = 'block';
    }

    const playProfileSelect = document.getElementById('mazemaster_play_profile');
    if (playProfileSelect) {
        playProfileSelect.addEventListener('change', updateMazePreview);
        // Initialize preview on load
        updateMazePreview();
    }

    // LLM PRESET DROPDOWN
    // =========================================================================
    populateLLMPresetDropdown();
    console.log('[MazeMaster] After populateLLMPresetDropdown, continuing initUI...');

    const llmPresetSelect = document.getElementById('mazemaster_llm_preset');
    if (llmPresetSelect) {
        llmPresetSelect.addEventListener('change', (e) => {
            extensionSettings.llmPreset = e.target.value;
            saveSettingsDebounced();
        });
    }

    const llmEnabledCheckbox = document.getElementById('mazemaster_llm_enabled');
    if (llmEnabledCheckbox) {
        llmEnabledCheckbox.addEventListener('change', (e) => {
            extensionSettings.llmEnabled = e.target.checked;
            saveSettingsDebounced();
        });
    }

    const closeChatCheckbox = document.getElementById('mazemaster_close_chat');
    if (closeChatCheckbox) {
        closeChatCheckbox.addEventListener('change', (e) => {
            extensionSettings.closeChatOnStart = e.target.checked;
            saveSettingsDebounced();
        });
    }

    // v2.1.0: AVATAR GENERATION SETTINGS
    // =========================================================================
    const avatarGenCheckbox = document.getElementById('mazemaster_avatar_gen_enabled');
    if (avatarGenCheckbox) {
        avatarGenCheckbox.addEventListener('change', (e) => {
            extensionSettings.avatarGenerationEnabled = e.target.checked;
            saveSettingsDebounced();
        });
    }

    // D-PAD SETTINGS
    // =========================================================================
    const dpadEnabledCheckbox = document.getElementById('mazemaster_dpad_enabled');
    if (dpadEnabledCheckbox) {
        dpadEnabledCheckbox.addEventListener('change', (e) => {
            if (!extensionSettings.dpadConfig) {
                extensionSettings.dpadConfig = { enabled: true, floating: true, position: { x: null, y: null } };
            }
            extensionSettings.dpadConfig.enabled = e.target.checked;
            // Update visibility if D-pad exists
            const dpad = document.getElementById('maze_dpad');
            if (dpad) {
                dpad.style.display = e.target.checked ? '' : 'none';
            }
            saveSettingsDebounced();
        });
    }

    const dpadFloatingCheckbox = document.getElementById('mazemaster_dpad_floating');
    if (dpadFloatingCheckbox) {
        dpadFloatingCheckbox.addEventListener('change', (e) => {
            if (!extensionSettings.dpadConfig) {
                extensionSettings.dpadConfig = { enabled: true, floating: true, position: { x: null, y: null } };
            }
            extensionSettings.dpadConfig.floating = e.target.checked;
            // Update floating class if D-pad exists
            const dpad = document.getElementById('maze_dpad');
            if (dpad) {
                dpad.classList.toggle('floating', e.target.checked);
                if (e.target.checked) {
                    initDpadDrag();
                }
            }
            saveSettingsDebounced();
        });
    }

    const dpadResetBtn = document.getElementById('mazemaster_dpad_reset');
    if (dpadResetBtn) {
        dpadResetBtn.addEventListener('click', () => {
            if (!extensionSettings.dpadConfig) {
                extensionSettings.dpadConfig = { enabled: true, floating: true, position: { x: null, y: null } };
            }
            extensionSettings.dpadConfig.position = { x: null, y: null };
            saveSettingsDebounced();
            // Also reset if D-Pad is currently visible
            const dpad = document.getElementById('maze_dpad');
            if (dpad) {
                dpad.style.left = '';
                dpad.style.top = '';
                dpad.style.right = '20px';
                dpad.style.bottom = '100px';
            }
        });
    }

    // RESET FACTORY DEFAULTS BUTTON
    // =========================================================================
    const resetFactoryBtn = document.getElementById('mazemaster_reset_factory');
    if (resetFactoryBtn) {
        resetFactoryBtn.addEventListener('click', async () => {
            const confirmed = await callGenericPopup(
                'This will DELETE all your custom profiles (including themes/styles) and restore v2.0.1 factory defaults.\n\nThis cannot be undone!',
                POPUP_TYPE.CONFIRM
            );
            if (confirmed) {
                resetFactoryDefaults();
                saveSettingsDebounced();
                await callGenericPopup('Factory defaults restored! Refreshing panel...', POPUP_TYPE.TEXT);
                refreshPanel();
            }
        });
    }

    // MINIMAP SETTINGS
    // =========================================================================
    const minimapEnabled = document.getElementById('mazemaster_minimap_enabled');
    if (minimapEnabled) {
        minimapEnabled.addEventListener('change', (e) => {
            if (!extensionSettings.minimapSettings) {
                extensionSettings.minimapSettings = { enabled: true };
            }
            extensionSettings.minimapSettings.enabled = e.target.checked;
            // Toggle minimap visibility if it exists
            const minimapContainer = document.getElementById('mazemaster_minimap_container');
            if (minimapContainer) {
                minimapContainer.style.display = e.target.checked ? '' : 'none';
            }
            saveSettingsDebounced();
        });
    }

    const minimapPosition = document.getElementById('mazemaster_minimap_position');
    if (minimapPosition) {
        minimapPosition.addEventListener('change', (e) => {
            if (!extensionSettings.minimapSettings) {
                extensionSettings.minimapSettings = { enabled: true };
            }
            extensionSettings.minimapSettings.position = e.target.value;
            // Update minimap position if it exists
            const minimapContainer = document.getElementById('mazemaster_minimap_container');
            if (minimapContainer) {
                minimapContainer.className = `mazemaster-minimap-container ${e.target.value}`;
            }
            saveSettingsDebounced();
        });
    }

    const minimapSize = document.getElementById('mazemaster_minimap_size');
    if (minimapSize) {
        minimapSize.addEventListener('change', (e) => {
            if (!extensionSettings.minimapSettings) {
                extensionSettings.minimapSettings = { enabled: true };
            }
            extensionSettings.minimapSettings.size = parseInt(e.target.value) || 150;
            // Update minimap size if it exists
            renderMinimap();
            saveSettingsDebounced();
        });
    }

    const minimapOpacity = document.getElementById('mazemaster_minimap_opacity');
    if (minimapOpacity) {
        minimapOpacity.addEventListener('input', (e) => {
            if (!extensionSettings.minimapSettings) {
                extensionSettings.minimapSettings = { enabled: true };
            }
            extensionSettings.minimapSettings.opacity = parseInt(e.target.value) / 100;
            // Update label
            const label = e.target.parentElement.querySelector('.mazemaster-range-value');
            if (label) label.textContent = `${e.target.value}%`;
            // Update minimap opacity if it exists
            const minimapContainer = document.getElementById('mazemaster_minimap_container');
            if (minimapContainer) {
                minimapContainer.style.opacity = extensionSettings.minimapSettings.opacity;
            }
            saveSettingsDebounced();
        });
    }

    const minimapShowMarkers = document.getElementById('mazemaster_minimap_show_markers');
    if (minimapShowMarkers) {
        minimapShowMarkers.addEventListener('change', (e) => {
            if (!extensionSettings.minimapSettings) {
                extensionSettings.minimapSettings = { enabled: true };
            }
            extensionSettings.minimapSettings.showMarkers = e.target.checked;
            renderMinimap();
            saveSettingsDebounced();
        });
    }

    const minimapShowMinions = document.getElementById('mazemaster_minimap_show_minions');
    if (minimapShowMinions) {
        minimapShowMinions.addEventListener('change', (e) => {
            if (!extensionSettings.minimapSettings) {
                extensionSettings.minimapSettings = { enabled: true };
            }
            extensionSettings.minimapSettings.showMinions = e.target.checked;
            renderMinimap();
            saveSettingsDebounced();
        });
    }

    const minimapShowChests = document.getElementById('mazemaster_minimap_show_chests');
    if (minimapShowChests) {
        minimapShowChests.addEventListener('change', (e) => {
            if (!extensionSettings.minimapSettings) {
                extensionSettings.minimapSettings = { enabled: true };
            }
            extensionSettings.minimapSettings.showChests = e.target.checked;
            renderMinimap();
            saveSettingsDebounced();
        });
    }

    // RENDERER SETTINGS
    // =========================================================================
    const rendererSelect = document.getElementById('mazemaster_renderer_type');
    if (rendererSelect) {
        rendererSelect.addEventListener('change', (e) => {
            extensionSettings.rendererType = e.target.value;
            RendererRegistry.getRenderer(e.target.value);  // Switch renderer
            saveSettingsDebounced();
        });
    }

    // LAYOUT MODE SETTINGS
    // =========================================================================
    const layoutSelect = document.getElementById('mazemaster_layout_mode');
    if (layoutSelect) {
        layoutSelect.addEventListener('change', (e) => {
            extensionSettings.layoutMode = e.target.value;
            saveSettingsDebounced();
            applyLayoutMode();  // Apply immediately
        });
    }

    // =========================================================================
    // BATTLEBAR HANDLERS
    // =========================================================================

    // Battlebar profile select
    const bbProfileSelect = document.getElementById('mazemaster_bb_profile_select');
    if (bbProfileSelect) {
        bbProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentBattlebarProfile = e.target.value;
            saveSettingsDebounced();
            updateBattlebarSettings();
            renderBattlebarImages();
        });
    }

    // Battlebar new profile
    const bbNewProfileBtn = document.getElementById('mazemaster_bb_new_profile_btn');
    if (bbNewProfileBtn) {
        bbNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new battlebar profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.battlebarProfiles[trimmed]) {
                    saveBattlebarProfile(trimmed, {});
                    extensionSettings.currentBattlebarProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    // Switch to battlebar view
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                    }, 100);
                } else {
                    await callGenericPopup(`Battlebar profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Battlebar delete profile
    const bbDeleteProfileBtn = document.getElementById('mazemaster_bb_delete_profile_btn');
    if (bbDeleteProfileBtn) {
        bbDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete battlebar profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteBattlebarProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                    }, 100);
                }
            }
        });
    }

    // Battlebar rename profile
    const bbRenameProfileBtn = document.getElementById('mazemaster_bb_rename_profile_btn');
    if (bbRenameProfileBtn) {
        bbRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_bb_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.battlebarProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.battlebarProfiles[trimmed] = extensionSettings.battlebarProfiles[oldName];
                delete extensionSettings.battlebarProfiles[oldName];
                extensionSettings.currentBattlebarProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                }, 100);
            }
        });
    }

    // Battlebar export
    const bbExportBtn = document.getElementById('mazemaster_bb_export_btn');
    if (bbExportBtn) {
        bbExportBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
            if (!profileName) {
                alert('No profile selected to export');
                return;
            }
            exportBattlebarProfile(profileName);
        });
    }

    // Battlebar import
    const bbImportBtn = document.getElementById('mazemaster_bb_import_btn');
    const bbImportFile = document.getElementById('mazemaster_bb_import_file');
    if (bbImportBtn && bbImportFile) {
        bbImportBtn.addEventListener('click', () => {
            bbImportFile.click();
        });

        bbImportFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            try {
                const profileName = await importBattlebarProfile(file);
                alert(`Battlebar profile "${profileName}" imported successfully!`);
                refreshPanel();
                document.getElementById('mazemaster_show_combat')?.click();
            } catch (err) {
                alert(`Import failed: ${err.message}`);
            }

            bbImportFile.value = '';
        });
    }

    // Battlebar save button
    const bbSaveBtn = document.getElementById('mazemaster_bb_save_btn');
    if (bbSaveBtn) {
        bbSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
            if (!profileName) {
                alert('Please create a battlebar profile first');
                return;
            }

            const profileData = collectBattlebarDataFromUI();

            // Validate required fields
            const errors = [];
            if (!profileData.hitsToWin || profileData.hitsToWin < 1) {
                errors.push('Hits to Win must be at least 1');
            }
            if (!profileData.missesToLose || profileData.missesToLose < 1) {
                errors.push('Misses to Lose must be at least 1');
            }
            if (!profileData.difficulty || profileData.difficulty < 1 || profileData.difficulty > 10) {
                errors.push('Difficulty must be between 1 and 10');
            }

            if (errors.length > 0) {
                alert('Validation Error:\n\n' + errors.join('\n'));
                return;
            }

            saveBattlebarProfile(profileName, profileData);
            alert(`Battlebar profile "${profileName}" saved!`);
        });
    }

    // Battlebar difficulty slider - update display value
    const bbDifficultySlider = document.getElementById('mazemaster_bb_difficulty');
    const bbDifficultyVal = document.getElementById('mazemaster_bb_diff_val');
    if (bbDifficultySlider && bbDifficultyVal) {
        bbDifficultySlider.addEventListener('input', (e) => {
            bbDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // Battlebar add image button
    const bbAddImageBtn = document.getElementById('mazemaster_bb_add_image_btn');
    const bbImageFile = document.getElementById('mazemaster_bb_image_file');
    if (bbAddImageBtn && bbImageFile) {
        bbAddImageBtn.addEventListener('click', () => {
            bbImageFile.click();
        });

        bbImageFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
            if (!profileName) {
                alert('Please create a profile first');
                bbImageFile.value = '';
                return;
            }

            try {
                const imagePath = await uploadBattlebarImage(file, profileName);
                const profile = getBattlebarProfile(profileName) || {};
                const images = profile.images || [];
                images.push({ path: imagePath, name: file.name });
                profile.images = images;
                saveBattlebarProfile(profileName, profile);
                renderBattlebarImages();
            } catch (err) {
                alert(`Image upload failed: ${err.message}`);
            }

            bbImageFile.value = '';
        });
    }

    // =========================================================================
    // TURN-BASED HANDLERS
    // =========================================================================

    // Turn-based profile select
    const tbProfileSelect = document.getElementById('mazemaster_tb_profile_select');
    if (tbProfileSelect) {
        tbProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentTurnbasedProfile = e.target.value;
            saveSettingsDebounced();
            loadTurnbasedProfileIntoUI(e.target.value);
        });
    }

    // Turn-based new profile
    const tbNewProfileBtn = document.getElementById('mazemaster_tb_new_profile_btn');
    if (tbNewProfileBtn) {
        tbNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new Turn-Based profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.turnbasedProfiles[trimmed]) {
                    const template = getTurnbasedProfile('Tutorial - Learn Turn-Based') || {};
                    saveTurnbasedProfile(trimmed, { ...template, mainTitle: trimmed });
                    extensionSettings.currentTurnbasedProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="turnbased"]')?.click();
                        }, 50);
                    }, 100);
                } else {
                    await callGenericPopup(`Turn-Based profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Turn-based delete profile
    const tbDeleteProfileBtn = document.getElementById('mazemaster_tb_delete_profile_btn');
    if (tbDeleteProfileBtn) {
        tbDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_tb_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete Turn-Based profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteTurnbasedProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="turnbased"]')?.click();
                        }, 50);
                    }, 100);
                }
            }
        });
    }

    // Turn-based rename profile
    const tbRenameProfileBtn = document.getElementById('mazemaster_tb_rename_profile_btn');
    if (tbRenameProfileBtn) {
        tbRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_tb_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.turnbasedProfiles[trimmed]) {
                    await callGenericPopup(`Profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                    return;
                }
                extensionSettings.turnbasedProfiles[trimmed] = extensionSettings.turnbasedProfiles[oldName];
                delete extensionSettings.turnbasedProfiles[oldName];
                extensionSettings.currentTurnbasedProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                    setTimeout(() => {
                        document.querySelector('[data-combat="turnbased"]')?.click();
                    }, 50);
                }, 100);
            }
        });
    }

    // Turn-based difficulty slider
    const tbDifficultySlider = document.getElementById('mazemaster_tb_difficulty');
    const tbDifficultyVal = document.getElementById('mazemaster_tb_diff_val');
    if (tbDifficultySlider && tbDifficultyVal) {
        tbDifficultySlider.addEventListener('input', (e) => {
            tbDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // Turn-based save button
    const tbSaveBtn = document.getElementById('mazemaster_tb_save_btn');
    if (tbSaveBtn) {
        tbSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_tb_profile_select')?.value;
            if (!profileName) {
                alert('Please create a Turn-Based profile first');
                return;
            }

            const profileData = {
                mainTitle: document.getElementById('mazemaster_tb_main_title')?.value || '',
                enemyName: document.getElementById('mazemaster_tb_enemy_name')?.value || 'Enemy',
                description: document.getElementById('mazemaster_tb_description')?.value || '',
                playerHP: parseInt(document.getElementById('mazemaster_tb_player_hp')?.value) || 100,
                playerAttack: parseInt(document.getElementById('mazemaster_tb_player_attack')?.value) || 15,
                playerDefense: parseInt(document.getElementById('mazemaster_tb_player_defense')?.value) || 5,
                enemyHP: parseInt(document.getElementById('mazemaster_tb_enemy_hp')?.value) || 50,
                enemyAttack: parseInt(document.getElementById('mazemaster_tb_enemy_attack')?.value) || 8,
                enemyDefense: parseInt(document.getElementById('mazemaster_tb_enemy_defense')?.value) || 2,
                turnOrder: document.getElementById('mazemaster_tb_turn_order')?.value || 'player_first',
                fleeChance: parseInt(document.getElementById('mazemaster_tb_flee_chance')?.value) || 50,
                critChance: parseInt(document.getElementById('mazemaster_tb_crit_chance')?.value) || 15,
                critMultiplier: parseFloat(document.getElementById('mazemaster_tb_crit_mult')?.value) || 1.5,
                difficulty: parseInt(document.getElementById('mazemaster_tb_difficulty')?.value) || 5,
                damage: parseInt(document.getElementById('mazemaster_tb_damage')?.value) || 15,
                onWin: document.getElementById('mazemaster_tb_on_win')?.value || '',
                onLose: document.getElementById('mazemaster_tb_on_lose')?.value || '',
                keyDropChance: parseInt(document.getElementById('mazemaster_tb_key_drop')?.value) || 30,
                strikeDropChance: parseInt(document.getElementById('mazemaster_tb_strike_drop')?.value) || 15,
                stealthDropChance: parseInt(document.getElementById('mazemaster_tb_stealth_drop')?.value) || 10,
                healingPotionDropChance: parseInt(document.getElementById('mazemaster_tb_potion_drop')?.value) || 25,
            };

            saveTurnbasedProfile(profileName, profileData);
            alert(`Turn-Based profile "${profileName}" saved!`);
        });
    }

    // Helper to load turn-based profile data into UI
    function loadTurnbasedProfileIntoUI(profileName) {
        const profile = getTurnbasedProfile(profileName) || {};
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        setVal('mazemaster_tb_main_title', profile.mainTitle);
        setVal('mazemaster_tb_enemy_name', profile.enemyName);
        setVal('mazemaster_tb_description', profile.description);
        setVal('mazemaster_tb_player_hp', profile.playerHP || 100);
        setVal('mazemaster_tb_player_attack', profile.playerAttack || 15);
        setVal('mazemaster_tb_player_defense', profile.playerDefense || 5);
        setVal('mazemaster_tb_enemy_hp', profile.enemyHP || 50);
        setVal('mazemaster_tb_enemy_attack', profile.enemyAttack || 8);
        setVal('mazemaster_tb_enemy_defense', profile.enemyDefense || 2);
        setVal('mazemaster_tb_turn_order', profile.turnOrder || 'player_first');
        setVal('mazemaster_tb_flee_chance', profile.fleeChance || 50);
        setVal('mazemaster_tb_crit_chance', profile.critChance || 15);
        setVal('mazemaster_tb_crit_mult', profile.critMultiplier || 1.5);
        setVal('mazemaster_tb_difficulty', profile.difficulty || 5);
        setVal('mazemaster_tb_damage', profile.damage || 15);
        setVal('mazemaster_tb_on_win', profile.onWin);
        setVal('mazemaster_tb_on_lose', profile.onLose);
        setVal('mazemaster_tb_key_drop', profile.keyDropChance || 30);
        setVal('mazemaster_tb_strike_drop', profile.strikeDropChance || 15);
        setVal('mazemaster_tb_stealth_drop', profile.stealthDropChance || 10);
        setVal('mazemaster_tb_potion_drop', profile.healingPotionDropChance || 25);
        // Update difficulty display
        const diffVal = document.getElementById('mazemaster_tb_diff_val');
        if (diffVal) diffVal.textContent = `(${profile.difficulty || 5})`;
    }

    // Load initial turn-based profile
    if (extensionSettings.currentTurnbasedProfile) {
        loadTurnbasedProfileIntoUI(extensionSettings.currentTurnbasedProfile);
    }

    // =========================================================================
    // QTE HANDLERS
    // =========================================================================

    // QTE profile select
    const qteProfileSelect = document.getElementById('mazemaster_qte_profile_select');
    if (qteProfileSelect) {
        qteProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentQteProfile = e.target.value;
            saveSettingsDebounced();
            loadQteProfileIntoUI(e.target.value);
        });
    }

    // QTE new profile
    const qteNewProfileBtn = document.getElementById('mazemaster_qte_new_profile_btn');
    if (qteNewProfileBtn) {
        qteNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new QTE profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.qteProfiles[trimmed]) {
                    // Create with defaults from tutorial profile
                    const template = getQteProfile('Tutorial - First Steps') || {};
                    saveQteProfile(trimmed, { ...template, mainTitle: trimmed });
                    extensionSettings.currentQteProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="qte"]')?.click();
                        }, 50);
                    }, 100);
                } else {
                    await callGenericPopup(`QTE profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // QTE delete profile
    const qteDeleteProfileBtn = document.getElementById('mazemaster_qte_delete_profile_btn');
    if (qteDeleteProfileBtn) {
        qteDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_qte_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete QTE profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteQteProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="qte"]')?.click();
                        }, 50);
                    }, 100);
                }
            }
        });
    }

    // QTE rename profile
    const qteRenameProfileBtn = document.getElementById('mazemaster_qte_rename_profile_btn');
    if (qteRenameProfileBtn) {
        qteRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_qte_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.qteProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.qteProfiles[trimmed] = extensionSettings.qteProfiles[oldName];
                extensionSettings.qteProfiles[trimmed].mainTitle = trimmed;
                delete extensionSettings.qteProfiles[oldName];
                extensionSettings.currentQteProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                    setTimeout(() => {
                        document.querySelector('[data-combat="qte"]')?.click();
                    }, 50);
                }, 100);
            }
        });
    }

    // QTE preview button
    const qtePreviewBtn = document.getElementById('mazemaster_preview_qte_btn');
    if (qtePreviewBtn) {
        qtePreviewBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_qte_profile_select')?.value;
            if (!profileName) {
                alert('Please select a QTE profile first');
                return;
            }
            const result = startQTE(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
            }
        });
    }

    // QTE difficulty slider
    const qteDifficultySlider = document.getElementById('mazemaster_qte_difficulty');
    const qteDifficultyVal = document.getElementById('mazemaster_qte_diff_val');
    if (qteDifficultySlider && qteDifficultyVal) {
        qteDifficultySlider.addEventListener('input', (e) => {
            qteDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // QTE save button
    const qteSaveBtn = document.getElementById('mazemaster_qte_save_btn');
    if (qteSaveBtn) {
        qteSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_qte_profile_select')?.value;
            if (!profileName) {
                alert('Please create a QTE profile first');
                return;
            }

            const allowedKeys = [];
            if (document.getElementById('mazemaster_qte_key_w')?.checked) allowedKeys.push('W');
            if (document.getElementById('mazemaster_qte_key_a')?.checked) allowedKeys.push('A');
            if (document.getElementById('mazemaster_qte_key_s')?.checked) allowedKeys.push('S');
            if (document.getElementById('mazemaster_qte_key_d')?.checked) allowedKeys.push('D');
            if (document.getElementById('mazemaster_qte_key_space')?.checked) allowedKeys.push('SPACE');

            const profileData = {
                mainTitle: document.getElementById('mazemaster_qte_main_title')?.value || '',
                description: document.getElementById('mazemaster_qte_description')?.value || '',
                sequenceLengthMin: parseInt(document.getElementById('mazemaster_qte_seq_min')?.value) || 3,
                sequenceLengthMax: parseInt(document.getElementById('mazemaster_qte_seq_max')?.value) || 5,
                timeWindowBase: parseInt(document.getElementById('mazemaster_qte_time_base')?.value) || 1500,
                timeWindowMin: parseInt(document.getElementById('mazemaster_qte_time_min')?.value) || 800,
                difficulty: parseInt(document.getElementById('mazemaster_qte_difficulty')?.value) || 5,
                damage: parseInt(document.getElementById('mazemaster_qte_damage')?.value) || 10,
                perfectWindowPercent: parseInt(document.getElementById('mazemaster_qte_perfect')?.value) || 30,
                allowedKeys: allowedKeys,
                onComplete: document.getElementById('mazemaster_qte_on_complete')?.value || '',
                onFail: document.getElementById('mazemaster_qte_on_fail')?.value || '',
            };

            saveQteProfile(profileName, profileData);
            alert(`QTE profile "${profileName}" saved!`);
        });
    }

    // Helper to load QTE profile data into UI
    function loadQteProfileIntoUI(profileName) {
        const profile = getQteProfile(profileName) || {};
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        const setCheck = (id, val) => { const el = document.getElementById(id); if (el) el.checked = val; };
        setVal('mazemaster_qte_main_title', profile.mainTitle);
        setVal('mazemaster_qte_description', profile.description);
        setVal('mazemaster_qte_seq_min', profile.sequenceLengthMin || 3);
        setVal('mazemaster_qte_seq_max', profile.sequenceLengthMax || 5);
        setVal('mazemaster_qte_time_base', profile.timeWindowBase || 1500);
        setVal('mazemaster_qte_time_min', profile.timeWindowMin || 800);
        setVal('mazemaster_qte_difficulty', profile.difficulty || 5);
        setVal('mazemaster_qte_damage', profile.damage || 10);
        setVal('mazemaster_qte_perfect', profile.perfectWindowPercent || 30);
        setVal('mazemaster_qte_on_complete', profile.onComplete);
        setVal('mazemaster_qte_on_fail', profile.onFail);
        // Allowed keys checkboxes
        const keys = profile.allowedKeys || ['W', 'A', 'S', 'D', 'SPACE'];
        setCheck('mazemaster_qte_key_w', keys.includes('W'));
        setCheck('mazemaster_qte_key_a', keys.includes('A'));
        setCheck('mazemaster_qte_key_s', keys.includes('S'));
        setCheck('mazemaster_qte_key_d', keys.includes('D'));
        setCheck('mazemaster_qte_key_space', keys.includes('SPACE'));
        // Update difficulty display
        const diffVal = document.getElementById('mazemaster_qte_diff_val');
        if (diffVal) diffVal.textContent = `(${profile.difficulty || 5})`;
    }

    // Load initial QTE profile
    if (extensionSettings.currentQteProfile) {
        loadQteProfileIntoUI(extensionSettings.currentQteProfile);
    }

    // =========================================================================
    // DICE HANDLERS
    // =========================================================================

    // Dice profile select
    const diceProfileSelect = document.getElementById('mazemaster_dice_profile_select');
    if (diceProfileSelect) {
        diceProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentDiceProfile = e.target.value;
            saveSettingsDebounced();
            loadDiceProfileIntoUI(e.target.value);
        });
    }

    // Dice new profile
    const diceNewProfileBtn = document.getElementById('mazemaster_dice_new_profile_btn');
    if (diceNewProfileBtn) {
        diceNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new Dice profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.diceProfiles[trimmed]) {
                    // Create with defaults from tutorial profile
                    const template = getDiceProfile('Tutorial - Luck Practice') || {};
                    saveDiceProfile(trimmed, { ...template, mainTitle: trimmed });
                    extensionSettings.currentDiceProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="dice"]')?.click();
                        }, 50);
                    }, 100);
                } else {
                    await callGenericPopup(`Dice profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Dice delete profile
    const diceDeleteProfileBtn = document.getElementById('mazemaster_dice_delete_profile_btn');
    if (diceDeleteProfileBtn) {
        diceDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_dice_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete Dice profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteDiceProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="dice"]')?.click();
                        }, 50);
                    }, 100);
                }
            }
        });
    }

    // Dice rename profile
    const diceRenameProfileBtn = document.getElementById('mazemaster_dice_rename_profile_btn');
    if (diceRenameProfileBtn) {
        diceRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_dice_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.diceProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.diceProfiles[trimmed] = extensionSettings.diceProfiles[oldName];
                extensionSettings.diceProfiles[trimmed].mainTitle = trimmed;
                delete extensionSettings.diceProfiles[oldName];
                extensionSettings.currentDiceProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                    setTimeout(() => {
                        document.querySelector('[data-combat="dice"]')?.click();
                    }, 50);
                }, 100);
            }
        });
    }

    // Dice preview button
    const dicePreviewBtn = document.getElementById('mazemaster_preview_dice_btn');
    if (dicePreviewBtn) {
        dicePreviewBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_dice_profile_select')?.value;
            if (!profileName) {
                alert('Please select a Dice profile first');
                return;
            }
            const result = startDice(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
            }
        });
    }

    // Dice difficulty slider
    const diceDifficultySlider = document.getElementById('mazemaster_dice_difficulty');
    const diceDifficultyVal = document.getElementById('mazemaster_dice_diff_val');
    if (diceDifficultySlider && diceDifficultyVal) {
        diceDifficultySlider.addEventListener('input', (e) => {
            diceDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // Dice save button
    const diceSaveBtn = document.getElementById('mazemaster_dice_save_btn');
    if (diceSaveBtn) {
        diceSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_dice_profile_select')?.value;
            if (!profileName) {
                alert('Please create a Dice profile first');
                return;
            }

            const profileData = {
                mainTitle: document.getElementById('mazemaster_dice_main_title')?.value || '',
                description: document.getElementById('mazemaster_dice_description')?.value || '',
                diceCount: parseInt(document.getElementById('mazemaster_dice_count')?.value) || 2,
                diceType: parseInt(document.getElementById('mazemaster_dice_type')?.value) || 6,
                targetNumber: parseInt(document.getElementById('mazemaster_dice_target')?.value) || 7,
                modifier: parseInt(document.getElementById('mazemaster_dice_modifier')?.value) || 0,
                difficulty: parseInt(document.getElementById('mazemaster_dice_difficulty')?.value) || 5,
                damage: parseInt(document.getElementById('mazemaster_dice_damage')?.value) || 15,
                rerolls: parseInt(document.getElementById('mazemaster_dice_rerolls')?.value) || 1,
                onSuccess: document.getElementById('mazemaster_dice_on_success')?.value || '',
                onFail: document.getElementById('mazemaster_dice_on_fail')?.value || '',
                onCritical: document.getElementById('mazemaster_dice_on_crit')?.value || '',
            };

            saveDiceProfile(profileName, profileData);
            alert(`Dice profile "${profileName}" saved!`);
        });
    }

    // Helper to load Dice profile data into UI
    function loadDiceProfileIntoUI(profileName) {
        const profile = getDiceProfile(profileName) || {};
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        setVal('mazemaster_dice_main_title', profile.mainTitle);
        setVal('mazemaster_dice_description', profile.description);
        setVal('mazemaster_dice_count', profile.diceCount || 2);
        setVal('mazemaster_dice_type', profile.diceType || 6);
        setVal('mazemaster_dice_target', profile.targetNumber || 7);
        setVal('mazemaster_dice_modifier', profile.modifier || 0);
        setVal('mazemaster_dice_difficulty', profile.difficulty || 5);
        setVal('mazemaster_dice_damage', profile.damage || 15);
        setVal('mazemaster_dice_rerolls', profile.rerolls || 1);
        setVal('mazemaster_dice_on_success', profile.onSuccess);
        setVal('mazemaster_dice_on_fail', profile.onFail);
        setVal('mazemaster_dice_on_crit', profile.onCritical);
        // Update difficulty display
        const diffVal = document.getElementById('mazemaster_dice_diff_val');
        if (diffVal) diffVal.textContent = `(${profile.difficulty || 5})`;
    }

    // Load initial Dice profile
    if (extensionSettings.currentDiceProfile) {
        loadDiceProfileIntoUI(extensionSettings.currentDiceProfile);
    }

    // =========================================================================
    // STEALTH HANDLERS
    // =========================================================================

    // Stealth profile select
    const stealthProfileSelect = document.getElementById('mazemaster_stealth_profile_select');
    if (stealthProfileSelect) {
        stealthProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentStealthProfile = e.target.value;
            saveSettingsDebounced();
            loadStealthProfileIntoUI(e.target.value);
        });
    }

    // Stealth new profile
    const stealthNewProfileBtn = document.getElementById('mazemaster_stealth_new_profile_btn');
    if (stealthNewProfileBtn) {
        stealthNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new Stealth profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.stealthProfiles[trimmed]) {
                    // Create with defaults from tutorial profile
                    const template = getStealthProfile('Tutorial - Stealth Basics') || {};
                    saveStealthProfile(trimmed, { ...template, mainTitle: trimmed });
                    extensionSettings.currentStealthProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="stealth"]')?.click();
                        }, 50);
                    }, 100);
                } else {
                    await callGenericPopup(`Stealth profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Stealth delete profile
    const stealthDeleteProfileBtn = document.getElementById('mazemaster_stealth_delete_profile_btn');
    if (stealthDeleteProfileBtn) {
        stealthDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_stealth_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete Stealth profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteStealthProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="stealth"]')?.click();
                        }, 50);
                    }, 100);
                }
            }
        });
    }

    // Stealth rename profile
    const stealthRenameProfileBtn = document.getElementById('mazemaster_stealth_rename_profile_btn');
    if (stealthRenameProfileBtn) {
        stealthRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_stealth_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.stealthProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.stealthProfiles[trimmed] = extensionSettings.stealthProfiles[oldName];
                extensionSettings.stealthProfiles[trimmed].mainTitle = trimmed;
                delete extensionSettings.stealthProfiles[oldName];
                extensionSettings.currentStealthProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                    setTimeout(() => {
                        document.querySelector('[data-combat="stealth"]')?.click();
                    }, 50);
                }, 100);
            }
        });
    }

    // Stealth preview button
    const stealthPreviewBtn = document.getElementById('mazemaster_preview_stealth_btn');
    if (stealthPreviewBtn) {
        stealthPreviewBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_stealth_profile_select')?.value;
            if (!profileName) {
                alert('Please select a Stealth profile first');
                return;
            }
            const result = startStealth(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
            }
        });
    }

    // Stealth difficulty slider
    const stealthDifficultySlider = document.getElementById('mazemaster_stealth_difficulty');
    const stealthDifficultyVal = document.getElementById('mazemaster_stealth_diff_val');
    if (stealthDifficultySlider && stealthDifficultyVal) {
        stealthDifficultySlider.addEventListener('input', (e) => {
            stealthDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // Stealth save button
    const stealthSaveBtn = document.getElementById('mazemaster_stealth_save_btn');
    if (stealthSaveBtn) {
        stealthSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_stealth_profile_select')?.value;
            if (!profileName) {
                alert('Please create a Stealth profile first');
                return;
            }

            const profileData = {
                mainTitle: document.getElementById('mazemaster_stealth_main_title')?.value || '',
                guardName: document.getElementById('mazemaster_stealth_guard_name')?.value || 'Guard',
                description: document.getElementById('mazemaster_stealth_description')?.value || '',
                sections: parseInt(document.getElementById('mazemaster_stealth_sections')?.value) || 3,
                detectionLimit: parseInt(document.getElementById('mazemaster_stealth_detection_limit')?.value) || 100,
                baseDetection: parseInt(document.getElementById('mazemaster_stealth_base_detection')?.value) || 15,
                damage: parseInt(document.getElementById('mazemaster_stealth_damage')?.value) || 20,
                difficulty: parseInt(document.getElementById('mazemaster_stealth_difficulty')?.value) || 5,
                hideReduction: parseInt(document.getElementById('mazemaster_stealth_hide_reduce')?.value) || 10,
                distractMax: parseInt(document.getElementById('mazemaster_stealth_distract_max')?.value) || 25,
                onSuccess: document.getElementById('mazemaster_stealth_on_success')?.value || '',
                onCaught: document.getElementById('mazemaster_stealth_on_caught')?.value || '',
            };

            saveStealthProfile(profileName, profileData);
            alert(`Stealth profile "${profileName}" saved!`);
        });
    }

    // Helper to load Stealth profile data into UI
    function loadStealthProfileIntoUI(profileName) {
        const profile = getStealthProfile(profileName) || {};
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        setVal('mazemaster_stealth_main_title', profile.mainTitle);
        setVal('mazemaster_stealth_guard_name', profile.guardName || 'Guard');
        setVal('mazemaster_stealth_description', profile.description);
        setVal('mazemaster_stealth_sections', profile.sections || 3);
        setVal('mazemaster_stealth_detection_limit', profile.detectionLimit || 100);
        setVal('mazemaster_stealth_base_detection', profile.baseDetection || 15);
        setVal('mazemaster_stealth_damage', profile.damage || 20);
        setVal('mazemaster_stealth_difficulty', profile.difficulty || 5);
        setVal('mazemaster_stealth_hide_reduce', profile.hideReduction || 10);
        setVal('mazemaster_stealth_distract_max', profile.distractMax || 25);
        setVal('mazemaster_stealth_on_success', profile.onSuccess);
        setVal('mazemaster_stealth_on_caught', profile.onCaught);
        // Update difficulty display
        const diffVal = document.getElementById('mazemaster_stealth_diff_val');
        if (diffVal) diffVal.textContent = `(${profile.difficulty || 5})`;
    }

    // Load initial Stealth profile
    if (extensionSettings.currentStealthProfile) {
        loadStealthProfileIntoUI(extensionSettings.currentStealthProfile);
    }

    // =========================================================================
    // PUZZLE HANDLERS
    // =========================================================================

    // Puzzle profile select
    const puzzleProfileSelect = document.getElementById('mazemaster_puzzle_profile_select');
    if (puzzleProfileSelect) {
        puzzleProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentPuzzleProfile = e.target.value;
            saveSettingsDebounced();
            loadPuzzleProfileIntoUI(e.target.value);
        });
    }

    // Puzzle new profile
    const puzzleNewProfileBtn = document.getElementById('mazemaster_puzzle_new_profile_btn');
    if (puzzleNewProfileBtn) {
        puzzleNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new Puzzle profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.puzzleProfiles[trimmed]) {
                    // Create with defaults from tutorial profile
                    const template = getPuzzleProfile('Tutorial - Mind Training') || {};
                    savePuzzleProfile(trimmed, { ...template, mainTitle: trimmed });
                    extensionSettings.currentPuzzleProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="puzzle"]')?.click();
                        }, 50);
                    }, 100);
                } else {
                    await callGenericPopup(`Puzzle profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Puzzle delete profile
    const puzzleDeleteProfileBtn = document.getElementById('mazemaster_puzzle_delete_profile_btn');
    if (puzzleDeleteProfileBtn) {
        puzzleDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_puzzle_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete Puzzle profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deletePuzzleProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="puzzle"]')?.click();
                        }, 50);
                    }, 100);
                }
            }
        });
    }

    // Puzzle rename profile
    const puzzleRenameProfileBtn = document.getElementById('mazemaster_puzzle_rename_profile_btn');
    if (puzzleRenameProfileBtn) {
        puzzleRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_puzzle_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.puzzleProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.puzzleProfiles[trimmed] = extensionSettings.puzzleProfiles[oldName];
                extensionSettings.puzzleProfiles[trimmed].mainTitle = trimmed;
                delete extensionSettings.puzzleProfiles[oldName];
                extensionSettings.currentPuzzleProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                    setTimeout(() => {
                        document.querySelector('[data-combat="puzzle"]')?.click();
                    }, 50);
                }, 100);
            }
        });
    }

    // Puzzle preview button
    const puzzlePreviewBtn = document.getElementById('mazemaster_preview_puzzle_btn');
    if (puzzlePreviewBtn) {
        puzzlePreviewBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_puzzle_profile_select')?.value;
            if (!profileName) {
                alert('Please select a Puzzle profile first');
                return;
            }
            const result = startPuzzle(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
            }
        });
    }

    // Puzzle difficulty slider
    const puzzleDifficultySlider = document.getElementById('mazemaster_puzzle_difficulty');
    const puzzleDifficultyVal = document.getElementById('mazemaster_puzzle_diff_val');
    if (puzzleDifficultySlider && puzzleDifficultyVal) {
        puzzleDifficultySlider.addEventListener('input', (e) => {
            puzzleDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // Puzzle save button
    const puzzleSaveBtn = document.getElementById('mazemaster_puzzle_save_btn');
    if (puzzleSaveBtn) {
        puzzleSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_puzzle_profile_select')?.value;
            if (!profileName) {
                alert('Please create a Puzzle profile first');
                return;
            }

            const profileData = {
                mainTitle: document.getElementById('mazemaster_puzzle_main_title')?.value || '',
                description: document.getElementById('mazemaster_puzzle_description')?.value || '',
                gridSize: parseInt(document.getElementById('mazemaster_puzzle_grid_size')?.value) || 3,
                sequenceLength: parseInt(document.getElementById('mazemaster_puzzle_seq_length')?.value) || 4,
                maxMistakes: parseInt(document.getElementById('mazemaster_puzzle_max_mistakes')?.value) || 5,
                hints: parseInt(document.getElementById('mazemaster_puzzle_hints')?.value) || 3,
                difficulty: parseInt(document.getElementById('mazemaster_puzzle_difficulty')?.value) || 5,
                damage: parseInt(document.getElementById('mazemaster_puzzle_damage')?.value) || 15,
                timeLimit: parseInt(document.getElementById('mazemaster_puzzle_time_limit')?.value) || 60,
                onSolve: document.getElementById('mazemaster_puzzle_on_solve')?.value || '',
                onFail: document.getElementById('mazemaster_puzzle_on_fail')?.value || '',
            };

            savePuzzleProfile(profileName, profileData);
            alert(`Puzzle profile "${profileName}" saved!`);
        });
    }

    // Helper to load Puzzle profile data into UI
    function loadPuzzleProfileIntoUI(profileName) {
        const profile = getPuzzleProfile(profileName) || {};
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        setVal('mazemaster_puzzle_main_title', profile.mainTitle);
        setVal('mazemaster_puzzle_description', profile.description);
        setVal('mazemaster_puzzle_grid_size', profile.gridSize || 3);
        setVal('mazemaster_puzzle_seq_length', profile.sequenceLength || 4);
        setVal('mazemaster_puzzle_max_mistakes', profile.maxMistakes || 5);
        setVal('mazemaster_puzzle_hints', profile.hints || 3);
        setVal('mazemaster_puzzle_difficulty', profile.difficulty || 5);
        setVal('mazemaster_puzzle_damage', profile.damage || 15);
        setVal('mazemaster_puzzle_time_limit', profile.timeLimit || 60);
        setVal('mazemaster_puzzle_on_solve', profile.onSolve);
        setVal('mazemaster_puzzle_on_fail', profile.onFail);
        // Update difficulty display
        const diffVal = document.getElementById('mazemaster_puzzle_diff_val');
        if (diffVal) diffVal.textContent = `(${profile.difficulty || 5})`;
    }

    // Load initial Puzzle profile
    if (extensionSettings.currentPuzzleProfile) {
        loadPuzzleProfileIntoUI(extensionSettings.currentPuzzleProfile);
    }

    // =========================================================================
    // NEGOTIATION HANDLERS
    // =========================================================================

    // Negotiation profile select
    const negotiationProfileSelect = document.getElementById('mazemaster_negotiation_profile_select');
    if (negotiationProfileSelect) {
        negotiationProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentNegotiationProfile = e.target.value;
            saveSettingsDebounced();
            loadNegotiationProfileIntoUI(e.target.value);
        });
    }

    // Negotiation new profile
    const negotiationNewProfileBtn = document.getElementById('mazemaster_negotiation_new_profile_btn');
    if (negotiationNewProfileBtn) {
        negotiationNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new Negotiation profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.negotiationProfiles[trimmed]) {
                    // Create with defaults from tutorial profile
                    const template = getNegotiationProfile('Tutorial - Social Training') || {};
                    saveNegotiationProfile(trimmed, { ...template, mainTitle: trimmed });
                    extensionSettings.currentNegotiationProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="negotiation"]')?.click();
                        }, 50);
                    }, 100);
                } else {
                    await callGenericPopup(`Negotiation profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Negotiation delete profile
    const negotiationDeleteProfileBtn = document.getElementById('mazemaster_negotiation_delete_profile_btn');
    if (negotiationDeleteProfileBtn) {
        negotiationDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_negotiation_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete Negotiation profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteNegotiationProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="negotiation"]')?.click();
                        }, 50);
                    }, 100);
                }
            }
        });
    }

    // Negotiation rename profile
    const negotiationRenameProfileBtn = document.getElementById('mazemaster_negotiation_rename_profile_btn');
    if (negotiationRenameProfileBtn) {
        negotiationRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_negotiation_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.negotiationProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.negotiationProfiles[trimmed] = extensionSettings.negotiationProfiles[oldName];
                extensionSettings.negotiationProfiles[trimmed].mainTitle = trimmed;
                delete extensionSettings.negotiationProfiles[oldName];
                extensionSettings.currentNegotiationProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                    setTimeout(() => {
                        document.querySelector('[data-combat="negotiation"]')?.click();
                    }, 50);
                }, 100);
            }
        });
    }

    // Negotiation preview button
    const negotiationPreviewBtn = document.getElementById('mazemaster_preview_negotiation_btn');
    if (negotiationPreviewBtn) {
        negotiationPreviewBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_negotiation_profile_select')?.value;
            if (!profileName) {
                alert('Please select a Negotiation profile first');
                return;
            }
            const result = startNegotiation(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
            }
        });
    }

    // Negotiation difficulty slider
    const negotiateDifficultySlider = document.getElementById('mazemaster_negotiate_difficulty');
    const negotiateDifficultyVal = document.getElementById('mazemaster_negotiate_diff_val');
    if (negotiateDifficultySlider && negotiateDifficultyVal) {
        negotiateDifficultySlider.addEventListener('input', (e) => {
            negotiateDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // Negotiation save button
    const negotiateSaveBtn = document.getElementById('mazemaster_negotiate_save_btn');
    if (negotiateSaveBtn) {
        negotiateSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_negotiation_profile_select')?.value;
            if (!profileName) {
                alert('Please create a Negotiation profile first');
                return;
            }

            const profileData = {
                mainTitle: document.getElementById('mazemaster_negotiate_main_title')?.value || '',
                npcName: document.getElementById('mazemaster_negotiate_npc_name')?.value || 'NPC',
                description: document.getElementById('mazemaster_negotiate_description')?.value || '',
                favorTarget: parseInt(document.getElementById('mazemaster_negotiate_favor_target')?.value) || 75,
                startingFavor: parseInt(document.getElementById('mazemaster_negotiate_starting_favor')?.value) || 25,
                maxTurns: parseInt(document.getElementById('mazemaster_negotiate_max_turns')?.value) || 6,
                damage: parseInt(document.getElementById('mazemaster_negotiate_damage')?.value) || 10,
                difficulty: parseInt(document.getElementById('mazemaster_negotiate_difficulty')?.value) || 5,
                persuadeAvg: parseInt(document.getElementById('mazemaster_negotiate_persuade')?.value) || 12,
                flatterAvg: parseInt(document.getElementById('mazemaster_negotiate_flatter')?.value) || 10,
                startingMood: document.getElementById('mazemaster_negotiate_mood')?.value || 'unfriendly',
                intimidateRisk: document.getElementById('mazemaster_negotiate_intimidate')?.value || 'medium',
                bribeCost: document.getElementById('mazemaster_negotiate_bribe_cost')?.value || 'gold',
                onSuccess: document.getElementById('mazemaster_negotiate_on_success')?.value || '',
                onFail: document.getElementById('mazemaster_negotiate_on_fail')?.value || '',
            };

            saveNegotiationProfile(profileName, profileData);
            alert(`Negotiation profile "${profileName}" saved!`);
        });
    }

    // Helper to load Negotiation profile data into UI
    function loadNegotiationProfileIntoUI(profileName) {
        const profile = getNegotiationProfile(profileName) || {};
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        setVal('mazemaster_negotiate_main_title', profile.mainTitle);
        setVal('mazemaster_negotiate_npc_name', profile.npcName || 'NPC');
        setVal('mazemaster_negotiate_description', profile.description);
        setVal('mazemaster_negotiate_favor_target', profile.favorTarget || 75);
        setVal('mazemaster_negotiate_starting_favor', profile.startingFavor || 25);
        setVal('mazemaster_negotiate_max_turns', profile.maxTurns || 6);
        setVal('mazemaster_negotiate_damage', profile.damage || 10);
        setVal('mazemaster_negotiate_difficulty', profile.difficulty || 5);
        setVal('mazemaster_negotiate_persuade', profile.persuadeAvg || 12);
        setVal('mazemaster_negotiate_flatter', profile.flatterAvg || 10);
        setVal('mazemaster_negotiate_mood', profile.startingMood || 'unfriendly');
        setVal('mazemaster_negotiate_intimidate', profile.intimidateRisk || 'medium');
        setVal('mazemaster_negotiate_bribe_cost', profile.bribeCost || 'gold');
        setVal('mazemaster_negotiate_on_success', profile.onSuccess);
        setVal('mazemaster_negotiate_on_fail', profile.onFail);
        // Update difficulty display
        const diffVal = document.getElementById('mazemaster_negotiate_diff_val');
        if (diffVal) diffVal.textContent = `(${profile.difficulty || 5})`;
    }

    // Load initial Negotiation profile
    if (extensionSettings.currentNegotiationProfile) {
        loadNegotiationProfileIntoUI(extensionSettings.currentNegotiationProfile);
    }

    // =========================================================================
    // v1.6.0: COMBAT MECHANICS HANDLERS
    // =========================================================================

    // Combat Mechanics profile select
    const cmProfileSelect = document.getElementById('mazemaster_cm_profile_select');
    if (cmProfileSelect) {
        cmProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentCombatMechanicsProfile = e.target.value;
            saveSettingsDebounced();
            loadCombatMechanicsProfileIntoUI(e.target.value);
        });
    }

    // Combat Mechanics new profile
    const cmNewProfileBtn = document.getElementById('mazemaster_cm_new_profile_btn');
    if (cmNewProfileBtn) {
        cmNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new combat mechanics profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.combatMechanicsProfiles?.[trimmed] && !DEFAULT_COMBAT_MECHANICS_PROFILES[trimmed]) {
                    saveCombatMechanicsProfile(trimmed, DEFAULT_COMBAT_MECHANICS_PROFILES.default);
                    extensionSettings.currentCombatMechanicsProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('.combat-subtab[data-combat="mechanics"]')?.click();
                        }, 100);
                    }, 100);
                } else {
                    await callGenericPopup(`Combat mechanics profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Combat Mechanics delete profile
    const cmDeleteProfileBtn = document.getElementById('mazemaster_cm_delete_profile_btn');
    if (cmDeleteProfileBtn) {
        cmDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_cm_profile_select')?.value;
            if (profileName) {
                if (DEFAULT_COMBAT_MECHANICS_PROFILES[profileName]) {
                    await callGenericPopup('Cannot delete default profiles.', POPUP_TYPE.TEXT);
                    return;
                }
                const confirmed = await callGenericPopup(`Delete combat mechanics profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteCombatMechanicsProfile(profileName);
                    refreshPanel();
                }
            }
        });
    }

    // Combat Mechanics rename profile
    const cmRenameProfileBtn = document.getElementById('mazemaster_cm_rename_profile_btn');
    if (cmRenameProfileBtn) {
        cmRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_cm_profile_select')?.value;
            if (!oldName) return;
            if (DEFAULT_COMBAT_MECHANICS_PROFILES[oldName]) {
                await callGenericPopup('Cannot rename default profiles.', POPUP_TYPE.TEXT);
                return;
            }
            const newName = await callGenericPopup('Enter new name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                const oldProfile = getCombatMechanicsProfileData(oldName);
                saveCombatMechanicsProfile(trimmed, oldProfile);
                deleteCombatMechanicsProfile(oldName);
                extensionSettings.currentCombatMechanicsProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
            }
        });
    }

    // Combat Mechanics save button
    const cmSaveBtn = document.getElementById('mazemaster_cm_save_btn');
    if (cmSaveBtn) {
        cmSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_cm_profile_select')?.value;
            if (!profileName) {
                alert('Please select a combat mechanics profile first');
                return;
            }

            const profileData = {
                name: profileName,
                // Combo
                comboEnabled: document.getElementById('mazemaster_cm_combo_enabled')?.checked ?? true,
                comboBonusPerHit: parseInt(document.getElementById('mazemaster_cm_combo_bonus')?.value) || 5,
                maxComboBonus: parseInt(document.getElementById('mazemaster_cm_combo_max')?.value) || 50,
                comboDecayTurns: parseInt(document.getElementById('mazemaster_cm_combo_decay')?.value) || 2,
                comboResetOnMiss: document.getElementById('mazemaster_cm_combo_reset_miss')?.checked ?? true,
                comboResetOnDamage: document.getElementById('mazemaster_cm_combo_reset_damage')?.checked ?? false,
                // Block
                blockEnabled: document.getElementById('mazemaster_cm_block_enabled')?.checked ?? true,
                blockDamageReduction: (parseInt(document.getElementById('mazemaster_cm_block_reduction')?.value) || 50) / 100,
                blockBreakThreshold: parseInt(document.getElementById('mazemaster_cm_block_threshold')?.value) || 0,
                perfectBlockReduction: (parseInt(document.getElementById('mazemaster_cm_perfect_block')?.value) || 80) / 100,
                // Parry
                parryEnabled: document.getElementById('mazemaster_cm_parry_enabled')?.checked ?? true,
                parryWindow: parseFloat(document.getElementById('mazemaster_cm_parry_window')?.value) || 0.5,
                parryDamageMultiplier: parseFloat(document.getElementById('mazemaster_cm_parry_mult')?.value) || 1.5,
                parryStunDuration: parseInt(document.getElementById('mazemaster_cm_parry_stun')?.value) || 1,
                parryDifficulty: document.getElementById('mazemaster_cm_parry_diff')?.value || 'normal',
                // Counter
                counterEnabled: document.getElementById('mazemaster_cm_counter_enabled')?.checked ?? true,
                counterDamageBonus: parseInt(document.getElementById('mazemaster_cm_counter_bonus')?.value) || 25,
                counterCritBonus: parseInt(document.getElementById('mazemaster_cm_counter_crit')?.value) || 15,
                // Hooks
                onComboIncrease: document.getElementById('mazemaster_cm_on_combo')?.value || '',
                onComboBreak: document.getElementById('mazemaster_cm_on_combo_break')?.value || '',
                onBlockSuccess: document.getElementById('mazemaster_cm_on_block')?.value || '',
                onParrySuccess: document.getElementById('mazemaster_cm_on_parry')?.value || '',
                onCounterAttack: document.getElementById('mazemaster_cm_on_counter')?.value || '',
            };

            saveCombatMechanicsProfile(profileName, profileData);
            toastr.success(`Combat mechanics profile "${profileName}" saved!`);
        });
    }

    // Helper to load Combat Mechanics profile data into UI
    function loadCombatMechanicsProfileIntoUI(profileName) {
        const profile = getCombatMechanicsProfileData(profileName) || DEFAULT_COMBAT_MECHANICS_PROFILES.default;
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        const setChecked = (id, val) => { const el = document.getElementById(id); if (el) el.checked = val ?? false; };

        // Combo
        setChecked('mazemaster_cm_combo_enabled', profile.comboEnabled);
        setVal('mazemaster_cm_combo_bonus', profile.comboBonusPerHit || 5);
        setVal('mazemaster_cm_combo_max', profile.maxComboBonus || 50);
        setVal('mazemaster_cm_combo_decay', profile.comboDecayTurns || 2);
        setChecked('mazemaster_cm_combo_reset_miss', profile.comboResetOnMiss !== false);
        setChecked('mazemaster_cm_combo_reset_damage', profile.comboResetOnDamage || false);

        // Block
        setChecked('mazemaster_cm_block_enabled', profile.blockEnabled);
        setVal('mazemaster_cm_block_reduction', Math.round((profile.blockDamageReduction || 0.5) * 100));
        setVal('mazemaster_cm_block_threshold', profile.blockBreakThreshold || 0);
        setVal('mazemaster_cm_perfect_block', Math.round((profile.perfectBlockReduction || 0.8) * 100));

        // Parry
        setChecked('mazemaster_cm_parry_enabled', profile.parryEnabled);
        setVal('mazemaster_cm_parry_window', profile.parryWindow || 0.5);
        setVal('mazemaster_cm_parry_mult', profile.parryDamageMultiplier || 1.5);
        setVal('mazemaster_cm_parry_stun', profile.parryStunDuration || 1);
        setVal('mazemaster_cm_parry_diff', profile.parryDifficulty || 'normal');

        // Counter
        setChecked('mazemaster_cm_counter_enabled', profile.counterEnabled !== false);
        setVal('mazemaster_cm_counter_bonus', profile.counterDamageBonus || 25);
        setVal('mazemaster_cm_counter_crit', profile.counterCritBonus || 15);

        // Hooks
        setVal('mazemaster_cm_on_combo', profile.onComboIncrease || '');
        setVal('mazemaster_cm_on_combo_break', profile.onComboBreak || '');
        setVal('mazemaster_cm_on_block', profile.onBlockSuccess || '');
        setVal('mazemaster_cm_on_parry', profile.onParrySuccess || '');
        setVal('mazemaster_cm_on_counter', profile.onCounterAttack || '');
    }

    // Load initial Combat Mechanics profile
    if (extensionSettings.currentCombatMechanicsProfile) {
        loadCombatMechanicsProfileIntoUI(extensionSettings.currentCombatMechanicsProfile);
    }

    // =========================================================================
    // v1.6.0: CUSTOM ITEM BUILDER HANDLERS
    // =========================================================================

    let currentEditingItemEffects = [];

    // Add new item button
    const itemAddBtn = document.getElementById('mazemaster_item_add_btn');
    if (itemAddBtn) {
        itemAddBtn.addEventListener('click', () => {
            // Clear the form
            document.getElementById('mazemaster_item_edit_id').value = '';
            document.getElementById('mazemaster_item_name').value = '';
            document.getElementById('mazemaster_item_type').value = 'consumable';
            document.getElementById('mazemaster_item_rarity').value = 'common';
            document.getElementById('mazemaster_item_icon').value = 'fa-box';
            document.getElementById('mazemaster_item_subtype').value = '';
            document.getElementById('mazemaster_item_loot_weight').value = '20';
            document.getElementById('mazemaster_item_description').value = '';
            document.getElementById('mazemaster_item_attack').value = '0';
            document.getElementById('mazemaster_item_defense').value = '0';
            document.getElementById('mazemaster_item_crit').value = '0';
            document.getElementById('mazemaster_item_on_use').value = '';
            document.getElementById('mazemaster_item_on_equip').value = '';
            document.getElementById('mazemaster_item_source_chest').checked = true;
            document.getElementById('mazemaster_item_source_combat').checked = false;
            document.getElementById('mazemaster_item_source_shop').checked = false;
            document.getElementById('mazemaster_item_source_quest').checked = false;

            // v1.7.0: Clear new fields
            document.getElementById('mazemaster_item_charges').value = '3';
            document.getElementById('mazemaster_item_absorb_percent').value = '100';
            document.getElementById('mazemaster_item_auto_use').checked = true;
            document.getElementById('mazemaster_item_trigger_combat').checked = true;
            document.getElementById('mazemaster_item_trigger_trap').checked = true;
            document.getElementById('mazemaster_item_heal_amount').value = '25';
            document.getElementById('mazemaster_item_heal_is_percent').checked = true;
            document.getElementById('mazemaster_item_visibility_bonus').value = '1';
            document.getElementById('mazemaster_item_duration').value = '0';
            document.getElementById('mazemaster_item_is_passive').checked = false;

            // Clear theme aliases - v1.9.0: Dynamic from available themes
            const themes = getAvailableThemes();
            themes.forEach(theme => {
                const input = document.getElementById(`mazemaster_item_alias_${theme}`);
                if (input) input.value = '';
            });

            currentEditingItemEffects = [];
            renderItemEffectsList();

            // Update type-specific field visibility
            updateItemTypeFields('consumable');

            // Show editor
            document.getElementById('mazemaster_item_editor').style.display = 'block';
        });
    }

    // Cancel editing
    const itemCancelBtn = document.getElementById('mazemaster_item_cancel_btn');
    if (itemCancelBtn) {
        itemCancelBtn.addEventListener('click', () => {
            document.getElementById('mazemaster_item_editor').style.display = 'none';
        });
    }

    // Save item
    const itemSaveBtn = document.getElementById('mazemaster_item_save_btn');
    if (itemSaveBtn) {
        itemSaveBtn.addEventListener('click', () => {
            const editId = document.getElementById('mazemaster_item_edit_id')?.value;
            const name = document.getElementById('mazemaster_item_name')?.value?.trim();
            if (!name) {
                toastr.error('Item name is required');
                return;
            }

            const lootSources = [];
            if (document.getElementById('mazemaster_item_source_chest')?.checked) lootSources.push('chest');
            if (document.getElementById('mazemaster_item_source_combat')?.checked) lootSources.push('combat');
            if (document.getElementById('mazemaster_item_source_shop')?.checked) lootSources.push('shop');
            if (document.getElementById('mazemaster_item_source_quest')?.checked) lootSources.push('quest');

            const itemType = document.getElementById('mazemaster_item_type')?.value || 'consumable';

            // v1.7.0: Collect triggers
            const triggers = [];
            if (document.getElementById('mazemaster_item_trigger_combat')?.checked) triggers.push('combat');
            if (document.getElementById('mazemaster_item_trigger_trap')?.checked) triggers.push('trap');

            // v1.7.0: Collect theme aliases - v1.9.0: Dynamic from available themes
            const aliases = {};
            const aliasThemes = getAvailableThemes();
            aliasThemes.forEach(theme => {
                const value = document.getElementById(`mazemaster_item_alias_${theme}`)?.value?.trim();
                if (value) aliases[theme] = value;
            });

            const itemData = {
                id: editId || name.toLowerCase().replace(/\s+/g, '_'),
                name,
                type: itemType,
                rarity: document.getElementById('mazemaster_item_rarity')?.value || 'common',
                icon: document.getElementById('mazemaster_item_icon')?.value || 'fa-box',
                subtype: document.getElementById('mazemaster_item_subtype')?.value || null,
                lootWeight: parseInt(document.getElementById('mazemaster_item_loot_weight')?.value) || 20,
                description: document.getElementById('mazemaster_item_description')?.value || '',
                attack: parseInt(document.getElementById('mazemaster_item_attack')?.value) || 0,
                defense: parseInt(document.getElementById('mazemaster_item_defense')?.value) || 0,
                critBonus: parseInt(document.getElementById('mazemaster_item_crit')?.value) || 0,
                effects: currentEditingItemEffects,
                lootSources,
                onUse: document.getElementById('mazemaster_item_on_use')?.value || '',
                onEquip: document.getElementById('mazemaster_item_on_equip')?.value || '',
                // v1.7.0: New fields
                aliases: Object.keys(aliases).length > 0 ? aliases : undefined,
                charges: itemType === 'equipment' ? parseInt(document.getElementById('mazemaster_item_charges')?.value) || 3 : undefined,
                absorbPercent: itemType === 'equipment' ? parseInt(document.getElementById('mazemaster_item_absorb_percent')?.value) || 100 : undefined,
                autoUse: itemType === 'equipment' ? document.getElementById('mazemaster_item_auto_use')?.checked : undefined,
                triggers: itemType === 'equipment' && triggers.length > 0 ? triggers : undefined,
                healAmount: itemType === 'potion' ? parseInt(document.getElementById('mazemaster_item_heal_amount')?.value) || 25 : undefined,
                healIsPercent: itemType === 'potion' ? document.getElementById('mazemaster_item_heal_is_percent')?.checked : undefined,
                visibilityBonus: itemType === 'vision' ? parseInt(document.getElementById('mazemaster_item_visibility_bonus')?.value) || 1 : undefined,
                duration: itemType === 'vision' ? parseInt(document.getElementById('mazemaster_item_duration')?.value) || 0 : undefined,
                passive: itemType === 'vision' ? document.getElementById('mazemaster_item_is_passive')?.checked : undefined,
            };

            // v1.7.0: Check if editing a default item - save as item profile override
            const isDefaultItem = DEFAULT_ITEM_PROFILES[editId];
            if (isDefaultItem) {
                saveItemProfile(editId, itemData);
                toastr.success(`Item "${name}" customized!`);
                renderDefaultItemsList();
            } else if (editId) {
                updateCustomItem(editId, itemData);
                toastr.success(`Item "${name}" updated!`);
            } else {
                createCustomItem(itemData);
                toastr.success(`Item "${name}" created!`);
            }

            document.getElementById('mazemaster_item_editor').style.display = 'none';
            renderCustomItemsList();
            renderCustomItemsInItemPool();
            attachItemListHandlers();
        });
    }

    // Add effect button
    const itemAddEffectBtn = document.getElementById('mazemaster_item_add_effect_btn');
    if (itemAddEffectBtn) {
        itemAddEffectBtn.addEventListener('click', () => {
            currentEditingItemEffects.push({
                type: 'damage',
                target: 'enemy',
                value: 10,
                element: '',
                status: '',
                duration: 3,
            });
            renderItemEffectsList();
        });
    }

    function renderItemEffectsList() {
        const container = document.getElementById('mazemaster_item_effects_list');
        if (!container) return;

        if (currentEditingItemEffects.length === 0) {
            container.innerHTML = '<p style="color: #888; font-size: 12px;">No effects. Add effects to define what the item does.</p>';
            return;
        }

        container.innerHTML = currentEditingItemEffects.map((effect, index) => `
            <div class="mazemaster-effect-row" data-index="${index}">
                <select class="effect-type mazemaster-select" style="width: 100px;">
                    <option value="damage" ${effect.type === 'damage' ? 'selected' : ''}>Damage</option>
                    <option value="heal" ${effect.type === 'heal' ? 'selected' : ''}>Heal</option>
                    <option value="status" ${effect.type === 'status' ? 'selected' : ''}>Status</option>
                    <option value="buff" ${effect.type === 'buff' ? 'selected' : ''}>Buff</option>
                    <option value="teleport" ${effect.type === 'teleport' ? 'selected' : ''}>Teleport</option>
                    <option value="reveal" ${effect.type === 'reveal' ? 'selected' : ''}>Reveal</option>
                </select>
                <select class="effect-target mazemaster-select" style="width: 80px;">
                    <option value="enemy" ${effect.target === 'enemy' ? 'selected' : ''}>Enemy</option>
                    <option value="self" ${effect.target === 'self' ? 'selected' : ''}>Self</option>
                </select>
                <input type="number" class="effect-value" value="${effect.value || 0}" min="0" max="999" style="width: 60px;" placeholder="Value">
                <input type="text" class="effect-extra" value="${effect.element || effect.status || ''}" style="width: 80px;" placeholder="Element/Status">
                <button class="menu_button menu_button_icon effect-delete" title="Remove">
                    <i class="fa-solid fa-times"></i>
                </button>
            </div>
        `).join('');

        // Add handlers for effect changes
        container.querySelectorAll('.mazemaster-effect-row').forEach((row, index) => {
            row.querySelector('.effect-type').addEventListener('change', (e) => {
                currentEditingItemEffects[index].type = e.target.value;
            });
            row.querySelector('.effect-target').addEventListener('change', (e) => {
                currentEditingItemEffects[index].target = e.target.value;
            });
            row.querySelector('.effect-value').addEventListener('change', (e) => {
                currentEditingItemEffects[index].value = parseInt(e.target.value) || 0;
            });
            row.querySelector('.effect-extra').addEventListener('change', (e) => {
                const val = e.target.value;
                if (currentEditingItemEffects[index].type === 'status') {
                    currentEditingItemEffects[index].status = val;
                } else {
                    currentEditingItemEffects[index].element = val;
                }
            });
            row.querySelector('.effect-delete').addEventListener('click', () => {
                currentEditingItemEffects.splice(index, 1);
                renderItemEffectsList();
            });
        });
    }

    // v1.7.0: Type change handler to show/hide type-specific fields
    function updateItemTypeFields(type) {
        const armorSettings = document.getElementById('mazemaster_item_armor_settings');
        const potionSettings = document.getElementById('mazemaster_item_potion_settings');
        const visionSettings = document.getElementById('mazemaster_item_vision_settings');
        const equipStats = document.getElementById('mazemaster_item_equip_stats');

        // Hide all type-specific sections first
        if (armorSettings) armorSettings.style.display = 'none';
        if (potionSettings) potionSettings.style.display = 'none';
        if (visionSettings) visionSettings.style.display = 'none';
        if (equipStats) equipStats.style.display = 'none';

        // Show relevant sections based on type
        switch (type) {
            case 'equipment':
                if (equipStats) equipStats.style.display = 'block';
                if (armorSettings) armorSettings.style.display = 'block';
                break;
            case 'potion':
                if (potionSettings) potionSettings.style.display = 'block';
                break;
            case 'vision':
                if (visionSettings) visionSettings.style.display = 'block';
                break;
        }
    }

    // Type change listener
    const itemTypeSelect = document.getElementById('mazemaster_item_type');
    if (itemTypeSelect) {
        itemTypeSelect.addEventListener('change', (e) => {
            updateItemTypeFields(e.target.value);
        });
    }

    // v1.7.0: Render default items list
    function renderDefaultItemsList() {
        const container = document.getElementById('mazemaster_default_items_list');
        if (!container) return;

        const itemIds = Object.keys(DEFAULT_ITEM_PROFILES);
        const customProfiles = extensionSettings.itemProfiles || {};

        container.innerHTML = itemIds.map(id => {
            const profile = DEFAULT_ITEM_PROFILES[id];
            const hasCustom = !!customProfiles[id];
            const icon = profile.icon || 'fa-box';
            const iconColor = profile.iconColor || '#888';

            return `
                <div class="mazemaster-item-card default-item ${hasCustom ? 'has-override' : ''}" data-id="${id}" title="${profile.description || ''}">
                    <i class="fa-solid ${icon}" style="color: ${iconColor}; margin-right: 8px;"></i>
                    <span class="item-name">${profile.name}</span>
                    <span class="item-type" style="color: #888; font-size: 11px; margin-left: auto;">${profile.type}</span>
                    ${hasCustom ? '<i class="fa-solid fa-pen" style="color: #f39c12; margin-left: 5px;" title="Has custom override"></i>' : ''}
                </div>
            `;
        }).join('');

        // Add click handlers
        container.querySelectorAll('.mazemaster-item-card').forEach(card => {
            card.addEventListener('click', () => {
                const id = card.dataset.id;
                editDefaultItem(id);
            });
        });
    }

    // v1.7.0: Edit a default item
    function editDefaultItem(itemId) {
        const profile = getItemProfile(itemId);
        if (!profile) return;

        // Populate form
        document.getElementById('mazemaster_item_edit_id').value = itemId;
        document.getElementById('mazemaster_item_name').value = profile.name || '';
        document.getElementById('mazemaster_item_type').value = profile.type || 'consumable';
        document.getElementById('mazemaster_item_rarity').value = profile.rarity || 'common';
        document.getElementById('mazemaster_item_icon').value = profile.icon || 'fa-box';
        document.getElementById('mazemaster_item_subtype').value = profile.subtype || '';
        document.getElementById('mazemaster_item_loot_weight').value = profile.lootWeight ?? 20;
        document.getElementById('mazemaster_item_description').value = profile.description || '';

        // Equipment stats
        document.getElementById('mazemaster_item_attack').value = profile.attack || 0;
        document.getElementById('mazemaster_item_defense').value = profile.defense || 0;
        document.getElementById('mazemaster_item_crit').value = profile.critBonus || 0;

        // v1.7.0: Armor settings
        document.getElementById('mazemaster_item_charges').value = profile.charges || 3;
        document.getElementById('mazemaster_item_absorb_percent').value = profile.absorbPercent || 100;
        document.getElementById('mazemaster_item_auto_use').checked = profile.autoUse !== false;
        document.getElementById('mazemaster_item_trigger_combat').checked = (profile.triggers || []).includes('combat');
        document.getElementById('mazemaster_item_trigger_trap').checked = (profile.triggers || []).includes('trap');

        // v1.7.0: Potion settings
        document.getElementById('mazemaster_item_heal_amount').value = profile.healAmount || 25;
        document.getElementById('mazemaster_item_heal_is_percent').checked = profile.healIsPercent !== false;

        // v1.7.0: Vision settings
        document.getElementById('mazemaster_item_visibility_bonus').value = profile.visibilityBonus || 1;
        document.getElementById('mazemaster_item_duration').value = profile.duration || 0;
        document.getElementById('mazemaster_item_is_passive').checked = !!profile.passive;

        // v1.7.0: Theme aliases - v1.9.0: Dynamic from available themes
        const loadThemes = getAvailableThemes();
        loadThemes.forEach(theme => {
            const input = document.getElementById(`mazemaster_item_alias_${theme}`);
            if (input) input.value = profile.aliases?.[theme] || '';
        });

        // Hooks
        document.getElementById('mazemaster_item_on_use').value = profile.onUse || profile.onActivate || '';
        document.getElementById('mazemaster_item_on_equip').value = profile.onEquip || profile.onBreak || '';

        currentEditingItemEffects = JSON.parse(JSON.stringify(profile.effects || []));
        renderItemEffectsList();

        // Update type-specific field visibility
        updateItemTypeFields(profile.type);

        // Show editor
        document.getElementById('mazemaster_item_editor').style.display = 'block';
    }

    // Initial render of default items
    renderDefaultItemsList();

    function attachItemListHandlers() {
        // Edit buttons
        document.querySelectorAll('.mazemaster-item-edit-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const card = e.target.closest('.mazemaster-item-card');
                const id = card?.dataset.id;
                if (!id) return;

                const item = getCustomItem(id);
                if (!item) return;

                // Populate form
                document.getElementById('mazemaster_item_edit_id').value = id;
                document.getElementById('mazemaster_item_name').value = item.name || '';
                document.getElementById('mazemaster_item_type').value = item.type || 'consumable';
                document.getElementById('mazemaster_item_rarity').value = item.rarity || 'common';
                document.getElementById('mazemaster_item_icon').value = item.icon || 'fa-box';
                document.getElementById('mazemaster_item_subtype').value = item.subtype || '';
                document.getElementById('mazemaster_item_loot_weight').value = item.lootWeight ?? 20;
                document.getElementById('mazemaster_item_description').value = item.description || '';
                document.getElementById('mazemaster_item_attack').value = item.attack || 0;
                document.getElementById('mazemaster_item_defense').value = item.defense || 0;
                document.getElementById('mazemaster_item_crit').value = item.critBonus || 0;
                document.getElementById('mazemaster_item_on_use').value = item.onUse || '';
                document.getElementById('mazemaster_item_on_equip').value = item.onEquip || '';

                const sources = item.lootSources || ['chest'];
                document.getElementById('mazemaster_item_source_chest').checked = sources.includes('chest');
                document.getElementById('mazemaster_item_source_combat').checked = sources.includes('combat');
                document.getElementById('mazemaster_item_source_shop').checked = sources.includes('shop');
                document.getElementById('mazemaster_item_source_quest').checked = sources.includes('quest');

                currentEditingItemEffects = JSON.parse(JSON.stringify(item.effects || []));
                renderItemEffectsList();

                // Show editor
                document.getElementById('mazemaster_item_editor').style.display = 'block';
            });
        });

        // Delete buttons
        document.querySelectorAll('.mazemaster-item-delete-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                const card = e.target.closest('.mazemaster-item-card');
                const id = card?.dataset.id;
                if (!id) return;

                const item = getCustomItem(id);
                const confirmed = await callGenericPopup(`Delete item "${item?.name || id}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteCustomItem(id);
                    renderCustomItemsList();
                    renderCustomItemsInItemPool();
                    attachItemListHandlers();
                }
            });
        });
    }

    // Export items
    const itemsExportBtn = document.getElementById('mazemaster_items_export_btn');
    if (itemsExportBtn) {
        itemsExportBtn.addEventListener('click', () => {
            const json = exportCustomItems();
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mazemaster-custom-items.json';
            a.click();
            URL.revokeObjectURL(url);
            toastr.success('Custom items exported!');
        });
    }

    // Import items
    const itemsImportBtn = document.getElementById('mazemaster_items_import_btn');
    const itemsImportFile = document.getElementById('mazemaster_items_import_file');
    if (itemsImportBtn && itemsImportFile) {
        itemsImportBtn.addEventListener('click', () => itemsImportFile.click());
        itemsImportFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            const text = await file.text();
            const count = importCustomItems(text);
            if (count > 0) {
                toastr.success(`Imported ${count} custom items!`);
                renderCustomItemsList();
                renderCustomItemsInItemPool();
                attachItemListHandlers();
            } else {
                toastr.error('No valid items found in file');
            }
            itemsImportFile.value = '';
        });
    }

    // v1.7.0: Old type handler replaced by updateItemTypeFields() above

    // Initial render
    renderCustomItemsList();
    renderCustomItemsInItemPool();
    attachItemListHandlers();

    // =========================================================================
    // MAZE HANDLERS
    // =========================================================================

    // Maze profile select
    const mazeProfileSelect = document.getElementById('mazemaster_maze_profile_select');
    if (mazeProfileSelect) {
        mazeProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentMazeProfile = e.target.value;
            saveSettingsDebounced();
            updateMazeSettings();
        });
    }

    // Maze new profile
    const mazeNewProfileBtn = document.getElementById('mazemaster_maze_new_profile_btn');
    if (mazeNewProfileBtn) {
        mazeNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new maze profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.mazeProfiles[trimmed]) {
                    saveMazeProfile(trimmed, { gridSize: 10 });
                    extensionSettings.currentMazeProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_maze')?.click();
                    }, 100);
                } else {
                    await callGenericPopup(`Maze profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Maze delete profile
    const mazeDeleteProfileBtn = document.getElementById('mazemaster_maze_delete_profile_btn');
    if (mazeDeleteProfileBtn) {
        mazeDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete maze profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteMazeProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_maze')?.click();
                    }, 100);
                }
            }
        });
    }

    // Maze rename profile
    const mazeRenameProfileBtn = document.getElementById('mazemaster_maze_rename_profile_btn');
    if (mazeRenameProfileBtn) {
        mazeRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_maze_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.mazeProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.mazeProfiles[trimmed] = extensionSettings.mazeProfiles[oldName];
                delete extensionSettings.mazeProfiles[oldName];
                extensionSettings.currentMazeProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_maze')?.click();
                }, 100);
            }
        });
    }

    // Maze save profile
    const mazeSaveBtn = document.getElementById('mazemaster_maze_save_btn');
    if (mazeSaveBtn) {
        mazeSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
            if (!profileName) {
                alert('Please create a maze profile first');
                return;
            }

            const profileData = collectMazeDataFromUI();

            // Validate required fields
            const errors = [];
            if (!profileData.gridSize || profileData.gridSize < 5 || profileData.gridSize > 20) {
                errors.push('Grid Size must be between 5 and 20');
            }

            // Validate encounter percentages don't exceed 100%
            if (profileData.minionEncounters && profileData.minionEncounters.length > 0) {
                const totalPercent = profileData.minionEncounters.reduce((sum, enc) => sum + (enc.percent || 0), 0);
                if (totalPercent > 100) {
                    errors.push(`Encounter percentages total ${totalPercent}% (max 100%)`);
                }
            }

            if (errors.length > 0) {
                alert('Validation Error:\n\n' + errors.join('\n'));
                return;
            }

            saveMazeProfile(profileName, profileData);
            alert(`Maze profile "${profileName}" saved!`);
        });
    }

    // Story Milestones button
    const storyBtn = document.getElementById('mazemaster_maze_story_btn');
    if (storyBtn) {
        storyBtn.addEventListener('click', () => {
            showStoryMilestonesModal();
        });
    }

    // Collapsible section toggles
    document.querySelectorAll('.mazemaster-collapsible-header').forEach(header => {
        header.addEventListener('click', () => {
            const targetId = header.getAttribute('data-target');
            const content = document.getElementById(targetId);
            const collapsible = header.closest('.mazemaster-collapsible');

            if (content) {
                const isExpanded = content.style.display !== 'none';
                content.style.display = isExpanded ? 'none' : 'block';
                collapsible?.classList.toggle('expanded', !isExpanded);
            }
        });
    });

    // v1.8.0: Item Pool event handlers
    const itemPoolEnabledCheckbox = document.getElementById('mazemaster_itempool_enabled');
    const itemPoolItemsDiv = document.getElementById('mazemaster_itempool_items');
    if (itemPoolEnabledCheckbox && itemPoolItemsDiv) {
        itemPoolEnabledCheckbox.addEventListener('change', (e) => {
            itemPoolItemsDiv.style.display = e.target.checked ? 'block' : 'none';
        });
    }

    // Item Pool quick action buttons
    document.getElementById('mazemaster_itempool_all')?.addEventListener('click', () => {
        document.querySelectorAll('#mazemaster_itempool_items input[data-pool-item]').forEach(cb => {
            cb.checked = true;
        });
    });

    document.getElementById('mazemaster_itempool_none')?.addEventListener('click', () => {
        document.querySelectorAll('#mazemaster_itempool_items input[data-pool-item]').forEach(cb => {
            cb.checked = false;
        });
    });

    document.getElementById('mazemaster_itempool_core')?.addEventListener('click', () => {
        const coreItems = ['key', 'strike', 'stealth', 'execute', 'healingPotion', 'greaterHealing'];
        document.querySelectorAll('#mazemaster_itempool_items input[data-pool-item]').forEach(cb => {
            cb.checked = coreItems.includes(cb.dataset.poolItem);
        });
        updateStartingItemsFromPool();
    });

    // v1.8.0: Update starting equipment dropdowns based on item pool
    function updateStartingItemsFromPool() {
        // Get all checked items in the pool
        const poolItems = new Set();
        document.querySelectorAll('#mazemaster_itempool_items input[data-pool-item]:checked').forEach(cb => {
            poolItems.add(cb.dataset.poolItem);
        });

        // Update weapon dropdown
        const weaponSelect = document.getElementById('mazemaster_start_weapon');
        if (weaponSelect) {
            Array.from(weaponSelect.options).forEach(opt => {
                if (opt.value === '') return; // Keep "None" enabled
                opt.disabled = !poolItems.has(opt.value);
                if (opt.disabled && opt.selected) {
                    weaponSelect.value = ''; // Reset to None if selected item no longer in pool
                }
            });
        }

        // Update armor dropdown
        const armorSelect = document.getElementById('mazemaster_start_armor');
        if (armorSelect) {
            Array.from(armorSelect.options).forEach(opt => {
                if (opt.value === '') return;
                opt.disabled = !poolItems.has(opt.value);
                if (opt.disabled && opt.selected) {
                    armorSelect.value = '';
                }
            });
        }

        // Update accessory dropdown
        const accessorySelect = document.getElementById('mazemaster_start_accessory');
        if (accessorySelect) {
            Array.from(accessorySelect.options).forEach(opt => {
                if (opt.value === '') return;
                opt.disabled = !poolItems.has(opt.value);
                if (opt.disabled && opt.selected) {
                    accessorySelect.value = '';
                }
            });
        }
    }

    // Listen to all item pool checkbox changes
    document.querySelectorAll('#mazemaster_itempool_items input[data-pool-item]').forEach(cb => {
        cb.addEventListener('change', updateStartingItemsFromPool);
    });

    // Also update when Select All / Clear All are clicked
    document.getElementById('mazemaster_itempool_all')?.addEventListener('click', () => {
        setTimeout(updateStartingItemsFromPool, 10);
    });
    document.getElementById('mazemaster_itempool_none')?.addEventListener('click', () => {
        setTimeout(updateStartingItemsFromPool, 10);
    });

    // Make function globally available for updateMazeSettings to call
    window.updateStartingItemsFromPool = updateStartingItemsFromPool;

    // Render saved games list
    renderSavedGamesList();

    // Intelligent Distribute button
    const distributeBtn = document.getElementById('mazemaster_intelligent_distribute');
    if (distributeBtn) {
        distributeBtn.addEventListener('click', handleIntelligentDistribute);
    }

    // Maze win image upload
    const mazeWinImageBtn = document.getElementById('mazemaster_maze_win_image_btn');
    const mazeWinImageFile = document.getElementById('mazemaster_maze_win_image_file');
    if (mazeWinImageBtn && mazeWinImageFile) {
        mazeWinImageBtn.addEventListener('click', () => {
            mazeWinImageFile.click();
        });

        mazeWinImageFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
            if (!profileName) {
                alert('Please create a profile first');
                mazeWinImageFile.value = '';
                return;
            }

            try {
                const imagePath = await uploadImage(file, `maze_win_${profileName}`);
                const profile = getMazeProfile(profileName) || {};
                profile.winImage = imagePath;
                saveMazeProfile(profileName, profile);

                // Update preview
                const previewContainer = document.querySelector('.mazemaster-maze-win-image-preview');
                if (previewContainer) {
                    previewContainer.innerHTML = `<img id="maze_win_image_preview" src="${imagePath}" alt="Victory">`;
                }
            } catch (err) {
                alert(`Image upload failed: ${err.message}`);
            }

            mazeWinImageFile.value = '';
        });
    }

    // Chest image upload
    const chestImageBtn = document.getElementById('mazemaster_chest_image_btn');
    const chestImageFile = document.getElementById('mazemaster_chest_image_file');
    if (chestImageBtn && chestImageFile) {
        chestImageBtn.addEventListener('click', () => {
            chestImageFile.click();
        });

        chestImageFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
            if (!profileName) {
                alert('Please create a profile first');
                chestImageFile.value = '';
                return;
            }

            try {
                const imagePath = await uploadImage(file, `chest_${profileName}`);
                const profile = getMazeProfile(profileName);
                if (profile) {
                    profile.chestImage = imagePath;
                    saveMazeProfile(profileName, profile);

                    // Update preview
                    const previewContainer = document.querySelector('.mazemaster-chest-preview');
                    if (previewContainer) {
                        previewContainer.innerHTML = `<img id="mazemaster_chest_preview_img" src="${imagePath}" style="width: 100%; height: 100%; object-fit: cover;">`;
                    }
                }
            } catch (err) {
                alert(`Image upload failed: ${err.message}`);
            }

            chestImageFile.value = '';
        });
    }

    // Main minion select - toggle settings visibility
    const mainMinionSelect = document.getElementById('mazemaster_maze_main_minion');
    if (mainMinionSelect) {
        mainMinionSelect.addEventListener('change', (e) => {
            const settingsDiv = document.getElementById('mazemaster_main_minion_settings');
            if (settingsDiv) {
                settingsDiv.style.display = e.target.value ? '' : 'none';
            }
        });
    }

    // Exit type select - update profile dropdown
    const exitTypeSelect = document.getElementById('mazemaster_maze_exit_type');
    if (exitTypeSelect) {
        exitTypeSelect.addEventListener('change', () => {
            const currentType = exitTypeSelect.value;
            updateExitProfileDropdown(currentType, '');
        });
    }

    // Add portal button
    const addPortalBtn = document.getElementById('mazemaster_add_portal_btn');
    if (addPortalBtn) {
        addPortalBtn.addEventListener('click', () => {
            const list = document.getElementById('mazemaster_portals_list');
            if (!list) return;

            const portalIndex = list.children.length;
            const portalItem = document.createElement('div');
            portalItem.className = 'mazemaster-portal-item';
            portalItem.dataset.portalIndex = portalIndex;
            portalItem.innerHTML = `
                <div class="portal-header">
                    <span class="portal-color" style="background: #9b59b6"></span>
                    <span class="portal-name">Portal ${portalIndex + 1}</span>
                    <button class="menu_button remove-portal-btn" title="Remove Portal">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
                <div class="portal-details">
                    <div class="portal-row">
                        <label>ID:</label>
                        <input type="text" class="portal-id mazemaster-input" value="" placeholder="portal${portalIndex + 1}">
                    </div>
                    <div class="portal-row">
                        <label>Color:</label>
                        <input type="color" class="portal-color-input" value="#9b59b6">
                    </div>
                    <div class="portal-row">
                        <label>Bidirectional:</label>
                        <input type="checkbox" class="portal-bidirectional" checked>
                    </div>
                    <div class="portal-row coords-row">
                        <span>Start: X</span>
                        <input type="number" class="portal-start-x mazemaster-input" value="" placeholder="auto" min="0">
                        <span>Y</span>
                        <input type="number" class="portal-start-y mazemaster-input" value="" placeholder="auto" min="0">
                    </div>
                    <div class="portal-row coords-row">
                        <span>End: X</span>
                        <input type="number" class="portal-end-x mazemaster-input" value="" placeholder="auto" min="0">
                        <span>Y</span>
                        <input type="number" class="portal-end-y mazemaster-input" value="" placeholder="auto" min="0">
                    </div>
                </div>
            `;

            // Add remove handler
            portalItem.querySelector('.remove-portal-btn').addEventListener('click', () => {
                portalItem.remove();
                updatePortalHint();
            });

            // Update color preview when color input changes
            portalItem.querySelector('.portal-color-input').addEventListener('input', (e) => {
                portalItem.querySelector('.portal-color').style.background = e.target.value;
            });

            // Update name when ID changes
            portalItem.querySelector('.portal-id').addEventListener('input', (e) => {
                portalItem.querySelector('.portal-name').textContent = e.target.value || `Portal ${portalIndex + 1}`;
            });

            list.appendChild(portalItem);
            updatePortalHint();
        });
    }

    // Update portal count hint in section header
    function updatePortalHint() {
        const list = document.getElementById('mazemaster_portals_list');
        const hint = document.querySelector('[data-target="portals_section"]')?.closest('.mazemaster-collapsible')?.querySelector('.mazemaster-collapse-hint');
        if (list && hint) {
            hint.textContent = `(${list.children.length} portal pairs)`;
        }
    }

    // Add remove handlers to existing portal items
    document.querySelectorAll('#mazemaster_portals_list .remove-portal-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            btn.closest('.mazemaster-portal-item').remove();
            updatePortalHint();
        });
    });

    // Add color preview update for existing portals
    document.querySelectorAll('#mazemaster_portals_list .portal-color-input').forEach(input => {
        input.addEventListener('input', (e) => {
            e.target.closest('.mazemaster-portal-item').querySelector('.portal-color').style.background = e.target.value;
        });
    });

    // Add objective button
    const addObjectiveBtn = document.getElementById('mazemaster_add_objective_btn');
    if (addObjectiveBtn) {
        addObjectiveBtn.addEventListener('click', () => {
            const list = document.getElementById('mazemaster_objectives_list');
            if (!list) return;

            const objIndex = list.children.length;
            const objectiveItem = document.createElement('div');
            objectiveItem.className = 'mazemaster-objective-item';
            objectiveItem.dataset.objectiveIndex = objIndex;
            objectiveItem.innerHTML = `
                <div class="objective-config-header">
                    <span class="objective-name">Objective ${objIndex + 1}</span>
                    <button class="menu_button remove-objective-btn" title="Remove Objective">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
                <div class="objective-config-details">
                    <div class="objective-config-row">
                        <label>ID:</label>
                        <input type="text" class="objective-id mazemaster-input" value="" placeholder="obj${objIndex + 1}">
                    </div>
                    <div class="objective-config-row">
                        <label>Type:</label>
                        <select class="objective-type mazemaster-select">
                            <option value="collect">Collect Item</option>
                            <option value="defeat">Defeat Minion</option>
                            <option value="explore">Explore %</option>
                        </select>
                    </div>
                    <div class="objective-config-row objective-target-row">
                        <label>Target:</label>
                        <input type="text" class="objective-target mazemaster-input" value="" placeholder="key, strike, stealth...">
                    </div>
                    <div class="objective-config-row">
                        <label>Count:</label>
                        <input type="number" class="objective-count mazemaster-input" value="1" min="1">
                    </div>
                    <div class="objective-config-row">
                        <label>Description:</label>
                        <input type="text" class="objective-description mazemaster-input" value="" placeholder="Find 3 Keys">
                    </div>
                    <div class="objective-config-row">
                        <label>Required:</label>
                        <input type="checkbox" class="objective-required" checked>
                    </div>
                    <div class="objective-config-row">
                        <label>Reward Script:</label>
                        <input type="text" class="objective-reward mazemaster-input" value="" placeholder="/echo Objective complete!">
                    </div>
                </div>
            `;

            // Add remove handler
            objectiveItem.querySelector('.remove-objective-btn').addEventListener('click', () => {
                objectiveItem.remove();
                updateObjectiveHint();
            });

            // Add type change handler to show/hide target row
            const typeSelect = objectiveItem.querySelector('.objective-type');
            const targetRow = objectiveItem.querySelector('.objective-target-row');
            typeSelect.addEventListener('change', () => {
                targetRow.style.display = typeSelect.value === 'explore' ? 'none' : 'flex';
            });

            // Update description when description changes
            objectiveItem.querySelector('.objective-description').addEventListener('input', (e) => {
                objectiveItem.querySelector('.objective-name').textContent = e.target.value || `Objective ${objIndex + 1}`;
            });

            list.appendChild(objectiveItem);
            updateObjectiveHint();
        });
    }

    // Update objective count hint in section header
    function updateObjectiveHint() {
        const list = document.getElementById('mazemaster_objectives_list');
        const hint = document.querySelector('[data-target="objectives_section"]')?.closest('.mazemaster-collapsible')?.querySelector('.mazemaster-collapse-hint');
        if (list && hint) {
            hint.textContent = `(${list.children.length} objectives)`;
        }
    }

    // Add remove handlers to existing objective items
    document.querySelectorAll('#mazemaster_objectives_list .remove-objective-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            btn.closest('.mazemaster-objective-item').remove();
            updateObjectiveHint();
        });
    });

    // Add type change handlers to existing objectives
    document.querySelectorAll('#mazemaster_objectives_list .objective-type').forEach(select => {
        const item = select.closest('.mazemaster-objective-item');
        const targetRow = item.querySelector('.objective-target-row');
        select.addEventListener('change', () => {
            targetRow.style.display = select.value === 'explore' ? 'none' : 'flex';
        });
    });

    // v2.1.0: Avatar generation refresh button
    const avatarGenRefreshBtn = document.getElementById('mazemaster_avatar_gen_refresh');
    if (avatarGenRefreshBtn) {
        avatarGenRefreshBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
            if (profileName) {
                renderAvatarMinionList(profileName);
            }
        });
    }

    // Add encounter button
    const addEncounterBtn = document.getElementById('mazemaster_add_encounter_btn');
    if (addEncounterBtn) {
        addEncounterBtn.addEventListener('click', () => {
            const list = document.getElementById('mazemaster_maze_encounters_list');
            if (!list) return;

            const minionOptions = Object.keys(extensionSettings.minions || {}).map(id => {
                const m = extensionSettings.minions[id];
                return `<option value="${id}">${m.name || id}</option>`;
            }).join('');

            const row = document.createElement('div');
            row.className = 'mazemaster-encounter-row';
            row.innerHTML = `
                <select class="encounter-minion-select">
                    <option value="">Select Minion</option>
                    ${minionOptions}
                </select>
                <input type="number" class="encounter-percent-input" min="1" max="100" value="5" placeholder="%">
                <span class="encounter-percent-label">%</span>
                <button class="encounter-remove-btn menu_button"><i class="fa-solid fa-trash"></i></button>
            `;

            // Add remove handler
            row.querySelector('.encounter-remove-btn').addEventListener('click', () => {
                row.remove();
            });

            list.appendChild(row);
        });
    }

    // Add trap encounter button
    const addTrapEncounterBtn = document.getElementById('mazemaster_add_trap_encounter_btn');
    if (addTrapEncounterBtn) {
        addTrapEncounterBtn.addEventListener('click', () => {
            const list = document.getElementById('mazemaster_maze_traps_list');
            if (!list) return;

            const trapOptions = getTrapNames().map(id => {
                const t = getTrap(id);
                return `<option value="${escapeHtml(id)}">${escapeHtml(t?.name || id)}</option>`;
            }).join('');

            if (!trapOptions) {
                alert('No traps available. Create traps in the Traps tab first.');
                return;
            }

            const row = document.createElement('div');
            row.className = 'mazemaster-encounter-row mazemaster-trap-encounter-row';
            row.innerHTML = `
                <select class="trap-encounter-select">
                    <option value="">Select Trap</option>
                    ${trapOptions}
                </select>
                <input type="number" class="trap-encounter-percent-input" min="1" max="100" value="5" placeholder="%">
                <span class="encounter-percent-label">%</span>
                <button class="trap-encounter-remove-btn menu_button"><i class="fa-solid fa-trash"></i></button>
            `;

            // Add remove handler
            row.querySelector('.trap-encounter-remove-btn').addEventListener('click', () => {
                row.remove();
            });

            list.appendChild(row);
        });
    }

    // Add quest pool button
    const addQuestPoolBtn = document.getElementById('mazemaster_add_quest_pool_btn');
    if (addQuestPoolBtn) {
        addQuestPoolBtn.addEventListener('click', () => {
            const list = document.getElementById('mazemaster_maze_quests_list');
            if (!list) return;

            const allQuests = getAllQuests();
            const questOptions = Object.keys(allQuests).map(id => {
                const q = allQuests[id];
                return `<option value="${escapeHtml(id)}">${escapeHtml(q?.name || id)}</option>`;
            }).join('');

            if (!questOptions) {
                toastr.warning('No quests available. Create quests in the Quests tab first.');
                return;
            }

            const row = document.createElement('div');
            row.className = 'mazemaster-encounter-row mazemaster-quest-pool-row';
            row.innerHTML = `
                <select class="quest-pool-select">
                    <option value="">Select Quest</option>
                    ${questOptions}
                </select>
                <input type="number" class="quest-pool-chance-input" min="1" max="100" value="50" placeholder="%">
                <span class="encounter-percent-label">%</span>
                <button class="quest-pool-remove-btn menu_button"><i class="fa-solid fa-trash"></i></button>
            `;

            // Add remove handler
            row.querySelector('.quest-pool-remove-btn').addEventListener('click', () => {
                row.remove();
            });

            list.appendChild(row);
        });
    }

    // =========================================================================
    // MINION HANDLERS
    // =========================================================================

    // Add minion button
    const addMinionBtn = document.getElementById('mazemaster_add_minion_btn');
    const minionImageFile = document.getElementById('mazemaster_minion_image_file');
    if (addMinionBtn && minionImageFile) {
        addMinionBtn.addEventListener('click', () => {
            minionImageFile.click();
        });

        minionImageFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            try {
                const minionId = `minion_${Date.now()}`;
                const imagePath = await uploadImage(file, minionId);
                const minionName = await callGenericPopup('Enter minion name:', POPUP_TYPE.INPUT, 'New Minion');

                if (minionName && minionName.trim()) {
                    saveMinion(minionId, {
                        name: minionName.trim(),
                        imagePath: imagePath,
                    });
                    renderMinionsList();
                }
            } catch (err) {
                alert(`Image upload failed: ${err.message}`);
            }

            minionImageFile.value = '';
        });
    }

    // Minion profile select change - filter displayed minions
    const minionProfileSelect = document.getElementById('mazemaster_minion_profile_select');
    if (minionProfileSelect) {
        minionProfileSelect.addEventListener('change', () => {
            renderMinionsList();
        });
    }

    // Minion profile save button
    const minionProfileSaveBtn = document.getElementById('mazemaster_minion_profile_save_btn');
    if (minionProfileSaveBtn) {
        minionProfileSaveBtn.addEventListener('click', async () => {
            const profileName = await callGenericPopup('Enter profile name:', POPUP_TYPE.INPUT, 'My Minions');
            if (profileName && profileName.trim()) {
                const trimmed = profileName.trim();
                extensionSettings.minionProfiles[trimmed] = JSON.parse(JSON.stringify(extensionSettings.minions || {}));
                saveSettingsDebounced();
                alert(`Minion profile "${trimmed}" saved!`);
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_minions')?.click();
                }, 100);
            }
        });
    }

    // Minion profile load button
    const minionProfileLoadBtn = document.getElementById('mazemaster_minion_profile_load_btn');
    if (minionProfileLoadBtn) {
        minionProfileLoadBtn.addEventListener('click', async () => {
            const profileSelect = document.getElementById('mazemaster_minion_profile_select');
            const profileName = profileSelect?.value;
            if (!profileName) {
                alert('Select a profile to load');
                return;
            }
            const confirmed = await callGenericPopup(`Load minion profile "${profileName}"? This will replace your current minions.`, POPUP_TYPE.CONFIRM);
            if (confirmed) {
                extensionSettings.minions = JSON.parse(JSON.stringify(extensionSettings.minionProfiles[profileName] || {}));
                saveSettingsDebounced();
                renderMinionsList();
                alert(`Minion profile "${profileName}" loaded!`);
            }
        });
    }

    // Minion profile delete button
    const minionProfileDeleteBtn = document.getElementById('mazemaster_minion_profile_delete_btn');
    if (minionProfileDeleteBtn) {
        minionProfileDeleteBtn.addEventListener('click', async () => {
            const profileSelect = document.getElementById('mazemaster_minion_profile_select');
            const profileName = profileSelect?.value;
            if (!profileName) {
                alert('Select a profile to delete');
                return;
            }
            const confirmed = await callGenericPopup(`Delete minion profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
            if (confirmed) {
                delete extensionSettings.minionProfiles[profileName];
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_minions')?.click();
                }, 100);
            }
        });
    }

    // =========================================================================
    // TRAP HANDLERS
    // =========================================================================

    // Add trap button
    const addTrapBtn = document.getElementById('mazemaster_add_trap_btn');
    const trapImageFile = document.getElementById('mazemaster_trap_image_file');
    if (addTrapBtn && trapImageFile) {
        addTrapBtn.addEventListener('click', () => {
            trapImageFile.click();
        });

        trapImageFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            try {
                const trapId = `trap_${Date.now()}`;
                const imagePath = await uploadImage(file, trapId);
                const trapName = await callGenericPopup('Enter trap name:', POPUP_TYPE.INPUT, 'New Trap');

                if (trapName && trapName.trim()) {
                    saveTrap(trapId, {
                        name: trapName.trim(),
                        imagePath: imagePath,
                        message: 'You triggered a trap!',
                        script: '',
                    });
                    renderTrapsList();
                }
            } catch (err) {
                alert(`Image upload failed: ${err.message}`);
            }

            trapImageFile.value = '';
        });
    }

    // Trap profile save button
    const trapProfileSaveBtn = document.getElementById('mazemaster_trap_profile_save_btn');
    if (trapProfileSaveBtn) {
        trapProfileSaveBtn.addEventListener('click', async () => {
            const profileName = await callGenericPopup('Enter profile name:', POPUP_TYPE.INPUT, 'My Traps');
            if (profileName && profileName.trim()) {
                const trimmed = profileName.trim();
                extensionSettings.trapProfiles[trimmed] = JSON.parse(JSON.stringify(extensionSettings.traps || {}));
                saveSettingsDebounced();
                alert(`Trap profile "${trimmed}" saved!`);
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_traps')?.click();
                }, 100);
            }
        });
    }

    // Trap profile load button
    const trapProfileLoadBtn = document.getElementById('mazemaster_trap_profile_load_btn');
    if (trapProfileLoadBtn) {
        trapProfileLoadBtn.addEventListener('click', async () => {
            const profileSelect = document.getElementById('mazemaster_trap_profile_select');
            const profileName = profileSelect?.value;
            if (!profileName) {
                alert('Select a profile to load');
                return;
            }
            const confirmed = await callGenericPopup(`Load trap profile "${profileName}"? This will replace your current traps.`, POPUP_TYPE.CONFIRM);
            if (confirmed) {
                extensionSettings.traps = JSON.parse(JSON.stringify(extensionSettings.trapProfiles[profileName] || {}));
                saveSettingsDebounced();
                renderTrapsList();
                alert(`Trap profile "${profileName}" loaded!`);
            }
        });
    }

    // Trap profile delete button
    const trapProfileDeleteBtn = document.getElementById('mazemaster_trap_profile_delete_btn');
    if (trapProfileDeleteBtn) {
        trapProfileDeleteBtn.addEventListener('click', async () => {
            const profileSelect = document.getElementById('mazemaster_trap_profile_select');
            const profileName = profileSelect?.value;
            if (!profileName) {
                alert('Select a profile to delete');
                return;
            }
            const confirmed = await callGenericPopup(`Delete trap profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
            if (confirmed) {
                delete extensionSettings.trapProfiles[profileName];
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_traps')?.click();
                }, 100);
            }
        });
    }

    // =========================================================================
    // QUEST HANDLERS (v1.5.0)
    // =========================================================================

    // Add quest button
    const addQuestBtn = document.getElementById('mazemaster_quest_add_btn');
    if (addQuestBtn) {
        addQuestBtn.addEventListener('click', () => {
            showQuestEditor(null);
        });
    }

    // Quest template list actions (delegated)
    const questList = document.getElementById('mazemaster_quest_list');
    if (questList) {
        questList.addEventListener('click', async (e) => {
            const editBtn = e.target.closest('.quest-edit-btn');
            const deleteBtn = e.target.closest('.quest-delete-btn');

            if (editBtn) {
                const questId = editBtn.dataset.quest;
                showQuestEditor(questId);
            }

            if (deleteBtn) {
                const questId = deleteBtn.dataset.quest;
                const quest = getQuest(questId);
                const confirmed = await callGenericPopup(`Delete quest "${quest?.name || questId}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteQuest(questId);
                    renderQuestTemplateList();
                }
            }
        });
    }

    // Quest profile handlers
    const questProfileSaveBtn = document.getElementById('mazemaster_quest_profile_save_btn');
    if (questProfileSaveBtn) {
        questProfileSaveBtn.addEventListener('click', async () => {
            const profileName = await callGenericPopup('Enter profile name:', POPUP_TYPE.INPUT, 'My Quests');
            if (profileName && profileName.trim()) {
                const trimmed = profileName.trim();
                const allQuests = getAllQuests();
                const questIds = Object.keys(allQuests).filter(id => !DEFAULT_QUESTS[id]);
                saveQuestProfile(trimmed, questIds);
                toastr.success(`Quest profile "${trimmed}" saved!`);
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_quests')?.click();
                }, 100);
            }
        });
    }

    const questProfileDeleteBtn = document.getElementById('mazemaster_quest_profile_delete_btn');
    if (questProfileDeleteBtn) {
        questProfileDeleteBtn.addEventListener('click', async () => {
            const profileSelect = document.getElementById('mazemaster_quest_profile_select');
            const profileName = profileSelect?.value;
            if (!profileName) {
                toastr.warning('Select a profile to delete');
                return;
            }
            const confirmed = await callGenericPopup(`Delete quest profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
            if (confirmed) {
                deleteQuestProfile(profileName);
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_quests')?.click();
                }, 100);
            }
        });
    }
    console.log('[MazeMaster] initUI() completed successfully');
}

function refreshPanel() {
    const drawer = document.getElementById('mazemaster_drawer');
    if (drawer) {
        drawer.innerHTML = getPanelHtml();
        setupEventHandlers();
        renderSegmentsList();
        renderBattlebarImages();
        renderMinionsList();
        renderTrapsList();
        updateMazeSettings();
    }
}

// =============================================================================
// MACRO PROCESSING (like TPLink pattern)
// =============================================================================

/**
 * Process a message element for MazeMaster macros
 * {{wheel:profileName}} - spins the wheel
 * {{battlebar:profileName}} - starts the battlebar
 * {{maze:profileName}} - starts the maze
 */
async function processMacroMessage(mesElement) {
    if (processedMacroMessages.has(mesElement)) return;

    // Skip streaming messages
    if (mesElement.classList.contains('streaming') ||
        mesElement.classList.contains('is-typing') ||
        mesElement.querySelector('.mes_text.streaming')) {
        return;
    }

    const mesText = mesElement.querySelector('.mes_text .stle--content') || mesElement.querySelector('.mes_text');
    if (!mesText) return;

    const text = mesText.textContent || '';

    // Match {{wheel:profileName}}, {{battlebar:profileName}}, and {{maze:profileName}}
    const wheelPattern = /\{\{wheel:([^}]+)\}\}/gi;
    const battlebarPattern = /\{\{battlebar:([^}]+)\}\}/gi;
    const mazePattern = /\{\{maze:([^}]+)\}\}/gi;

    const wheelMatches = [];
    const battlebarMatches = [];
    const mazeMatches = [];

    let match;
    while ((match = wheelPattern.exec(text)) !== null) {
        wheelMatches.push({ full: match[0], profile: match[1].trim() });
    }
    while ((match = battlebarPattern.exec(text)) !== null) {
        battlebarMatches.push({ full: match[0], profile: match[1].trim() });
    }
    while ((match = mazePattern.exec(text)) !== null) {
        mazeMatches.push({ full: match[0], profile: match[1].trim() });
    }

    if (wheelMatches.length === 0 && battlebarMatches.length === 0 && mazeMatches.length === 0) return;

    // Mark as processed
    processedMacroMessages.add(mesElement);

    const context = SillyTavern.getContext();
    const mesId = mesElement.getAttribute('mesid');

    // Process wheel macros
    for (const m of wheelMatches) {
        console.log(`[MazeMaster] Processing wheel macro: ${m.full}`);

        // Trigger the wheel (same as slash command)
        const result = loadWheelFromProfile(m.profile);
        if (!result.error) {
            const validation = validateWheelBalance();
            if (validation.valid) {
                showWheelModal();
            }
        }

        const replacement = `[🎡 Wheel: ${m.profile}]`;

        // Update chat context and DOM
        if (context.chat && mesId !== null) {
            const msgIndex = parseInt(mesId);
            if (context.chat[msgIndex]) {
                const originalMes = context.chat[msgIndex].mes;
                // Strip macro from context (AI never sees it)
                const contextMes = originalMes.replace(m.full, '').replace(/\s+/g, ' ').trim();
                // Visual replacement for user
                const visualMes = originalMes.replace(m.full, replacement);

                context.chat[msgIndex].mes = contextMes;

                const mesTextEl = mesElement.querySelector('.mes_text');
                if (mesTextEl) {
                    mesTextEl.innerHTML = visualMes;
                }
            }
        }
    }

    // Process battlebar macros
    for (const m of battlebarMatches) {
        console.log(`[MazeMaster] Processing battlebar macro: ${m.full}`);

        // Trigger the battlebar (same as slash command)
        startBattlebar(m.profile);

        const replacement = `[⚔️ Battlebar: ${m.profile}]`;

        // Update chat context and DOM
        if (context.chat && mesId !== null) {
            const msgIndex = parseInt(mesId);
            if (context.chat[msgIndex]) {
                const originalMes = context.chat[msgIndex].mes;
                // Strip macro from context
                const contextMes = originalMes.replace(m.full, '').replace(/\s+/g, ' ').trim();
                // Visual replacement
                const visualMes = originalMes.replace(m.full, replacement);

                context.chat[msgIndex].mes = contextMes;

                const mesTextEl = mesElement.querySelector('.mes_text');
                if (mesTextEl) {
                    mesTextEl.innerHTML = visualMes;
                }
            }
        }
    }

    // Process maze macros
    for (const m of mazeMatches) {
        console.log(`[MazeMaster] Processing maze macro: ${m.full}`);

        // Trigger the maze (same as slash command)
        startMaze(m.profile);

        const replacement = `[🏛️ Maze: ${m.profile}]`;

        // Update chat context and DOM
        if (context.chat && mesId !== null) {
            const msgIndex = parseInt(mesId);
            if (context.chat[msgIndex]) {
                const originalMes = context.chat[msgIndex].mes;
                // Strip macro from context
                const contextMes = originalMes.replace(m.full, '').replace(/\s+/g, ' ').trim();
                // Visual replacement
                const visualMes = originalMes.replace(m.full, replacement);

                context.chat[msgIndex].mes = contextMes;

                const mesTextEl = mesElement.querySelector('.mes_text');
                if (mesTextEl) {
                    mesTextEl.innerHTML = visualMes;
                }
            }
        }
    }
}

/**
 * Register message hooks to intercept and process MazeMaster macros
 */
function registerMacroHooks() {
    const context = SillyTavern.getContext();

    if (!context || !context.eventSource || !context.eventTypes) {
        console.warn('[MazeMaster] Context not ready for macro hooks, retrying...');
        setTimeout(registerMacroHooks, 500);
        return;
    }

    // Listen for user messages
    if (context.eventTypes.USER_MESSAGE_RENDERED) {
        context.eventSource.on(context.eventTypes.USER_MESSAGE_RENDERED, (messageId) => {
            setTimeout(() => {
                const mesElement = document.querySelector(`#chat .mes[mesid="${messageId}"]`);
                if (mesElement) processMacroMessage(mesElement);
            }, 500);
        });
    }

    // Listen for AI messages
    if (context.eventTypes.CHARACTER_MESSAGE_RENDERED) {
        context.eventSource.on(context.eventTypes.CHARACTER_MESSAGE_RENDERED, (messageId) => {
            const tryProcess = (attempt = 1) => {
                const mesElement = document.querySelector(`#chat .mes[mesid="${messageId}"]`);
                if (!mesElement) return;

                const isStreaming = mesElement.classList.contains('streaming') ||
                                   mesElement.classList.contains('is-typing');

                if (isStreaming && attempt < 5) {
                    setTimeout(() => tryProcess(attempt + 1), 1000);
                } else {
                    processMacroMessage(mesElement);
                }
            };
            setTimeout(() => tryProcess(), 500);
        });
    }

    console.log('[MazeMaster] Macro hooks registered');
}

// =============================================================================
// INITIALIZATION
// =============================================================================

// Register slash commands immediately - they don't need DOM
(function registerCommandsImmediately() {
    console.log('[MazeMaster] Registering slash commands immediately...');
    try {
        registerSlashCommands();
        console.log('[MazeMaster] Slash commands registered successfully');
    } catch (err) {
        console.error('[MazeMaster] ERROR registering slash commands:', err);
    }
    try {
        registerMacroHooks();
        console.log('[MazeMaster] Macro hooks registered successfully');
    } catch (err) {
        console.error('[MazeMaster] ERROR registering macro hooks:', err);
    }
})();

// Initialize UI when DOM is ready
(function init() {
    console.log('[MazeMaster] init() starting, readyState:', document.readyState);
    loadSettings();

    if (document.readyState === 'loading') {
        console.log('[MazeMaster] Document still loading, adding DOMContentLoaded listener');
        document.addEventListener('DOMContentLoaded', () => {
            console.log('[MazeMaster] DOMContentLoaded fired');
            try {
                initUI();
                console.log('[MazeMaster] initUI complete');
            } catch (initUIError) {
                console.error('[MazeMaster] ERROR in initUI():', initUIError);
            }
        });
    } else {
        console.log('[MazeMaster] Document ready, initializing UI immediately');
        try {
            initUI();
            console.log('[MazeMaster] initUI complete');
        } catch (initUIError) {
            console.error('[MazeMaster] ERROR in initUI():', initUIError);
        }
    }

    console.log(`[${MODULE_NAME}] Extension loaded (folder: ${EXTENSION_FOLDER_NAME})`);
})();
