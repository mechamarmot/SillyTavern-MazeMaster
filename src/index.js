/* global SillyTavern */

const MODULE_NAME = 'MazeMaster';

// Factory defaults version - increment this when you update DEFAULT_* constants
// and want all users to get the updated factory defaults
const FACTORY_DEFAULTS_VERSION = 10;

// Dynamically detect the extension folder name from the script URL
// This handles both 'MazeMaster' and 'SillyTavern-MazeMaster' folder names
let EXTENSION_FOLDER_NAME = MODULE_NAME;
try {
    // import.meta.url gives us the current script's URL in ES modules
    const scriptUrl = import.meta.url;
    const match = scriptUrl.match(/\/scripts\/extensions\/third-party\/([^/]+)\//);
    if (match && match[1]) {
        EXTENSION_FOLDER_NAME = match[1];
    }
} catch (e) {
    // Fallback: search for our script in document
    const scripts = document.querySelectorAll('script[src*="MazeMaster"]');
    for (const script of scripts) {
        const match = script.src.match(/\/scripts\/extensions\/third-party\/([^/]+)\//);
        if (match && match[1]) {
            EXTENSION_FOLDER_NAME = match[1];
            break;
        }
    }
}

const {
    saveSettingsDebounced,
    SlashCommandParser,
    SlashCommand,
    ARGUMENT_TYPE,
    SlashCommandNamedArgument,
    executeSlashCommandsWithOptions,
    getRequestHeaders,
    callGenericPopup,
    POPUP_TYPE,
    generateQuietPrompt,
    getPresetManager,
    mainApi,
} = SillyTavern.getContext();

// =============================================================================
// CONSTANTS
// =============================================================================

const WHEEL_COLORS = [
    '#e74c3c', '#3498db', '#2ecc71', '#f39c12',
    '#9b59b6', '#1abc9c', '#e67e22', '#34495e',
    '#e91e63', '#00bcd4', '#8bc34a', '#ff5722',
];

const SIZE_UNITS = {
    fraction: 1,
    halfseg: 0.5,
    doubleseg: 2,
};

const SIZE_OPTIONS = ['fraction', 'halfseg', 'doubleseg'];

// Battlebar difficulty: continuous 1-10 scale
// Lower = bigger zone + slower speed, Higher = smaller zone + faster speed
// Maze profiles can apply a difficulty multiplier on top of this
const BATTLEBAR_DIFFICULTY_RANGE = {
    minZoneWidth: 0.10,   // Hardest (difficulty 10)
    maxZoneWidth: 0.45,   // Easiest (difficulty 1)
    minTraverseTime: 1200, // Fastest (difficulty 10)
    maxTraverseTime: 4000, // Slowest (difficulty 1)
};

/**
 * Calculate battlebar settings from difficulty value (1-10)
 * @param {number} difficulty - Base difficulty 1-10 from battlebar profile
 * @param {number} multiplier - Difficulty multiplier from maze profile (default 1.0)
 * @returns {{ zoneWidth: number, traverseTime: number }}
 */
function getBattlebarDifficultySettings(difficulty = 5, multiplier = 1.0) {
    // Apply multiplier to difficulty (higher multiplier = harder)
    const effectiveDifficulty = Math.max(1, Math.min(10, difficulty * multiplier));
    // Convert 1-10 to 0-1 scale
    const t = (effectiveDifficulty - 1) / 9;
    // Interpolate: at t=0 (easy) use max values, at t=1 (hard) use min values
    const range = BATTLEBAR_DIFFICULTY_RANGE;
    const zoneWidth = range.maxZoneWidth - (t * (range.maxZoneWidth - range.minZoneWidth));
    const traverseTime = range.maxTraverseTime - (t * (range.maxTraverseTime - range.minTraverseTime));
    return { zoneWidth, traverseTime: Math.round(traverseTime) };
}

// Legacy compatibility: map old 1-5 scale to new 1-10 scale
const BATTLEBAR_DIFFICULTY_LEGACY = { 1: 2, 2: 4, 3: 5, 4: 7, 5: 9 };

// Default timeout for STScript execution (10 seconds)
const STSCRIPT_TIMEOUT_MS = 10000;

// Difficulty tier configurations for full scaling
const DIFFICULTY_TIERS = {
    easy: {
        name: 'Easy',
        gridSizeRange: { min: 5, max: 10 },
        encounterDensityMult: 1.0,
        trapFrequencyMult: 0.5,
        battlebarZoneMult: 1.3,
        battlebarSpeedMult: 0.8,
        inventoryStartMult: 1.5,
        minionAggressionMult: 0.5,
        chestLootMult: 1.2,
        // HP System multipliers
        hpMult: 1.3,
        damageMult: 0.7,
        healMult: 1.2,
    },
    normal: {
        name: 'Normal',
        gridSizeRange: { min: 5, max: 20 },
        encounterDensityMult: 1.2,
        trapFrequencyMult: 1.0,
        battlebarZoneMult: 1.0,
        battlebarSpeedMult: 1.0,
        inventoryStartMult: 1.0,
        minionAggressionMult: 1.0,
        chestLootMult: 1.0,
        // HP System multipliers
        hpMult: 1.0,
        damageMult: 1.0,
        healMult: 1.0,
    },
    hard: {
        name: 'Hard',
        gridSizeRange: { min: 8, max: 20 },
        encounterDensityMult: 1.5,
        trapFrequencyMult: 1.5,
        battlebarZoneMult: 0.8,
        battlebarSpeedMult: 1.2,
        inventoryStartMult: 0.7,
        minionAggressionMult: 1.5,
        chestLootMult: 0.8,
        // HP System multipliers
        hpMult: 0.8,
        damageMult: 1.3,
        healMult: 0.8,
    },
    nightmare: {
        name: 'Nightmare',
        gridSizeRange: { min: 10, max: 20 },
        encounterDensityMult: 1.8,
        trapFrequencyMult: 2.0,
        battlebarZoneMult: 0.6,
        battlebarSpeedMult: 1.4,
        inventoryStartMult: 0.5,
        minionAggressionMult: 2.0,
        chestLootMult: 0.6,
        // HP System multipliers
        hpMult: 0.6,
        damageMult: 1.6,
        healMult: 0.6,
    },
};

// Scenario themes for flavor text and naming
const SCENARIO_THEMES = {
    fantasy: {
        name: 'Fantasy',
        tileMappings: {
            wall: 'stone wall',
            floor: 'dungeon floor',
            chest: 'treasure chest',
            exit: 'portal to freedom',
            portal: 'mystic gateway',
            trap: 'arcane trap',
            stairUp: 'ascending staircase',
            stairDown: 'descending staircase',
            minion: 'creature',
        },
        itemAliases: {
            key: 'Iron Key',
            stealth: 'Cloak of Shadows',
            strike: 'Battle Fury',
            execute: 'Divine Wrath',
            floorKey: 'Stairway Key',
            portalStone: 'Portal Stone',
            minionBane: 'Monster Bane',
            mapFragment: 'Ancient Map',
            timeShard: 'Time Crystal',
            voidWalk: 'Ghost Step Potion',
        },
        flavorMessages: {
            chestFind: 'You discover an ancient treasure chest!',
            portalUse: 'The mystic gateway shimmers and pulls you through!',
            trapTrigger: 'An arcane glyph activates beneath your feet!',
            stairUp: 'You ascend the ancient staircase...',
            stairDown: 'You descend into the depths below...',
            victory: 'Glory! You have conquered the dungeon!',
            defeat: 'The darkness claims another soul...',
        },
        colors: {
            primary: '#2ecc71',
            secondary: '#27ae60',
            accent: '#f1c40f',
        },
    },
    horror: {
        name: 'Horror',
        tileMappings: {
            wall: 'blood-stained wall',
            floor: 'creaking floorboard',
            chest: 'ominous coffin',
            exit: 'escape route',
            portal: 'dark rift',
            trap: 'deadly snare',
            stairUp: 'rickety ladder up',
            stairDown: 'descending pit',
            minion: 'abomination',
        },
        itemAliases: {
            key: 'Rusty Key',
            stealth: 'Shadow Shroud',
            strike: 'Adrenaline Rush',
            execute: 'Survival Instinct',
            floorKey: 'Cellar Key',
            portalStone: 'Dark Crystal',
            minionBane: 'Banishment Charm',
            mapFragment: 'Torn Note',
            timeShard: 'Slowing Serum',
            voidWalk: 'Phase Vial',
        },
        flavorMessages: {
            chestFind: 'A decrepit coffin... dare you open it?',
            portalUse: 'The rift tears open, pulling you into darkness!',
            trapTrigger: 'You hear a click... then screaming.',
            stairUp: 'The ladder groans under your weight...',
            stairDown: 'You descend into the suffocating darkness...',
            victory: 'You escape... but the nightmares will follow.',
            defeat: 'Your screams echo eternally in the void...',
        },
        colors: {
            primary: '#c0392b',
            secondary: '#8e1b1b',
            accent: '#7f8c8d',
        },
    },
    scifi: {
        name: 'Sci-Fi',
        tileMappings: {
            wall: 'reinforced bulkhead',
            floor: 'metal grating',
            chest: 'supply crate',
            exit: 'escape pod',
            portal: 'warp gate',
            trap: 'security system',
            stairUp: 'elevator up',
            stairDown: 'elevator down',
            minion: 'hostile entity',
        },
        itemAliases: {
            key: 'Access Card',
            stealth: 'Cloaking Device',
            strike: 'Combat Stim',
            execute: 'Overdrive Module',
            floorKey: 'Deck Keycard',
            portalStone: 'Teleport Beacon',
            minionBane: 'EMP Grenade',
            mapFragment: 'Data Pad',
            timeShard: 'Temporal Disruptor',
            voidWalk: 'Phase Shifter',
        },
        flavorMessages: {
            chestFind: 'A sealed supply crate. Contents unknown.',
            portalUse: 'Warp gate activated. Brace for teleportation.',
            trapTrigger: 'SECURITY ALERT: Hostile detected!',
            stairUp: 'Elevator ascending to upper deck...',
            stairDown: 'Elevator descending to lower deck...',
            victory: 'Mission complete. Extraction successful.',
            defeat: 'SYSTEM FAILURE: Life signs terminated.',
        },
        colors: {
            primary: '#3498db',
            secondary: '#2980b9',
            accent: '#1abc9c',
        },
    },
    action: {
        name: 'Action',
        tileMappings: {
            wall: 'concrete barrier',
            floor: 'worn tile',
            chest: 'ammo crate',
            exit: 'extraction point',
            portal: 'fast rope insertion',
            trap: 'booby trap',
            stairUp: 'ladder up',
            stairDown: 'ladder down',
            minion: 'hostile',
        },
        itemAliases: {
            key: 'Master Key',
            stealth: 'Smoke Grenade',
            strike: 'Adrenaline Shot',
            execute: 'Air Strike',
            floorKey: 'Building Key',
            portalStone: 'Zip Line',
            minionBane: 'Flashbang',
            mapFragment: 'Intel Report',
            timeShard: 'Slow-Mo Serum',
            voidWalk: 'Breach Charge',
        },
        flavorMessages: {
            chestFind: 'Supply cache located. Check for booby traps.',
            portalUse: 'Moving to new position!',
            trapTrigger: 'Contact! Hostile fire!',
            stairUp: 'Moving up! Watch your six!',
            stairDown: 'Descending! Stay frosty!',
            victory: 'Area secured. Good work, soldier.',
            defeat: 'Man down! Mission failed.',
        },
        colors: {
            primary: '#e67e22',
            secondary: '#d35400',
            accent: '#95a5a6',
        },
    },
    cyberpunk: {
        name: 'Cyberpunk',
        tileMappings: {
            wall: 'neon-lit barrier',
            floor: 'chrome plating',
            chest: 'data cache',
            exit: 'extraction node',
            portal: 'netrunner jack',
            trap: 'ICE protocol',
            stairUp: 'mag-lift up',
            stairDown: 'mag-lift down',
            minion: 'cyborg',
        },
        itemAliases: {
            key: 'Access Chip',
            stealth: 'Optical Camo',
            strike: 'Combat Stims',
            execute: 'Berserker Mode',
            floorKey: 'Elevator Override',
            portalStone: 'Fast Travel Chip',
            minionBane: 'System Crash',
            mapFragment: 'Hacked Schematic',
            timeShard: 'Reflex Booster',
            voidWalk: 'Ghost Protocol',
        },
        flavorMessages: {
            chestFind: 'Data cache detected. Initiating decrypt...',
            portalUse: 'Jacking in... connection established.',
            trapTrigger: 'ICE DETECTED! Countermeasures active!',
            stairUp: 'Mag-lift ascending to upper level...',
            stairDown: 'Mag-lift descending to sub-level...',
            victory: 'Run complete. Payout received, choom.',
            defeat: 'Flatlined. Your chrome belongs to the corp now.',
        },
        colors: {
            primary: '#ff00ff',
            secondary: '#00ffff',
            accent: '#ffff00',
        },
    },
    noir: {
        name: 'Noir',
        tileMappings: {
            wall: 'rain-streaked wall',
            floor: 'wet pavement',
            chest: 'locked safe',
            exit: 'back alley exit',
            portal: 'secret passage',
            trap: 'hidden wire',
            stairUp: 'fire escape up',
            stairDown: 'cellar stairs',
            minion: 'goon',
        },
        itemAliases: {
            key: 'Skeleton Key',
            stealth: 'Trench Coat',
            strike: 'Brass Knuckles',
            execute: 'Tommy Gun',
            floorKey: 'Service Key',
            portalStone: 'Secret Map',
            minionBane: 'Blackmail File',
            mapFragment: 'Case Notes',
            timeShard: 'Pocket Watch',
            voidWalk: 'Shadow Step',
        },
        flavorMessages: {
            chestFind: 'A safe in the shadows. Someone has secrets...',
            portalUse: 'The bookcase slides aside, revealing a passage.',
            trapTrigger: 'You hear a click. This was a setup.',
            stairUp: 'The fire escape groans in the rain...',
            stairDown: 'Down into the cellar. Watch your back.',
            victory: 'Case closed. Time for a drink.',
            defeat: 'Another gumshoe lost to the city...',
        },
        colors: {
            primary: '#4a4a4a',
            secondary: '#2c2c2c',
            accent: '#c9a227',
        },
    },
    postapoc: {
        name: 'Post-Apocalyptic',
        tileMappings: {
            wall: 'crumbling rubble',
            floor: 'irradiated ground',
            chest: 'salvage pile',
            exit: 'safe zone',
            portal: 'collapsed tunnel',
            trap: 'radiation hotspot',
            stairUp: 'rusted ladder up',
            stairDown: 'crater descent',
            minion: 'mutant',
        },
        itemAliases: {
            key: 'Vault Keycard',
            stealth: 'Ghillie Wrap',
            strike: 'Rad-X Boost',
            execute: 'Mini Nuke',
            floorKey: 'Bunker Code',
            portalStone: 'Signal Flare',
            minionBane: 'Purifier',
            mapFragment: 'Scavenged Map',
            timeShard: 'Stasis Field',
            voidWalk: 'Hazmat Suit',
        },
        flavorMessages: {
            chestFind: 'A salvage cache from the old world...',
            portalUse: 'You squeeze through the collapsed tunnel.',
            trapTrigger: 'GEIGER SPIKE! Radiation flooding the area!',
            stairUp: 'The rusted ladder holds... barely.',
            stairDown: 'Descending into the crater...',
            victory: 'You survived. For now.',
            defeat: 'The wasteland claims another soul...',
        },
        colors: {
            primary: '#8b7355',
            secondary: '#556b2f',
            accent: '#cd853f',
        },
    },
    comedy: {
        name: 'Comedy',
        tileMappings: {
            wall: 'suspiciously normal wall',
            floor: 'slightly sticky floor',
            chest: 'mystery box',
            exit: 'extremely obvious exit',
            portal: 'plot hole',
            trap: 'banana peel',
            stairUp: 'escalator (broken)',
            stairDown: 'slide',
            minion: 'weirdo',
        },
        itemAliases: {
            key: 'Comically Large Key',
            stealth: 'Cardboard Box',
            strike: 'Energy Drink',
            execute: 'Power of Friendship',
            floorKey: 'Janitor\'s Master Key',
            portalStone: 'Plot Device',
            minionBane: 'Bad Pun',
            mapFragment: 'Napkin Drawing',
            timeShard: 'Dramatic Pause',
            voidWalk: 'Fourth Wall Break',
        },
        flavorMessages: {
            chestFind: 'Ooh, a mystery box! It could be anything!',
            portalUse: 'You fall through a plot hole!',
            trapTrigger: 'Classic banana peel. You saw it coming.',
            stairUp: 'The escalator is broken. Guess it\'s just stairs now.',
            stairDown: 'WHEEE! *slide noises*',
            victory: 'You win! The crowd goes mild!',
            defeat: 'Wah wah wahhh... Game Over, buddy.',
        },
        colors: {
            primary: '#ff6b6b',
            secondary: '#feca57',
            accent: '#48dbfb',
        },
    },
    western: {
        name: 'Western',
        tileMappings: {
            wall: 'wooden planks',
            floor: 'dusty floorboards',
            chest: 'strongbox',
            exit: 'town limits',
            portal: 'mine shaft',
            trap: 'rattlesnake den',
            stairUp: 'rickety stairs up',
            stairDown: 'cellar hatch',
            minion: 'outlaw',
        },
        itemAliases: {
            key: 'Skeleton Key',
            stealth: 'Poncho',
            strike: 'Whiskey Courage',
            execute: 'Dynamite Bundle',
            floorKey: 'Mine Key',
            portalStone: 'Treasure Map',
            minionBane: 'Silver Bullet',
            mapFragment: 'Wanted Poster',
            timeShard: 'High Noon Focus',
            voidWalk: 'Tumbleweed Roll',
        },
        flavorMessages: {
            chestFind: 'A locked strongbox. Could be gold inside...',
            portalUse: 'You duck into the old mine shaft.',
            trapTrigger: 'RATTLESNAKES! Draw!',
            stairUp: 'The stairs creak with every step...',
            stairDown: 'Down into the root cellar...',
            victory: 'You ride off into the sunset, partner.',
            defeat: 'This town wasn\'t big enough for both of ya.',
        },
        colors: {
            primary: '#d2691e',
            secondary: '#8b4513',
            accent: '#ffd700',
        },
    },
};

// =============================================================================
// ROOM NAME GENERATION SYSTEM (v1.2.1)
// =============================================================================

/**
 * Theme modifiers applied on top of base mapStyle room names
 */
const THEME_MODIFIERS = {
    fantasy: { adjectives: ['Ancient', 'Mystical', 'Enchanted', 'Arcane', 'Forgotten'] },
    horror: { adjectives: ['Blood-Stained', 'Haunted', 'Cursed', 'Rotting', 'Whispering'] },
    scifi: { adjectives: ['Automated', 'Sterile', 'Malfunctioning', 'Quarantined', 'Pressurized'] },
    action: { adjectives: ['Reinforced', 'Tactical', 'Fortified', 'Hostile', 'Secured'] },
    cyberpunk: { adjectives: ['Neon-Lit', 'Chrome', 'Glitched', 'Hacked', 'Blackmarket'] },
    noir: { adjectives: ['Shadowy', 'Smoky', 'Rain-Soaked', 'Dimly-Lit', 'Forgotten'] },
    postapoc: { adjectives: ['Ruined', 'Overgrown', 'Irradiated', 'Collapsed', 'Scavenged'] },
    comedy: { adjectives: ['Suspiciously Normal', 'Slightly Damp', 'Questionable', 'Overdecorated', 'Poorly Labeled'] },
    western: { adjectives: ['Dusty', 'Sun-Bleached', 'Weathered', 'Abandoned', 'Rickety'] },
};

/**
 * Room name data organized by mapStyle and roomType
 * Room types: common, junction, deadend, staircase, portal, chest, minion, trap, exit, start
 */
const ROOM_NAME_DATA = {
    maze: {
        common: {
            prefixes: ['Winding', 'Narrow', 'Long', 'Dark', 'Quiet'],
            nouns: ['Corridor', 'Passage', 'Hallway', 'Path', 'Tunnel'],
            descriptions: ['The walls press in from both sides.', 'Echoes fade into the distance.', 'The path stretches onward.'],
        },
        junction: {
            prefixes: ['Central', 'Open', 'Connecting', 'Main'],
            nouns: ['Junction', 'Crossroads', 'Intersection', 'Hub'],
            descriptions: ['Multiple paths branch from here.', 'A decision point in the maze.', 'Which way to go?'],
        },
        deadend: {
            prefixes: ['Sealed', 'Blocked', 'Empty', 'Forgotten'],
            nouns: ['Dead End', 'Alcove', 'Nook', 'Corner'],
            descriptions: ['No way forward from here.', 'A quiet corner of the maze.', 'Time to backtrack.'],
        },
        staircase: {
            names: ['The Spiral Path', 'Winding Stairs', 'The Descent', 'Stone Steps'],
            descriptions: ['Worn steps lead to another level.', 'The stairway beckons.'],
        },
        portal: {
            names: ['Mystic Gateway', 'Shimmering Portal', 'The Threshold', 'Warp Point'],
            descriptions: ['Reality bends here.', 'Step through to somewhere else.'],
        },
        chest: {
            names: ['Treasure Alcove', 'Hidden Cache', 'Fortune\'s Corner', 'The Vault'],
            descriptions: ['Something valuable awaits.', 'A promising discovery.'],
        },
        minion: {
            names: ['Guardian\'s Post', 'The Confrontation', 'Danger Zone', 'Enemy Territory'],
            descriptions: ['You sense a presence.', 'Something stirs ahead.'],
        },
        trap: {
            names: ['Treacherous Ground', 'The Snare', 'Danger Ahead', 'False Safety'],
            descriptions: ['The floor seems unstable.', 'Something feels wrong here.'],
        },
        exit: {
            names: ['The Final Gate', 'Freedom\'s Door', 'The End', 'Escape Route'],
            descriptions: ['The exit is within reach!', 'Almost there...'],
        },
        start: {
            names: ['The Beginning', 'Starting Point', 'Entry Hall', 'The Origin'],
            descriptions: ['Your journey begins here.', 'The entrance to the maze.'],
        },
    },
    dungeon: {
        common: {
            prefixes: ['Damp', 'Crumbling', 'Moss-Covered', 'Torch-Lit', 'Stone'],
            nouns: ['Corridor', 'Passage', 'Chamber', 'Tunnel', 'Crypt'],
            descriptions: ['Water drips from the ceiling.', 'Ancient stones line the walls.', 'The air is thick and musty.'],
        },
        junction: {
            prefixes: ['Grand', 'Central', 'Ruined', 'Pillared'],
            nouns: ['Hall', 'Atrium', 'Chamber', 'Rotunda'],
            descriptions: ['Pillars support the vaulted ceiling.', 'Several passages meet here.'],
        },
        deadend: {
            prefixes: ['Collapsed', 'Sealed', 'Empty', 'Forgotten'],
            nouns: ['Tomb', 'Cell', 'Alcove', 'Crypt'],
            descriptions: ['The way is blocked by rubble.', 'Nothing but bones and dust.'],
        },
        staircase: {
            names: ['The Spiral Descent', 'Stone Stairwell', 'Dungeon Steps', 'The Deep Stairs'],
            descriptions: ['Worn steps descend into darkness.', 'Each step echoes ominously.'],
        },
        portal: {
            names: ['Arcane Circle', 'The Dark Rift', 'Summoning Chamber', 'Void Gate'],
            descriptions: ['Strange runes glow on the floor.', 'The air crackles with energy.'],
        },
        chest: {
            names: ['Treasure Vault', 'Burial Cache', 'Hidden Hoard', 'Ancient Coffer'],
            descriptions: ['Gold glimmers in the torchlight.', 'What treasures lie within?'],
        },
        minion: {
            names: ['Guardian\'s Lair', 'The Beast\'s Den', 'Cursed Chamber', 'Haunted Hall'],
            descriptions: ['Something lurks in the shadows.', 'Eyes watch from the darkness.'],
        },
        trap: {
            names: ['Pressure Plates', 'Spike Corridor', 'The Gauntlet', 'Death Trap'],
            descriptions: ['The floor has suspicious tiles.', 'Previous adventurers weren\'t so lucky.'],
        },
        exit: {
            names: ['Dungeon Gate', 'Surface Access', 'The Way Out', 'Freedom\'s Light'],
            descriptions: ['Daylight streams through ahead!', 'The exit awaits!'],
        },
        start: {
            names: ['Dungeon Entrance', 'The First Chamber', 'Entry Vault', 'Beginning of the End'],
            descriptions: ['You enter the dungeon depths.', 'Adventure awaits within.'],
        },
    },
    city: {
        common: {
            prefixes: ['Narrow', 'Crowded', 'Busy', 'Quiet', 'Back'],
            nouns: ['Street', 'Alley', 'Lane', 'Road', 'Avenue'],
            descriptions: ['Buildings tower on either side.', 'The city hums around you.', 'Footsteps echo on cobblestones.'],
        },
        junction: {
            prefixes: ['Main', 'Central', 'Open', 'Market'],
            nouns: ['Square', 'Plaza', 'Intersection', 'Crossroads'],
            descriptions: ['Several streets converge here.', 'A bustling urban hub.'],
        },
        deadend: {
            prefixes: ['Blocked', 'Private', 'Forgotten', 'Secluded'],
            nouns: ['Courtyard', 'Dead End', 'Cul-de-sac', 'Alley'],
            descriptions: ['No way through here.', 'A quiet corner of the city.'],
        },
        staircase: {
            names: ['Fire Escape', 'Metro Stairs', 'Building Access', 'Service Stairwell'],
            descriptions: ['Metal stairs lead up or down.', 'An urban vertical passage.'],
        },
        portal: {
            names: ['Subway Entrance', 'Secret Door', 'Hidden Passage', 'Underground Access'],
            descriptions: ['A way to move quickly.', 'Not everyone knows about this.'],
        },
        chest: {
            names: ['Supply Cache', 'Abandoned Stash', 'Hidden Storage', 'Drop Point'],
            descriptions: ['Someone left supplies here.', 'Could be useful items inside.'],
        },
        minion: {
            names: ['Gang Territory', 'Hostile Zone', 'Ambush Point', 'Danger Zone'],
            descriptions: ['This area isn\'t safe.', 'Watch your back.'],
        },
        trap: {
            names: ['Construction Zone', 'Hazard Area', 'Unstable Ground', 'Danger Zone'],
            descriptions: ['Caution signs litter the area.', 'Something\'s not right here.'],
        },
        exit: {
            names: ['City Limits', 'The Way Out', 'Freedom Boulevard', 'Exit Gate'],
            descriptions: ['Safety is just ahead!', 'Almost out of the city!'],
        },
        start: {
            names: ['Downtown Drop', 'Starting Block', 'Entry Point', 'Ground Zero'],
            descriptions: ['Your urban adventure begins.', 'The city awaits.'],
        },
    },
    forest: {
        common: {
            prefixes: ['Overgrown', 'Shaded', 'Winding', 'Mossy', 'Dense'],
            nouns: ['Path', 'Trail', 'Grove', 'Thicket', 'Clearing'],
            descriptions: ['Leaves rustle overhead.', 'Sunlight filters through the canopy.', 'The forest is alive with sounds.'],
        },
        junction: {
            prefixes: ['Central', 'Open', 'Sunny', 'Ancient'],
            nouns: ['Clearing', 'Glade', 'Meadow', 'Crossroads'],
            descriptions: ['Several paths diverge here.', 'A peaceful clearing in the woods.'],
        },
        deadend: {
            prefixes: ['Tangled', 'Blocked', 'Overgrown', 'Dense'],
            nouns: ['Thicket', 'Dead End', 'Brush', 'Undergrowth'],
            descriptions: ['The vegetation is too thick to pass.', 'No way through this tangle.'],
        },
        staircase: {
            names: ['Root Steps', 'Cliff Path', 'Tree Ladder', 'Natural Stairs'],
            descriptions: ['Natural formations create a path up or down.', 'The terrain changes elevation.'],
        },
        portal: {
            names: ['Fairy Ring', 'Ancient Tree', 'Spirit Gate', 'Enchanted Grove'],
            descriptions: ['Magic lingers in this place.', 'The veil between worlds is thin here.'],
        },
        chest: {
            names: ['Hollow Tree', 'Hidden Cache', 'Nature\'s Gift', 'Forest Bounty'],
            descriptions: ['Something hidden among the roots.', 'The forest provides.'],
        },
        minion: {
            names: ['Beast\'s Territory', 'Predator\'s Ground', 'Wild Zone', 'Creature\'s Lair'],
            descriptions: ['Something territorial lives here.', 'The wildlife seems hostile.'],
        },
        trap: {
            names: ['Quicksand', 'Poison Ivy Patch', 'Hunter\'s Snare', 'Treacherous Ground'],
            descriptions: ['The ground looks unstable.', 'Nature can be dangerous.'],
        },
        exit: {
            names: ['Forest Edge', 'The Clearing', 'Open Fields', 'Way Out'],
            descriptions: ['The tree line ends ahead!', 'Almost out of the forest!'],
        },
        start: {
            names: ['Forest Entrance', 'Trail Head', 'Woods Edge', 'Into the Wild'],
            descriptions: ['The forest path begins here.', 'Adventure awaits in the trees.'],
        },
    },
    outpost: {
        common: {
            prefixes: ['Dusty', 'Wooden', 'Fortified', 'Patrol', 'Guard'],
            nouns: ['Walkway', 'Corridor', 'Passage', 'Path', 'Route'],
            descriptions: ['Wooden planks creak underfoot.', 'The outpost feels hastily constructed.', 'Frontier life is rough.'],
        },
        junction: {
            prefixes: ['Central', 'Main', 'Command', 'Trading'],
            nouns: ['Courtyard', 'Square', 'Hub', 'Plaza'],
            descriptions: ['The heart of the outpost.', 'People gather here.'],
        },
        deadend: {
            prefixes: ['Storage', 'Private', 'Blocked', 'Abandoned'],
            nouns: ['Corner', 'Area', 'Section', 'Alcove'],
            descriptions: ['This area is off-limits.', 'Nothing to see here.'],
        },
        staircase: {
            names: ['Watchtower Ladder', 'Rampart Stairs', 'Cellar Access', 'Tower Steps'],
            descriptions: ['Rough-hewn steps lead up or down.', 'A vertical route through the outpost.'],
        },
        portal: {
            names: ['Secret Tunnel', 'Escape Route', 'Hidden Exit', 'Underground Path'],
            descriptions: ['A hidden way to move quickly.', 'Not on any official maps.'],
        },
        chest: {
            names: ['Supply Crate', 'Armory Cache', 'Provisions Store', 'Trade Goods'],
            descriptions: ['Frontier supplies are valuable.', 'Someone stockpiled resources here.'],
        },
        minion: {
            names: ['Hostile Territory', 'Raider Camp', 'Enemy Ground', 'Danger Zone'],
            descriptions: ['This area isn\'t friendly.', 'Hostiles have been spotted here.'],
        },
        trap: {
            names: ['Perimeter Defense', 'Booby Trap', 'Defensive Line', 'Warning Zone'],
            descriptions: ['The outpost has defenses.', 'Watch where you step.'],
        },
        exit: {
            names: ['Main Gate', 'Frontier Exit', 'The Way Out', 'Open Plains'],
            descriptions: ['The frontier awaits beyond!', 'Almost to safety!'],
        },
        start: {
            names: ['Outpost Gate', 'Arrival Point', 'Entry Post', 'Checkpoint'],
            descriptions: ['Welcome to the frontier.', 'Your mission begins here.'],
        },
    },
    spacestation: {
        common: {
            prefixes: ['Pressurized', 'Maintenance', 'Crew', 'Service', 'Transit'],
            nouns: ['Corridor', 'Deck', 'Section', 'Tube', 'Passageway'],
            descriptions: ['The hum of life support fills the air.', 'Zero-G handles line the walls.', 'Status lights blink in sequence.'],
        },
        junction: {
            prefixes: ['Central', 'Main', 'Command', 'Hub'],
            nouns: ['Atrium', 'Nexus', 'Hub', 'Junction'],
            descriptions: ['Multiple decks connect here.', 'The station\'s central point.'],
        },
        deadend: {
            prefixes: ['Sealed', 'Depressurized', 'Locked', 'Abandoned'],
            nouns: ['Airlock', 'Module', 'Section', 'Bay'],
            descriptions: ['This section is sealed off.', 'No access beyond this point.'],
        },
        staircase: {
            names: ['Deck Ladder', 'Gravity Lift', 'Access Tube', 'Inter-deck Transit'],
            descriptions: ['Vertical transit between decks.', 'Watch your head in zero-G.'],
        },
        portal: {
            names: ['Teleport Pad', 'Warp Gate', 'Transit Pod', 'Instant Travel'],
            descriptions: ['Advanced technology enables instant travel.', 'Step on the pad to teleport.'],
        },
        chest: {
            names: ['Supply Locker', 'Cargo Pod', 'Equipment Bay', 'Resource Cache'],
            descriptions: ['Standard station supplies.', 'Emergency equipment stored here.'],
        },
        minion: {
            names: ['Hostile Sector', 'Quarantine Zone', 'Breach Area', 'Danger Zone'],
            descriptions: ['Security protocols are active.', 'Something hostile is aboard.'],
        },
        trap: {
            names: ['Radiation Leak', 'Decompression Risk', 'Electrical Hazard', 'System Failure'],
            descriptions: ['Warning lights flash urgently.', 'Safety systems are offline.'],
        },
        exit: {
            names: ['Escape Pod Bay', 'Extraction Point', 'Docking Ring', 'The Way Out'],
            descriptions: ['Rescue is just ahead!', 'Almost to the escape pods!'],
        },
        start: {
            names: ['Docking Bay', 'Arrival Deck', 'Entry Point', 'Station Access'],
            descriptions: ['Welcome aboard the station.', 'Your mission begins here.'],
        },
    },
    college: {
        common: {
            prefixes: ['Main', 'Academic', 'Student', 'Faculty', 'Campus'],
            nouns: ['Hallway', 'Corridor', 'Wing', 'Path', 'Walkway'],
            descriptions: ['Lockers line the walls.', 'Motivational posters are everywhere.', 'The smell of cafeteria food lingers.'],
        },
        junction: {
            prefixes: ['Central', 'Main', 'Student', 'Campus'],
            nouns: ['Quad', 'Commons', 'Atrium', 'Hub'],
            descriptions: ['Students gather between classes.', 'The heart of campus life.'],
        },
        deadend: {
            prefixes: ['Maintenance', 'Staff Only', 'Locked', 'Private'],
            nouns: ['Closet', 'Office', 'Room', 'Storage'],
            descriptions: ['This area is restricted.', 'Faculty only beyond this point.'],
        },
        staircase: {
            names: ['Main Stairwell', 'Fire Stairs', 'Back Stairs', 'Service Access'],
            descriptions: ['Standard institutional stairs.', 'Watch out for students rushing to class.'],
        },
        portal: {
            names: ['Secret Passage', 'Underground Tunnel', 'Maintenance Route', 'Shortcut'],
            descriptions: ['Not on the official campus map.', 'Students pass down secret knowledge.'],
        },
        chest: {
            names: ['Lost and Found', 'Supply Closet', 'Locker', 'Hidden Stash'],
            descriptions: ['Someone left something behind.', 'Might find something useful.'],
        },
        minion: {
            names: ['Bully Territory', 'Staff Patrol', 'Security Zone', 'No-Go Area'],
            descriptions: ['Best to avoid this area.', 'Someone unfriendly is here.'],
        },
        trap: {
            names: ['Wet Floor', 'Construction Zone', 'Prank Setup', 'Hazard Area'],
            descriptions: ['Watch your step.', 'Something seems off here.'],
        },
        exit: {
            names: ['Main Exit', 'Campus Gate', 'Front Doors', 'Freedom'],
            descriptions: ['School\'s out!', 'Almost to freedom!'],
        },
        start: {
            names: ['Main Entrance', 'Welcome Hall', 'Registration', 'Starting Point'],
            descriptions: ['Welcome to campus.', 'Your academic adventure begins.'],
        },
    },
    apartment: {
        common: {
            prefixes: ['Narrow', 'Dimly-Lit', 'Carpeted', 'Quiet', 'Long'],
            nouns: ['Hallway', 'Corridor', 'Landing', 'Passage', 'Floor'],
            descriptions: ['Apartment doors line both sides.', 'The building is eerily quiet.', 'Fluorescent lights flicker.'],
        },
        junction: {
            prefixes: ['Main', 'Central', 'Elevator', 'Stair'],
            nouns: ['Lobby', 'Landing', 'Foyer', 'Hub'],
            descriptions: ['Multiple hallways branch from here.', 'The building\'s central area.'],
        },
        deadend: {
            prefixes: ['Locked', 'Private', 'Utility', 'Maintenance'],
            nouns: ['Apartment', 'Room', 'Closet', 'Unit'],
            descriptions: ['This unit is locked.', 'No access here.'],
        },
        staircase: {
            names: ['Fire Stairs', 'Main Stairwell', 'Back Stairs', 'Service Stairs'],
            descriptions: ['Concrete steps echo with each footfall.', 'Standard apartment building stairs.'],
        },
        portal: {
            names: ['Dumbwaiter', 'Laundry Chute', 'Hidden Panel', 'Secret Room'],
            descriptions: ['A hidden way through the building.', 'Not everyone knows about this.'],
        },
        chest: {
            names: ['Storage Unit', 'Abandoned Locker', 'Supply Closet', 'Hidden Cache'],
            descriptions: ['Someone left something behind.', 'Might contain useful items.'],
        },
        minion: {
            names: ['Hostile Unit', 'Occupied Floor', 'Danger Zone', 'Unfriendly Neighbors'],
            descriptions: ['Something unfriendly lives here.', 'Best to be careful.'],
        },
        trap: {
            names: ['Broken Floor', 'Electrical Hazard', 'Gas Leak', 'Structural Damage'],
            descriptions: ['The building isn\'t safe here.', 'Watch your step.'],
        },
        exit: {
            names: ['Main Exit', 'Front Door', 'Fire Exit', 'Street Access'],
            descriptions: ['The street is just ahead!', 'Almost out of the building!'],
        },
        start: {
            names: ['Building Entrance', 'Main Lobby', 'Entry Hall', 'Ground Floor'],
            descriptions: ['You enter the apartment building.', 'Your urban exploration begins.'],
        },
    },
    neotokyo: {
        common: {
            prefixes: ['Neon', 'Crowded', 'Rain-Slicked', 'Holographic', 'Bustling'],
            nouns: ['Street', 'Alley', 'Arcade', 'Passage', 'Lane'],
            descriptions: ['Neon signs reflect off wet pavement.', 'Holographic ads fill the air.', 'The city never sleeps.'],
        },
        junction: {
            prefixes: ['Central', 'Shibuya-Style', 'Main', 'Mega'],
            nouns: ['Crossing', 'Plaza', 'Square', 'Hub'],
            descriptions: ['Thousands of screens illuminate the area.', 'A sensory overload of lights and sounds.'],
        },
        deadend: {
            prefixes: ['Sealed', 'Private', 'VIP', 'Restricted'],
            nouns: ['Booth', 'Room', 'Alley', 'Zone'],
            descriptions: ['No access without credentials.', 'This area is off-limits.'],
        },
        staircase: {
            names: ['Gravity Lift', 'Mag-Rail', 'Sky Bridge', 'Vertical Transit'],
            descriptions: ['High-tech vertical transportation.', 'The city builds upward.'],
        },
        portal: {
            names: ['VR Hub', 'Data Port', 'Network Node', 'Fast Travel'],
            descriptions: ['Jack in to move instantly.', 'The network connects all.'],
        },
        chest: {
            names: ['Vending Cache', 'Data Stash', 'Loot Box', 'Street Vendor'],
            descriptions: ['Even garbage has value here.', 'Credits can buy anything.'],
        },
        minion: {
            names: ['Yakuza Turf', 'Corp Security', 'Gang Territory', 'Hostile Zone'],
            descriptions: ['Someone owns this block.', 'You\'re not welcome here.'],
        },
        trap: {
            names: ['ICE Node', 'Security Grid', 'Drone Patrol', 'Surveillance Zone'],
            descriptions: ['Automated defenses are active.', 'Big Brother is watching.'],
        },
        exit: {
            names: ['City Limits', 'Extraction Point', 'Safe House', 'The Way Out'],
            descriptions: ['Almost out of the neon jungle!', 'Freedom awaits beyond!'],
        },
        start: {
            names: ['Drop Zone', 'Street Level', 'Entry Point', 'Ground Zero'],
            descriptions: ['Welcome to the future.', 'Your cyberpunk adventure begins.'],
        },
    },
    arena: {
        common: {
            prefixes: ['Stone', 'Sandy', 'Blood-Stained', 'Gladiator', 'Battle'],
            nouns: ['Corridor', 'Passage', 'Tunnel', 'Path', 'Way'],
            descriptions: ['The roar of the crowd echoes.', 'Sand and blood mix underfoot.', 'Glory or death awaits.'],
        },
        junction: {
            prefixes: ['Central', 'Main', 'Grand', 'Champion\'s'],
            nouns: ['Arena', 'Ring', 'Pit', 'Stage'],
            descriptions: ['The fighting grounds await.', 'All paths lead to battle.'],
        },
        deadend: {
            prefixes: ['Holding', 'Recovery', 'Equipment', 'Fighter\'s'],
            nouns: ['Cell', 'Room', 'Bay', 'Quarters'],
            descriptions: ['A moment of rest between fights.', 'Prepare for the next battle.'],
        },
        staircase: {
            names: ['Gladiator\'s Rise', 'Champion\'s Lift', 'Arena Access', 'Victory Steps'],
            descriptions: ['The path to glory.', 'Rise to meet your opponent.'],
        },
        portal: {
            names: ['Fighter\'s Gate', 'Champion Portal', 'Mystery Entrance', 'Wild Card'],
            descriptions: ['Where will you emerge?', 'The crowd loves surprises.'],
        },
        chest: {
            names: ['Weapon Rack', 'Prize Cache', 'Spoils of War', 'Victor\'s Reward'],
            descriptions: ['The strong deserve rewards.', 'Claim your prize.'],
        },
        minion: {
            names: ['Fighter\'s Corner', 'Beast Pit', 'Champion\'s Ground', 'Battle Zone'],
            descriptions: ['An opponent awaits.', 'Prepare for combat!'],
        },
        trap: {
            names: ['Spike Pit', 'Fire Trap', 'Collapsing Floor', 'Arena Hazard'],
            descriptions: ['The arena is dangerous.', 'Watch your footing!'],
        },
        exit: {
            names: ['Victor\'s Gate', 'Champion\'s Exit', 'Freedom Gate', 'The Way Out'],
            descriptions: ['Glory awaits the victor!', 'Survive and escape!'],
        },
        start: {
            names: ['Challenger\'s Gate', 'Fighter\'s Entrance', 'Arena Entry', 'The Beginning'],
            descriptions: ['The crowd awaits.', 'Prove your worth!'],
        },
    },
    hospital: {
        common: {
            prefixes: ['Sterile', 'White', 'Quiet', 'Flickering', 'Abandoned'],
            nouns: ['Corridor', 'Hallway', 'Ward', 'Wing', 'Section'],
            descriptions: ['The smell of antiseptic lingers.', 'Medical equipment lies scattered.', 'Fluorescent lights hum overhead.'],
        },
        junction: {
            prefixes: ['Central', 'Main', 'Nurse\'s', 'Reception'],
            nouns: ['Station', 'Hub', 'Desk', 'Lobby'],
            descriptions: ['Multiple wards connect here.', 'The hospital\'s central hub.'],
        },
        deadend: {
            prefixes: ['Private', 'Quarantine', 'Restricted', 'Sealed'],
            nouns: ['Room', 'Bay', 'Ward', 'Unit'],
            descriptions: ['This area is restricted.', 'No access without clearance.'],
        },
        staircase: {
            names: ['Emergency Stairs', 'Service Elevator', 'Staff Access', 'Fire Stairs'],
            descriptions: ['Standard hospital vertical access.', 'Watch for gurneys.'],
        },
        portal: {
            names: ['Morgue Tunnel', 'Utility Access', 'Hidden Passage', 'Underground Route'],
            descriptions: ['Not on the hospital map.', 'A hidden way through.'],
        },
        chest: {
            names: ['Supply Closet', 'Medical Storage', 'Equipment Room', 'Pharmacy Cache'],
            descriptions: ['Medical supplies could be useful.', 'Someone stockpiled resources.'],
        },
        minion: {
            names: ['Quarantine Zone', 'Infected Ward', 'Danger Area', 'Hostile Section'],
            descriptions: ['Something isn\'t right here.', 'Proceed with caution.'],
        },
        trap: {
            names: ['Biohazard Zone', 'Contaminated Area', 'Structural Damage', 'Hazmat Zone'],
            descriptions: ['Warning signs are everywhere.', 'This area isn\'t safe.'],
        },
        exit: {
            names: ['Emergency Exit', 'Main Entrance', 'Ambulance Bay', 'The Way Out'],
            descriptions: ['Fresh air awaits!', 'Almost out of the hospital!'],
        },
        start: {
            names: ['ER Entrance', 'Main Lobby', 'Admission', 'Ground Floor'],
            descriptions: ['You enter the hospital.', 'Something feels wrong here.'],
        },
    },
    highrise: {
        common: {
            prefixes: ['Dusty', 'Abandoned', 'Crumbling', 'Empty', 'Dark'],
            nouns: ['Hallway', 'Floor', 'Corridor', 'Office', 'Suite'],
            descriptions: ['Abandoned furniture gathers dust.', 'The building creaks in the wind.', 'Nature reclaims the space.'],
        },
        junction: {
            prefixes: ['Main', 'Central', 'Executive', 'Open'],
            nouns: ['Lobby', 'Atrium', 'Floor', 'Hub'],
            descriptions: ['Once a place of business.', 'Multiple paths through the floor.'],
        },
        deadend: {
            prefixes: ['Collapsed', 'Sealed', 'Blocked', 'Destroyed'],
            nouns: ['Office', 'Room', 'Section', 'Area'],
            descriptions: ['The way is impassable.', 'Structural damage blocks the path.'],
        },
        staircase: {
            names: ['Fire Stairs', 'Emergency Exit', 'Service Stairs', 'Broken Elevator'],
            descriptions: ['Concrete stairs wind upward.', 'The elevator hasn\'t worked in years.'],
        },
        portal: {
            names: ['Window Ledge', 'Broken Wall', 'Collapsed Floor', 'Vent Shaft'],
            descriptions: ['An unconventional route.', 'Not for the faint of heart.'],
        },
        chest: {
            names: ['Old Safe', 'Forgotten Cache', 'Executive Stash', 'Supply Closet'],
            descriptions: ['Something was left behind.', 'Previous occupants stored valuables.'],
        },
        minion: {
            names: ['Squatter\'s Territory', 'Hostile Floor', 'Danger Zone', 'Occupied Area'],
            descriptions: ['Someone else calls this home.', 'You\'re not alone here.'],
        },
        trap: {
            names: ['Weak Floor', 'Broken Glass', 'Falling Debris', 'Structural Collapse'],
            descriptions: ['The building is unstable.', 'Every step could be your last.'],
        },
        exit: {
            names: ['Ground Floor', 'Street Exit', 'Fire Escape', 'The Way Out'],
            descriptions: ['Solid ground awaits!', 'Almost out of the building!'],
        },
        start: {
            names: ['Rooftop Access', 'Upper Floor', 'Entry Point', 'The Beginning'],
            descriptions: ['You enter the abandoned building.', 'Urban exploration begins.'],
        },
    },
};

/**
 * Determine the room type based on cell properties
 * @param {object} cell - The cell to analyze
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 * @param {number} size - Grid size
 * @param {number} exitX - Exit X coordinate
 * @param {number} exitY - Exit Y coordinate
 * @returns {string} Room type identifier
 */
function determineRoomType(cell, x, y, size, exitX, exitY) {
    // Check for special tiles first (priority order)
    if (x === 0 && y === 0) return 'start';
    if (x === exitX && y === exitY) return 'exit';
    if (cell.staircase) return 'staircase';
    if (cell.portal) return 'portal';
    if (cell.chest) return 'chest';
    if (cell.minion) return 'minion';
    if (cell.trap) return 'trap';

    // Count open exits (no walls)
    const exits = [!cell.walls.top, !cell.walls.right, !cell.walls.bottom, !cell.walls.left].filter(Boolean).length;

    if (exits >= 3) return 'junction';
    if (exits === 1) return 'deadend';
    return 'common';
}

/**
 * Generate room info (name and description) for a cell
 * @param {object} cell - The cell to generate info for
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 * @param {object} profile - The maze profile with theme and mapStyle
 * @param {number} size - Grid size
 * @param {number} exitX - Exit X coordinate
 * @param {number} exitY - Exit Y coordinate
 * @returns {object} { name, description, roomType }
 */
function generateRoomInfo(cell, x, y, profile, size, exitX, exitY) {
    const theme = profile.theme || 'fantasy';
    const mapStyle = profile.mapStyle || 'maze';
    const roomType = determineRoomType(cell, x, y, size, exitX, exitY);

    // Get room data for this mapStyle and roomType, fallback to maze/common
    const styleData = ROOM_NAME_DATA[mapStyle] || ROOM_NAME_DATA.maze;
    const roomData = styleData[roomType] || styleData.common;
    const themeModifier = THEME_MODIFIERS[theme] || THEME_MODIFIERS.fantasy;

    let name, description;

    if (roomData.names) {
        // Special room type with predefined names
        name = roomData.names[Math.floor(Math.random() * roomData.names.length)];
    } else {
        // Common room type with prefix + noun construction
        const prefix = roomData.prefixes[Math.floor(Math.random() * roomData.prefixes.length)];
        const noun = roomData.nouns[Math.floor(Math.random() * roomData.nouns.length)];

        // 30% chance to add a theme modifier adjective
        if (Math.random() < 0.3 && themeModifier.adjectives) {
            const themeAdj = themeModifier.adjectives[Math.floor(Math.random() * themeModifier.adjectives.length)];
            name = `${themeAdj} ${prefix} ${noun}`;
        } else {
            name = `${prefix} ${noun}`;
        }
    }

    // Pick a random description
    description = roomData.descriptions[Math.floor(Math.random() * roomData.descriptions.length)];

    return { name, description, roomType };
}

/**
 * Generate room info for all cells in a floor grid
 * @param {array} grid - The floor grid
 * @param {object} profile - The maze profile
 * @param {number} size - Grid size
 * @param {number} exitX - Exit X coordinate
 * @param {number} exitY - Exit Y coordinate
 */
function generateRoomInfoForGrid(grid, profile, size, exitX, exitY) {
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const cell = grid[y][x];
            cell.roomInfo = generateRoomInfo(cell, x, y, profile, size, exitX, exitY);
        }
    }
}

// =============================================================================
// PLUGGABLE RENDERER SYSTEM (v1.2.0)
// =============================================================================

/**
 * Base MazeRenderer interface - all renderers must implement these methods
 * This abstraction allows swapping between CSS Grid, Canvas, WebGL, Isometric, etc.
 */
class MazeRenderer {
    constructor(options = {}) {
        this.options = options;
        this.container = null;
        this.initialized = false;
    }

    /**
     * Get the renderer type identifier
     * @returns {string}
     */
    getType() {
        return 'base';
    }

    /**
     * Initialize the renderer with a container element
     * @param {HTMLElement} container - The container to render into
     * @param {Object} mazeState - Initial maze state
     */
    init(container, mazeState) {
        this.container = container;
        this.initialized = true;
    }

    /**
     * Get the HTML template for the grid container
     * @param {number} size - Grid size
     * @returns {string} HTML string
     */
    getGridHTML(size) {
        throw new Error('getGridHTML must be implemented by subclass');
    }

    /**
     * Get the HTML for the player overlay element
     * @param {number} cellSize - Size of each cell
     * @returns {string} HTML string
     */
    getPlayerOverlayHTML(cellSize) {
        throw new Error('getPlayerOverlayHTML must be implemented by subclass');
    }

    /**
     * Calculate cell size based on grid size
     * @param {number} gridSize - Number of cells per side
     * @returns {number} Cell size in pixels
     */
    getCellSize(gridSize) {
        // Larger cells for desktop - map area has more space now
        if (gridSize <= 5) return 50;
        if (gridSize <= 7) return 45;
        if (gridSize <= 10) return 38;
        if (gridSize <= 12) return 32;
        if (gridSize <= 15) return 26;
        return 22;
    }

    /**
     * Render the entire maze grid
     * @param {Object} mazeState - Current maze state
     */
    render(mazeState) {
        throw new Error('render must be implemented by subclass');
    }

    /**
     * Update player position with optional animation
     * @param {number} x - Player X coordinate
     * @param {number} y - Player Y coordinate
     * @param {boolean} animate - Whether to animate the movement
     * @param {number} cellSize - Size of each cell
     */
    updatePlayerPosition(x, y, animate, cellSize) {
        throw new Error('updatePlayerPosition must be implemented by subclass');
    }

    /**
     * Highlight a cell (for encounters, selection, etc.)
     * @param {number} x - Cell X coordinate
     * @param {number} y - Cell Y coordinate
     * @param {string} type - Highlight type (encounter, selected, path, etc.)
     */
    highlightCell(x, y, type) {
        // Optional - base implementation does nothing
    }

    /**
     * Clear all highlights
     */
    clearHighlights() {
        // Optional - base implementation does nothing
    }

    /**
     * Play a visual effect at a cell
     * @param {number} x - Cell X coordinate
     * @param {number} y - Cell Y coordinate
     * @param {string} effect - Effect name (teleport, damage, heal, etc.)
     */
    playEffect(x, y, effect) {
        // Optional - base implementation does nothing
    }

    /**
     * Get CSS styles required by this renderer
     * @returns {string} CSS styles string
     */
    getStyles() {
        return '';
    }

    /**
     * Clean up renderer resources
     */
    cleanup() {
        this.initialized = false;
        this.container = null;
    }
}

/**
 * CSS Grid Renderer - Current default renderer using CSS Grid layout
 * Simple, fast, works everywhere, easy to style with CSS
 */
class CSSGridRenderer extends MazeRenderer {
    getType() {
        return 'css-grid';
    }

    /**
     * Get CSS filter and color for map style differentiation
     */
    getStyleCSS(mapStyle) {
        const styles = {
            dungeon: { filter: 'saturate(0.7)', bg: '#1a1520', accent: '#6b5b7a' },
            maze: { filter: 'hue-rotate(20deg)', bg: '#1a1828', accent: '#7866a0' },
            forest: { filter: 'saturate(1.4) hue-rotate(-15deg)', bg: '#0d1a0d', accent: '#4a7a4a' },
            city: { filter: 'saturate(0.6) contrast(1.1)', bg: '#161820', accent: '#6a7080' },
            spacestation: { filter: 'saturate(1.2) hue-rotate(200deg)', bg: '#0d1525', accent: '#4080b0' },
            college: { filter: 'sepia(0.3)', bg: '#1a1510', accent: '#9a8060' },
            apartment: { filter: 'sepia(0.2)', bg: '#1a1612', accent: '#8a7660' },
            neotokyo: { filter: 'saturate(1.5) hue-rotate(300deg)', bg: '#1a0d18', accent: '#b040a0' },
            arena: { filter: 'hue-rotate(25deg) saturate(1.2)', bg: '#1a1408', accent: '#b07040' },
            hospital: { filter: 'saturate(0.5) brightness(1.1)', bg: '#141a1a', accent: '#60a0a0' },
            highrise: { filter: 'saturate(0.4) contrast(1.2)', bg: '#12121a', accent: '#606080' },
            outpost: { filter: 'sepia(0.4) hue-rotate(15deg)', bg: '#1a1508', accent: '#a08040' },
        };
        return styles[mapStyle] || styles.dungeon;
    }

    getGridHTML(size) {
        const cellSize = this.getCellSize(size);
        return `
            <div id="maze_grid" class="maze-grid" style="
                display: grid;
                grid-template-columns: repeat(${size}, ${cellSize}px);
                gap: 0;
                position: relative;
            "></div>
        `;
    }

    getPlayerOverlayHTML(cellSize) {
        return `
            <div id="maze_player_overlay" class="maze-player-overlay" style="width: ${cellSize}px; height: ${cellSize}px;">
                <div class="maze-player-marker"></div>
            </div>
        `;
    }

    render(mazeState) {
        const { grid, size, playerX, playerY, visited, exitX, exitY, isVictory, profile, currentFloor, totalFloors } = mazeState;
        const gridEl = document.getElementById('maze_grid');
        if (!gridEl) return;

        const cellSize = this.getCellSize(size);
        // Map visibility: 'showAll', 'fogOfWar', 'hideUnexplored' (backward compat with fogOfWar boolean)
        const mapVisibility = profile?.mapVisibility || (profile?.fogOfWar === false ? 'showAll' : 'fogOfWar');
        gridEl.style.gridTemplateColumns = `repeat(${size}, ${cellSize}px)`;
        gridEl.innerHTML = '';

        // Apply aggressive map style coloring
        const styleCSS = this.getStyleCSS(profile?.mapStyle);
        gridEl.style.filter = styleCSS.filter;
        gridEl.style.backgroundColor = styleCSS.bg;
        gridEl.style.setProperty('--map-accent', styleCSS.accent);

        // Build visited key - always use floor prefix for consistency
        const floorPrefix = `${currentFloor}:`;

        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const cell = grid[y][x];
                const cellEl = document.createElement('div');
                cellEl.className = 'maze-cell';
                cellEl.style.width = `${cellSize}px`;
                cellEl.style.height = `${cellSize}px`;

                // Check visited status (support both old and new format)
                const keyNew = `${floorPrefix}${x},${y}`;
                const keyOld = `${x},${y}`;
                const isVisited = visited.has(keyNew) || visited.has(keyOld);
                const isPlayer = x === playerX && y === playerY;
                const isExit = x === exitX && y === exitY;

                // Determine visibility based on mapVisibility setting
                let showAsVisited = false;
                let hideCompletely = false;
                if (mapVisibility === 'showAll') {
                    showAsVisited = true;
                } else if (mapVisibility === 'hideUnexplored') {
                    showAsVisited = isVisited || isPlayer; // Always show player cell
                    hideCompletely = !isVisited && !isPlayer;
                } else { // fogOfWar (default)
                    showAsVisited = isVisited || isPlayer;
                }

                // Hide unexplored mode: completely hide unvisited cells
                if (hideCompletely) {
                    cellEl.classList.add('completely-hidden');
                } else if (!showAsVisited) {
                    // Fog of war mode: show "?" for unvisited
                    cellEl.classList.add('hidden');
                } else {
                    cellEl.classList.add('visited');
                    if (cell.walls.top) cellEl.classList.add('wall-top');
                    if (cell.walls.right) cellEl.classList.add('wall-right');
                    if (cell.walls.bottom) cellEl.classList.add('wall-bottom');
                    if (cell.walls.left) cellEl.classList.add('wall-left');
                }

                if (isPlayer) cellEl.classList.add('player');
                const isFinalFloor = currentFloor === totalFloors - 1;
                if (isExit && showAsVisited && isFinalFloor) {
                    cellEl.classList.add('exit');
                    if (isVictory) cellEl.classList.add('victory-glow');
                }

                // Minion indicators
                if (cell.minion && showAsVisited) {
                    cellEl.classList.add('has-minion');
                    if (cell.minion.triggered) {
                        cellEl.classList.add('minion-triggered');
                    }
                }

                // Chest indicators
                if (cell.chest && showAsVisited) {
                    cellEl.classList.add('has-chest');
                    if (cell.chest.type === 'locked') cellEl.classList.add('chest-locked');
                    if (cell.chest.opened) cellEl.classList.add('chest-opened');

                    // Custom chest image
                    if (profile?.chestImage && !cell.chest.opened) {
                        cellEl.classList.add('has-custom-chest');
                        const chestImg = document.createElement('img');
                        chestImg.src = getExtensionImagePath(profile.chestImage);
                        chestImg.className = 'maze-chest-img';
                        chestImg.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 70%; height: 70%; object-fit: cover; border-radius: 3px; z-index: 1;';
                        if (cell.chest.type === 'locked') chestImg.style.filter = 'grayscale(50%)';
                        cellEl.appendChild(chestImg);
                    }
                }

                // Trap indicators
                if (cell.trap && showAsVisited) {
                    cellEl.classList.add('has-trap');
                    if (cell.trap.triggered) cellEl.classList.add('trap-triggered');
                }

                // Portal indicators
                if (cell.portal && showAsVisited) {
                    cellEl.classList.add('has-portal');
                    cellEl.dataset.portalColor = cell.portal.color || '#9b59b6';
                    cellEl.style.setProperty('--portal-color', cell.portal.color || '#9b59b6');
                    if (!cell.portal.bidirectional && !cell.portal.isStart) {
                        cellEl.classList.add('portal-exit-only');
                    }
                }

                // Staircase indicators
                if (cell.staircase && showAsVisited) {
                    cellEl.classList.add('has-staircase');
                    cellEl.classList.add(cell.staircase.direction === 'up' ? 'staircase-up' : 'staircase-down');
                    if (cell.staircase.requireKey) cellEl.classList.add('staircase-locked');
                }

                // Safe room indicator (healing zone)
                if (cell.safeRoom && !cell.safeRoom.exhausted && showAsVisited) {
                    cellEl.classList.add('safe-room');
                }

                // Store coordinates for event handling
                cellEl.dataset.x = x;
                cellEl.dataset.y = y;

                gridEl.appendChild(cellEl);
            }
        }
    }

    updatePlayerPosition(x, y, animate, cellSize) {
        const overlay = document.getElementById('maze_player_overlay');
        if (!overlay) return;

        const pixelX = x * cellSize;
        const pixelY = y * cellSize;

        if (!animate) {
            overlay.style.transition = 'none';
        } else {
            overlay.style.transition = 'transform 0.15s ease-out';
        }

        overlay.style.transform = `translate(${pixelX}px, ${pixelY}px)`;

        if (!animate) {
            requestAnimationFrame(() => {
                overlay.style.transition = 'transform 0.15s ease-out';
            });
        }
    }

    highlightCell(x, y, type) {
        const cell = document.querySelector(`.maze-cell[data-x="${x}"][data-y="${y}"]`);
        if (cell) {
            cell.classList.add(`highlight-${type}`);
        }
    }

    clearHighlights() {
        document.querySelectorAll('.maze-cell[class*="highlight-"]').forEach(cell => {
            cell.className = cell.className.replace(/highlight-\w+/g, '').trim();
        });
    }

    playEffect(x, y, effect) {
        const cell = document.querySelector(`.maze-cell[data-x="${x}"][data-y="${y}"]`);
        if (!cell) return;

        cell.classList.add(`effect-${effect}`);
        setTimeout(() => {
            cell.classList.remove(`effect-${effect}`);
        }, 500);
    }
}

/**
 * Get theme-based minion color for 2D rendering
 * v1.4.2: Shared helper for theme-based minion recoloring
 */
function getThemeMinionColor(theme) {
    const colors = {
        fantasy: '#ef4444',   // Red
        horror: '#5a5a6a',    // Gray/purple undead
        scifi: '#06b6d4',     // Cyan
        cyberpunk: '#ec4899', // Hot pink
        western: '#92400e',   // Brown/rust
        action: '#dc2626',    // Bright red
        comedy: '#84cc16',    // Lime green
        postapoc: '#78716c',  // Ash gray
    };
    return colors[theme] || colors.fantasy;
}

/**
 * Canvas Renderer - Placeholder for future sprite-based 2.5D rendering
 * Will use HTML5 Canvas for tile/sprite rendering
 */
class CanvasRenderer extends MazeRenderer {
    constructor(options = {}) {
        super(options);
        this.canvas = null;
        this.ctx = null;
        this.sprites = {};
        this.tileSize = options.tileSize || 32;
    }

    getType() {
        return 'canvas';
    }

    getGridHTML(size) {
        const canvasSize = size * this.tileSize;
        return `
            <canvas id="maze_canvas" width="${canvasSize}" height="${canvasSize}" style="
                display: block;
                image-rendering: pixelated;
            "></canvas>
        `;
    }

    getPlayerOverlayHTML(cellSize) {
        // Canvas renderer doesn't use overlay - player is drawn on canvas
        return '';
    }

    async loadSprites(spriteMap) {
        // spriteMap: { floor: 'url', wall: 'url', player: 'url', ... }
        const loadPromises = Object.entries(spriteMap).map(async ([key, url]) => {
            const img = new Image();
            img.src = url;
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
            });
            this.sprites[key] = img;
        });
        await Promise.all(loadPromises);
    }

    init(container, mazeState) {
        super.init(container, mazeState);
        this.canvas = document.getElementById('maze_canvas');
        if (this.canvas) {
            this.ctx = this.canvas.getContext('2d');
        }
    }

    render(mazeState) {
        if (!this.ctx) return;

        const { grid, size, playerX, playerY, visited, exitX, exitY, profile, currentFloor, totalFloors } = mazeState;
        const ts = this.tileSize;
        // Map visibility: 'showAll', 'fogOfWar', 'hideUnexplored' (backward compat with fogOfWar boolean)
        const mapVisibility = profile?.mapVisibility || (profile?.fogOfWar === false ? 'showAll' : 'fogOfWar');

        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw tiles
        // Build visited key - always use floor prefix for consistency
        const floorPrefix = `${currentFloor}:`;

        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const cell = grid[y][x];
                const keyNew = `${floorPrefix}${x},${y}`;
                const keyOld = `${x},${y}`;
                const isVisited = visited.has(keyNew) || visited.has(keyOld);
                const isPlayer = x === playerX && y === playerY;

                // Determine visibility based on mapVisibility setting
                let showAsVisited = false;
                let hideCompletely = false;
                if (mapVisibility === 'showAll') {
                    showAsVisited = true;
                } else if (mapVisibility === 'hideUnexplored') {
                    showAsVisited = isVisited || isPlayer; // Always show player cell
                    hideCompletely = !isVisited && !isPlayer;
                } else { // fogOfWar (default)
                    showAsVisited = isVisited || isPlayer;
                }

                if (hideCompletely) {
                    // Hide unexplored - draw nothing (transparent/black)
                    continue;
                } else if (!showAsVisited) {
                    // Fog of war - draw dark with "?" hint
                    this.ctx.fillStyle = '#1a1a2e';
                    this.ctx.fillRect(x * ts, y * ts, ts, ts);
                } else {
                    // Draw floor sprite or fallback color
                    if (this.sprites.floor) {
                        this.ctx.drawImage(this.sprites.floor, x * ts, y * ts, ts, ts);
                    } else {
                        this.ctx.fillStyle = '#2d2d44';
                        this.ctx.fillRect(x * ts, y * ts, ts, ts);
                    }

                    // Draw walls
                    this.ctx.strokeStyle = '#8b5cf6';
                    this.ctx.lineWidth = 2;
                    if (cell.walls.top) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x * ts, y * ts);
                        this.ctx.lineTo((x + 1) * ts, y * ts);
                        this.ctx.stroke();
                    }
                    if (cell.walls.right) {
                        this.ctx.beginPath();
                        this.ctx.moveTo((x + 1) * ts, y * ts);
                        this.ctx.lineTo((x + 1) * ts, (y + 1) * ts);
                        this.ctx.stroke();
                    }
                    if (cell.walls.bottom) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x * ts, (y + 1) * ts);
                        this.ctx.lineTo((x + 1) * ts, (y + 1) * ts);
                        this.ctx.stroke();
                    }
                    if (cell.walls.left) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x * ts, y * ts);
                        this.ctx.lineTo(x * ts, (y + 1) * ts);
                        this.ctx.stroke();
                    }

                    // Draw exit (only on final floor)
                    const isFinalFloor = currentFloor === totalFloors - 1;
                    if (x === exitX && y === exitY && isFinalFloor) {
                        if (this.sprites.exit) {
                            this.ctx.drawImage(this.sprites.exit, x * ts, y * ts, ts, ts);
                        } else {
                            this.ctx.fillStyle = '#22c55e';
                            this.ctx.fillRect(x * ts + 4, y * ts + 4, ts - 8, ts - 8);
                        }
                    }

                    // Draw entities
                    if (cell.chest && !cell.chest.opened) {
                        if (this.sprites.chest) {
                            this.ctx.drawImage(this.sprites.chest, x * ts, y * ts, ts, ts);
                        } else {
                            this.ctx.fillStyle = '#f59e0b';
                            this.ctx.fillRect(x * ts + 6, y * ts + 6, ts - 12, ts - 12);
                        }
                    }

                    if (cell.minion && !cell.minion.triggered) {
                        // v1.4.2: Theme-based minion coloring
                        const minionColor = getThemeMinionColor(profile?.theme);
                        if (this.sprites.minion) {
                            this.ctx.drawImage(this.sprites.minion, x * ts, y * ts, ts, ts);
                        } else {
                            this.ctx.fillStyle = minionColor;
                            this.ctx.beginPath();
                            this.ctx.arc(x * ts + ts/2, y * ts + ts/2, ts/4, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
            }
        }

        // Draw player
        if (this.sprites.player) {
            this.ctx.drawImage(this.sprites.player, playerX * ts, playerY * ts, ts, ts);
        } else {
            this.ctx.fillStyle = '#3b82f6';
            this.ctx.beginPath();
            this.ctx.arc(playerX * ts + ts/2, playerY * ts + ts/2, ts/3, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    updatePlayerPosition(x, y, animate, cellSize) {
        // Canvas renderer re-renders everything, no separate update needed
        // Animation would be handled via requestAnimationFrame in a real implementation
    }

    getCellSize(gridSize) {
        return this.tileSize;
    }
}

/**
 * Isometric Renderer - Full 2.5D isometric rendering with programmatic sprites
 * Supports both generated placeholders and loaded sprite assets
 */
class IsometricRenderer extends CanvasRenderer {
    constructor(options = {}) {
        super(options);
        this.tileWidth = options.tileWidth || 64;
        this.tileHeight = options.tileHeight || 32;
        this.wallHeight = options.wallHeight || 24;
        this.spriteCache = {};
        this.spritesLoaded = false;
        this.spritesLoading = false;
        this.currentMapStyle = 'dungeon';

        // Generate sprite paths based on mapStyle
        this.spritePaths = this.getSpritePathsForStyle(this.currentMapStyle);

        // Fallback color palette for procedural sprites (used if sprites not loaded)
        this.palette = {
            floor: { top: '#3d3d5c', light: '#4a4a6a', dark: '#2d2d44' },
            wall: { top: '#6b5b95', light: '#8b7bb5', dark: '#4b3b75' },
            fog: { top: '#2a2a4e', light: '#3a3a6a', dark: '#1a1a3a' },
            exit: { top: '#22c55e', light: '#4ade80', dark: '#16a34a' },
            chest: { top: '#f59e0b', light: '#fbbf24', dark: '#d97706' },
            chestOpen: { top: '#78716c', light: '#a8a29e', dark: '#57534e' },
            minion: { top: '#ef4444', light: '#f87171', dark: '#dc2626' },
            trap: { top: '#a855f7', light: '#c084fc', dark: '#9333ea' },
            portal: { top: '#06b6d4', light: '#22d3ee', dark: '#0891b2' },
            stairUp: { top: '#10b981', light: '#34d399', dark: '#059669' },
            stairDown: { top: '#f97316', light: '#fb923c', dark: '#ea580c' },
            player: { top: '#3b82f6', light: '#60a5fa', dark: '#2563eb' },
            safeRoom: { top: '#2dd4bf', light: '#5eead4', dark: '#14b8a6' }, // Teal for healing zones
        };
    }

    getType() {
        return 'isometric';
    }

    /**
     * Generate sprite paths for a given map style
     */
    getSpritePathsForStyle(mapStyle) {
        const style = mapStyle || 'dungeon';
        return {
            floor: `assets/isometric/${style}/floor.png`,
            wall: `assets/isometric/${style}/wall.png`,
            wallCorner: `assets/isometric/${style}/wall_corner.png`,
            fog: `assets/isometric/${style}/fog.png`,
            exit: `assets/isometric/${style}/exit.png`,
            chest: `assets/isometric/${style}/chest_closed.png`,
            chestOpen: `assets/isometric/${style}/chest_open.png`,
            portal: `assets/isometric/${style}/portal.png`,
            trap: `assets/isometric/${style}/trap.png`,
            minion: `assets/isometric/${style}/minion.png`,
            player: `assets/isometric/${style}/player.png`,
            stairsUp: `assets/isometric/${style}/stairs_up.png`,
            stairsDown: `assets/isometric/${style}/stairs_down.png`,
        };
    }

    /**
     * Set map style and reload sprites if changed
     */
    setMapStyle(mapStyle) {
        const newStyle = mapStyle || 'dungeon';
        if (newStyle !== this.currentMapStyle) {
            this.currentMapStyle = newStyle;
            this.spritePaths = this.getSpritePathsForStyle(newStyle);
            this.spriteCache = {};
            this.spritesLoaded = false;
            this.spritesLoading = false;
            this.loadSprites();
        }
    }

    /**
     * Get ambient color tint for map style (applied as overlay)
     */
    getStyleTint(mapStyle) {
        // Aggressive color tints for strong visual differentiation
        const tints = {
            dungeon: { r: 40, g: 30, b: 50, a: 0.25 },       // Deep purple dungeon
            maze: { r: 60, g: 50, b: 80, a: 0.3 },           // Mystical purple
            forest: { r: 20, g: 100, b: 40, a: 0.35 },       // Vibrant green
            city: { r: 80, g: 90, b: 100, a: 0.3 },          // Cool gray-blue urban
            spacestation: { r: 30, g: 60, b: 120, a: 0.4 },  // Strong sci-fi blue
            college: { r: 100, g: 80, b: 50, a: 0.25 },      // Warm sepia academic
            apartment: { r: 90, g: 70, b: 50, a: 0.3 },      // Warm cozy indoor
            neotokyo: { r: 140, g: 40, b: 100, a: 0.4 },     // Intense neon pink
            arena: { r: 120, g: 60, b: 30, a: 0.35 },        // Hot sandy/orange
            hospital: { r: 60, g: 100, b: 100, a: 0.35 },    // Cold teal sterile
            highrise: { r: 50, g: 50, b: 70, a: 0.4 },       // Dark slate concrete
            outpost: { r: 100, g: 80, b: 40, a: 0.35 },      // Dusty desert tan
        };
        return tints[mapStyle] || tints.dungeon;
    }

    /**
     * Get aggressive CSS filter for minion sprites based on theme
     * v1.4.2: Theme-based minion recoloring
     */
    getThemeMinionFilter(theme) {
        const filters = {
            fantasy: 'hue-rotate(0deg) saturate(1.2) brightness(1.0)',           // Default warm colors
            horror: 'hue-rotate(270deg) saturate(0.4) brightness(0.7) contrast(1.3)',  // Desaturated purple/gray, dark
            scifi: 'hue-rotate(180deg) saturate(1.5) brightness(1.2)',           // Cyan/teal shift
            cyberpunk: 'hue-rotate(300deg) saturate(2.0) brightness(1.1) contrast(1.2)', // Hot pink/magenta
            western: 'hue-rotate(30deg) saturate(0.8) sepia(0.5) brightness(1.0)', // Sepia/dusty brown
            action: 'hue-rotate(0deg) saturate(1.4) contrast(1.3) brightness(1.1)', // High contrast, vivid
            comedy: 'hue-rotate(60deg) saturate(2.0) brightness(1.3)',           // Bright yellow/green shift
            postapoc: 'hue-rotate(20deg) saturate(0.5) sepia(0.4) brightness(0.8)', // Muted brown/rust
        };
        return filters[theme] || filters.fantasy;
    }

    /**
     * Get minion palette colors based on theme
     * v1.4.2: Theme-based minion recoloring for fallback sprites
     */
    getThemeMinionPalette(theme) {
        const palettes = {
            fantasy: { top: '#ef4444', light: '#f87171', dark: '#dc2626' },      // Red (default)
            horror: { top: '#4a4a5a', light: '#6a6a7a', dark: '#2a2a3a' },        // Gray/purple undead
            scifi: { top: '#06b6d4', light: '#22d3ee', dark: '#0891b2' },         // Cyan/teal
            cyberpunk: { top: '#ec4899', light: '#f472b6', dark: '#db2777' },     // Hot pink
            western: { top: '#92400e', light: '#b45309', dark: '#78350f' },       // Brown/rust
            action: { top: '#dc2626', light: '#ef4444', dark: '#b91c1c' },        // Bright red
            comedy: { top: '#84cc16', light: '#a3e635', dark: '#65a30d' },        // Lime green
            postapoc: { top: '#78716c', light: '#a8a29e', dark: '#57534e' },      // Ash gray
        };
        return palettes[theme] || palettes.fantasy;
    }

    /**
     * Get CSS filter string for aggressive style differentiation
     */
    getStyleFilter(mapStyle) {
        const filters = {
            dungeon: 'saturate(0.7) contrast(1.1)',
            maze: 'saturate(0.8) hue-rotate(20deg)',
            forest: 'saturate(1.4) hue-rotate(-20deg) brightness(1.1)',
            city: 'saturate(0.6) contrast(1.2) brightness(0.9)',
            spacestation: 'saturate(1.2) hue-rotate(200deg) brightness(1.1)',
            college: 'saturate(0.9) sepia(0.3) brightness(1.1)',
            apartment: 'saturate(0.8) sepia(0.2) contrast(1.05)',
            neotokyo: 'saturate(1.5) hue-rotate(300deg) contrast(1.2) brightness(1.1)',
            arena: 'saturate(1.3) hue-rotate(30deg) contrast(1.15)',
            hospital: 'saturate(0.5) brightness(1.2) contrast(0.9)',
            highrise: 'saturate(0.4) contrast(1.3) brightness(0.7)',
            outpost: 'saturate(1.1) sepia(0.4) hue-rotate(15deg)',
        };
        return filters[mapStyle] || filters.dungeon;
    }

    /**
     * Get background color for each map style
     */
    getStyleBackground(mapStyle) {
        const backgrounds = {
            dungeon: '#0a0815',      // Deep purple-black
            maze: '#0d0a18',         // Mystical dark
            forest: '#050d05',       // Forest night
            city: '#0a0c10',         // Urban dark
            spacestation: '#050812', // Space blue-black
            college: '#0f0c08',      // Warm dark
            apartment: '#0c0a08',    // Cozy dark
            neotokyo: '#0f050a',     // Neon dark
            arena: '#100a05',        // Sandy dark
            hospital: '#080c0c',     // Sterile dark
            highrise: '#080810',     // Concrete dark
            outpost: '#0d0a06',      // Desert dark
        };
        return backgrounds[mapStyle] || backgrounds.dungeon;
    }

    /**
     * Load all sprite images asynchronously
     */
    async loadSprites() {
        if (this.spritesLoaded || this.spritesLoading) return;
        this.spritesLoading = true;

        const extensionPath = '/scripts/extensions/third-party/SillyTavern-MazeMaster/';
        const loadPromises = Object.entries(this.spritePaths).map(async ([key, path]) => {
            try {
                const img = new Image();
                img.src = extensionPath + path;
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                });
                this.spriteCache[key] = img;
            } catch (e) {
                console.warn(`[MazeMaster] Failed to load sprite: ${path}`);
            }
        });

        await Promise.all(loadPromises);
        this.spritesLoaded = true;
        this.spritesLoading = false;
        console.log('[MazeMaster] Isometric sprites loaded:', Object.keys(this.spriteCache));

        // Re-render with sprites now that they're loaded
        if (this.lastMazeState) {
            this.render(this.lastMazeState);
        }
    }

    gridToIso(x, y) {
        return {
            x: (x - y) * (this.tileWidth / 2),
            y: (x + y) * (this.tileHeight / 2),
        };
    }

    isoToGrid(screenX, screenY) {
        const x = (screenX / (this.tileWidth / 2) + screenY / (this.tileHeight / 2)) / 2;
        const y = (screenY / (this.tileHeight / 2) - screenX / (this.tileWidth / 2)) / 2;
        return { x: Math.floor(x), y: Math.floor(y) };
    }

    getGridHTML(size) {
        // Pre-compute tile sizes based on grid size (same logic as init)
        const tileWidth = this.getCellSize(size);
        const tileHeight = tileWidth / 2;
        const spriteHeight = tileWidth * 2; // Kenney sprites are 256x512 (2:1 aspect)

        const canvasWidth = (size + 1) * tileWidth;
        const canvasHeight = size * tileHeight + spriteHeight + tileHeight;
        return `
            <canvas id="maze_canvas" width="${canvasWidth}" height="${canvasHeight}" style="
                display: block;
                image-rendering: crisp-edges;
                max-width: 100%;
            "></canvas>
        `;
    }

    getPlayerOverlayHTML() {
        return ''; // Player drawn on canvas
    }

    getCellSize(gridSize) {
        // Balanced tile sizes for visibility
        if (gridSize <= 7) return 76;
        if (gridSize <= 10) return 64;
        if (gridSize <= 15) return 52;
        if (gridSize <= 20) return 44;
        return 36;
    }

    init(container, mazeState) {
        // Adjust tile size based on maze size
        if (mazeState?.size) {
            const newSize = this.getCellSize(mazeState.size);
            this.tileWidth = newSize;
            this.tileHeight = newSize / 2;
            this.wallHeight = newSize * 0.375;
        }
        // Set map style from profile (triggers sprite reload if changed)
        if (mazeState?.profile?.mapStyle) {
            this.setMapStyle(mazeState.profile.mapStyle);
        }
        super.init(container, mazeState);
        // Start loading sprites (async, will be ready for next render)
        this.loadSprites();
    }

    /**
     * Draw a sprite at isometric position, scaled to tile size
     * Kenney sprites are 256x512 with the isometric tile at the bottom ~1/4 of image
     */
    drawSprite(spriteName, x, y, scale = 1) {
        const sprite = this.spriteCache[spriteName];
        if (!sprite) return false;

        // Kenney sprites are 256x512, we scale to fit tile width
        const spriteAspect = sprite.height / sprite.width; // ~2 for Kenney
        const w = this.tileWidth * scale;
        const h = w * spriteAspect;

        // The isometric diamond in Kenney sprites is at the bottom ~25% of the image
        // Position so the diamond part aligns with the tile position
        // Bottom of sprite should be at y + tileHeight/2 (bottom of isometric diamond)
        const drawX = x - w / 2;
        const drawY = y + this.tileHeight / 2 - h;

        this.ctx.drawImage(sprite, drawX, drawY, w, h);
        return true;
    }

    drawSpriteDirectional(spriteName, x, y, scale = 1, direction = 'south') {
        const sprite = this.spriteCache[spriteName];
        if (!sprite) return false;

        // Kenney sprites are 256x512, we scale to fit tile width
        const spriteAspect = sprite.height / sprite.width;
        const w = this.tileWidth * scale;
        const h = w * spriteAspect;

        const drawX = x - w / 2;
        const drawY = y + this.tileHeight / 2 - h;

        // In isometric view, flip horizontally for west/north directions
        // Default sprite faces down-right (south/east), flipped faces down-left (north/west)
        const shouldFlip = direction === 'west' || direction === 'north';

        if (shouldFlip) {
            this.ctx.save();
            // Flip around the sprite's center
            this.ctx.translate(x, drawY + h / 2);
            this.ctx.scale(-1, 1);
            this.ctx.translate(-x, -(drawY + h / 2));
            this.ctx.drawImage(sprite, drawX, drawY, w, h);
            this.ctx.restore();
        } else {
            this.ctx.drawImage(sprite, drawX, drawY, w, h);
        }
        return true;
    }

    render(mazeState) {
        if (!this.ctx) {
            this.canvas = document.getElementById('maze_canvas');
            if (this.canvas) this.ctx = this.canvas.getContext('2d');
            if (!this.ctx) return;
        }

        // Store for re-rendering after sprites load
        this.lastMazeState = mazeState;

        const { grid, size, playerX, playerY, visited, exitX, exitY, isVictory, currentFloor, totalFloors, profile, playerDirection } = mazeState;
        // Map visibility: 'showAll', 'fogOfWar', 'hideUnexplored' (backward compat with fogOfWar boolean)
        const mapVisibility = profile?.mapVisibility || (profile?.fogOfWar === false ? 'showAll' : 'fogOfWar');

        // Kenney sprites are 256x512 (2:1 aspect), so sprite height = tileWidth * 2
        const spriteHeight = this.tileWidth * 2;

        // Canvas needs extra height at top for tall sprites
        const canvasWidth = (size + 1) * this.tileWidth;
        const canvasHeight = size * this.tileHeight + spriteHeight + this.tileHeight;
        if (this.canvas.width !== canvasWidth || this.canvas.height !== canvasHeight) {
            this.canvas.width = canvasWidth;
            this.canvas.height = canvasHeight;
        }

        // Clear with style-specific background color
        const bgColor = this.getStyleBackground(profile?.mapStyle);
        this.ctx.fillStyle = bgColor;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Match container background to canvas (no visible edges when zooming)
        const mazeArea = document.querySelector('.mazemaster-maze-area');
        if (mazeArea) mazeArea.style.backgroundColor = bgColor;

        // Apply aggressive style filter for visual differentiation
        const styleFilter = this.getStyleFilter(profile?.mapStyle);
        this.ctx.filter = styleFilter;

        const offsetX = this.canvas.width / 2;
        // Offset Y needs room for tall sprites at the top
        const offsetY = spriteHeight;

        // Build visited key - always use floor prefix for consistency
        const floorPrefix = `${currentFloor}:`;

        // Draw in isometric order (back to front)
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const cell = grid[y][x];
                const keyNew = `${floorPrefix}${x},${y}`;
                const keyOld = `${x},${y}`;
                const isVisited = visited.has(keyNew) || visited.has(keyOld);
                const iso = this.gridToIso(x, y);
                const drawX = iso.x + offsetX;
                const drawY = iso.y + offsetY;

                // Determine visibility based on mapVisibility setting
                const isPlayer = x === playerX && y === playerY;
                let showAsVisited = false;
                let hideCompletely = false;
                if (mapVisibility === 'showAll') {
                    showAsVisited = true;
                } else if (mapVisibility === 'hideUnexplored') {
                    showAsVisited = isVisited || isPlayer; // Always show player cell
                    hideCompletely = !isVisited && !isPlayer;
                } else { // fogOfWar (default)
                    showAsVisited = isVisited || isPlayer;
                }

                if (hideCompletely) {
                    // Hide unexplored - draw nothing (skip this cell entirely)
                    continue;
                } else if (!showAsVisited) {
                    // Fog of war - draw a raised fog block with question mark
                    this.drawIsoBlock(drawX, drawY, this.palette.fog, 4);
                    // Draw question mark on fog
                    this.ctx.fillStyle = '#5a5a8a';
                    this.ctx.font = `bold ${Math.floor(this.tileWidth / 3)}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('?', drawX, drawY - 2);
                } else {
                    // Draw floor
                    if (!this.drawSprite('floor', drawX, drawY)) {
                        this.drawIsoDiamond(drawX, drawY, this.palette.floor);
                    }

                    // Draw safe room overlay (healing zone indicator)
                    if (cell.safeRoom && !cell.safeRoom.exhausted) {
                        this.drawSafeRoomIndicator(drawX, drawY);
                    }

                    // Draw walls - ISOMETRIC MAPPING (based on gridToIso transform):
                    // walls.left (West/x-1) blocks UP-LEFT  TOP-LEFT edge (drawWallLeft)
                    // walls.top (North/y-1) blocks UP-RIGHT  TOP-RIGHT edge (drawWallTop)
                    // walls.right (East/x+1) blocks DOWN-RIGHT  BOTTOM-RIGHT edge (drawWallRight)
                    // walls.bottom (South/y+1) blocks DOWN-LEFT  BOTTOM-LEFT edge (drawWallBottom)

                    // Draw "back" walls (left and top in grid)
                    if (cell.walls.left) {
                        this.drawWallLeft(drawX, drawY, this.palette.wall);
                    }
                    if (cell.walls.top) {
                        this.drawWallTop(drawX, drawY, this.palette.wall);
                    }

                    // Draw "front" walls only when adjacent cell won't draw them
                    // Check if right cell (East/x+1) will draw its own left wall
                    const isRightEdge = x >= size - 1;
                    const rightCellKeyNew = `${floorPrefix}${x + 1},${y}`;
                    const rightCellKeyOld = `${x + 1},${y}`;
                    const rightCellVisited = visited.has(rightCellKeyNew) || visited.has(rightCellKeyOld);
                    const rightCellWillDraw = !isRightEdge && (mapVisibility === 'showAll' || rightCellVisited);

                    // Check if bottom cell (South/y+1) will draw its own top wall
                    const isBottomEdge = y >= size - 1;
                    const bottomCellKeyNew = `${floorPrefix}${x},${y + 1}`;
                    const bottomCellKeyOld = `${x},${y + 1}`;
                    const bottomCellVisited = visited.has(bottomCellKeyNew) || visited.has(bottomCellKeyOld);
                    const bottomCellWillDraw = !isBottomEdge && (mapVisibility === 'showAll' || bottomCellVisited);

                    // Draw right wall if we have one AND the right cell won't draw its left
                    if (cell.walls.right && !rightCellWillDraw) {
                        this.drawWallRight(drawX, drawY, this.palette.wall);
                    }

                    // Draw bottom wall if we have one AND the bottom cell won't draw its top
                    if (cell.walls.bottom && !bottomCellWillDraw) {
                        this.drawWallBottom(drawX, drawY, this.palette.wall);
                    }

                    // Draw entities on top of floor
                    const isExit = x === exitX && y === exitY;
                    const isFinalFloor = currentFloor === totalFloors - 1;

                    // Only render exit on final floor
                    if (isExit && isFinalFloor) {
                        if (!this.drawSprite('exit', drawX, drawY, 1.0)) {
                            this.drawIsoBlock(drawX, drawY - 2, isVictory ? this.palette.stairUp : this.palette.exit, 4);
                        }
                    }

                    if (cell.staircase) {
                        const stairSprite = cell.staircase.direction === 'up' ? 'stairsUp' : 'stairsDown';
                        if (!this.drawSprite(stairSprite, drawX, drawY, 1.0)) {
                            const pal = cell.staircase.direction === 'up' ? this.palette.stairUp : this.palette.stairDown;
                            this.drawIsoBlock(drawX, drawY - 2, pal, 6);
                            this.drawStairIcon(drawX, drawY - 6, cell.staircase.direction);
                        }
                    }

                    if (cell.portal) {
                        if (!this.drawSprite('portal', drawX, drawY, 0.8)) {
                            this.drawPortal(drawX, drawY);
                        }
                    }

                    if (cell.chest) {
                        const chestSprite = cell.chest.opened ? 'chestOpen' : 'chest';
                        if (!this.drawSprite(chestSprite, drawX, drawY, 0.8)) {
                            const pal = cell.chest.opened ? this.palette.chestOpen : this.palette.chest;
                            this.drawChest(drawX, drawY, pal, cell.chest.opened);
                        }
                    }

                    if (cell.trap && !cell.trap.triggered) {
                        if (!this.drawSprite('trap', drawX, drawY, 1.0)) {
                            this.drawTrap(drawX, drawY);
                        }
                    }

                    if (cell.minion && !cell.minion.triggered) {
                        // v1.4.2: Apply theme-based minion tinting
                        const theme = profile?.theme || 'fantasy';
                        this.ctx.filter = this.getThemeMinionFilter(theme);

                        if (!this.drawSprite('minion', drawX, drawY, 1.0)) {
                            // Use theme-specific palette for fallback minion
                            const origPalette = this.palette.minion;
                            this.palette.minion = this.getThemeMinionPalette(theme);
                            this.drawMinion(drawX, drawY);
                            this.palette.minion = origPalette;
                        }

                        // Reset filter after minion
                        this.ctx.filter = 'none';
                    }

                    if (isPlayer) {
                        // Draw player sprite slightly larger for visibility, facing movement direction
                        const facing = playerDirection || 'south';
                        if (!this.drawSpriteDirectional('player', drawX, drawY, 1.15, facing)) {
                            this.drawPlayerDirectional(drawX, drawY, facing);
                        }
                        // Draw floating indicator above player
                        this.drawPlayerIndicator(drawX, drawY);
                    }
                }
            }
        }

        // Reset filter before tint overlay
        this.ctx.filter = 'none';

        // Apply map style color tint overlay with screen blend for atmospheric effect
        const tint = this.getStyleTint(profile?.mapStyle);
        if (tint.a > 0) {
            // Use multiply blend for richer color grading
            this.ctx.globalCompositeOperation = 'multiply';
            this.ctx.fillStyle = `rgba(${tint.r + 100}, ${tint.g + 100}, ${tint.b + 100}, ${tint.a * 0.6})`;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // Add color overlay for stronger tint
            this.ctx.globalCompositeOperation = 'overlay';
            this.ctx.fillStyle = `rgba(${tint.r}, ${tint.g}, ${tint.b}, ${tint.a * 0.4})`;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // Reset blend mode
            this.ctx.globalCompositeOperation = 'source-over';
        }
    }

    drawIsoDiamond(x, y, palette) {
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;

        this.ctx.fillStyle = palette.top;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - hh);
        this.ctx.lineTo(x + hw, y);
        this.ctx.lineTo(x, y + hh);
        this.ctx.lineTo(x - hw, y);
        this.ctx.closePath();
        this.ctx.fill();
    }

    drawIsoBlock(x, y, palette, height = 8) {
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;

        // Left face
        this.ctx.fillStyle = palette.dark;
        this.ctx.beginPath();
        this.ctx.moveTo(x - hw, y);
        this.ctx.lineTo(x, y + hh);
        this.ctx.lineTo(x, y + hh + height);
        this.ctx.lineTo(x - hw, y + height);
        this.ctx.closePath();
        this.ctx.fill();

        // Right face
        this.ctx.fillStyle = palette.light;
        this.ctx.beginPath();
        this.ctx.moveTo(x + hw, y);
        this.ctx.lineTo(x, y + hh);
        this.ctx.lineTo(x, y + hh + height);
        this.ctx.lineTo(x + hw, y + height);
        this.ctx.closePath();
        this.ctx.fill();

        // Top face
        this.drawIsoDiamond(x, y, palette);
    }

    drawWallLeft(x, y, palette) {
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;
        const h = this.wallHeight;

        this.ctx.fillStyle = palette.dark;
        this.ctx.beginPath();
        this.ctx.moveTo(x - hw, y);
        this.ctx.lineTo(x - hw, y - h);
        this.ctx.lineTo(x, y - hh - h);
        this.ctx.lineTo(x, y - hh);
        this.ctx.closePath();
        this.ctx.fill();

        // Top edge
        this.ctx.fillStyle = palette.top;
        this.ctx.fillRect(x - hw - 1, y - h - 2, 4, 4);
    }

    drawWallTop(x, y, palette) {
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;
        const h = this.wallHeight;

        this.ctx.fillStyle = palette.light;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - hh);
        this.ctx.lineTo(x, y - hh - h);
        this.ctx.lineTo(x + hw, y - h);
        this.ctx.lineTo(x + hw, y);
        this.ctx.closePath();
        this.ctx.fill();

        // Top edge
        this.ctx.fillStyle = palette.top;
        this.ctx.fillRect(x + hw - 2, y - h - 2, 4, 4);
    }

    // Draw wall on right edge (for edge cells only - normally this is drawn by the adjacent cell's left wall)
    drawWallRight(x, y, palette) {
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;
        const h = this.wallHeight;

        // Right wall faces the "front" of isometric view, use light color
        this.ctx.fillStyle = palette.light;
        this.ctx.beginPath();
        this.ctx.moveTo(x + hw, y);
        this.ctx.lineTo(x + hw, y - h);
        this.ctx.lineTo(x, y + hh - h);
        this.ctx.lineTo(x, y + hh);
        this.ctx.closePath();
        this.ctx.fill();

        // Top edge
        this.ctx.fillStyle = palette.top;
        this.ctx.fillRect(x + hw - 2, y - h - 2, 4, 4);
    }

    // Draw wall on bottom edge (for edge cells only - normally this is drawn by the adjacent cell's top wall)
    drawWallBottom(x, y, palette) {
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;
        const h = this.wallHeight;

        // Bottom wall faces the "front" of isometric view, use dark color (shadow side)
        this.ctx.fillStyle = palette.dark;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y + hh);
        this.ctx.lineTo(x, y + hh - h);
        this.ctx.lineTo(x - hw, y - h);
        this.ctx.lineTo(x - hw, y);
        this.ctx.closePath();
        this.ctx.fill();

        // Top edge
        this.ctx.fillStyle = palette.top;
        this.ctx.fillRect(x - hw - 1, y - h - 2, 4, 4);
    }

    drawPlayer(x, y) {
        const pal = this.palette.player;
        const r = this.tileWidth / 5;

        // Shadow
        this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
        this.ctx.beginPath();
        this.ctx.ellipse(x, y + 2, r, r/2, 0, 0, Math.PI * 2);
        this.ctx.fill();

        // Body (sphere-ish)
        const gradient = this.ctx.createRadialGradient(x - r/3, y - r - r/2, 0, x, y - r/2, r * 1.5);
        gradient.addColorStop(0, pal.light);
        gradient.addColorStop(0.5, pal.top);
        gradient.addColorStop(1, pal.dark);
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(x, y - r/2, r, 0, Math.PI * 2);
        this.ctx.fill();

        // Highlight
        this.ctx.fillStyle = 'rgba(255,255,255,0.4)';
        this.ctx.beginPath();
        this.ctx.arc(x - r/3, y - r, r/4, 0, Math.PI * 2);
        this.ctx.fill();
    }

    drawPlayerDirectional(x, y, direction = 'south') {
        const pal = this.palette.player;
        const r = this.tileWidth / 5;

        // Shadow
        this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
        this.ctx.beginPath();
        this.ctx.ellipse(x, y + 2, r, r/2, 0, 0, Math.PI * 2);
        this.ctx.fill();

        // Body (sphere-ish)
        const gradient = this.ctx.createRadialGradient(x - r/3, y - r - r/2, 0, x, y - r/2, r * 1.5);
        gradient.addColorStop(0, pal.light);
        gradient.addColorStop(0.5, pal.top);
        gradient.addColorStop(1, pal.dark);
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(x, y - r/2, r, 0, Math.PI * 2);
        this.ctx.fill();

        // Directional highlight - shift based on facing direction
        // In isometric: east/south = down-right, west/north = down-left
        const highlightOffset = (direction === 'west' || direction === 'north') ? r/3 : -r/3;
        this.ctx.fillStyle = 'rgba(255,255,255,0.4)';
        this.ctx.beginPath();
        this.ctx.arc(x + highlightOffset, y - r, r/4, 0, Math.PI * 2);
        this.ctx.fill();

        // Small direction indicator dot
        const dotOffsets = {
            north: { dx: 0, dy: -r * 1.3 },
            south: { dx: 0, dy: r * 0.3 },
            east: { dx: r * 0.9, dy: -r * 0.4 },
            west: { dx: -r * 0.9, dy: -r * 0.4 }
        };
        const dot = dotOffsets[direction] || dotOffsets.south;
        this.ctx.fillStyle = pal.light;
        this.ctx.beginPath();
        this.ctx.arc(x + dot.dx, y - r/2 + dot.dy, r/6, 0, Math.PI * 2);
        this.ctx.fill();
    }

    drawChest(x, y, palette, opened) {
        const w = this.tileWidth / 3;
        const h = this.tileHeight / 2;

        // Chest body
        this.ctx.fillStyle = palette.dark;
        this.ctx.fillRect(x - w/2, y - h, w, h);
        this.ctx.fillStyle = palette.top;
        this.ctx.fillRect(x - w/2, y - h, w, h/3);

        if (!opened) {
            // Lock
            this.ctx.fillStyle = '#ffd700';
            this.ctx.fillRect(x - 2, y - h/2 - 2, 4, 4);
        } else {
            // Open lid
            this.ctx.fillStyle = palette.light;
            this.ctx.fillRect(x - w/2, y - h - 4, w, 4);
        }
    }

    drawMinion(x, y) {
        const pal = this.palette.minion;
        const r = this.tileWidth / 6;

        // Shadow
        this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
        this.ctx.beginPath();
        this.ctx.ellipse(x, y + 2, r, r/2, 0, 0, Math.PI * 2);
        this.ctx.fill();

        // Body
        this.ctx.fillStyle = pal.top;
        this.ctx.beginPath();
        this.ctx.arc(x, y - r/2, r, 0, Math.PI * 2);
        this.ctx.fill();

        // Eyes
        this.ctx.fillStyle = '#fff';
        this.ctx.beginPath();
        this.ctx.arc(x - 3, y - r/2, 2, 0, Math.PI * 2);
        this.ctx.arc(x + 3, y - r/2, 2, 0, Math.PI * 2);
        this.ctx.fill();
    }

    /**
     * Draw floating indicator above player (bouncing arrow/diamond)
     * Flashes orange when LLM is generating, blue otherwise
     */
    drawPlayerIndicator(x, y) {
        // Animated bounce using time
        const time = Date.now() / 300;
        const bounce = Math.sin(time) * 4;
        const indicatorY = y - this.tileHeight - 25 + bounce;

        // v1.4.8: Color scheme based on LLM generation state
        // Orange when generating, blue when idle
        const isGenerating = isLLMGenerating;
        const glowColor = isGenerating ? '#f97316' : '#3b82f6';      // Orange / Blue
        const fillColor = isGenerating ? '#fb923c' : '#60a5fa';      // Light orange / Light blue
        const highlightColor = isGenerating ? '#fdba74' : '#93c5fd'; // Lighter orange / Lighter blue

        // Draw glowing diamond/arrow pointing down
        this.ctx.save();

        // Outer glow (pulsing effect when generating)
        this.ctx.shadowColor = glowColor;
        this.ctx.shadowBlur = isGenerating ? 15 + Math.sin(time * 2) * 5 : 10;

        // Diamond shape pointing down
        const size = 8;
        this.ctx.fillStyle = fillColor;
        this.ctx.beginPath();
        this.ctx.moveTo(x, indicatorY + size * 2);  // Bottom point
        this.ctx.lineTo(x - size, indicatorY + size);
        this.ctx.lineTo(x, indicatorY);  // Top point
        this.ctx.lineTo(x + size, indicatorY + size);
        this.ctx.closePath();
        this.ctx.fill();

        // Inner highlight
        this.ctx.fillStyle = highlightColor;
        this.ctx.beginPath();
        this.ctx.moveTo(x, indicatorY + size * 1.5);
        this.ctx.lineTo(x - size/2, indicatorY + size);
        this.ctx.lineTo(x, indicatorY + size/2);
        this.ctx.lineTo(x + size/2, indicatorY + size);
        this.ctx.closePath();
        this.ctx.fill();

        this.ctx.restore();

        // Trigger re-render for animation (throttled)
        if (!this._animationFrame) {
            this._animationFrame = requestAnimationFrame(() => {
                this._animationFrame = null;
                if (this.lastMazeState) {
                    this.render(this.lastMazeState);
                }
            });
        }
    }

    drawTrap(x, y) {
        const pal = this.palette.trap;
        this.ctx.fillStyle = pal.top;

        // Spikes pattern
        for (let i = -1; i <= 1; i++) {
            this.ctx.beginPath();
            this.ctx.moveTo(x + i * 6 - 2, y);
            this.ctx.lineTo(x + i * 6, y - 6);
            this.ctx.lineTo(x + i * 6 + 2, y);
            this.ctx.fill();
        }
    }

    drawSafeRoomIndicator(x, y) {
        const pal = this.palette.safeRoom;
        const hw = this.tileWidth / 2;
        const hh = this.tileHeight / 2;

        // Draw glowing teal diamond overlay
        const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, hw);
        gradient.addColorStop(0, pal.light + 'aa');
        gradient.addColorStop(0.6, pal.top + '66');
        gradient.addColorStop(1, 'transparent');
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - hh);
        this.ctx.lineTo(x + hw, y);
        this.ctx.lineTo(x, y + hh);
        this.ctx.lineTo(x - hw, y);
        this.ctx.closePath();
        this.ctx.fill();

        // Draw heart icon (healing symbol)
        this.ctx.fillStyle = pal.top;
        this.ctx.font = `bold ${Math.floor(this.tileWidth / 4)}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText('', x, y - 2);
    }

    drawPortal(x, y) {
        const pal = this.palette.portal;
        const r = this.tileWidth / 4;

        // Glow
        const gradient = this.ctx.createRadialGradient(x, y - r/2, 0, x, y - r/2, r * 1.5);
        gradient.addColorStop(0, pal.light);
        gradient.addColorStop(0.5, pal.top + '88');
        gradient.addColorStop(1, 'transparent');
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(x, y - r/2, r * 1.5, 0, Math.PI * 2);
        this.ctx.fill();

        // Core
        this.ctx.fillStyle = pal.top;
        this.ctx.beginPath();
        this.ctx.arc(x, y - r/2, r/2, 0, Math.PI * 2);
        this.ctx.fill();
    }

    drawStairIcon(x, y, direction) {
        this.ctx.fillStyle = '#fff';
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(direction === 'up' ? '' : '', x, y);
    }

    updatePlayerPosition(x, y, animate, cellSize) {
        // Canvas re-renders everything, animation handled in render
    }
}

/**
 * Renderer Registry - Factory for creating and switching renderers
 */
const RendererRegistry = {
    renderers: {
        'css-grid': CSSGridRenderer,
        'canvas': CanvasRenderer,
        'isometric': IsometricRenderer,
    },

    currentRenderer: null,
    currentType: 'isometric',

    /**
     * Register a new renderer type
     */
    register(type, RendererClass) {
        this.renderers[type] = RendererClass;
    },

    /**
     * Create a renderer instance
     */
    create(type, options = {}) {
        const RendererClass = this.renderers[type];
        if (!RendererClass) {
            console.warn(`[MazeMaster] Unknown renderer type: ${type}, falling back to css-grid`);
            return new CSSGridRenderer(options);
        }
        return new RendererClass(options);
    },

    /**
     * Get or create the current active renderer
     */
    getRenderer(type = null) {
        // If no type specified, check settings for renderer preference
        if (!type && typeof extensionSettings !== 'undefined' && extensionSettings?.rendererType) {
            type = extensionSettings.rendererType;
        }

        if (type && type !== this.currentType) {
            if (this.currentRenderer) {
                this.currentRenderer.cleanup();
            }
            this.currentType = type;
            this.currentRenderer = this.create(type);
        }

        if (!this.currentRenderer) {
            this.currentRenderer = this.create(this.currentType);
        }

        return this.currentRenderer;
    },

    /**
     * Get list of available renderer types
     */
    getAvailableTypes() {
        return Object.keys(this.renderers);
    },
};

// =============================================================================
// LAYOUT MODE SYSTEM (v1.2.0)
// =============================================================================

/**
 * Detect if we're on a mobile/portrait device
 * @returns {'mobile' | 'desktop'}
 */
function detectLayoutMode() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    const isPortrait = height > width;
    const isSmallScreen = width < 768;

    // Mobile if portrait OR small screen
    return (isPortrait || isSmallScreen) ? 'mobile' : 'desktop';
}

/**
 * Get the current layout mode based on settings
 * @returns {'mobile' | 'desktop'}
 */
function getLayoutMode() {
    const mode = extensionSettings?.layoutMode || 'desktop';
    if (mode === 'auto') {
        return detectLayoutMode();
    }
    return mode;
}

/**
 * Apply layout mode CSS classes to maze modal
 */
function applyLayoutMode() {
    const modal = document.getElementById('mazemaster_maze_modal');
    if (!modal) return;

    const mode = getLayoutMode();
    modal.classList.remove('layout-mobile', 'layout-desktop');
    modal.classList.add(`layout-${mode}`);

    // Also update the main container if it exists
    const container = modal.querySelector('.maze-modal-container');
    if (container) {
        container.classList.remove('layout-mobile', 'layout-desktop');
        container.classList.add(`layout-${mode}`);
    }
}

// Listen for orientation/resize changes
if (typeof window !== 'undefined') {
    window.addEventListener('resize', () => {
        if (extensionSettings?.layoutMode === 'auto') {
            applyLayoutMode();
        }
    });
}

// Default maze profile fields for backwards compatibility
const MAZE_PROFILE_DEFAULTS = {
    difficulty: 'normal',
    theme: 'fantasy',
    mapStyle: 'maze',
    floors: 1,
    mapVisibility: 'fogOfWar', // 'showAll', 'fogOfWar', or 'hideUnexplored'
    // STScript hooks
    onMove: '',
    onMilestone: '',
    onExploreComplete: '',
    onItemAdd: '',
    onItemRemove: '',
    onChestOpen: '',
    onTrade: '',
    onEnemyMove: '',
    onTeleport: '',
    onObjectiveProgress: '',
    onObjectiveComplete: '',
    onAllObjectivesComplete: '',
    onDifficultySet: '',
    onStatUpdate: '',
    // New features
    portals: [],
    objectives: [],
    // HP System (v1.3.0)
    hpEnabled: true,
    maxHP: 100,
    battlebarDamageMultiplier: 1.0,      // Multiplier applied to battlebar profile damage
    battlebarDifficultyMultiplier: 1.0,  // Multiplier applied to battlebar difficulty (affects speed/zone)
    onDeath: 'respawn',        // 'respawn', 'respawnPenalty', 'gameover'
    respawnHPPercent: 50,
    safeRoomCount: 3,          // Number of safe rooms per floor
    safeRoomHealPercent: 100,  // % of HP healed when using a safe room
    safeRoomUseLLM: false,     // Use LLM for themed safe room messages
    // Rest mechanic
    restEnabled: true,         // Enable rest button
    restHealPercent: 20,       // % of HP restored when resting
    restCooldown: 3,           // Turns before can rest again
    restInterruptChance: 0,    // % chance rest is interrupted (0 = always safe)
    restInterruptScript: '',   // STScript on interrupt (empty = random encounter)
    // HP STScript hooks
    onDamage: '',
    onHeal: '',
    onPlayerDeath: '',
    // v1.4.7: Fairness system (pity mechanics)
    fairness: {
        enabled: true,              // Enable fairness modifiers
        keyPityThreshold: 3,        // Chests without key before boost
        healingPityThreshold: 4,    // Chests without healing before boost
        lowHpThreshold: 0.4,        // HP % below which healing boost activates
        mercyUnlock: true,          // Allow locked chests to mercy-unlock
        mercyUnlockThreshold: 2,    // Skipped locked chests before mercy unlock
    },
    // v1.4.8: LLM Room Enhancement
    llmEnhanceRooms: true,          // Use LLM to enhance room descriptions on first entry
    llmRoomPrompt: 'Describe this {{roomType}} room in 1-2 vivid sentences. Theme: {{theme}}. Context: {{sessionNotes}}',
};

/**
 * Execute STScript command with timeout protection
 * Prevents hanging if a script takes too long or gets stuck
 * @param {string} command - The STScript command to execute
 * @param {number} timeoutMs - Timeout in milliseconds (default: 10000)
 * @returns {Promise<any>} - Result of the command or null if timed out
 */
async function executeWithTimeout(command, timeoutMs = STSCRIPT_TIMEOUT_MS) {
    if (!command || typeof command !== 'string' || command.trim() === '') {
        return null;
    }

    try {
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error(`STScript timed out after ${timeoutMs}ms`)), timeoutMs);
        });

        const result = await Promise.race([
            executeSlashCommandsWithOptions(command),
            timeoutPromise
        ]);

        return result;
    } catch (err) {
        if (err.message?.includes('timed out')) {
            console.warn(`[MazeMaster] STScript timed out: ${command.substring(0, 50)}...`);
        } else {
            console.error('[MazeMaster] STScript error:', err);
        }
        return null;
    }
}

/**
 * Fire an STScript hook with parameter substitution
 * @param {string} hookName - The hook name (e.g., 'onMove', 'onItemAdd')
 * @param {Object} params - Parameters to substitute (e.g., {x: 1, y: 2})
 */
async function fireHook(hookName, params = {}) {
    const profile = currentMaze?.profile;
    if (!profile) return;

    let command = profile[hookName];
    if (!command || typeof command !== 'string' || !command.trim()) return;

    // Replace template variables {{varName}} with values
    for (const [key, value] of Object.entries(params)) {
        command = command.replaceAll(`{{${key}}}`, String(value));
    }

    await executeWithTimeout(command);
}

/**
 * Get difficulty tier settings for a profile
 * @param {Object|string} profileOrDifficulty - Profile object or difficulty string
 * @returns {Object} Difficulty tier configuration
 */
function getDifficultySettings(profileOrDifficulty) {
    const difficulty = typeof profileOrDifficulty === 'string'
        ? profileOrDifficulty
        : (profileOrDifficulty?.difficulty || 'normal');
    return DIFFICULTY_TIERS[difficulty] || DIFFICULTY_TIERS.normal;
}

/**
 * Get maze profile with defaults merged in for backwards compatibility
 * @param {string} name - Profile name
 * @returns {Object|null} Profile with defaults merged
 */
function getMazeProfileWithDefaults(name) {
    const profile = extensionSettings.mazeProfiles?.[name];
    if (!profile) return null;
    return { ...MAZE_PROFILE_DEFAULTS, ...profile };
}

// =============================================================================
// HP SYSTEM (v1.3.0)
// =============================================================================

/**
 * Initialize HP for a new maze based on profile and difficulty settings
 * @param {Object} profile - The maze profile
 * @returns {Object} HP state object
 */
function initHP(profile) {
    const difficulty = getDifficultySettings(profile);
    const hpMult = difficulty.hpMult || 1.0;
    const baseMax = profile.maxHP || 100;
    const maxHP = Math.round(baseMax * hpMult);

    return {
        current: maxHP,
        max: maxHP,
        maxBonus: 0,
        reviveCharges: 0,
    };
}

/**
 * Apply damage to the player
 * @param {number} amount - Raw damage amount
 * @param {string} source - Damage source: 'battlebar', 'trap', 'contact', 'script'
 * @returns {Promise<boolean>} True if player survived, false if dead
 */
async function applyDamage(amount, source = 'unknown') {
    if (!currentMaze.hpEnabled || !currentMaze.hp) return true;

    const prevHP = currentMaze.hp.current;
    currentMaze.hp.current = Math.max(0, currentMaze.hp.current - amount);

    // Update UI
    updateHPDisplay();
    updateRestButton(); // Update rest button when HP changes
    showDamageFlash();

    // Fire hook
    await fireHook('onDamage', {
        amount,
        source,
        previousHP: prevHP,
        currentHP: currentMaze.hp.current,
        maxHP: currentMaze.hp.max + currentMaze.hp.maxBonus,
    });

    // Log message
    addMazeMessage('Combat', `Took ${amount} damage! (${currentMaze.hp.current}/${currentMaze.hp.max + currentMaze.hp.maxBonus} HP)`);

    // Check for death
    if (currentMaze.hp.current <= 0) {
        await handlePlayerDeath(source);
        return false;
    }

    // Low HP warning at 25%
    const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;
    if (currentMaze.hp.current <= maxTotal * 0.25 && prevHP > maxTotal * 0.25) {
        addMazeMessage('Warning', 'Your health is critically low!');
    }

    return true;
}

/**
 * Heal the player
 * @param {number} amount - Amount to heal (raw or percentage based on isPercent)
 * @param {boolean} isPercent - If true, amount is percentage of max HP
 * @param {string} source - Heal source: 'potion', 'elixir', 'safeRoom', 'script'
 */
async function healPlayer(amount, isPercent = false, source = 'unknown') {
    if (!currentMaze.hpEnabled || !currentMaze.hp) return;

    const difficulty = getDifficultySettings(currentMaze.profile);
    const healMult = difficulty.healMult || 1.0;
    const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;

    let healAmount = isPercent
        ? Math.round((amount / 100) * maxTotal * healMult)
        : Math.round(amount * healMult);

    const prevHP = currentMaze.hp.current;
    currentMaze.hp.current = Math.min(maxTotal, currentMaze.hp.current + healAmount);
    const actualHeal = currentMaze.hp.current - prevHP;

    // Update UI
    updateHPDisplay();
    updateRestButton(); // Update rest button when HP changes
    if (actualHeal > 0) {
        showHealFlash();
    }

    // Fire hook
    await fireHook('onHeal', {
        amount: actualHeal,
        source,
        previousHP: prevHP,
        currentHP: currentMaze.hp.current,
        maxHP: maxTotal,
    });

    if (actualHeal > 0) {
        addMazeMessage('Healing', `Restored ${actualHeal} HP! (${currentMaze.hp.current}/${maxTotal} HP)`);
    }
}

/**
 * Handle player death
 * @param {string} source - What killed the player
 */
async function handlePlayerDeath(source) {
    console.log('[MazeMaster] handlePlayerDeath called, source:', source);

    // Check for revival charges (from revival charms)
    if (currentMaze.hp.reviveCharges > 0) {
        currentMaze.hp.reviveCharges--;
        const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;
        currentMaze.hp.current = Math.round(maxTotal * 0.25); // Revive at 25% HP

        updateHPDisplay();
        addMazeMessage('Revival', 'Your Revival Charm activates! You cheat death...');
        addSessionNote(`Revival charm activated! Cheated death from ${source}`, 'Death');
        console.log('[MazeMaster] Revival charm used, HP restored');
        return;
    }

    // Log death to session notes
    addSessionNote(`DEATH: Killed by ${source}`, 'Death');

    // Fire death hook
    await fireHook('onPlayerDeath', { source });

    // Handle based on profile setting
    const deathAction = currentMaze.profile?.onDeath || 'respawn';
    console.log('[MazeMaster] Death action:', deathAction, 'Profile onDeath:', currentMaze.profile?.onDeath);

    switch (deathAction) {
        case 'respawn':
            console.log('[MazeMaster] Respawning player');
            await respawnPlayerWithHP(100);
            break;
        case 'respawnPenalty':
            const respawnPercent = currentMaze.profile?.respawnHPPercent || 50;
            console.log('[MazeMaster] Respawning with penalty:', respawnPercent + '%');
            await respawnPlayerWithHP(respawnPercent);
            break;
        case 'gameover':
        default:
            console.log('[MazeMaster] Game over triggered');
            handleMazeLoss();
            break;
    }
}

/**
 * Respawn player at start with specified HP percentage
 * @param {number} hpPercent - Percentage of max HP to restore
 */
async function respawnPlayerWithHP(hpPercent) {
    // Move to start
    currentMaze.playerX = 0;
    currentMaze.playerY = 0;
    currentMaze.isPaused = false;
    currentMaze.pendingEncounter = null;
    currentMaze.pendingConfirmation = null;

    // Restore HP
    const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;
    currentMaze.hp.current = Math.round(maxTotal * (hpPercent / 100));
    updateHPDisplay();

    // Re-render
    renderMazeGrid();
    updateDpadFloorButtons();
    addMazeMessage('Respawn', `Returned to the start with ${hpPercent}% HP...`);

    // Smooth pan camera back to player at start position
    setTimeout(() => {
        if (typeof window.mazeCenterOnPlayer === 'function') {
            window.mazeCenterOnPlayer(true); // true = smooth animation
        }
    }, 100);

    // Update hero display
    const profile = currentMaze.profile;
    if (profile?.mainMinion) {
        const mainMinion = getMinion(profile.mainMinion);
        if (mainMinion) {
            currentMaze.currentMinion = {
                name: mainMinion.name,
                imagePath: mainMinion.imagePath,
                message: 'Back to the beginning with you!',
            };
            updateMazeHero();
        }
    }
}

/**
 * Increase max HP permanently (from items like Heart Crystal)
 * @param {number} amount - Amount to increase max HP by
 */
async function increaseMaxHP(amount) {
    if (!currentMaze.hpEnabled || !currentMaze.hp) return;

    currentMaze.hp.maxBonus += amount;
    currentMaze.hp.current += amount; // Also heal by that amount
    updateHPDisplay();

    addMazeMessage('Power Up', `Max HP increased by ${amount}!`);
}

// =============================================================================
// REST MECHANIC
// =============================================================================

/**
 * Handle rest action - consume turn to heal, with potential interruption
 */
async function handleRestAction() {
    if (!currentMaze.isOpen || currentMaze.isPaused || currentMaze.isVictory) return;
    if (!currentMaze.hpEnabled || !currentMaze.hp) return;

    const profile = currentMaze.profile || {};
    if (!profile.restEnabled) return;

    // Check cooldown
    if ((currentMaze.restCooldown || 0) > 0) {
        addMazeMessage('Rest', `Cannot rest yet. Wait ${currentMaze.restCooldown} more turn(s).`);
        return;
    }

    // Check if at full HP
    const maxTotal = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
    if (currentMaze.hp.current >= maxTotal) {
        addMazeMessage('Rest', 'You are already at full health.');
        return;
    }

    // Consume turn (count as a move)
    await incrementStat('moves', 1);

    // Check for interruption
    const interruptChance = profile.restInterruptChance ?? 0;
    if (interruptChance > 0) {
        const roll = Math.random() * 100;
        if (roll < interruptChance) {
            // Interrupted!
            console.log(`[MazeMaster] Rest interrupted (rolled ${roll.toFixed(1)} vs ${interruptChance}%)`);

            // Set cooldown anyway (attempted rest still uses the action)
            currentMaze.restCooldown = profile.restCooldown ?? 3;
            updateRestButton();

            // Run interrupt script or trigger random encounter
            if (profile.restInterruptScript && profile.restInterruptScript.trim()) {
                addMazeMessage('Interrupted!', 'Your rest is disturbed!');
                await executeWithTimeout(profile.restInterruptScript);
            } else {
                // Trigger random minion encounter from the profile's encounters
                await triggerRandomRestEncounter();
            }
            return;
        }
    }

    // Successful rest - heal
    const healPercent = profile.restHealPercent ?? 20;
    await healPlayer(healPercent, true, 'rest');

    // Set cooldown
    currentMaze.restCooldown = profile.restCooldown ?? 3;
    updateRestButton();

    addMazeMessage('Rest', `You take a moment to rest and recover ${healPercent}% HP.`);
}

/**
 * Trigger a random encounter when rest is interrupted
 */
async function triggerRandomRestEncounter() {
    const profile = currentMaze.profile || {};
    const encounters = profile.minionEncounters || [];

    if (encounters.length === 0) {
        addMazeMessage('Interrupted!', 'Something disturbs your rest, but nothing appears...');
        return;
    }

    // Pick a random minion from the profile's encounters
    const randomEncounter = encounters[Math.floor(Math.random() * encounters.length)];
    const minionId = randomEncounter.minionId;

    if (minionId) {
        addMazeMessage('Ambush!', 'You are caught off guard while resting!');
        await triggerMinionEncounter(minionId, currentMaze.playerX, currentMaze.playerY, true); // true = skip movement
    } else {
        addMazeMessage('Interrupted!', 'Your rest is disturbed by strange noises...');
    }
}

/**
 * Decrement rest cooldown (called after each player move)
 */
function decrementRestCooldown() {
    if (currentMaze.restCooldown && currentMaze.restCooldown > 0) {
        currentMaze.restCooldown--;
        updateRestButton();
    }
}

/**
 * Update rest button visibility and state
 */
function updateRestButton() {
    const restBtn = document.getElementById('maze_rest_btn');
    if (!restBtn) return;

    const profile = currentMaze.profile || {};

    // Show/hide based on HP system and rest enabled
    if (!currentMaze.hpEnabled || !profile.restEnabled) {
        restBtn.style.display = 'none';
        return;
    }

    restBtn.style.display = 'flex';

    // Update disabled state
    const cooldown = currentMaze.restCooldown || 0;
    const hpMax = currentMaze.hp?.max || 100;
    const hpMaxBonus = currentMaze.hp?.maxBonus || 0;
    const hpCurrent = currentMaze.hp?.current || 0;
    const maxTotal = hpMax + hpMaxBonus;
    const atFullHP = hpCurrent >= maxTotal;
    const onCooldown = cooldown > 0;

    restBtn.disabled = onCooldown || atFullHP || currentMaze.isPaused;

    // Update tooltip
    if (atFullHP) {
        restBtn.title = 'Already at full HP';
    } else if (onCooldown) {
        restBtn.title = `Rest available in ${cooldown} turn(s)`;
    } else {
        const healPercent = profile.restHealPercent ?? 20;
        restBtn.title = `Rest to recover ${healPercent}% HP`;
    }

    // Update cooldown badge
    const badge = restBtn.querySelector('.rest-cooldown-badge');
    if (badge) {
        if (onCooldown) {
            badge.style.display = 'flex';
            badge.textContent = cooldown;
        } else {
            badge.style.display = 'none';
        }
    }
}

/**
 * Update the HP display in the maze modal
 */
function updateHPDisplay() {
    if (!currentMaze.hpEnabled || !currentMaze.hp) return;

    const currentEl = document.getElementById('maze_hp_current');
    const maxEl = document.getElementById('maze_hp_max');
    const barEl = document.getElementById('maze_hp_bar');
    const container = document.querySelector('.mazemaster-maze-container');
    const hpOverlay = document.getElementById('maze_hp_overlay');

    const current = currentMaze.hp.current;
    const max = currentMaze.hp.max + currentMaze.hp.maxBonus;
    const percent = Math.round((current / max) * 100);

    if (currentEl) currentEl.textContent = current;
    if (maxEl) maxEl.textContent = max;

    if (barEl) {
        barEl.style.width = `${percent}%`;
        barEl.classList.remove('low', 'medium', 'high');
        if (percent <= 25) {
            barEl.classList.add('low');
        } else if (percent <= 50) {
            barEl.classList.add('medium');
        } else {
            barEl.classList.add('high');
        }
    }

    // Show/hide HP overlay based on hpEnabled
    if (hpOverlay) {
        hpOverlay.style.display = currentMaze.hpEnabled ? '' : 'none';
    }

    // Low HP container warning pulse
    if (container) {
        if (percent <= 25) {
            container.classList.add('low-hp');
        } else {
            container.classList.remove('low-hp');
        }
    }
}

/**
 * Show damage flash effect on screen
 */
function showDamageFlash() {
    const flash = document.createElement('div');
    flash.className = 'maze-hp-flash damage';
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), 300);
}

/**
 * Show heal flash effect on screen
 */
function showHealFlash() {
    const flash = document.createElement('div');
    flash.className = 'maze-hp-flash heal';
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), 300);
}

/**
 * Use an HP item from inventory
 * @param {string} itemType - The HP item type
 */
async function useHPItem(itemType) {
    if (!currentMaze.hpEnabled || !currentMaze.hp) return;
    if (!currentMaze.inventory[itemType] || currentMaze.inventory[itemType] <= 0) return;

    switch (itemType) {
        case 'healingPotion':
            await removeFromInventory('healingPotion');
            await healPlayer(25, true, 'potion');
            break;

        case 'greaterHealing':
            await removeFromInventory('greaterHealing');
            await healPlayer(50, true, 'potion');
            break;

        case 'elixir':
            await removeFromInventory('elixir');
            await healPlayer(100, true, 'elixir');
            break;

        case 'heartCrystal':
            await removeFromInventory('heartCrystal');
            await increaseMaxHP(10);
            break;

        case 'revivalCharm':
            // Passive item - activates on death
            currentMaze.hp.reviveCharges++;
            await removeFromInventory('revivalCharm');
            addMazeMessage('Item', 'Revival Charm ready. You will cheat death once.');
            break;
    }
}

/**
 * Use a visibility item from inventory
 * @param {string} itemType - The visibility item type
 */
async function useVisibilityItem(itemType) {
    if (!currentMaze.isOpen) return;
    if (!currentMaze.inventory[itemType] || currentMaze.inventory[itemType] <= 0) return;

    // Ensure visibility object exists
    if (!currentMaze.visibility) {
        currentMaze.visibility = { baseRadius: 1, tempBonus: 0, tempMovesLeft: 0, permBonus: 0, floorRevealed: false };
    }

    switch (itemType) {
        case 'torch':
            await removeFromInventory('torch');
            currentMaze.visibility.tempBonus = 2;
            currentMaze.visibility.tempMovesLeft = 3;
            addMazeMessage('Item', 'Torch lit! +2 visibility for 3 moves.');
            break;

        case 'revealScroll':
            await removeFromInventory('revealScroll');
            currentMaze.visibility.floorRevealed = true;
            // Reveal all tiles on current floor
            const size = currentMaze.grid.length;
            const floorPrefix = `${currentMaze.currentFloor}:`;
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    currentMaze.visited.add(`${floorPrefix}${x},${y}`);
                }
            }
            addMazeMessage('Item', 'The scroll reveals the entire floor!');
            break;

        case 'sightPotion':
            await removeFromInventory('sightPotion');
            currentMaze.visibility.permBonus = (currentMaze.visibility.permBonus || 0) + 1;
            addMazeMessage('Item', 'Your vision sharpens! Permanent +1 visibility.');
            break;

        case 'crystalBall':
            await removeFromInventory('crystalBall');
            // Reveal all minion positions on current floor
            const minionsRevealed = [];
            const gridSize = currentMaze.grid.length;
            const currentFloorPrefix = `${currentMaze.currentFloor}:`;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = currentMaze.grid[y][x];
                    if (cell.minion && !cell.minion.triggered) {
                        currentMaze.visited.add(`${currentFloorPrefix}${x},${y}`);
                        minionsRevealed.push(cell.minion.name || 'Unknown');
                    }
                }
            }
            if (minionsRevealed.length > 0) {
                addMazeMessage('Item', `Crystal Ball reveals ${minionsRevealed.length} minion(s)!`);
            } else {
                addMazeMessage('Item', 'Crystal Ball shows no minions remain on this floor.');
            }
            break;

        case 'lantern':
            // Lantern is passive - just inform the player
            addMazeMessage('Info', 'Lantern provides passive +1 visibility while held.');
            return; // Don't consume
    }

    // Re-render the maze to show updated visibility
    renderMaze();
}

/**
 * Calculate current visibility radius based on items and buffs
 * @returns {number} The current visibility radius
 */
function getVisibilityRadius() {
    if (!currentMaze.isOpen) return 1;

    const vis = currentMaze.visibility || { baseRadius: 1, tempBonus: 0, permBonus: 0 };
    const lanternBonus = (currentMaze.inventory?.lantern || 0) > 0 ? 1 : 0;

    return vis.baseRadius + vis.tempBonus + vis.permBonus + lanternBonus;
}

/**
 * Check if movement between two adjacent cells is blocked by walls
 * @param {number} x1 - Start X
 * @param {number} y1 - Start Y
 * @param {number} x2 - End X
 * @param {number} y2 - End Y
 * @param {Array} grid - The maze grid
 * @returns {boolean} True if movement is blocked
 */
function isWallBlocking(x1, y1, x2, y2, grid) {
    const cell = grid[y1]?.[x1];
    const destCell = grid[y2]?.[x2];
    if (!cell) return true;

    const dx = x2 - x1;
    const dy = y2 - y1;

    // Check wall in movement direction from source cell
    if (dx === 1 && cell.walls.right) return true;
    if (dx === -1 && cell.walls.left) return true;
    if (dy === 1 && cell.walls.bottom) return true;
    if (dy === -1 && cell.walls.top) return true;

    // Also check from destination cell's perspective (walls should be symmetric but sometimes aren't)
    if (destCell) {
        if (dx === 1 && destCell.walls.left) return true;
        if (dx === -1 && destCell.walls.right) return true;
        if (dy === 1 && destCell.walls.top) return true;
        if (dy === -1 && destCell.walls.bottom) return true;
    }

    return false;
}

/**
 * Check if there's line of sight between two cells (no walls blocking)
 * Uses strict cell-by-cell path walking - if ANY wall blocks the path, visibility is blocked
 * @param {number} x1 - Start X
 * @param {number} y1 - Start Y
 * @param {number} x2 - End X
 * @param {number} y2 - End Y
 * @param {Array} grid - The maze grid
 * @returns {boolean} True if line of sight exists
 */
function hasLineOfSight(x1, y1, x2, y2, grid) {
    // Same cell - always visible
    if (x1 === x2 && y1 === y2) return true;

    const dx = x2 - x1;
    const dy = y2 - y1;
    const adx = Math.abs(dx);
    const ady = Math.abs(dy);
    const sx = dx > 0 ? 1 : dx < 0 ? -1 : 0;
    const sy = dy > 0 ? 1 : dy < 0 ? -1 : 0;

    // For straight lines (cardinal directions), check each cell along the path
    if (dx === 0 || dy === 0) {
        let cx = x1;
        let cy = y1;
        while (cx !== x2 || cy !== y2) {
            const nextX = cx + sx;
            const nextY = cy + sy;
            if (isWallBlocking(cx, cy, nextX, nextY, grid)) {
                return false;
            }
            cx = nextX;
            cy = nextY;
        }
        return true;
    }

    // For diagonal/angled lines, use Bresenham's algorithm and check walls strictly
    // We need BOTH L-shaped paths to be clear at each step for diagonal visibility
    let cx = x1;
    let cy = y1;
    let err = adx - ady;

    while (cx !== x2 || cy !== y2) {
        const e2 = 2 * err;
        let nextX = cx;
        let nextY = cy;
        let movedX = false;
        let movedY = false;

        if (e2 > -ady) {
            err -= ady;
            nextX += sx;
            movedX = true;
        }
        if (e2 < adx) {
            err += adx;
            nextY += sy;
            movedY = true;
        }

        // Check wall blocking based on movement type
        if (movedX && movedY) {
            // Diagonal movement - BOTH paths must be clear for visibility
            // Path A: horizontal then vertical
            const pathABlocked = isWallBlocking(cx, cy, cx + sx, cy, grid) ||
                                 isWallBlocking(cx + sx, cy, nextX, nextY, grid);
            // Path B: vertical then horizontal
            const pathBBlocked = isWallBlocking(cx, cy, cx, cy + sy, grid) ||
                                 isWallBlocking(cx, cy + sy, nextX, nextY, grid);
            // For visibility, require at least one clear path
            // But for strict fog-of-war, require BOTH to be blocked to block vision
            if (pathABlocked && pathBBlocked) {
                return false;
            }
        } else if (movedX) {
            if (isWallBlocking(cx, cy, nextX, nextY, grid)) {
                return false;
            }
        } else if (movedY) {
            if (isWallBlocking(cx, cy, nextX, nextY, grid)) {
                return false;
            }
        }

        cx = nextX;
        cy = nextY;
    }

    return true;
}

/**
 * Apply visibility at a given position (reveal tiles within radius)
 * Uses line-of-sight checking to prevent seeing through walls
 * @param {number} x - Player X position
 * @param {number} y - Player Y position
 * @param {number} gridSize - Size of the grid
 */
function applyVisibilityAtPosition(x, y, gridSize) {
    if (!currentMaze.isOpen) return;

    const visRadius = getVisibilityRadius();
    const floorPrefix = `${currentMaze.currentFloor}:`;

    // Get the current floor's grid
    const floorData = currentMaze.floorsData?.[currentMaze.currentFloor];
    const grid = floorData?.grid || currentMaze.grid;

    if (!grid) return;

    for (let vy = Math.max(0, y - visRadius); vy <= Math.min(gridSize - 1, y + visRadius); vy++) {
        for (let vx = Math.max(0, x - visRadius); vx <= Math.min(gridSize - 1, x + visRadius); vx++) {
            // Use Manhattan distance for visibility range
            if (Math.abs(vx - x) + Math.abs(vy - y) <= visRadius) {
                // Check line of sight - don't reveal through walls
                if (hasLineOfSight(x, y, vx, vy, grid)) {
                    currentMaze.visited.add(`${floorPrefix}${vx},${vy}`);
                }
            }
        }
    }
}

/**
 * Called after each move to update visibility timers
 */
function updateVisibilityOnMove() {
    if (!currentMaze.visibility) return;

    // Decrement temp bonus moves
    if (currentMaze.visibility.tempMovesLeft > 0) {
        currentMaze.visibility.tempMovesLeft--;
        if (currentMaze.visibility.tempMovesLeft <= 0) {
            currentMaze.visibility.tempBonus = 0;
            addMazeMessage('Info', 'Your torch burns out.');
        }
    }

    // Reset floor revealed flag (only lasts 1 move for display purposes)
    currentMaze.visibility.floorRevealed = false;
}

// =============================================================================
// STATISTICS TRACKING
// =============================================================================

/**
 * Initialize session stats for a new maze
 */
/**
 * Get current persona name from SillyTavern context
 * @returns {string} The current persona name or 'Default User'
 */
function getCurrentPersonaName() {
    try {
        const context = SillyTavern.getContext();
        // Try various context properties that might contain the persona name
        return context?.name1 || context?.persona || context?.user_avatar?.replace(/\.[^/.]+$/, '') || 'Default User';
    } catch (e) {
        console.warn('[MazeMaster] Could not get persona name:', e);
        return 'Default User';
    }
}

function initSessionStats() {
    return {
        startTime: Date.now(),
        moves: 0,
        encountersTotal: 0,
        encountersWon: 0,
        encountersLost: 0,
        chestsOpened: 0,
        trapsTriggered: 0,
        teleportsUsed: 0,
        itemsCollected: { key: 0, strike: 0, stealth: 0, execute: 0 },
    };
}

/**
 * Increment a stat and fire the onStatUpdate hook
 * @param {string} statName - Name of the stat to increment
 * @param {number} delta - Amount to add (default 1)
 */
async function incrementStat(statName, delta = 1) {
    if (!currentMaze?.stats) return;

    if (typeof currentMaze.stats[statName] === 'number') {
        currentMaze.stats[statName] += delta;
        updateStatsDisplay();
        await fireHook('onStatUpdate', { statName, value: currentMaze.stats[statName] });
    }
}

/**
 * Get current session stats
 * @returns {Object} Current session stats
 */
function getSessionStats() {
    if (!currentMaze?.stats) return null;
    return {
        ...currentMaze.stats,
        elapsedTime: getElapsedTime(),
        explorationPercent: getExplorationPercent(),
    };
}

/**
 * Get elapsed time as formatted string
 * @returns {string} Formatted time (M:SS or H:MM:SS)
 */
function getElapsedTime() {
    if (!currentMaze?.stats?.startTime) return '0:00';
    const elapsed = Math.floor((Date.now() - currentMaze.stats.startTime) / 1000);
    const hours = Math.floor(elapsed / 3600);
    const mins = Math.floor((elapsed % 3600) / 60);
    const secs = elapsed % 60;
    if (hours > 0) {
        return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Get exploration percentage
 * @returns {number} Exploration percentage (0-100)
 */
function getExplorationPercent() {
    if (!currentMaze?.visited || !currentMaze?.size) return 0;
    const totalFloors = currentMaze.totalFloors || 1;
    const totalCells = currentMaze.size * currentMaze.size * totalFloors;
    return Math.floor((currentMaze.visited.size / totalCells) * 100);
}

/**
 * Update the stats display in the maze modal
 */
function updateStatsDisplay() {
    const movesEl = document.getElementById('maze_stat_moves');
    const timeEl = document.getElementById('maze_stat_time');
    const exploreEl = document.getElementById('maze_stat_explore');

    if (movesEl) movesEl.textContent = currentMaze?.stats?.moves || 0;
    if (timeEl) timeEl.textContent = getElapsedTime();
    if (exploreEl) exploreEl.textContent = `${getExplorationPercent()}%`;

    // v1.4.0: Update zone display
    updateZoneDisplay();
}

/**
 * v1.4.0: Update the zone progress display in the maze modal
 */
function updateZoneDisplay() {
    const zoneDisplayEl = document.getElementById('maze_zone_display');
    const zoneNameEl = document.getElementById('maze_zone_name');
    const zoneProgressEl = document.getElementById('maze_zone_progress');

    if (!zoneDisplayEl) return;

    const zoneProgress = getZoneProgress();

    if (!zoneProgress || !currentMaze.floorsData?.[currentMaze.currentFloor]?.zones?.length) {
        // Hide zone display if no zones or single zone
        zoneDisplayEl.style.display = 'none';
        return;
    }

    const floorZones = currentMaze.floorsData[currentMaze.currentFloor].zones;
    if (floorZones.length <= 1) {
        zoneDisplayEl.style.display = 'none';
        return;
    }

    // Show zone display
    zoneDisplayEl.style.display = '';

    if (zoneNameEl) {
        zoneNameEl.textContent = zoneProgress.zoneName || `Zone ${zoneProgress.zoneId + 1}`;
    }

    if (zoneProgressEl) {
        if (zoneProgress.unlockHint) {
            zoneProgressEl.textContent = `(${zoneProgress.clearedRooms}/${zoneProgress.totalRooms})`;
            zoneProgressEl.title = zoneProgress.unlockHint;
        } else {
            zoneProgressEl.textContent = `(${zoneProgress.clearedRooms}/${zoneProgress.totalRooms})`;
            zoneProgressEl.title = '';
        }
    }
}

/**
 * Helper to update a stats object with game results
 * @param {Object} statsObj - The stats object to update
 * @param {string} profileName - The profile name
 * @param {string} result - 'win' or 'lose'
 * @param {number} elapsed - Elapsed time in ms
 * @param {number} moves - Number of moves
 */
function updateStatsObject(statsObj, profileName, result, elapsed, moves) {
    if (!statsObj.profileStats) {
        statsObj.profileStats = {};
    }

    // Update profile-specific stats
    const profileStats = statsObj.profileStats[profileName] || {
        totalGames: 0,
        wins: 0,
        losses: 0,
        bestTime: null,
        totalMoves: 0,
    };

    profileStats.totalGames++;
    if (result === 'win') {
        profileStats.wins++;
        if (profileStats.bestTime === null || elapsed < profileStats.bestTime) {
            profileStats.bestTime = elapsed;
        }
    } else {
        profileStats.losses++;
    }
    profileStats.totalMoves += moves;
    statsObj.profileStats[profileName] = profileStats;

    // Update aggregate stats
    statsObj.totalGames = (statsObj.totalGames || 0) + 1;
    if (result === 'win') {
        statsObj.wins = (statsObj.wins || 0) + 1;
        if (statsObj.bestTime === null || elapsed < statsObj.bestTime) {
            statsObj.bestTime = elapsed;
        }
    } else {
        statsObj.losses = (statsObj.losses || 0) + 1;
    }
    statsObj.totalMoves = (statsObj.totalMoves || 0) + moves;
}

/**
 * Migrate old stats format to new global/persona structure
 */
function migrateStatsToNewFormat() {
    if (!extensionSettings.mazeStats) return;

    // Check if already migrated (has global property)
    if (extensionSettings.mazeStats.global) return;

    // Old format: { profileStats: { ... } }
    // New format: { global: { profileStats: { ... }, ... }, personas: { ... } }
    const oldProfileStats = extensionSettings.mazeStats.profileStats || {};

    extensionSettings.mazeStats = {
        global: {
            totalGames: 0,
            wins: 0,
            losses: 0,
            bestTime: null,
            totalMoves: 0,
            profileStats: { ...oldProfileStats },
        },
        personas: {},
    };

    // Calculate aggregate totals from migrated profile stats
    for (const profileName in oldProfileStats) {
        const ps = oldProfileStats[profileName];
        extensionSettings.mazeStats.global.totalGames += ps.totalGames || 0;
        extensionSettings.mazeStats.global.wins += ps.wins || 0;
        extensionSettings.mazeStats.global.losses += ps.losses || 0;
        extensionSettings.mazeStats.global.totalMoves += ps.totalMoves || 0;
        if (ps.bestTime !== null) {
            if (extensionSettings.mazeStats.global.bestTime === null ||
                ps.bestTime < extensionSettings.mazeStats.global.bestTime) {
                extensionSettings.mazeStats.global.bestTime = ps.bestTime;
            }
        }
    }

    console.log('[MazeMaster] Migrated stats to new global/persona format');
    saveSettingsDebounced();
}

/**
 * Save persistent stats after game end
 * @param {string} result - 'win' or 'lose'
 */
function savePersistentStats(result) {
    if (!currentMaze?.profileName || !currentMaze?.stats) return;

    const profileName = currentMaze.profileName;
    const personaName = getCurrentPersonaName();
    const elapsed = Date.now() - currentMaze.stats.startTime;
    const moves = currentMaze.stats.moves;

    // Initialize mazeStats structure if needed
    if (!extensionSettings.mazeStats) {
        extensionSettings.mazeStats = {
            global: {
                totalGames: 0,
                wins: 0,
                losses: 0,
                bestTime: null,
                totalMoves: 0,
                profileStats: {},
            },
            personas: {},
        };
    }

    // Migrate old format if needed
    if (!extensionSettings.mazeStats.global) {
        migrateStatsToNewFormat();
    }

    // Update global stats
    updateStatsObject(extensionSettings.mazeStats.global, profileName, result, elapsed, moves);

    // Initialize persona stats if needed
    if (!extensionSettings.mazeStats.personas[personaName]) {
        extensionSettings.mazeStats.personas[personaName] = {
            totalGames: 0,
            wins: 0,
            losses: 0,
            bestTime: null,
            totalMoves: 0,
            profileStats: {},
        };
    }

    // Update persona-specific stats
    updateStatsObject(extensionSettings.mazeStats.personas[personaName], profileName, result, elapsed, moves);

    saveSettingsDebounced();
}

// Stats display update interval
let statsUpdateInterval = null;

function startStatsTimer() {
    if (statsUpdateInterval) clearInterval(statsUpdateInterval);
    statsUpdateInterval = setInterval(() => {
        if (currentMaze?.isOpen && !currentMaze?.isVictory) {
            updateStatsDisplay();
        } else {
            clearInterval(statsUpdateInterval);
            statsUpdateInterval = null;
        }
    }, 1000);
}

function stopStatsTimer() {
    if (statsUpdateInterval) {
        clearInterval(statsUpdateInterval);
        statsUpdateInterval = null;
    }
}

// =============================================================================
// THEME HELPER FUNCTIONS
// =============================================================================

/**
 * Get themed text for an element type
 * @param {string} elementType - Type of element (wall, floor, chest, exit, portal, trap, etc.)
 * @param {Object} profile - The maze profile
 * @returns {string} Themed text or original elementType
 */
function getThemedText(elementType, profile) {
    const themeName = profile?.theme || 'fantasy';
    const theme = SCENARIO_THEMES[themeName] || SCENARIO_THEMES.fantasy;
    return theme?.tileMappings?.[elementType] || elementType;
}

/**
 * Get themed item name
 * @param {string} itemId - The item ID (key, strike, stealth, etc.)
 * @param {Object} profile - The maze profile
 * @returns {string} Themed item name or original itemId
 */
function getThemedItemName(itemId, profile) {
    const themeName = profile?.theme || 'fantasy';
    const theme = SCENARIO_THEMES[themeName] || SCENARIO_THEMES.fantasy;
    return theme?.itemAliases?.[itemId] || itemId;
}

/**
 * Get themed flavor message
 * @param {string} messageType - Type of message (chestFind, portalUse, trapTrigger, etc.)
 * @param {Object} profile - The maze profile
 * @returns {string} Themed message or empty string
 */
function getThemedFlavorMessage(messageType, profile) {
    const themeName = profile?.theme || 'fantasy';
    const theme = SCENARIO_THEMES[themeName] || SCENARIO_THEMES.fantasy;
    return theme?.flavorMessages?.[messageType] || '';
}

/**
 * Get theme colors
 * @param {Object} profile - The maze profile
 * @returns {Object} Theme colors object with primary, secondary, accent
 */
function getThemeColors(profile) {
    const themeName = profile?.theme || 'fantasy';
    const theme = SCENARIO_THEMES[themeName] || SCENARIO_THEMES.fantasy;
    return theme?.colors || { primary: '#2ecc71', secondary: '#27ae60', accent: '#f1c40f' };
}

/**
 * Apply theme colors to maze UI as CSS variables
 * @param {Object} profile - The maze profile
 */
function applyThemeColors(profile) {
    const colors = getThemeColors(profile);
    const container = document.querySelector('.mazemaster-maze-container');
    if (container) {
        container.style.setProperty('--theme-primary', colors.primary);
        container.style.setProperty('--theme-secondary', colors.secondary);
        container.style.setProperty('--theme-accent', colors.accent);
    }
}

// =============================================================================
// D-PAD FUNCTIONALITY
// =============================================================================

/**
 * Initialize D-Pad drag functionality for floating mode
 */
function initDpadDrag() {
    const dpad = document.getElementById('maze_dpad');
    if (!dpad || !dpad.classList.contains('floating')) return;

    const handle = dpad.querySelector('.dpad-drag-handle');
    if (!handle) return;

    let isDragging = false;
    let offsetX = 0;
    let offsetY = 0;

    const startDrag = (clientX, clientY) => {
        isDragging = true;
        offsetX = clientX - dpad.offsetLeft;
        offsetY = clientY - dpad.offsetTop;
        dpad.style.cursor = 'grabbing';
    };

    const moveDrag = (clientX, clientY) => {
        if (!isDragging) return;
        const x = Math.max(0, Math.min(window.innerWidth - dpad.offsetWidth, clientX - offsetX));
        const y = Math.max(0, Math.min(window.innerHeight - dpad.offsetHeight, clientY - offsetY));
        dpad.style.left = `${x}px`;
        dpad.style.top = `${y}px`;
        dpad.style.right = 'auto';
        dpad.style.bottom = 'auto';
    };

    const endDrag = () => {
        if (isDragging) {
            isDragging = false;
            dpad.style.cursor = '';
            // Save position to settings
            if (!extensionSettings.dpadConfig) {
                extensionSettings.dpadConfig = { enabled: true, floating: true, position: {} };
            }
            extensionSettings.dpadConfig.position = {
                x: dpad.offsetLeft,
                y: dpad.offsetTop
            };
            saveSettingsDebounced();
        }
    };

    // Mouse events
    handle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        startDrag(e.clientX, e.clientY);
    });

    document.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
    document.addEventListener('mouseup', endDrag);

    // Touch events
    handle.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        startDrag(touch.clientX, touch.clientY);
    });

    document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        const touch = e.touches[0];
        moveDrag(touch.clientX, touch.clientY);
    });

    document.addEventListener('touchend', endDrag);
}

/**
 * Initialize pinch-zoom and pan/drag for the maze map area
 */
function initMapPanZoom() {
    const container = document.getElementById('maze_grid_container');
    const mazeArea = document.querySelector('.mazemaster-maze-area');
    if (!container || !mazeArea) return;

    // Calculate initial zoom based on grid size (larger grids need more zoom)
    const gridSize = currentMaze?.size || 10;
    let tileWidth;
    if (gridSize <= 7) tileWidth = 76;
    else if (gridSize <= 10) tileWidth = 64;
    else if (gridSize <= 15) tileWidth = 52;
    else if (gridSize <= 20) tileWidth = 44;
    else tileWidth = 36;

    // Scale up larger mazes to match visual size of reference (64px tiles)
    const referenceTileSize = 64;
    const baseScale = 1.5;
    const initialScale = baseScale * (referenceTileSize / tileWidth);

    let scale = initialScale;
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let startX = 0;
    let startY = 0;
    let lastTouchDist = 0;
    let lastScale = initialScale;

    const minScale = 0.5;
    const maxScale = 4; // Allow more zoom for large mazes

    // Apply transform without transition (for dragging)
    const applyTransform = (smooth = false) => {
        if (smooth) {
            container.style.transition = 'transform 0.3s ease-out';
        } else {
            container.style.transition = 'none';
        }
        container.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        container.style.transformOrigin = '0 0'; // Top-left origin for simpler math
    };

    // Calculate player screen position in isometric view (must match IsometricRenderer exactly)
    const getPlayerIsometricPosition = (canvas) => {
        if (!currentMaze || currentMaze.playerX === undefined) return null;

        // Get tile size based on grid size (must match IsometricRenderer.getCellSize)
        const gridSize = currentMaze.size || 10;
        let tileWidth;
        if (gridSize <= 7) tileWidth = 76;
        else if (gridSize <= 10) tileWidth = 64;
        else if (gridSize <= 15) tileWidth = 52;
        else if (gridSize <= 20) tileWidth = 44;
        else tileWidth = 36;

        const tileHeight = tileWidth / 2;
        const spriteHeight = tileWidth * 2;

        // Player maze coordinates
        const px = currentMaze.playerX;
        const py = currentMaze.playerY;

        // gridToIso formula (exact match to renderer)
        const isoX = (px - py) * (tileWidth / 2);
        const isoY = (px + py) * (tileHeight / 2);

        // Add canvas offsets (exact match to renderer)
        const offsetX = canvas.width / 2;
        const offsetY = spriteHeight;

        const drawX = isoX + offsetX;
        const drawY = isoY + offsetY;

        return { x: drawX, y: drawY };
    };

    // Center on player function - exposed globally for reuse
    const centerOnPlayer = (smooth = false) => {
        const playerEl = container.querySelector('.player-marker, .maze-cell.current');
        const canvas = container.querySelector('canvas');
        const areaRect = mazeArea.getBoundingClientRect();

        if (playerEl) {
            // CSS Grid renderer - find player cell
            const cellRect = playerEl.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            // Calculate offset to center the player
            const playerCenterX = cellRect.left + cellRect.width / 2 - containerRect.left;
            const playerCenterY = cellRect.top + cellRect.height / 2 - containerRect.top;
            const areaCenterX = areaRect.width / 2;
            const areaCenterY = areaRect.height / 2;

            panX = (areaCenterX - playerCenterX * scale);
            panY = (areaCenterY - playerCenterY * scale);
            applyTransform(smooth);
        } else if (canvas) {
            // Isometric renderer - calculate player position on canvas
            const playerPos = getPlayerIsometricPosition(canvas);

            if (playerPos) {
                // Center viewport on player's isometric position
                const areaCenterX = areaRect.width / 2;
                const areaCenterY = areaRect.height / 2;

                // Calculate pan to center player in view
                panX = areaCenterX - (playerPos.x * scale);
                panY = areaCenterY - (playerPos.y * scale);
                applyTransform(smooth);
            } else {
                // Fallback: center canvas generally
                const canvasHeight = canvas.height;
                const areaHeight = areaRect.height;
                panY = (areaHeight - canvasHeight * scale) / 2 + (canvasHeight * scale * 0.45);
                applyTransform(smooth);
            }
        }
    };

    // Store centerOnPlayer globally so it can be called after moves
    window.mazeCenterOnPlayer = (smooth = true) => centerOnPlayer(smooth);

    // Initial centering after canvas renders (multiple attempts for larger mazes)
    setTimeout(() => centerOnPlayer(false), 50);
    setTimeout(() => centerOnPlayer(false), 150);
    setTimeout(() => centerOnPlayer(false), 300); // Fallback for large mazes

    // Mouse wheel zoom (centered on player)
    mazeArea.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        scale = Math.max(minScale, Math.min(maxScale, scale * delta));
        centerOnPlayer(false); // Re-center on player when zooming
    }, { passive: false });

    // Mouse drag pan
    mazeArea.addEventListener('mousedown', (e) => {
        if (e.target.closest('.maze-cell, canvas')) {
            isPanning = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;
            mazeArea.style.cursor = 'grabbing';
            container.style.transition = 'none'; // Disable transition while dragging
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (!isPanning) return;
        panX = e.clientX - startX;
        panY = e.clientY - startY;
        applyTransform(false);
    });

    document.addEventListener('mouseup', () => {
        isPanning = false;
        mazeArea.style.cursor = '';
    });

    // Touch pinch zoom
    const getTouchDist = (touches) => {
        if (touches.length < 2) return 0;
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    };

    mazeArea.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            // Pinch start
            lastTouchDist = getTouchDist(e.touches);
            lastScale = scale;
        } else if (e.touches.length === 1) {
            // Pan start
            isPanning = true;
            startX = e.touches[0].clientX - panX;
            startY = e.touches[0].clientY - panY;
            container.style.transition = 'none'; // Disable transition while dragging
        }
    }, { passive: true });

    mazeArea.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            // Pinch zoom - stay centered on player
            e.preventDefault();
            const dist = getTouchDist(e.touches);
            if (lastTouchDist > 0) {
                const delta = dist / lastTouchDist;
                scale = Math.max(minScale, Math.min(maxScale, lastScale * delta));
                centerOnPlayer(false); // Re-center on player when zooming
            }
        } else if (e.touches.length === 1 && isPanning) {
            // Pan
            panX = e.touches[0].clientX - startX;
            panY = e.touches[0].clientY - startY;
            applyTransform(false);
        }
    }, { passive: false });

    mazeArea.addEventListener('touchend', () => {
        isPanning = false;
        lastTouchDist = 0;
        lastScale = scale;
    });

    // Double-tap to reset zoom and re-center on player
    let lastTap = 0;
    mazeArea.addEventListener('touchend', (e) => {
        const now = Date.now();
        if (now - lastTap < 300 && e.changedTouches.length === 1) {
            // Double tap - reset zoom to initial and center on player
            scale = initialScale;
            lastScale = initialScale;
            centerOnPlayer(true); // Smooth animation on double-tap reset
        }
        lastTap = now;
    });

    // Add cursor hint
    mazeArea.style.cursor = 'grab';
}

/**
 * Update D-Pad floor buttons visibility based on current position
 */
function updateDpadFloorButtons() {
    const upBtn = document.querySelector('.dpad-floor-up');
    const downBtn = document.querySelector('.dpad-floor-down');

    if (!upBtn || !downBtn || !currentMaze) {
        return;
    }

    // Check if player is on a staircase
    const cell = currentMaze.grid?.[currentMaze.playerY]?.[currentMaze.playerX];
    const staircase = cell?.staircase;

    if (staircase?.direction === 'up') {
        upBtn.classList.remove('hidden');
    } else {
        upBtn.classList.add('hidden');
    }

    if (staircase?.direction === 'down') {
        downBtn.classList.remove('hidden');
    } else {
        downBtn.classList.add('hidden');
    }
}

/**
 * Try to change floors via staircase
 * @param {string} direction - 'up' or 'down'
 */
async function tryFloorChange(direction) {
    if (!currentMaze?.isOpen || currentMaze.isPaused) return false;
    if (currentMaze.totalFloors <= 1) return false;

    const cell = currentMaze.grid?.[currentMaze.playerY]?.[currentMaze.playerX];
    if (!cell?.staircase) {
        console.log('[MazeMaster] Not on a staircase');
        return false;
    }

    if (cell.staircase.direction !== direction) {
        console.log('[MazeMaster] Staircase direction mismatch');
        return false;
    }

    // Check if floor key is required
    if (cell.staircase.requireKey && direction === 'up') {
        if (!hasFloorKey()) {
            currentMaze.currentMinion = {
                name: 'Locked Staircase',
                imagePath: '',
                message: 'This staircase is locked! You need a Floor Key to ascend.',
            };
            updateMazeHero();
            return false;
        }
        // Consume the floor key
        await consumeFloorKey();
    }

    const targetFloor = cell.staircase.targetFloor;
    const targetX = cell.staircase.targetX;
    const targetY = cell.staircase.targetY;

    // Validate target floor
    if (targetFloor < 0 || targetFloor >= currentMaze.totalFloors) {
        console.error('[MazeMaster] Invalid target floor');
        return false;
    }

    // Update floor and position
    currentMaze.currentFloor = targetFloor;
    currentMaze.grid = currentMaze.floors[targetFloor];
    currentMaze.playerX = targetX;
    currentMaze.playerY = targetY;

    // Mark new position as visited (with floor prefix for proper tracking)
    currentMaze.visited.add(`${targetFloor}:${targetX},${targetY}`);

    // Log floor change to session notes
    addSessionNote(`${direction === 'up' ? 'Ascended' : 'Descended'} to Floor ${targetFloor + 1}/${currentMaze.totalFloors}`, 'Floor');

    // Show transition message
    const theme = SCENARIO_THEMES[currentMaze.profile?.theme] || SCENARIO_THEMES.fantasy;
    const flavorMsg = direction === 'up'
        ? theme.flavorMessages.stairUp
        : theme.flavorMessages.stairDown;

    currentMaze.currentMinion = {
        name: direction === 'up' ? 'Ascending' : 'Descending',
        imagePath: '',
        message: flavorMsg || `You ${direction === 'up' ? 'ascend' : 'descend'} to floor ${targetFloor + 1}...`,
    };
    updateMazeHero();

    // Fire hook
    await fireHook('onMove', { x: targetX, y: targetY, direction: direction === 'up' ? 'floor-up' : 'floor-down', floor: targetFloor });

    // Re-render grid
    renderMazeGrid();
    updatePlayerPosition(false);
    updateStatsDisplay();
    updateDpadFloorButtons();
    updateFloorIndicator();

    // Center camera on player (smooth pan)
    if (typeof window.mazeCenterOnPlayer === 'function') {
        window.mazeCenterOnPlayer(true);
    }

    console.log(`[MazeMaster] Changed to floor ${targetFloor + 1}`);
    return true;
}

/**
 * Update floor indicator display
 */
function updateFloorIndicator() {
    const currentEl = document.getElementById('maze_floor_current');
    const totalEl = document.getElementById('maze_floor_total');
    const indicator = document.querySelector('.maze-floor-indicator');

    if (currentMaze.totalFloors <= 1) {
        if (indicator) indicator.style.display = 'none';
        return;
    }

    if (indicator) indicator.style.display = '';
    if (currentEl) currentEl.textContent = currentMaze.currentFloor + 1;
    if (totalEl) totalEl.textContent = currentMaze.totalFloors;
}

// =============================================================================
// v1.2.0 NEW ITEM USAGE FUNCTIONS
// =============================================================================

/**
 * Use a Map Fragment to reveal a 3x3 area around the player
 */
async function useMapFragment() {
    if (!currentMaze || currentMaze.isPaused) return false;
    if (!currentMaze.inventory.mapFragment || currentMaze.inventory.mapFragment <= 0) {
        console.log('[MazeMaster] No Map Fragments available');
        return false;
    }

    const { playerX, playerY, grid, size } = currentMaze;

    // Reveal 3x3 area around player
    let revealed = 0;
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            const x = playerX + dx;
            const y = playerY + dy;
            if (x >= 0 && x < size && y >= 0 && y < size) {
                const key = `${x},${y}`;
                if (!currentMaze.visited.has(key)) {
                    currentMaze.visited.add(key);
                    grid[y][x].visited = true;
                    revealed++;
                }
            }
        }
    }

    await removeFromInventory('mapFragment', 1);
    renderMazeGrid();

    // Show message
    currentMaze.currentMinion = {
        name: 'Map Fragment',
        imagePath: '',
        message: revealed > 0
            ? `The ancient map reveals ${revealed} hidden area${revealed > 1 ? 's' : ''}!`
            : 'The map shows only what you already knew.',
    };
    updateMazeHero();

    await fireHook('onItemRemove', { item: 'mapFragment', count: 1, total: currentMaze.inventory.mapFragment });
    return true;
}

/**
 * Use a Portal Stone to teleport to a revealed portal
 * Shows selection UI if multiple portals are available
 */
async function usePortalStone() {
    if (!currentMaze || currentMaze.isPaused) return false;
    if (!currentMaze.inventory.portalStone || currentMaze.inventory.portalStone <= 0) {
        console.log('[MazeMaster] No Portal Stones available');
        return false;
    }

    // Find all revealed portals (visited cells with portal)
    const revealedPortals = [];
    for (const key of currentMaze.visited) {
        const [x, y] = key.split(',').map(Number);
        const cell = currentMaze.grid[y]?.[x];
        if (cell?.portal && !(x === currentMaze.playerX && y === currentMaze.playerY)) {
            revealedPortals.push({ x, y, portal: cell.portal });
        }
    }

    if (revealedPortals.length === 0) {
        currentMaze.currentMinion = {
            name: 'Portal Stone',
            imagePath: '',
            message: 'No revealed portals to teleport to. Explore more to find portals first!',
        };
        updateMazeHero();
        return false;
    }

    // If only one portal, teleport directly
    if (revealedPortals.length === 1) {
        const target = revealedPortals[0];
        await executePortalStoneTeleport(target.x, target.y);
        return true;
    }

    // Multiple portals - show selection (simple first-found for now, TODO: selection UI)
    const target = revealedPortals[0];
    await executePortalStoneTeleport(target.x, target.y);
    return true;
}

/**
 * Execute portal stone teleportation
 */
async function executePortalStoneTeleport(targetX, targetY) {
    await removeFromInventory('portalStone', 1);

    // Teleport player
    currentMaze.playerX = targetX;
    currentMaze.playerY = targetY;
    currentMaze.visited.add(`${currentMaze.currentFloor}:${targetX},${targetY}`);

    updatePlayerPosition(true);
    renderMazeGrid();
    updateDpadFloorButtons();

    currentMaze.currentMinion = {
        name: 'Portal Stone',
        imagePath: '',
        message: 'The portal stone crumbles as you are whisked through space!',
    };
    updateMazeHero();

    await fireHook('onTeleport', { x: targetX, y: targetY, source: 'portalStone' });
}

/**
 * Activate Void Walk mode - next move can phase through a wall
 */
function activateVoidWalk() {
    if (!currentMaze || currentMaze.isPaused) return false;
    if (!currentMaze.inventory.voidWalk || currentMaze.inventory.voidWalk <= 0) {
        console.log('[MazeMaster] No Void Walk available');
        return false;
    }

    if (currentMaze.voidWalkActive) {
        console.log('[MazeMaster] Void Walk already active');
        return false;
    }

    currentMaze.voidWalkActive = true;

    // Visual indicator
    const dpad = document.getElementById('maze_dpad');
    if (dpad) dpad.classList.add('void-walk-active');

    currentMaze.currentMinion = {
        name: 'Void Walk',
        imagePath: '',
        message: 'You become ethereal... Your next move can phase through walls!',
    };
    updateMazeHero();

    return true;
}

/**
 * Consume void walk on successful wall phase
 */
async function consumeVoidWalk() {
    if (currentMaze?.voidWalkActive) {
        currentMaze.voidWalkActive = false;
        await removeFromInventory('voidWalk', 1);

        const dpad = document.getElementById('maze_dpad');
        if (dpad) dpad.classList.remove('void-walk-active');
    }
}

/**
 * Cancel void walk mode
 */
function cancelVoidWalk() {
    if (currentMaze?.voidWalkActive) {
        currentMaze.voidWalkActive = false;
        const dpad = document.getElementById('maze_dpad');
        if (dpad) dpad.classList.remove('void-walk-active');
    }
}

/**
 * Check if Minion Bane should auto-defeat a minion
 * Returns true if bane was consumed and minion defeated
 */
async function checkMinionBane() {
    if (!currentMaze?.inventory.minionBane || currentMaze.inventory.minionBane <= 0) {
        return false;
    }

    await removeFromInventory('minionBane', 1);

    currentMaze.currentMinion = {
        name: 'Minion Bane',
        imagePath: '',
        message: 'Your Minion Bane flares with power, instantly vanquishing the foe!',
    };
    updateMazeHero();

    return true;
}

/**
 * Apply Time Shard effect to battlebar (50% slower)
 * Returns the multiplier to apply
 */
function getTimeShardMultiplier() {
    if (!currentMaze?.inventory.timeShard || currentMaze.inventory.timeShard <= 0) {
        return 1.0;
    }
    return 0.5; // 50% speed = 2x more time to react
}

/**
 * Consume time shard when battlebar starts
 */
async function consumeTimeShard() {
    if (currentMaze?.inventory.timeShard > 0) {
        await removeFromInventory('timeShard', 1);
        currentMaze.currentMinion = {
            name: 'Time Shard',
            imagePath: '',
            message: 'Time slows around you... The battlebar moves at half speed!',
        };
        updateMazeHero();
    }
}

/**
 * Check if Floor Key is required and available
 */
function hasFloorKey() {
    return currentMaze?.inventory.floorKey > 0;
}

/**
 * Consume a floor key when using stairs
 */
async function consumeFloorKey() {
    if (currentMaze?.inventory.floorKey > 0) {
        await removeFromInventory('floorKey', 1);
    }
}

/**
 * Check if exploration is complete and fire hook
 */
async function checkExplorationComplete() {
    if (!currentMaze) return;

    const percent = getExplorationPercent();

    // Update explore objectives with current percentage
    if (currentMaze.profile?.objectives) {
        for (const obj of currentMaze.profile.objectives) {
            if (obj.type === 'explore') {
                const objProgress = currentMaze.objectiveProgress[obj.id];
                if (objProgress && !objProgress.completed) {
                    // Set current to actual exploration percent
                    objProgress.current = percent;

                    // Check if target reached
                    if (percent >= (obj.count || 100)) {
                        objProgress.completed = true;
                        await fireHook('onObjectiveComplete', { objectiveId: obj.id });
                        if (obj.reward && obj.reward.trim()) {
                            await executeWithTimeout(obj.reward);
                        }
                    }
                }
            }
        }
        updateObjectivesDisplay();
        checkAllObjectivesComplete();
    }

    if (!currentMaze.explorationComplete && percent >= 100) {
        currentMaze.explorationComplete = true;
        await fireHook('onExploreComplete', { percentage: 100 });
    }
}

/**
 * Update player overlay position for smooth animation
 * @param {boolean} animate - Whether to animate the movement
 */
function updatePlayerPosition(animate = true) {
    if (!currentMaze) return;

    const renderer = RendererRegistry.getRenderer();
    const cellSize = getCellSize(currentMaze.size);
    renderer.updatePlayerPosition(currentMaze.playerX, currentMaze.playerY, animate, cellSize);

    // v1.2.1: Update room info when player moves
    updateRoomInfoBox();
}

/**
 * Place portals on the maze grid based on profile configuration
 */
function placePortals(grid, profile, size, validCells) {
    if (!profile.portals || profile.portals.length === 0) return;

    const placedPortals = [];

    for (const portalConfig of profile.portals) {
        // Find start and end positions
        let startX = portalConfig.startX;
        let startY = portalConfig.startY;
        let endX = portalConfig.endX;
        let endY = portalConfig.endY;

        // If positions are null/undefined, pick random empty cells
        if (startX == null || startY == null) {
            const availableStart = validCells.find(c =>
                !grid[c.y][c.x].chest &&
                !grid[c.y][c.x].minion &&
                !grid[c.y][c.x].trap &&
                !grid[c.y][c.x].portal &&
                !(c.x === 0 && c.y === 0) &&
                !(c.x === size - 1 && c.y === size - 1)
            );
            if (availableStart) {
                startX = availableStart.x;
                startY = availableStart.y;
                // Remove from valid cells
                const idx = validCells.indexOf(availableStart);
                if (idx > -1) validCells.splice(idx, 1);
            } else continue;
        }

        if (endX == null || endY == null) {
            const availableEnd = validCells.find(c =>
                !grid[c.y][c.x].chest &&
                !grid[c.y][c.x].minion &&
                !grid[c.y][c.x].trap &&
                !grid[c.y][c.x].portal &&
                !(c.x === startX && c.y === startY) &&
                !(c.x === 0 && c.y === 0) &&
                !(c.x === size - 1 && c.y === size - 1)
            );
            if (availableEnd) {
                endX = availableEnd.x;
                endY = availableEnd.y;
                const idx = validCells.indexOf(availableEnd);
                if (idx > -1) validCells.splice(idx, 1);
            } else continue;
        }

        const portalId = portalConfig.id || `portal_${placedPortals.length + 1}`;
        const color = portalConfig.color || '#9b59b6';
        const bidirectional = portalConfig.bidirectional !== false;

        // Place start portal
        grid[startY][startX].portal = {
            id: portalId,
            target: { x: endX, y: endY },
            isStart: true,
            color: color,
            bidirectional: bidirectional,
        };

        // Place end portal (bidirectional or one-way destination)
        grid[endY][endX].portal = {
            id: portalId,
            target: { x: startX, y: startY },
            isStart: false,
            color: color,
            bidirectional: bidirectional,
        };

        placedPortals.push({
            id: portalId,
            startX, startY,
            endX, endY,
            color,
            bidirectional,
        });
    }

    if (placedPortals.length > 0) {
        console.log(`[MazeMaster] Placed ${placedPortals.length} portal pair(s)`);
    }

    return placedPortals;
}

/**
 * Handle teleportation when player steps on a portal
 */
async function handleTeleport(fromX, fromY, portal) {
    if (!portal) return false;

    // Check if this portal can teleport (bidirectional portals always work, one-way only from start)
    if (!portal.bidirectional && !portal.isStart) {
        return false; // One-way portal exit, no teleportation
    }

    const target = portal.target;
    if (!target || target.x == null || target.y == null) return false;

    // Fire the onTeleport hook
    await fireHook('onTeleport', {
        portalId: portal.id,
        fromX: fromX,
        fromY: fromY,
        toX: target.x,
        toY: target.y,
    });

    // Update player position
    currentMaze.playerX = target.x;
    currentMaze.playerY = target.y;

    // Mark destination as visited
    currentMaze.visited.add(`${currentMaze.currentFloor}:${target.x},${target.y}`);

    // Update position instantly (no animation for teleport)
    updatePlayerPosition(false);
    updateDpadFloorButtons();

    // Increment teleport stat
    await incrementStat('teleportsUsed', 1);

    // Flash effect on both cells
    const startCell = document.querySelector(`.maze-cell[data-x="${fromX}"][data-y="${fromY}"]`);
    const endCell = document.querySelector(`.maze-cell[data-x="${target.x}"][data-y="${target.y}"]`);

    if (startCell) {
        startCell.classList.add('portal-flash');
        setTimeout(() => startCell.classList.remove('portal-flash'), 300);
    }
    if (endCell) {
        endCell.classList.add('portal-flash');
        setTimeout(() => endCell.classList.remove('portal-flash'), 300);
    }

    console.log(`[MazeMaster] Teleported from (${fromX},${fromY}) to (${target.x},${target.y})`);
    return true;
}

/**
 * Initialize moving minions list from placed minions on the grid
 */
function initMovingMinions(grid, size) {
    const movingMinions = [];

    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const cell = grid[y][x];
            if (cell.minion && !cell.minion.triggered) {
                const minionData = getMinion(cell.minion.minionId);
                const movement = minionData?.movement || { type: 'stationary' };

                if (movement.type !== 'stationary') {
                    movingMinions.push({
                        minionId: cell.minion.minionId,
                        x: x,
                        y: y,
                        originX: x,
                        originY: y,
                        triggered: false,
                        movement: { ...movement },
                    });
                }
            }
        }
    }

    console.log(`[MazeMaster] Initialized ${movingMinions.length} moving minion(s)`);
    return movingMinions;
}

/**
 * Process minion movement after player moves
 */
async function processMinionMovement() {
    if (!currentMaze || !currentMaze.movingMinions || currentMaze.movingMinions.length === 0) return;

    const { grid, size, playerX, playerY, moveCount } = currentMaze;
    const difficulty = getDifficultySettings(currentMaze.profile);

    for (const minion of currentMaze.movingMinions) {
        if (minion.triggered) continue;

        // Check speed (moves every N player moves)
        const speed = minion.movement.speed || 1;
        if (moveCount % speed !== 0) continue;

        const newPos = calculateMinionMove(minion, grid, size, playerX, playerY, difficulty);
        if (!newPos) continue;

        const fromX = minion.x;
        const fromY = minion.y;

        // Remove minion from old cell
        if (grid[fromY][fromX].minion?.minionId === minion.minionId) {
            grid[fromY][fromX].minion = null;
        }

        // Move minion to new cell
        minion.x = newPos.x;
        minion.y = newPos.y;
        grid[newPos.y][newPos.x].minion = {
            minionId: minion.minionId,
            triggered: false,
        };

        // Fire onEnemyMove hook
        await fireHook('onEnemyMove', {
            minionId: minion.minionId,
            fromX: fromX,
            fromY: fromY,
            toX: newPos.x,
            toY: newPos.y,
        });

        // Check for collision with player
        if (newPos.x === playerX && newPos.y === playerY) {
            console.log(`[MazeMaster] Moving minion ${minion.minionId} caught the player!`);
            minion.triggered = true;
            grid[newPos.y][newPos.x].minion.triggered = true;
            triggerMinionEncounter(minion.minionId, newPos.x, newPos.y);
            return; // Stop processing after encounter
        }
    }
}

/**
 * Calculate the next move for a minion based on its movement type
 */
function calculateMinionMove(minion, grid, size, playerX, playerY, difficulty) {
    const { x, y, originX, originY, movement } = minion;
    const aggressionMult = difficulty?.minionAggressionMult || 1;

    // Get valid adjacent cells (not blocked by walls)
    const validMoves = getValidMinionMoves(x, y, grid, size);
    if (validMoves.length === 0) return null;

    switch (movement.type) {
        case 'patrol': {
            // Patrol: Random movement within radius of origin
            const radius = movement.patrolRadius || 3;
            const inRangeMoves = validMoves.filter(pos => {
                const distFromOrigin = Math.abs(pos.x - originX) + Math.abs(pos.y - originY);
                return distFromOrigin <= radius;
            });
            if (inRangeMoves.length === 0) return null;
            return inRangeMoves[Math.floor(Math.random() * inRangeMoves.length)];
        }

        case 'chase': {
            // Chase: Move toward player if within range
            const baseRange = movement.chaseRange || 5;
            const range = Math.ceil(baseRange * aggressionMult);
            const distToPlayer = Math.abs(x - playerX) + Math.abs(y - playerY);

            if (distToPlayer > range) {
                // Out of range, random movement
                return validMoves[Math.floor(Math.random() * validMoves.length)];
            }

            // Move toward player (A* would be overkill, use greedy approach)
            let bestMove = null;
            let bestDist = distToPlayer;

            for (const pos of validMoves) {
                const newDist = Math.abs(pos.x - playerX) + Math.abs(pos.y - playerY);
                if (newDist < bestDist) {
                    bestDist = newDist;
                    bestMove = pos;
                }
            }

            // 50% chance to make suboptimal move (makes AI less predictable)
            if (bestMove && Math.random() < 0.5 * (1 / aggressionMult)) {
                return validMoves[Math.floor(Math.random() * validMoves.length)];
            }

            return bestMove || validMoves[Math.floor(Math.random() * validMoves.length)];
        }

        default:
            return null;
    }
}

/**
 * Initialize objectives for the current maze
 */
function initObjectives(profile) {
    const progress = {};
    const objectives = profile.objectives || [];

    for (const obj of objectives) {
        progress[obj.id] = {
            current: 0,
            completed: false,
            target: obj.count || 1,
        };
    }

    return progress;
}

/**
 * Update objective progress for a specific type/target
 */
async function updateObjectiveProgress(type, target, delta = 1) {
    if (!currentMaze || !currentMaze.profile?.objectives) return;

    const objectives = currentMaze.profile.objectives;
    const progress = currentMaze.objectiveProgress;

    for (const obj of objectives) {
        if (obj.type !== type) continue;
        // For collect/defeat, target must match; for explore/moves, target is optional
        if ((type === 'collect' || type === 'defeat') && obj.target !== target) continue;

        const objProgress = progress[obj.id];
        if (!objProgress || objProgress.completed) continue;

        objProgress.current += delta;

        // Fire progress hook
        await fireHook('onObjectiveProgress', {
            objectiveId: obj.id,
            current: objProgress.current,
            target: obj.count || 1,
        });

        // Check completion
        if (objProgress.current >= (obj.count || 1) && !objProgress.completed) {
            objProgress.completed = true;

            // Fire completion hook
            await fireHook('onObjectiveComplete', { objectiveId: obj.id });

            // Execute reward script if any
            if (obj.reward && obj.reward.trim()) {
                await executeWithTimeout(obj.reward);
            }

            console.log(`[MazeMaster] Objective "${obj.id}" completed!`);
        }
    }

    // Update objectives display
    updateObjectivesDisplay();

    // Check if all required objectives complete
    checkAllObjectivesComplete();
}

/**
 * Check if all required objectives are complete
 */
async function checkAllObjectivesComplete() {
    if (!currentMaze || currentMaze.allObjectivesComplete) return;

    const objectives = currentMaze.profile?.objectives || [];
    const progress = currentMaze.objectiveProgress;

    const requiredComplete = objectives.every(obj => {
        if (!obj.required) return true;
        return progress[obj.id]?.completed;
    });

    if (requiredComplete && objectives.some(obj => obj.required)) {
        currentMaze.allObjectivesComplete = true;
        await fireHook('onAllObjectivesComplete', {});
        console.log('[MazeMaster] All required objectives complete!');
    }
}

/**
 * Check if the player can win the maze (all required objectives completed)
 */
function canWinMaze() {
    if (!currentMaze || !currentMaze.profile?.objectives) return true;

    const objectives = currentMaze.profile.objectives;
    const progress = currentMaze.objectiveProgress;

    // If no required objectives, can always win
    const requiredObjectives = objectives.filter(obj => obj.required);
    if (requiredObjectives.length === 0) return true;

    return requiredObjectives.every(obj => progress[obj.id]?.completed);
}

/**
 * Update the objectives display in the maze modal
 */
function updateObjectivesDisplay() {
    const container = document.getElementById('maze_objectives_list');
    if (!container || !currentMaze) return;

    const objectives = currentMaze.profile?.objectives || [];
    const progress = currentMaze.objectiveProgress;

    if (objectives.length === 0) {
        container.innerHTML = '';
        container.closest('.maze-objectives-section')?.classList.add('hidden');
        return;
    }

    container.closest('.maze-objectives-section')?.classList.remove('hidden');

    container.innerHTML = objectives.map(obj => {
        const objProgress = progress[obj.id] || { current: 0, completed: false };
        const isComplete = objProgress.completed;
        const icon = isComplete ? 'fa-check-circle' : (obj.required ? 'fa-circle' : 'fa-circle-o');
        const colorClass = isComplete ? 'objective-complete' : (obj.required ? 'objective-required' : 'objective-optional');

        return `
            <div class="objective-item ${colorClass}">
                <i class="fa-solid ${icon}"></i>
                <span class="objective-description">${escapeHtml(obj.description || obj.id)}</span>
                <span class="objective-progress">${objProgress.current}/${obj.count || 1}</span>
            </div>
        `;
    }).join('');
}

/**
 * Get valid movement positions for a minion (respects walls)
 */
function getValidMinionMoves(x, y, grid, size) {
    const moves = [];
    const cell = grid[y][x];

    // Check each direction
    if (!cell.walls.top && y > 0) {
        const targetCell = grid[y - 1][x];
        if (!targetCell.minion && !(x === 0 && y - 1 === 0)) {
            moves.push({ x: x, y: y - 1 });
        }
    }
    if (!cell.walls.bottom && y < size - 1) {
        const targetCell = grid[y + 1][x];
        if (!targetCell.minion && !(x === size - 1 && y + 1 === size - 1)) {
            moves.push({ x: x, y: y + 1 });
        }
    }
    if (!cell.walls.left && x > 0) {
        const targetCell = grid[y][x - 1];
        if (!targetCell.minion && !(x - 1 === 0 && y === 0)) {
            moves.push({ x: x - 1, y: y });
        }
    }
    if (!cell.walls.right && x < size - 1) {
        const targetCell = grid[y][x + 1];
        if (!targetCell.minion && !(x + 1 === size - 1 && y === size - 1)) {
            moves.push({ x: x + 1, y: y });
        }
    }

    return moves;
}

// =============================================================================
// STATE
// =============================================================================

const defaultSettings = {
    profiles: {
        // "profileName": { segments: [{ trigger, text, command, size, respin }] }
    },
    battlebarProfiles: {
        // "profileName": { difficulty, hitsToWin, missesToLose, hitCommand, missCommand, winCommand, loseCommand, images }
    },
    mazeProfiles: {
        // "profileName": { gridSize, winCommand, winImage, winMessage, mainMinion, mainMinionIntroMessage,
        //   mainMinionRandomChance, mainMinionRandomMessages, mainMinionExitType, mainMinionExitProfile,
        //   minionEncounters, onBattlebarLoss, loseCommand }
    },
    minions: {
        // "minionId": { name, imagePath, type, battlebarProfiles, wheelProfiles, messages }
    },
    minionProfiles: {
        // "profileName": { minions: { minionId: {...}, ... } }
    },
    trapProfiles: {
        // "profileName": { traps: { trapId: {...}, ... } }
    },
    currentProfile: 'default',
    currentBattlebarProfile: 'default',
    currentMazeProfile: 'default',
    currentMinionProfile: 'default',
    currentTrapProfile: 'default',
    activeGameConfig: 'maze', // 'wheel' | 'battlebar' | 'maze' | 'minions' | 'traps'
    layoutMode: 'desktop', // 'desktop' | 'mobile' | 'auto'
    llmEnabled: true,
    llmPreset: '',
    closeChatOnStart: true, // Close current chat before starting maze to prevent context bleed
    // D-Pad configuration
    dpadConfig: {
        enabled: true,
        floating: true,
        position: { x: null, y: null }, // null = auto-position
    },
};

// =============================================================================
// DEFAULT EXAMPLE DATA
// =============================================================================

const DEFAULT_WHEEL_PROFILES = {
    // === BENEFICIAL WHEELS (friendly NPCs) ===
    // Balance: 2 halfseg + 2 doubleseg = balanced
    'Blessing Wheel': {
        segments: [
            { trigger: 'com0', text: 'Key', command: '/echo You receive a Key!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Strike', command: '/echo You receive a STRIKE!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Stealth', command: '/echo You receive a Stealth!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Double Key!', command: '/echo You receive 2 Keys!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'EXECUTE!', command: '/echo You receive an EXECUTE!', size: 'halfseg', respin: false },
            { trigger: 'com5', text: 'Spin Again', command: '/echo Blessed luck! Spin again!', size: 'fraction', respin: true },
        ],
        randomize: true,
        difficulty: 1,
    },
    'Treasure Wheel': {
        segments: [
            { trigger: 'com0', text: 'Key', command: '/echo A key materializes!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Strike', command: '/echo Power surges through you!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Stealth', command: '/echo Shadows embrace you!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Floor Key', command: '/echo A Floor Key appears!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Bonus Spin', command: '/echo Fortune favors you!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'Portal Stone', command: '/echo A Portal Stone!', size: 'fraction', respin: false },
        ],
        randomize: true,
        difficulty: 1,
    },
    // === MIXED WHEELS (neutral NPCs) ===
    'Gambler\'s Wheel': {
        segments: [
            { trigger: 'com0', text: 'JACKPOT!', command: '/echo JACKPOT! You win big!', size: 'halfseg', respin: false },
            { trigger: 'com1', text: 'Win Key', command: '/echo You win a Key!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Lose Key', command: '/echo You lose a Key...', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Double Down', command: '/echo Double or nothing!', size: 'doubleseg', respin: true },
            { trigger: 'com4', text: 'Nothing', command: '/echo The wheel mocks you...', size: 'fraction', respin: false },
            { trigger: 'com5', text: 'Lose Strike', command: '/echo Your power fades...', size: 'halfseg', respin: false },
        ],
        randomize: true,
        difficulty: 2,
    },
    'Mystery Wheel': {
        segments: [
            { trigger: 'com0', text: '???', command: '/echo Something strange happens...', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Gain Item', command: '/echo You gain a random item!', size: 'fraction', respin: false },
            { trigger: 'com2', text: 'Lose Item', command: '/echo An item vanishes!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Teleport', command: '/echo Reality shifts around you!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Nothing', command: '/echo The mystery remains...', size: 'halfseg', respin: false },
            { trigger: 'com5', text: 'Respin', command: '/echo Fate intervenes!', size: 'doubleseg', respin: true },
        ],
        randomize: true,
        difficulty: 2,
    },
    'Tech Lottery': {
        segments: [
            { trigger: 'com0', text: 'System Bonus', command: '/echo System grants bonus credits!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Malfunction', command: '/echo System error! Item lost!', size: 'fraction', respin: false },
            { trigger: 'com2', text: 'Reboot', command: '/echo System rebooting...', size: 'fraction', respin: true },
            { trigger: 'com3', text: 'Data Key', command: '/echo Access key downloaded!', size: 'doubleseg', respin: false },
            { trigger: 'com4', text: 'Virus', command: '/echo Virus detected! Strike drained!', size: 'halfseg', respin: false },
            { trigger: 'com5', text: 'Jackpot', command: '/echo JACKPOT PROTOCOL ACTIVATED!', size: 'halfseg', respin: false },
        ],
        randomize: true,
        difficulty: 2,
    },
    // === PUNISHING WHEELS (hostile NPCs) ===
    'Cursed Wheel': {
        segments: [
            { trigger: 'com0', text: 'Lose Key', command: '/echo The curse claims your key!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Lose Strike', command: '/echo Dark energy drains you!', size: 'doubleseg', respin: false },
            { trigger: 'com2', text: 'Lose Stealth', command: '/echo Shadows betray you!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Nothing', command: '/echo You escape the curse... barely.', size: 'fraction', respin: false },
            { trigger: 'com4', text: 'Cursed Spin', command: '/echo The wheel demands another spin!', size: 'halfseg', respin: true },
            { trigger: 'com5', text: 'RARE: Blessing', command: '/echo Against all odds, a blessing!', size: 'halfseg', respin: false },
        ],
        randomize: true,
        difficulty: 3,
    },
    'Trap Wheel': {
        segments: [
            { trigger: 'com0', text: 'Spike Trap', command: '/echo Spikes shoot up! Lose 1 STRIKE!', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Poison Gas', command: '/echo Gas fills the room! Lose 1 Stealth!', size: 'fraction', respin: false },
            { trigger: 'com2', text: 'Lock Trap', command: '/echo Your key breaks! Lose 1 Key!', size: 'fraction', respin: false },
            { trigger: 'com3', text: 'Escape!', command: '/echo You dodge the trap!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Double Trap', command: '/echo Two traps trigger!', size: 'halfseg', respin: false },
            { trigger: 'com5', text: 'Trapped Again', command: '/echo Another trap awaits!', size: 'doubleseg', respin: true },
        ],
        randomize: true,
        difficulty: 3,
    },
    'Dark Bargain': {
        segments: [
            { trigger: 'com0', text: 'Sacrifice Key', command: '/echo Your key dissolves...', size: 'doubleseg', respin: false },
            { trigger: 'com1', text: 'Sacrifice Strike', command: '/echo Your power drains away...', size: 'fraction', respin: false },
            { trigger: 'com2', text: 'Sacrifice All', command: '/echo Everything fades...', size: 'halfseg', respin: false },
            { trigger: 'com3', text: 'EXECUTE!', command: '/echo The bargain pays off! EXECUTE!', size: 'halfseg', respin: false },
            { trigger: 'com4', text: 'Nothing', command: '/echo The darkness waits...', size: 'doubleseg', respin: false },
            { trigger: 'com5', text: 'Try Again', command: '/echo The darkness offers again...', size: 'fraction', respin: true },
        ],
        randomize: true,
        difficulty: 4,
    },
};

const DEFAULT_BATTLEBAR_PROFILES = {
    // Tutorial/Easy - very forgiving, basic drops
    'Training Dummy': {
        difficulty: 2,  // 1-10 scale: 2 = very easy
        hitsToWin: 2,
        missesToLose: 5,
        damage: 15,  // HP damage on loss (before maze multiplier)
        description: 'A simple training target - perfect for learning combat basics.',
        hitCommand: '/echo Nice hit! You\'re getting the hang of it!',
        missCommand: '/echo Missed! Try again, no rush.',
        winCommand: '/echo Training complete! You\'re ready for real combat.',
        loseCommand: '/echo Don\'t worry, practice makes perfect!',
        mainTitle: 'Training Dummy',
        images: [],
        // Core drops
        keyDropChance: 30, strikeDropChance: 15, stealthDropChance: 5, executeDropChance: 0,
        // Special drops (very low for easy enemies)
        floorKeyDropChance: 2, portalStoneDropChance: 1, minionBaneDropChance: 1,
        mapFragmentDropChance: 5, timeShardDropChance: 0, voidWalkDropChance: 0,
    },
    // Fantasy themed - moderate
    'Dungeon Guardian': {
        difficulty: 4,  // 1-10 scale: 4 = easy-moderate
        hitsToWin: 3,
        missesToLose: 4,
        damage: 20,
        description: 'A stalwart guardian blocks your path through the dungeon.',
        hitCommand: '/echo Your blade finds its mark!',
        missCommand: '/echo The guardian deflects your attack!',
        winCommand: '/echo The guardian falls! The way is clear.',
        loseCommand: '/echo The guardian has bested you...',
        mainTitle: 'Dungeon Guardian',
        images: [],
        keyDropChance: 40, strikeDropChance: 20, stealthDropChance: 10, executeDropChance: 1,
        floorKeyDropChance: 4, portalStoneDropChance: 2, minionBaneDropChance: 3,
        mapFragmentDropChance: 8, timeShardDropChance: 1, voidWalkDropChance: 0,
    },
    // Fantasy themed - harder
    'Knight\'s Challenge': {
        difficulty: 5,  // 1-10 scale: 5 = moderate
        hitsToWin: 4,
        missesToLose: 3,
        damage: 25,
        description: 'An armored knight demands honorable combat. Steel clashes against steel.',
        hitCommand: '/echo A solid blow! The knight staggers!',
        missCommand: '/echo The knight parries with practiced ease!',
        winCommand: '/echo The knight yields! Honor is satisfied.',
        loseCommand: '/echo The knight proves the superior warrior...',
        mainTitle: 'Dark Knight',
        images: [],
        keyDropChance: 50, strikeDropChance: 25, stealthDropChance: 15, executeDropChance: 2,
        floorKeyDropChance: 6, portalStoneDropChance: 4, minionBaneDropChance: 5,
        mapFragmentDropChance: 10, timeShardDropChance: 2, voidWalkDropChance: 1,
    },
    // Horror themed - balanced tension
    'Horror Encounter': {
        difficulty: 5,  // 1-10 scale: 5 = moderate
        hitsToWin: 3,
        missesToLose: 3,
        damage: 25,
        description: 'Something unspeakable lurches from the shadows. Fight or be consumed!',
        hitCommand: '/echo The creature screeches in pain!',
        missCommand: '/echo It\'s too fast! Your attack goes wide!',
        winCommand: '/echo The horror dissipates into mist...',
        loseCommand: '/echo The darkness claims another victim...',
        mainTitle: 'The Horror',
        images: [],
        keyDropChance: 35, strikeDropChance: 25, stealthDropChance: 20, executeDropChance: 2,
        floorKeyDropChance: 5, portalStoneDropChance: 4, minionBaneDropChance: 6,
        mapFragmentDropChance: 8, timeShardDropChance: 3, voidWalkDropChance: 2,
    },
    // Horror themed - brutal, high rewards
    'Nightmare Battle': {
        difficulty: 7,  // 1-10 scale: 7 = hard
        hitsToWin: 4,
        missesToLose: 2,
        damage: 35,
        description: 'A manifestation of pure terror. One wrong move could be your last.',
        hitCommand: '/echo You strike at the nightmare\'s core!',
        missCommand: '/echo The nightmare\'s form shifts! Impossible to hit!',
        winCommand: '/echo The nightmare shatters! Dawn breaks through.',
        loseCommand: '/echo You are lost in eternal darkness...',
        mainTitle: 'Nightmare',
        images: [],
        keyDropChance: 55, strikeDropChance: 35, stealthDropChance: 25, executeDropChance: 4,
        floorKeyDropChance: 8, portalStoneDropChance: 6, minionBaneDropChance: 7,
        mapFragmentDropChance: 12, timeShardDropChance: 4, voidWalkDropChance: 2,
    },
    // Sci-fi themed - moderate
    'Security Drone': {
        difficulty: 4,  // 1-10 scale: 4 = easy-moderate
        hitsToWin: 3,
        missesToLose: 4,
        damage: 20,
        description: 'Automated security has detected an intruder. Disable it before the alarm triggers.',
        hitCommand: '/echo Direct hit! Sparks fly!',
        missCommand: '/echo The drone evades with precise thrusters!',
        winCommand: '/echo System offline. Security bypassed.',
        loseCommand: '/echo ALERT: Intruder neutralized.',
        mainTitle: 'SEC-BOT',
        images: [],
        keyDropChance: 40, strikeDropChance: 20, stealthDropChance: 15, executeDropChance: 1,
        floorKeyDropChance: 5, portalStoneDropChance: 3, minionBaneDropChance: 4,
        mapFragmentDropChance: 10, timeShardDropChance: 2, voidWalkDropChance: 1,
    },
    // Sci-fi themed - hard, great rewards
    'System Override': {
        difficulty: 7,  // 1-10 scale: 7 = hard
        hitsToWin: 5,
        missesToLose: 3,
        damage: 35,
        description: 'The mainframe AI has activated combat protocols. Override or be terminated.',
        hitCommand: '/echo Firewall breached! Keep attacking!',
        missCommand: '/echo ACCESS DENIED. Countermeasures deployed.',
        winCommand: '/echo SYSTEM OVERRIDE COMPLETE. Full access granted.',
        loseCommand: '/echo USER TERMINATED. Memory wiped.',
        mainTitle: 'MAINFRAME',
        images: [],
        keyDropChance: 60, strikeDropChance: 40, stealthDropChance: 25, executeDropChance: 5,
        floorKeyDropChance: 10, portalStoneDropChance: 8, minionBaneDropChance: 6,
        mapFragmentDropChance: 15, timeShardDropChance: 5, voidWalkDropChance: 3,
    },
    // Cyberpunk/Action themed
    'Street Fight': {
        difficulty: 5,  // 1-10 scale: 5 = moderate
        hitsToWin: 4,
        missesToLose: 3,
        damage: 25,
        description: 'Fists and chrome clash in the neon-lit alley. No rules, no mercy.',
        hitCommand: '/echo That\'s gonna leave a mark!',
        missCommand: '/echo They\'re fast - street smart!',
        winCommand: '/echo They hit the ground. You walk away.',
        loseCommand: '/echo Concrete meets face. Lights out.',
        mainTitle: 'Street Thug',
        images: [],
        keyDropChance: 45, strikeDropChance: 25, stealthDropChance: 15, executeDropChance: 2,
        floorKeyDropChance: 5, portalStoneDropChance: 4, minionBaneDropChance: 5,
        mapFragmentDropChance: 10, timeShardDropChance: 2, voidWalkDropChance: 1,
    },
    // Western themed
    'Showdown': {
        difficulty: 5,  // 1-10 scale: 5 = moderate
        hitsToWin: 3,
        missesToLose: 3,
        damage: 25,
        description: 'High noon. One chance. Draw!',
        hitCommand: '/echo Quick draw! Right on target!',
        missCommand: '/echo Dust in your eyes! Shot goes wide!',
        winCommand: '/echo They fall. There\'s a new fastest gun in town.',
        loseCommand: '/echo Not fast enough, partner...',
        mainTitle: 'Outlaw',
        images: [],
        keyDropChance: 45, strikeDropChance: 30, stealthDropChance: 10, executeDropChance: 2,
        floorKeyDropChance: 6, portalStoneDropChance: 3, minionBaneDropChance: 4,
        mapFragmentDropChance: 12, timeShardDropChance: 2, voidWalkDropChance: 1,
    },
    // Elite/Boss tier - very hard, best rewards
    'Elite Combat': {
        difficulty: 9,  // 1-10 scale: 9 = very hard
        hitsToWin: 5,
        missesToLose: 2,
        damage: 40,
        description: 'The elite of the elite. Every move must be perfect. There are no second chances.',
        hitCommand: '/echo Perfect strike! They\'re vulnerable!',
        missCommand: '/echo Countered! They\'re impossibly fast!',
        winCommand: '/echo Against all odds... victory is yours.',
        loseCommand: '/echo Outmatched. Outplayed. Eliminated.',
        mainTitle: 'Elite Operative',
        images: [],
        keyDropChance: 65, strikeDropChance: 45, stealthDropChance: 30, executeDropChance: 8,
        floorKeyDropChance: 12, portalStoneDropChance: 10, minionBaneDropChance: 8,
        mapFragmentDropChance: 18, timeShardDropChance: 6, voidWalkDropChance: 4,
    },
};

// =============================================================================
// DEFAULT TURN-BASED COMBAT PROFILES
// =============================================================================

const DEFAULT_TURNBASED_PROFILES = {
    'Training Bout': {
        difficulty: 2,
        playerHP: 100,
        enemyHP: 50,
        playerAttack: 15,
        playerDefense: 5,
        enemyAttack: 8,
        enemyDefense: 2,
        turnOrder: 'player_first',
        fleeChance: 80,
        critChance: 15,
        critMultiplier: 1.5,
        damage: 15,
        description: 'A practice fight against a training dummy. Perfect for learning the combat system.',
        mainTitle: 'Training Bout',
        enemyName: 'Training Dummy',
        // STScript hooks
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/echo You defeated the training dummy!',
        onLose: '/echo The training dummy got the better of you...',
        // Drop chances
        keyDropChance: 30, strikeDropChance: 15, stealthDropChance: 10, executeDropChance: 2,
        healingPotionDropChance: 25, greaterHealingDropChance: 5, elixirDropChance: 1, revivalCharmDropChance: 0,
    },
    'Dungeon Skirmish': {
        difficulty: 5,
        playerHP: 100,
        enemyHP: 80,
        playerAttack: 18,
        playerDefense: 6,
        enemyAttack: 14,
        enemyDefense: 4,
        turnOrder: 'player_first',
        fleeChance: 50,
        critChance: 12,
        critMultiplier: 2.0,
        damage: 25,
        description: 'A standard dungeon encounter. Trade blows wisely and watch your health.',
        mainTitle: 'Dungeon Skirmish',
        enemyName: 'Dungeon Creature',
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/echo Victory! The creature falls!',
        onLose: '/echo You were overwhelmed by the creature...',
        keyDropChance: 40, strikeDropChance: 20, stealthDropChance: 12, executeDropChance: 4,
        healingPotionDropChance: 20, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 1,
    },
    'Knight\'s Duel': {
        difficulty: 6,
        playerHP: 100,
        enemyHP: 100,
        playerAttack: 20,
        playerDefense: 8,
        enemyAttack: 18,
        enemyDefense: 10,
        turnOrder: 'player_first',
        fleeChance: 30,
        critChance: 10,
        critMultiplier: 2.0,
        damage: 30,
        description: 'An honorable duel against a skilled knight. Defense is key to survival.',
        mainTitle: 'Knight\'s Duel',
        enemyName: 'Armored Knight',
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/echo The knight yields! Honor is satisfied.',
        onLose: '/echo Defeated in honorable combat...',
        keyDropChance: 50, strikeDropChance: 25, stealthDropChance: 15, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 3, revivalCharmDropChance: 2,
    },
    'Boss Battle': {
        difficulty: 8,
        playerHP: 100,
        enemyHP: 150,
        playerAttack: 22,
        playerDefense: 8,
        enemyAttack: 25,
        enemyDefense: 12,
        turnOrder: 'enemy_first',
        fleeChance: 10,
        critChance: 15,
        critMultiplier: 2.5,
        damage: 40,
        description: 'A fearsome boss blocks your path. This will be a battle for survival.',
        mainTitle: 'Boss Battle',
        enemyName: 'Dungeon Boss',
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/echo The boss is defeated! Glory is yours!',
        onLose: '/echo The boss proved too powerful...',
        keyDropChance: 60, strikeDropChance: 35, stealthDropChance: 20, executeDropChance: 8,
        healingPotionDropChance: 30, greaterHealingDropChance: 18, elixirDropChance: 5, revivalCharmDropChance: 3,
    },
    'Nightmare Encounter': {
        difficulty: 10,
        playerHP: 100,
        enemyHP: 200,
        playerAttack: 25,
        playerDefense: 10,
        enemyAttack: 35,
        enemyDefense: 15,
        turnOrder: 'enemy_first',
        fleeChance: 0,
        critChance: 20,
        critMultiplier: 3.0,
        damage: 50,
        description: 'A nightmare made flesh. There is no escape. Only victory or death.',
        mainTitle: 'Nightmare Encounter',
        enemyName: 'Nightmare Entity',
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/echo Against impossible odds, you have prevailed!',
        onLose: '/echo The nightmare consumes you...',
        keyDropChance: 70, strikeDropChance: 45, stealthDropChance: 30, executeDropChance: 12,
        healingPotionDropChance: 35, greaterHealingDropChance: 25, elixirDropChance: 10, revivalCharmDropChance: 5,
    },
    // ===== MINION-THEMED COMBAT PROFILES =====
    'Skeleton Warrior': {
        difficulty: 4,
        playerHP: 100,
        enemyHP: 60,
        playerAttack: 16,
        playerDefense: 5,
        enemyAttack: 12,
        enemyDefense: 3,
        turnOrder: 'player_first',
        fleeChance: 60,
        critChance: 10,
        critMultiplier: 1.5,
        damage: 18,
        description: 'A rattling skeleton rises from the shadows, rusted blade in hand.',
        mainTitle: 'Skeleton Warrior',
        enemyName: 'Skeleton Warrior',
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/echo The skeleton crumbles into a pile of bones!',
        onLose: '/echo The skeleton adds your bones to its collection...',
        keyDropChance: 35, strikeDropChance: 18, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 20, greaterHealingDropChance: 6, elixirDropChance: 1, revivalCharmDropChance: 0,
    },
    'Goblin Ambush': {
        difficulty: 3,
        playerHP: 100,
        enemyHP: 45,
        playerAttack: 14,
        playerDefense: 4,
        enemyAttack: 10,
        enemyDefense: 2,
        turnOrder: 'enemy_first',
        fleeChance: 70,
        critChance: 18,
        critMultiplier: 1.8,
        damage: 15,
        description: 'A sneaky goblin leaps from the shadows with a rusty dagger!',
        mainTitle: 'Goblin Ambush',
        enemyName: 'Goblin Ambusher',
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/echo The goblin squeals and flees into the darkness!',
        onLose: '/echo The goblin cackles as you fall...',
        keyDropChance: 30, strikeDropChance: 15, stealthDropChance: 20, executeDropChance: 2,
        healingPotionDropChance: 18, greaterHealingDropChance: 4, elixirDropChance: 1, revivalCharmDropChance: 0,
    },
    'Dragon Whelp': {
        difficulty: 6,
        playerHP: 100,
        enemyHP: 90,
        playerAttack: 18,
        playerDefense: 6,
        enemyAttack: 20,
        enemyDefense: 8,
        turnOrder: 'random',
        fleeChance: 40,
        critChance: 15,
        critMultiplier: 2.0,
        damage: 28,
        description: 'A young dragon hatchling with scales as hard as steel and breath of flame.',
        mainTitle: 'Dragon Whelp',
        enemyName: 'Dragon Whelp',
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/echo The dragon whelp retreats, screeching in defeat!',
        onLose: '/echo Dragon fire engulfs you...',
        keyDropChance: 45, strikeDropChance: 25, stealthDropChance: 15, executeDropChance: 6,
        healingPotionDropChance: 25, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 2,
    },
    'Vampire Lord': {
        difficulty: 8,
        playerHP: 100,
        enemyHP: 120,
        playerAttack: 20,
        playerDefense: 7,
        enemyAttack: 22,
        enemyDefense: 10,
        turnOrder: 'enemy_first',
        fleeChance: 20,
        critChance: 20,
        critMultiplier: 2.5,
        damage: 35,
        description: 'An ancient vampire with pale skin and crimson eyes emerges from the shadows.',
        mainTitle: 'Vampire Lord',
        enemyName: 'Vampire Lord',
        onTurnStart: '',
        onAttack: '',
        onDefend: '',
        onItem: '',
        onFlee: '',
        onPlayerHit: '',
        onEnemyHit: '',
        onWin: '/echo The vampire lord dissolves into mist, defeated!',
        onLose: '/echo The vampire drains your life essence...',
        keyDropChance: 55, strikeDropChance: 30, stealthDropChance: 20, executeDropChance: 10,
        healingPotionDropChance: 28, greaterHealingDropChance: 15, elixirDropChance: 6, revivalCharmDropChance: 3,
    },
};

// =============================================================================
// DEFAULT QTE PROFILES
// =============================================================================
const DEFAULT_QTE_PROFILES = {
    'Reaction Test': {
        difficulty: 2,
        sequenceLengthMin: 3,
        sequenceLengthMax: 5,
        timeWindowBase: 1500,  // ms per prompt
        timeWindowMin: 800,    // minimum after difficulty scaling
        difficultyScaling: 0.9, // time multiplier per successful prompt
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE'],
        displayStyle: 'single', // 'single' key at a time
        damage: 10,
        comboEnabled: true,
        perfectWindowPercent: 30, // % of time window for "Perfect" bonus
        description: 'A simple reaction test. Press SPACE when prompted!',
        mainTitle: 'Reaction Test',
        // STScript hooks
        onStart: '',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '',
        onMiss: '',
        onComplete: '/echo Quick reflexes!',
        onFail: '/echo Too slow...',
        // Drop chances (for maze integration)
        keyDropChance: 20, strikeDropChance: 10, stealthDropChance: 5, executeDropChance: 1,
        healingPotionDropChance: 15, greaterHealingDropChance: 3, elixirDropChance: 0, revivalCharmDropChance: 0,
    },
    'Quick Dodge': {
        difficulty: 4,
        sequenceLengthMin: 4,
        sequenceLengthMax: 6,
        timeWindowBase: 1200,
        timeWindowMin: 600,
        difficultyScaling: 0.85,
        allowedKeys: ['W', 'A', 'S', 'D'],
        displayStyle: 'single',
        damage: 20,
        comboEnabled: true,
        perfectWindowPercent: 25,
        description: 'Dodge incoming attacks! Use WASD to evade in the right direction.',
        mainTitle: 'Quick Dodge',
        onStart: '',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '',
        onMiss: '',
        onComplete: '/echo Dodged them all!',
        onFail: '/echo You took a hit!',
        keyDropChance: 30, strikeDropChance: 15, stealthDropChance: 10, executeDropChance: 2,
        healingPotionDropChance: 18, greaterHealingDropChance: 6, elixirDropChance: 1, revivalCharmDropChance: 0,
    },
    'Combat Flurry': {
        difficulty: 6,
        sequenceLengthMin: 6,
        sequenceLengthMax: 9,
        timeWindowBase: 1000,
        timeWindowMin: 500,
        difficultyScaling: 0.88,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE'],
        displayStyle: 'single',
        damage: 30,
        comboEnabled: true,
        perfectWindowPercent: 22,
        description: 'A flurry of attacks! Keep up with the rapid sequence to land your combo.',
        mainTitle: 'Combat Flurry',
        onStart: '',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '',
        onMiss: '',
        onComplete: '/echo Devastating combo!',
        onFail: '/echo Your attack was interrupted!',
        keyDropChance: 40, strikeDropChance: 22, stealthDropChance: 15, executeDropChance: 4,
        healingPotionDropChance: 20, greaterHealingDropChance: 10, elixirDropChance: 2, revivalCharmDropChance: 1,
    },
    'Boss Sequence': {
        difficulty: 8,
        sequenceLengthMin: 8,
        sequenceLengthMax: 12,
        timeWindowBase: 900,
        timeWindowMin: 400,
        difficultyScaling: 0.85,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E'],
        displayStyle: 'single',
        damage: 45,
        comboEnabled: true,
        perfectWindowPercent: 20,
        description: 'The boss unleashes a deadly sequence. Match the pattern perfectly to survive!',
        mainTitle: 'Boss Sequence',
        onStart: '',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '',
        onMiss: '',
        onComplete: '/echo You weathered the storm!',
        onFail: '/echo The boss overwhelms you!',
        keyDropChance: 55, strikeDropChance: 30, stealthDropChance: 20, executeDropChance: 7,
        healingPotionDropChance: 25, greaterHealingDropChance: 15, elixirDropChance: 4, revivalCharmDropChance: 2,
    },
    'Deadly Dance': {
        difficulty: 10,
        sequenceLengthMin: 10,
        sequenceLengthMax: 15,
        timeWindowBase: 800,
        timeWindowMin: 350,
        difficultyScaling: 0.82,
        allowedKeys: ['W', 'A', 'S', 'D', 'SPACE', 'E', 'Q'],
        displayStyle: 'single',
        damage: 60,
        comboEnabled: true,
        perfectWindowPercent: 18,
        description: 'The ultimate test of reflexes. A deadly dance where one misstep means death.',
        mainTitle: 'Deadly Dance',
        onStart: '',
        onPrompt: '',
        onSuccess: '',
        onPerfect: '',
        onMiss: '',
        onComplete: '/echo Flawless execution!',
        onFail: '/echo The dance claims another victim...',
        keyDropChance: 65, strikeDropChance: 40, stealthDropChance: 28, executeDropChance: 10,
        healingPotionDropChance: 30, greaterHealingDropChance: 20, elixirDropChance: 8, revivalCharmDropChance: 4,
    },
};

// =============================================================================
// DEFAULT DICE COMBAT PROFILES
// =============================================================================
const DEFAULT_DICE_PROFILES = {
    'Lucky Roll': {
        difficulty: 2,
        diceType: 'd6',           // d4, d6, d8, d10, d12, d20, d100
        diceCount: 2,             // Number of dice to roll
        threshold: 7,             // Target number to beat
        thresholdType: 'meet',    // 'meet' (>=) or 'beat' (>)
        modifier: 0,              // Bonus/penalty to roll
        criticalSuccess: 12,      // Roll this or higher = critical
        criticalFail: 2,          // Roll this or lower = critical fail
        rerollsAllowed: 1,        // Number of rerolls allowed
        rerollCost: 'none',       // 'none', 'strike', 'key'
        damage: 10,               // HP damage on failure
        description: 'A simple luck test. Roll 2d6 and try to get 7 or higher!',
        mainTitle: 'Lucky Roll',
        rollLabel: 'Roll for Luck',
        // STScript hooks
        onStart: '',
        onRoll: '',
        onCriticalSuccess: '',
        onCriticalFail: '',
        onSuccess: '',
        onFail: '',
        onReroll: '',
        onComplete: '/echo Fortune smiles upon you!',
        onLose: '/echo Luck was not on your side...',
        // Drop chances
        keyDropChance: 25, strikeDropChance: 12, stealthDropChance: 8, executeDropChance: 1,
        healingPotionDropChance: 18, greaterHealingDropChance: 5, elixirDropChance: 1, revivalCharmDropChance: 0,
    },
    'Skill Check': {
        difficulty: 4,
        diceType: 'd20',
        diceCount: 1,
        threshold: 12,
        thresholdType: 'meet',
        modifier: 2,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 0,
        rerollCost: 'none',
        damage: 20,
        description: 'Roll a d20 skill check. You have a +2 modifier. Need 12 or higher to succeed.',
        mainTitle: 'Skill Check',
        rollLabel: 'Make Skill Check',
        onStart: '',
        onRoll: '',
        onCriticalSuccess: '/echo Natural 20! Critical success!',
        onCriticalFail: '/echo Natural 1! Critical failure!',
        onSuccess: '',
        onFail: '',
        onReroll: '',
        onComplete: '/echo You passed the skill check!',
        onLose: '/echo You failed the skill check...',
        keyDropChance: 35, strikeDropChance: 18, stealthDropChance: 12, executeDropChance: 3,
        healingPotionDropChance: 20, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Saving Throw': {
        difficulty: 6,
        diceType: 'd20',
        diceCount: 1,
        threshold: 15,
        thresholdType: 'meet',
        modifier: 0,
        criticalSuccess: 20,
        criticalFail: 1,
        rerollsAllowed: 1,
        rerollCost: 'strike',
        damage: 30,
        description: 'A dangerous saving throw! Roll d20 and meet DC 15. Spend a Strike to reroll.',
        mainTitle: 'Saving Throw',
        rollLabel: 'Roll Save',
        onStart: '',
        onRoll: '',
        onCriticalSuccess: '/echo Natural 20! You shrug off the effect completely!',
        onCriticalFail: '/echo Natural 1! You suffer the full effect!',
        onSuccess: '',
        onFail: '',
        onReroll: '',
        onComplete: '/echo You made your saving throw!',
        onLose: '/echo You failed your saving throw...',
        keyDropChance: 45, strikeDropChance: 25, stealthDropChance: 15, executeDropChance: 5,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'High Stakes': {
        difficulty: 8,
        diceType: 'd10',
        diceCount: 3,
        threshold: 20,
        thresholdType: 'meet',
        modifier: -2,
        criticalSuccess: 28,
        criticalFail: 5,
        rerollsAllowed: 2,
        rerollCost: 'key',
        damage: 45,
        description: 'Roll 3d10 with a -2 penalty. You need 20 or higher. High risk, high reward!',
        mainTitle: 'High Stakes',
        rollLabel: 'Take the Risk',
        onStart: '',
        onRoll: '',
        onCriticalSuccess: '/echo Maximum luck! The odds were in your favor!',
        onCriticalFail: '/echo Snake eyes... things went very wrong.',
        onSuccess: '',
        onFail: '',
        onReroll: '',
        onComplete: '/echo The gamble paid off!',
        onLose: '/echo You lost the gamble...',
        keyDropChance: 55, strikeDropChance: 32, stealthDropChance: 20, executeDropChance: 8,
        healingPotionDropChance: 28, greaterHealingDropChance: 16, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Fate\'s Judgment': {
        difficulty: 10,
        diceType: 'd100',
        diceCount: 1,
        threshold: 75,
        thresholdType: 'beat',
        modifier: 0,
        criticalSuccess: 95,
        criticalFail: 5,
        rerollsAllowed: 0,
        rerollCost: 'none',
        damage: 60,
        description: 'Roll the percentile dice! You need to roll above 75. No rerolls - pure fate.',
        mainTitle: 'Fate\'s Judgment',
        rollLabel: 'Face Your Fate',
        onStart: '',
        onRoll: '',
        onCriticalSuccess: '/echo Destiny itself bows to you!',
        onCriticalFail: '/echo Fate has dealt a cruel hand...',
        onSuccess: '',
        onFail: '',
        onReroll: '',
        onComplete: '/echo Fate has judged you worthy!',
        onLose: '/echo Fate has judged you wanting...',
        keyDropChance: 70, strikeDropChance: 45, stealthDropChance: 30, executeDropChance: 12,
        healingPotionDropChance: 35, greaterHealingDropChance: 22, elixirDropChance: 10, revivalCharmDropChance: 5,
    },
};

// =============================================================================
// DEFAULT STEALTH ENCOUNTER PROFILES
// =============================================================================
const DEFAULT_STEALTH_PROFILES = {
    'Simple Sneak': {
        difficulty: 2,
        sectionsToPass: 3,        // Number of sections to sneak through
        detectionThreshold: 100,  // Max detection before caught
        baseDetectionRate: 15,    // Detection gained per failed action
        advanceSuccessChance: 70, // % chance to advance without detection
        hideRecovery: 25,         // Detection reduced when hiding
        distractSuccessChance: 60,// % chance distract works
        distractReduction: 40,    // Detection reduced on successful distract
        waitRecovery: 15,         // Detection reduced when waiting
        damage: 15,               // HP damage if caught
        description: 'Sneak past a single guard. Take your time and stay hidden.',
        mainTitle: 'Simple Sneak',
        guardName: 'Guard',
        // STScript hooks
        onStart: '',
        onAdvance: '',
        onHide: '',
        onDistract: '',
        onWait: '',
        onDetectionIncrease: '',
        onComplete: '/echo You slipped past unnoticed!',
        onCaught: '/echo You\'ve been spotted!',
        // Drop chances
        keyDropChance: 20, strikeDropChance: 10, stealthDropChance: 15, executeDropChance: 2,
        healingPotionDropChance: 15, greaterHealingDropChance: 5, elixirDropChance: 1, revivalCharmDropChance: 0,
    },
    'Guard Patrol': {
        difficulty: 4,
        sectionsToPass: 4,
        detectionThreshold: 100,
        baseDetectionRate: 20,
        advanceSuccessChance: 55,
        hideRecovery: 20,
        distractSuccessChance: 50,
        distractReduction: 35,
        waitRecovery: 12,
        damage: 25,
        description: 'Navigate through a patrol route. Time your movements carefully.',
        mainTitle: 'Guard Patrol',
        guardName: 'Patrol',
        onStart: '',
        onAdvance: '',
        onHide: '',
        onDistract: '',
        onWait: '',
        onDetectionIncrease: '',
        onComplete: '/echo The patrol passed without seeing you!',
        onCaught: '/echo The patrol has spotted you!',
        keyDropChance: 30, strikeDropChance: 18, stealthDropChance: 22, executeDropChance: 4,
        healingPotionDropChance: 18, greaterHealingDropChance: 8, elixirDropChance: 2, revivalCharmDropChance: 0,
    },
    'Watchful Sentry': {
        difficulty: 6,
        sectionsToPass: 5,
        detectionThreshold: 80,
        baseDetectionRate: 25,
        advanceSuccessChance: 45,
        hideRecovery: 18,
        distractSuccessChance: 45,
        distractReduction: 30,
        waitRecovery: 10,
        damage: 35,
        description: 'A vigilant sentry blocks your path. One wrong move and you\'re caught.',
        mainTitle: 'Watchful Sentry',
        guardName: 'Sentry',
        onStart: '',
        onAdvance: '',
        onHide: '',
        onDistract: '',
        onWait: '',
        onDetectionIncrease: '',
        onComplete: '/echo The sentry never knew you were there!',
        onCaught: '/echo The sentry raises the alarm!',
        keyDropChance: 40, strikeDropChance: 25, stealthDropChance: 28, executeDropChance: 6,
        healingPotionDropChance: 22, greaterHealingDropChance: 12, elixirDropChance: 4, revivalCharmDropChance: 1,
    },
    'Shadow Run': {
        difficulty: 8,
        sectionsToPass: 6,
        detectionThreshold: 70,
        baseDetectionRate: 30,
        advanceSuccessChance: 40,
        hideRecovery: 15,
        distractSuccessChance: 40,
        distractReduction: 25,
        waitRecovery: 8,
        damage: 50,
        description: 'Multiple guards patrol the area. Use every trick to stay unseen.',
        mainTitle: 'Shadow Run',
        guardName: 'Guards',
        onStart: '',
        onAdvance: '',
        onHide: '',
        onDistract: '',
        onWait: '',
        onDetectionIncrease: '',
        onComplete: '/echo Like a shadow, you vanish into the night!',
        onCaught: '/echo Multiple guards converge on your position!',
        keyDropChance: 55, strikeDropChance: 32, stealthDropChance: 35, executeDropChance: 9,
        healingPotionDropChance: 28, greaterHealingDropChance: 16, elixirDropChance: 6, revivalCharmDropChance: 2,
    },
    'Impossible Infiltration': {
        difficulty: 10,
        sectionsToPass: 8,
        detectionThreshold: 60,
        baseDetectionRate: 35,
        advanceSuccessChance: 35,
        hideRecovery: 12,
        distractSuccessChance: 35,
        distractReduction: 20,
        waitRecovery: 5,
        damage: 70,
        description: 'Elite guards, magical wards, and traps. Only a master infiltrator can succeed.',
        mainTitle: 'Impossible Infiltration',
        guardName: 'Elite Guards',
        onStart: '',
        onAdvance: '',
        onHide: '',
        onDistract: '',
        onWait: '',
        onDetectionIncrease: '',
        onComplete: '/echo Against impossible odds, you infiltrated successfully!',
        onCaught: '/echo The elite guards capture you instantly!',
        keyDropChance: 70, strikeDropChance: 45, stealthDropChance: 50, executeDropChance: 15,
        healingPotionDropChance: 35, greaterHealingDropChance: 22, elixirDropChance: 10, revivalCharmDropChance: 5,
    },
};

// =========================================================================
// DEFAULT PUZZLE PROFILES
// =========================================================================
const DEFAULT_PUZZLE_PROFILES = {
    'Simple Riddle': {
        difficulty: 2,
        puzzleType: 'sequence', // sequence, memory, pattern, logic
        gridSize: 3, // 3x3 grid
        sequenceLength: 4,
        timeLimit: 60, // seconds, 0 = no limit
        hintsAllowed: 3,
        hintPenalty: 10, // score penalty per hint
        wrongGuessPenalty: 1, // wrong guesses before fail
        wrongGuessesAllowed: 5,
        damage: 10,
        description: 'A simple puzzle to warm up your mind.',
        mainTitle: 'Simple Riddle',
        successMessage: 'You solved it!',
        failMessage: 'The puzzle defeats you...',
        onStart: '',
        onHint: '',
        onCorrectMove: '',
        onWrongMove: '',
        onComplete: '/echo You solved the simple riddle!',
        onFail: '/mazedamage amount=10 | /echo The puzzle was too complex...',
        keyDropChance: 15, strikeDropChance: 10, stealthDropChance: 8, executeDropChance: 2,
        healingPotionDropChance: 12, greaterHealingDropChance: 5, elixirDropChance: 1, revivalCharmDropChance: 0,
    },
    'Memory Trial': {
        difficulty: 4,
        puzzleType: 'memory',
        gridSize: 4, // 4x4 grid
        sequenceLength: 6,
        timeLimit: 90,
        hintsAllowed: 2,
        hintPenalty: 15,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 4,
        damage: 20,
        description: 'Remember the pattern before it fades away.',
        mainTitle: 'Memory Trial',
        successMessage: 'Your memory serves you well!',
        failMessage: 'The pattern slips from your mind...',
        onStart: '',
        onHint: '',
        onCorrectMove: '',
        onWrongMove: '',
        onComplete: '/echo Your memory is sharp as a blade!',
        onFail: '/mazedamage amount=15 | /echo You couldn\'t remember the sequence...',
        keyDropChance: 25, strikeDropChance: 18, stealthDropChance: 15, executeDropChance: 4,
        healingPotionDropChance: 18, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Pattern Maze': {
        difficulty: 6,
        puzzleType: 'pattern',
        gridSize: 5, // 5x5 grid
        sequenceLength: 8,
        timeLimit: 120,
        hintsAllowed: 2,
        hintPenalty: 20,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 3,
        damage: 35,
        description: 'Find the hidden pattern within the chaos.',
        mainTitle: 'Pattern Maze',
        successMessage: 'The pattern reveals itself!',
        failMessage: 'Chaos consumes your thoughts...',
        onStart: '',
        onHint: '',
        onCorrectMove: '',
        onWrongMove: '',
        onComplete: '/echo You see the pattern in all things now!',
        onFail: '/mazedamage amount=20 | /echo The pattern was beyond your comprehension...',
        keyDropChance: 40, strikeDropChance: 25, stealthDropChance: 22, executeDropChance: 6,
        healingPotionDropChance: 22, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Logic Lock': {
        difficulty: 8,
        puzzleType: 'logic',
        gridSize: 5,
        sequenceLength: 10,
        timeLimit: 150,
        hintsAllowed: 1,
        hintPenalty: 25,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 2,
        damage: 50,
        description: 'A devious logic puzzle guards the way forward.',
        mainTitle: 'Logic Lock',
        successMessage: 'Logic prevails!',
        failMessage: 'Your reasoning fails you...',
        onStart: '',
        onHint: '',
        onCorrectMove: '',
        onWrongMove: '',
        onComplete: '/echo Your logical mind unlocked the way!',
        onFail: '/mazedamage amount=25 | /echo The logic was too twisted...',
        keyDropChance: 55, strikeDropChance: 35, stealthDropChance: 30, executeDropChance: 10,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 7, revivalCharmDropChance: 3,
    },
    'Mind Shatter': {
        difficulty: 10,
        puzzleType: 'sequence',
        gridSize: 6, // 6x6 grid
        sequenceLength: 12,
        timeLimit: 180,
        hintsAllowed: 0,
        hintPenalty: 0,
        wrongGuessPenalty: 1,
        wrongGuessesAllowed: 1,
        damage: 70,
        description: 'A puzzle so complex it threatens to shatter your very mind.',
        mainTitle: 'Mind Shatter',
        successMessage: 'Impossible! You solved it!',
        failMessage: 'Your mind shatters under the complexity...',
        onStart: '',
        onHint: '',
        onCorrectMove: '',
        onWrongMove: '',
        onComplete: '/echo Against all odds, your mind prevailed!',
        onFail: '/mazedamage amount=35 | /echo The puzzle was beyond mortal comprehension...',
        keyDropChance: 70, strikeDropChance: 45, stealthDropChance: 40, executeDropChance: 15,
        healingPotionDropChance: 35, greaterHealingDropChance: 22, elixirDropChance: 10, revivalCharmDropChance: 5,
    },
};

// =========================================================================
// DEFAULT NEGOTIATION PROFILES
// =========================================================================
const DEFAULT_NEGOTIATION_PROFILES = {
    'Friendly Chat': {
        difficulty: 2,
        startingFavor: 50,      // Starting disposition (0-100)
        favorThreshold: 75,     // Favor needed to succeed
        turnsAllowed: 6,        // Max turns before timeout
        persuadeBonus: 15,      // Base success for Persuade
        intimidateBonus: 10,    // Base success for Intimidate
        bribeBonus: 20,         // Base success for Bribe
        flattery: true,         // Allow Flatter action
        flatterBonus: 12,
        insult: false,          // Allow Insult action (risky)
        insultPenalty: 20,
        bribeCost: 'key',       // Item required for bribe
        damage: 10,
        description: 'A simple conversation to get what you want.',
        mainTitle: 'Friendly Chat',
        npcName: 'Stranger',
        successMessage: 'They agree to your request!',
        failMessage: 'They refuse to help you.',
        onStart: '',
        onPersuade: '',
        onIntimidate: '',
        onBribe: '',
        onFlatter: '',
        onInsult: '',
        onComplete: '/echo You convinced them successfully!',
        onFail: '/echo The negotiation failed...',
        keyDropChance: 15, strikeDropChance: 10, stealthDropChance: 8, executeDropChance: 2,
        healingPotionDropChance: 12, greaterHealingDropChance: 5, elixirDropChance: 1, revivalCharmDropChance: 0,
    },
    'Merchant Haggle': {
        difficulty: 4,
        startingFavor: 40,
        favorThreshold: 70,
        turnsAllowed: 5,
        persuadeBonus: 12,
        intimidateBonus: 8,
        bribeBonus: 25,
        flattery: true,
        flatterBonus: 10,
        insult: true,
        insultPenalty: 25,
        bribeCost: 'key',
        damage: 20,
        description: 'Haggle with a shrewd merchant for a better deal.',
        mainTitle: 'Merchant Haggle',
        npcName: 'Merchant',
        successMessage: 'The merchant agrees to your terms!',
        failMessage: 'No deal. The merchant stands firm.',
        onStart: '',
        onPersuade: '',
        onIntimidate: '',
        onBribe: '',
        onFlatter: '',
        onInsult: '',
        onComplete: '/echo A deal is struck in your favor!',
        onFail: '/echo The merchant refuses to budge...',
        keyDropChance: 25, strikeDropChance: 18, stealthDropChance: 15, executeDropChance: 4,
        healingPotionDropChance: 18, greaterHealingDropChance: 10, elixirDropChance: 3, revivalCharmDropChance: 1,
    },
    'Guard Bribery': {
        difficulty: 6,
        startingFavor: 30,
        favorThreshold: 65,
        turnsAllowed: 4,
        persuadeBonus: 8,
        intimidateBonus: 15,
        bribeBonus: 30,
        flattery: true,
        flatterBonus: 8,
        insult: true,
        insultPenalty: 30,
        bribeCost: 'strike',
        damage: 35,
        description: 'Convince a guard to look the other way.',
        mainTitle: 'Guard Bribery',
        npcName: 'Guard',
        successMessage: 'The guard pockets the bribe and looks away.',
        failMessage: 'The guard calls for reinforcements!',
        onStart: '',
        onPersuade: '',
        onIntimidate: '',
        onBribe: '',
        onFlatter: '',
        onInsult: '',
        onComplete: '/echo The guard lets you pass!',
        onFail: '/echo The guard sounds the alarm!',
        keyDropChance: 40, strikeDropChance: 25, stealthDropChance: 22, executeDropChance: 6,
        healingPotionDropChance: 22, greaterHealingDropChance: 14, elixirDropChance: 5, revivalCharmDropChance: 2,
    },
    'Noble Audience': {
        difficulty: 8,
        startingFavor: 25,
        favorThreshold: 80,
        turnsAllowed: 5,
        persuadeBonus: 10,
        intimidateBonus: 5,
        bribeBonus: 15,
        flattery: true,
        flatterBonus: 18,
        insult: true,
        insultPenalty: 35,
        bribeCost: 'execute',
        damage: 50,
        description: 'Seek favor from a haughty noble.',
        mainTitle: 'Noble Audience',
        npcName: 'Noble',
        successMessage: 'The noble grants your request with a wave.',
        failMessage: 'The noble dismisses you with contempt.',
        onStart: '',
        onPersuade: '',
        onIntimidate: '',
        onBribe: '',
        onFlatter: '',
        onInsult: '',
        onComplete: '/echo The noble smiles and grants your wish!',
        onFail: '/echo You have displeased the noble...',
        keyDropChance: 55, strikeDropChance: 35, stealthDropChance: 30, executeDropChance: 10,
        healingPotionDropChance: 28, greaterHealingDropChance: 18, elixirDropChance: 7, revivalCharmDropChance: 3,
    },
    'Dark Pact': {
        difficulty: 10,
        startingFavor: 15,
        favorThreshold: 85,
        turnsAllowed: 4,
        persuadeBonus: 8,
        intimidateBonus: 12,
        bribeBonus: 20,
        flattery: true,
        flatterBonus: 10,
        insult: true,
        insultPenalty: 40,
        bribeCost: 'execute',
        damage: 70,
        description: 'Negotiate with a malevolent entity. Choose your words carefully.',
        mainTitle: 'Dark Pact',
        npcName: 'Entity',
        successMessage: 'The entity agrees to your terms... for now.',
        failMessage: 'The entity laughs as it takes what it wants.',
        onStart: '',
        onPersuade: '',
        onIntimidate: '',
        onBribe: '',
        onFlatter: '',
        onInsult: '',
        onComplete: '/echo A dark bargain is struck!',
        onFail: '/echo The entity claims its due...',
        keyDropChance: 70, strikeDropChance: 45, stealthDropChance: 40, executeDropChance: 15,
        healingPotionDropChance: 35, greaterHealingDropChance: 22, elixirDropChance: 10, revivalCharmDropChance: 5,
    },
};

const EXTENSION_NAME = 'MazeMaster';

// Helper to resolve extension asset paths
function getExtensionImagePath(relativePath) {
    if (!relativePath) return '';

    // If it's an external URL, return as-is
    if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
        return relativePath;
    }

    // Check if this is an old-style absolute path to our extension's images
    // e.g., /scripts/extensions/third-party/MazeMaster/images/herald.jpeg
    // We need to extract the relative part and use the current folder name
    const extensionPathMatch = relativePath.match(/\/scripts\/extensions\/third-party\/[^/]+\/(.+)/);
    if (extensionPathMatch) {
        // Extract the relative path after the folder name
        const extractedRelativePath = extensionPathMatch[1];
        return `/scripts/extensions/third-party/${EXTENSION_FOLDER_NAME}/${extractedRelativePath}`;
    }

    // If it starts with /, assume it's some other absolute path and return as-is
    if (relativePath.startsWith('/')) {
        return relativePath;
    }

    // Use the dynamically detected folder name for the extension path
    // This works whether the extension is installed as 'MazeMaster' or 'SillyTavern-MazeMaster'
    return `/scripts/extensions/third-party/${EXTENSION_FOLDER_NAME}/${relativePath}`;
}

const DEFAULT_MINIONS = {
    // ===== FANTASY PACK =====
    'fantasy_herald': {
        name: 'The Herald',
        imagePath: '',
        type: 'messenger',
        description: 'A cloaked messenger who appears from the shadows with cryptic warnings about the dungeon ahead.',
        messages: ['Greetings, adventurer...', 'The maze master watches your every step...', 'Beware the darkness that lies ahead!', 'Many have entered. Few have returned.'],
        encounterScript: '',
    },
    'fantasy_guardian': {
        name: 'Dungeon Guardian',
        imagePath: '',
        type: 'battlebar',
        description: 'A stalwart armored warrior sworn to protect this passage from intruders.',
        battlebarProfiles: ['Dungeon Guardian', 'Knight\'s Challenge'],
        messages: ['None shall pass!', 'Prepare yourself, intruder!', 'Only the worthy may continue!'],
        encounterScript: '',
    },
    'fantasy_oracle': {
        name: 'The Oracle',
        imagePath: '',
        type: 'prizewheel',
        description: 'An ancient mystic with glowing eyes who offers to reveal your fate through a magical spinning wheel.',
        wheelProfiles: ['Blessing Wheel', 'Mystery Wheel'],
        messages: ['Spin the wheel of fate!', 'Let destiny reveal itself!', 'Fortune favors the bold...'],
        encounterScript: '',
    },
    'fantasy_merchant': {
        name: 'Wandering Merchant',
        imagePath: '',
        type: 'merchant',
        description: 'A shrewd trader draped in exotic fabrics who deals in magical wares.',
        merchantItemCount: { min: 2, max: 4 },
        merchantItemPool: 'Adventurer Supplies',
        messages: ['Rare goods for a rare adventurer!', 'A fair trade benefits us both.', 'Perhaps something catches your eye?'],
        encounterScript: '',
    },
    // ===== HORROR PACK =====
    'horror_spirit': {
        name: 'Whispering Spirit',
        imagePath: '',
        type: 'messenger',
        description: 'A translucent specter that whispers unsettling warnings from beyond the grave.',
        messages: ['You should not be here...', 'They are watching... always watching...', 'Turn back while you still can...', 'Join usssss...'],
        encounterScript: '',
    },
    'horror_revenant': {
        name: 'The Revenant',
        imagePath: '',
        type: 'battlebar',
        description: 'An undying horror that claws its way from the shadows to claim another victim.',
        battlebarProfiles: ['Horror Encounter', 'Nightmare Battle'],
        messages: ['Your soul... will be mine...', 'Death is only the beginning!', 'YOU CANNOT ESCAPE!'],
        encounterScript: '',
    },
    'horror_gambler': {
        name: 'Cursed Gambler',
        imagePath: '',
        type: 'prizewheel',
        description: 'A ghastly figure bound to an eternal game of chance. Win at your peril.',
        wheelProfiles: ['Cursed Wheel', 'Dark Bargain'],
        messages: ['Care to play a little game?', 'The stakes are... everything.', 'Fortune rarely favors the living here...'],
        encounterScript: '',
    },
    'horror_graverobber': {
        name: 'Graverobber',
        imagePath: '',
        type: 'merchant',
        description: 'A hunched figure who deals in items "liberated" from the dead. Don\'t ask where they came from.',
        merchantItemCount: { min: 2, max: 4 },
        merchantItemPool: 'Dark Market',
        messages: ['Fresh stock... freshly acquired...', 'The dead have no need for such things.', 'A trade? The living always want something...'],
        encounterScript: '',
    },
    // ===== SCI-FI PACK =====
    'scifi_ai': {
        name: 'AI Assistant',
        imagePath: '',
        type: 'messenger',
        description: 'A holographic interface that provides technical readouts and mission updates.',
        messages: ['ALERT: Hostile activity detected in adjacent sectors.', 'Scanning complete. Multiple life forms ahead.', 'Recommended route calculated. Proceed with caution.', 'Mission parameters updated.'],
        encounterScript: '',
    },
    'scifi_bot': {
        name: 'Security Bot',
        imagePath: '',
        type: 'battlebar',
        description: 'An automated defense unit programmed to eliminate all unauthorized personnel.',
        battlebarProfiles: ['Security Drone', 'System Override'],
        messages: ['HALT. IDENTIFICATION REQUIRED.', 'INTRUDER DETECTED. ENGAGING COMBAT PROTOCOLS.', 'RESISTANCE IS INEFFICIENT.'],
        encounterScript: '',
    },
    'scifi_matrix': {
        name: 'Probability Matrix',
        imagePath: '',
        type: 'prizewheel',
        description: 'A quantum randomization terminal that dispenses rewards based on probability algorithms.',
        wheelProfiles: ['Tech Lottery', 'Treasure Wheel'],
        messages: ['INITIATING PROBABILITY CASCADE...', 'QUANTUM OUTCOME GENERATOR READY.', 'CALCULATING OPTIMAL REWARD DISTRIBUTION...'],
        encounterScript: '',
    },
    'scifi_terminal': {
        name: 'Supply Terminal',
        imagePath: '',
        type: 'merchant',
        description: 'An automated supply kiosk that exchanges resources for equipment.',
        merchantItemCount: { min: 2, max: 4 },
        merchantItemPool: 'Rare Artifacts',
        messages: ['SUPPLY EXCHANGE TERMINAL ONLINE.', 'TRADE PROTOCOLS ACTIVATED.', 'RESOURCES DETECTED. INITIATING EXCHANGE.'],
        encounterScript: '',
    },
    // ===== CYBERPUNK PACK =====
    'cyber_fixer': {
        name: 'Street Fixer',
        imagePath: '',
        type: 'messenger',
        description: 'A well-connected operative with chrome implants who deals in underground intel.',
        messages: ['Word on the street is things are about to get hot.', 'Got a tip for you, choom. For free this time.', 'Corp goons are crawling all over this sector.', 'Watch your back. Trust no one.'],
        encounterScript: '',
    },
    'cyber_enforcer': {
        name: 'Corp Enforcer',
        imagePath: '',
        type: 'battlebar',
        description: 'A heavily augmented corporate security agent with combat-grade cyberware.',
        battlebarProfiles: ['Street Fight', 'Elite Combat'],
        messages: ['You\'re in restricted space, meat.', 'Corporate property. No trespassing.', 'This won\'t take long.'],
        encounterScript: '',
    },
    'cyber_casino': {
        name: 'Underground Casino',
        imagePath: '',
        type: 'prizewheel',
        description: 'An illegal gambling den hidden in the neon underbelly of the city.',
        wheelProfiles: ['Gambler\'s Wheel', 'Dark Bargain'],
        messages: ['Step right up, choom. Feeling lucky?', 'The house always wins... usually.', 'High stakes, high rewards. You in?'],
        encounterScript: '',
    },
    'cyber_market': {
        name: 'Black Market',
        imagePath: '',
        type: 'merchant',
        description: 'A shady dealer offering hot merchandise with no questions asked.',
        merchantItemCount: { min: 2, max: 4 },
        merchantItemPool: 'Black Market Tech',
        messages: ['Fell off a truck. Very recently.', 'You didn\'t get this from me.', 'Best prices in Night City. Untraceable.'],
        encounterScript: '',
    },
    // ===== WESTERN PACK =====
    'western_crier': {
        name: 'Town Crier',
        imagePath: '',
        type: 'messenger',
        description: 'A weathered old-timer who shares news and gossip from around these parts.',
        messages: ['Howdy, stranger! Word is there\'s trouble ahead.', 'Outlaws been seen in these parts lately.', 'Watch your back out there, partner.', 'This here\'s dangerous territory.'],
        encounterScript: '',
    },
    'western_outlaw': {
        name: 'Outlaw',
        imagePath: '',
        type: 'battlebar',
        description: 'A notorious desperado with a quick draw and a mean streak.',
        battlebarProfiles: ['Showdown', 'Street Fight'],
        messages: ['This town ain\'t big enough for the both of us.', 'Draw, stranger!', 'Your money or your life!'],
        encounterScript: '',
    },
    'western_gambler': {
        name: 'Saloon Gambler',
        imagePath: '',
        type: 'prizewheel',
        description: 'A slick card shark who runs games of chance in the back room.',
        wheelProfiles: ['Gambler\'s Wheel', 'Mystery Wheel'],
        messages: ['Care to try your luck, partner?', 'The wheel never lies.', 'Fortune favors the bold... sometimes.'],
        encounterScript: '',
    },
    'western_trader': {
        name: 'Traveling Trader',
        imagePath: '',
        type: 'merchant',
        description: 'A dusty merchant with a wagon full of frontier supplies.',
        merchantItemCount: { min: 2, max: 4 },
        merchantItemPool: 'Frontier Trading Post',
        messages: ['Got supplies fresh from back East!', 'Fair prices for fair folks.', 'Need anything for the trail ahead?'],
        encounterScript: '',
    },
    // ===== ACTION PACK =====
    'action_intel': {
        name: 'Intel Officer',
        imagePath: '',
        type: 'messenger',
        description: 'A tactical advisor providing real-time mission intelligence via secure comms.',
        messages: ['Intel update: multiple hostiles in your AO.', 'HQ reports enemy movement ahead.', 'Objective markers updated. Stay frosty.', 'Watch your sectors, operator.'],
        encounterScript: '',
    },
    'action_combatant': {
        name: 'Enemy Combatant',
        imagePath: '',
        type: 'battlebar',
        description: 'A heavily armed hostile operative blocking your route to the objective.',
        battlebarProfiles: ['Street Fight', 'Elite Combat'],
        messages: ['Contact! Engaging!', 'You\'re not getting past me!', 'Target acquired!'],
        encounterScript: '',
    },
    'action_supply': {
        name: 'Supply Drop',
        imagePath: '',
        type: 'prizewheel',
        description: 'An airdropped supply crate with randomized military-grade equipment.',
        wheelProfiles: ['Treasure Wheel', 'Mystery Wheel'],
        messages: ['Supply drop inbound. Contents unknown.', 'Field requisition package received.', 'Let\'s see what command sent us...'],
        encounterScript: '',
    },
    'action_dealer': {
        name: 'Arms Dealer',
        imagePath: '',
        type: 'merchant',
        description: 'A private military contractor offering tactical equipment trades.',
        merchantItemCount: { min: 2, max: 4 },
        merchantItemPool: 'Rare Artifacts',
        messages: ['Need to gear up, soldier?', 'Top-shelf hardware. Fair exchange.', 'Got what you need to complete the mission.'],
        encounterScript: '',
    },

    // ===== TURN-BASED COMBAT MINIONS (PRIORITY) =====
    // Fantasy Turn-Based
    'fantasy_knight': {
        name: 'Dark Knight',
        imagePath: '',
        type: 'turnbased',
        description: 'A corrupted paladin wielding a cursed blade, challenging all who pass.',
        turnbasedProfiles: ['Skeleton Warrior', 'Goblin Ambush'],
        messages: ['My blade hungers for battle!', 'You shall fall like all the others!', 'Honor demands we fight!'],
        encounterScript: '',
    },
    'fantasy_mage': {
        name: 'Arcane Duelist',
        imagePath: '',
        type: 'turnbased',
        description: 'A battle mage who tests worthy opponents with magical combat.',
        turnbasedProfiles: ['Dragon Whelp', 'Skeleton Warrior'],
        messages: ['Your skills shall be tested!', 'Face the power of the arcane!', 'Magic and steel shall decide this!'],
        encounterScript: '',
    },
    // Horror Turn-Based
    'horror_wraith': {
        name: 'Vengeful Wraith',
        imagePath: '',
        type: 'turnbased',
        description: 'A tortured spirit seeking to drag the living into eternal darkness.',
        turnbasedProfiles: ['Vampire Lord', 'Skeleton Warrior'],
        messages: ['JOIN USSS IN DEATH...', 'Your soul will never escape!', 'The grave awaits you!'],
        encounterScript: '',
    },
    'horror_butcher': {
        name: 'The Butcher',
        imagePath: '',
        type: 'turnbased',
        description: 'A massive, blood-soaked figure wielding a cleaver, blocking the only exit.',
        turnbasedProfiles: ['Boss Battle', 'Vampire Lord'],
        messages: ['Fresh meat...', 'No one leaves alive!', 'I\'ll add you to my collection!'],
        encounterScript: '',
    },
    // Sci-Fi Turn-Based
    'scifi_commander': {
        name: 'Rogue Commander',
        imagePath: '',
        type: 'turnbased',
        description: 'A cybernetically enhanced military officer who went AWOL.',
        turnbasedProfiles: ['Dragon Whelp', 'Skeleton Warrior'],
        messages: ['TACTICAL ENGAGEMENT INITIATED.', 'You are outmatched, organic.', 'Combat protocols: Maximum force.'],
        encounterScript: '',
    },
    'scifi_mech': {
        name: 'Combat Mech',
        imagePath: '',
        type: 'turnbased',
        description: 'A bipedal war machine with heavy armor and integrated weapons.',
        turnbasedProfiles: ['Boss Battle', 'Vampire Lord'],
        messages: ['TARGET LOCKED.', 'WEAPONS SYSTEMS ONLINE.', 'RESISTANCE IS FUTILE.'],
        encounterScript: '',
    },
    // Cyberpunk Turn-Based
    'cyber_samurai': {
        name: 'Street Samurai',
        imagePath: '',
        type: 'turnbased',
        description: 'A chrome-plated warrior following an ancient code of combat.',
        turnbasedProfiles: ['Dragon Whelp', 'Skeleton Warrior'],
        messages: ['My blade cuts faster than your reflexes.', 'This is your only warning, choom.', 'Honor demands satisfaction.'],
        encounterScript: '',
    },
    'cyber_boss': {
        name: 'Corp Executive',
        imagePath: '',
        type: 'turnbased',
        description: 'A heavily augmented corporate overlord with military-grade implants.',
        turnbasedProfiles: ['Boss Battle', 'Vampire Lord'],
        messages: ['You think you can hurt me?', 'I own this entire district.', 'Time to flatline, street trash.'],
        encounterScript: '',
    },
    // Western Turn-Based
    'western_sheriff': {
        name: 'Corrupt Sheriff',
        imagePath: '',
        type: 'turnbased',
        description: 'A lawman gone bad, enforcing his own twisted version of justice.',
        turnbasedProfiles: ['Skeleton Warrior', 'Goblin Ambush'],
        messages: ['The law says you die today.', 'I AM the law in these parts!', 'Draw, outlaw!'],
        encounterScript: '',
    },
    'western_bandit': {
        name: 'Bandit Leader',
        imagePath: '',
        type: 'turnbased',
        description: 'The notorious head of a ruthless gang of desperados.',
        turnbasedProfiles: ['Boss Battle', 'Dragon Whelp'],
        messages: ['My gang will avenge me!', 'You\'ll never take me alive!', 'This territory belongs to me!'],
        encounterScript: '',
    },
    // Action Turn-Based
    'action_soldier': {
        name: 'Elite Soldier',
        imagePath: '',
        type: 'turnbased',
        description: 'A highly trained special forces operator guarding a critical position.',
        turnbasedProfiles: ['Skeleton Warrior', 'Dragon Whelp'],
        messages: ['Engage! Engage!', 'You picked the wrong fight!', 'This position will not fall!'],
        encounterScript: '',
    },
    'action_warlord': {
        name: 'Warlord',
        imagePath: '',
        type: 'turnbased',
        description: 'A legendary mercenary commander with countless victories.',
        turnbasedProfiles: ['Boss Battle', 'Vampire Lord'],
        messages: ['I\'ve killed a hundred like you.', 'No retreat, no surrender!', 'Your death will be glorious!'],
        encounterScript: '',
    },

    // ===== QTE COMBAT MINIONS =====
    // Fantasy QTE
    'fantasy_assassin': {
        name: 'Shadow Assassin',
        imagePath: '',
        type: 'qte',
        description: 'A deadly assassin who strikes from the shadows with lightning speed.',
        qteProfiles: ['Quick Dodge', 'Combat Flurry'],
        messages: ['Can you match my speed?', 'Reflexes determine survival!', 'Too slow means death!'],
        encounterScript: '',
    },
    // Horror QTE
    'horror_crawler': {
        name: 'Ceiling Crawler',
        imagePath: '',
        type: 'qte',
        description: 'A twisted creature that drops from above, attacking with terrifying speed.',
        qteProfiles: ['Reaction Test', 'Quick Dodge'],
        messages: ['*skittering sounds*', 'AHHHHHH!', '*inhuman screech*'],
        encounterScript: '',
    },
    // Sci-Fi QTE
    'scifi_drone': {
        name: 'Attack Drone',
        imagePath: '',
        type: 'qte',
        description: 'An agile combat drone that requires quick reflexes to evade.',
        qteProfiles: ['Combat Flurry', 'Boss Sequence'],
        messages: ['EVASION PROTOCOL ACTIVE.', 'TRACKING TARGET.', 'ATTACK RUN INITIATED.'],
        encounterScript: '',
    },
    // Cyberpunk QTE
    'cyber_netrunner': {
        name: 'Hostile Netrunner',
        imagePath: '',
        type: 'qte',
        description: 'A hacker attempting to fry your neural implants remotely.',
        qteProfiles: ['Boss Sequence', 'Deadly Dance'],
        messages: ['Jacking into your system...', 'Let\'s see how fast you really are.', 'Your ICE is pathetic.'],
        encounterScript: '',
    },
    // Western QTE
    'western_quickdraw': {
        name: 'Quick Draw Duelist',
        imagePath: '',
        type: 'qte',
        description: 'A legendary gunslinger known for the fastest draw in the West.',
        qteProfiles: ['Reaction Test', 'Quick Dodge'],
        messages: ['On the count of three...', 'Fastest hand wins.', 'Hope you made your peace.'],
        encounterScript: '',
    },
    // Action QTE
    'action_sniper': {
        name: 'Enemy Sniper',
        imagePath: '',
        type: 'qte',
        description: 'A hidden marksman forcing you to react quickly to laser sights.',
        qteProfiles: ['Combat Flurry', 'Quick Dodge'],
        messages: ['*laser sight on your chest*', 'SNIPER! GET DOWN!', 'Contact! Overwatch position!'],
        encounterScript: '',
    },

    // ===== DICE COMBAT MINIONS =====
    // Fantasy Dice
    'fantasy_sphinx': {
        name: 'The Sphinx',
        imagePath: '',
        type: 'dice',
        description: 'An ancient creature that tests travelers with games of chance and skill.',
        diceProfiles: ['Skill Check', 'Saving Throw'],
        messages: ['Answer my challenge or perish!', 'Fate shall decide your worth.', 'Roll the bones of destiny!'],
        encounterScript: '',
    },
    // Horror Dice
    'horror_demon': {
        name: 'Gambling Demon',
        imagePath: '',
        type: 'dice',
        description: 'A fiend who wagers souls in games of infernal chance.',
        diceProfiles: ['High Stakes', 'Fate\'s Judgment'],
        messages: ['Care to wager your soul?', 'The dice are loaded with destiny!', 'Even demons play fair... sometimes.'],
        encounterScript: '',
    },
    // Sci-Fi Dice
    'scifi_quantum': {
        name: 'Quantum Entity',
        imagePath: '',
        type: 'dice',
        description: 'A being existing in multiple probability states simultaneously.',
        diceProfiles: ['Skill Check', 'High Stakes'],
        messages: ['PROBABILITY COLLAPSE IMMINENT.', 'YOUR FATE EXISTS IN SUPERPOSITION.', 'OBSERVE THE OUTCOME.'],
        encounterScript: '',
    },
    // Cyberpunk Dice
    'cyber_ripperdoc': {
        name: 'Back-Alley Ripperdoc',
        imagePath: '',
        type: 'dice',
        description: 'An unlicensed surgeon who might save you... or butcher you.',
        diceProfiles: ['Lucky Roll', 'Skill Check'],
        messages: ['Steady hands? Let\'s find out.', 'Don\'t worry, I\'ve done this before. Mostly.', 'Surgery is just controlled dice rolls.'],
        encounterScript: '',
    },
    // Western Dice
    'western_dealer': {
        name: 'Card Sharp',
        imagePath: '',
        type: 'dice',
        description: 'A professional gambler who stakes high and never loses... fairly.',
        diceProfiles: ['Lucky Roll', 'High Stakes'],
        messages: ['Lady luck is fickle today.', 'All in, stranger?', 'The cards never lie.'],
        encounterScript: '',
    },
    // Action Dice
    'action_defuser': {
        name: 'Bomb Disposal',
        imagePath: '',
        type: 'dice',
        description: 'A tense situation requiring precision and luck to disarm an explosive.',
        diceProfiles: ['Saving Throw', 'Fate\'s Judgment'],
        messages: ['Red wire or blue wire...', 'Steady... steady...', 'One wrong move and we\'re all dead.'],
        encounterScript: '',
    },

    // ===== STEALTH COMBAT MINIONS =====
    // Fantasy Stealth
    'fantasy_patrol': {
        name: 'Castle Guards',
        imagePath: '',
        type: 'stealth',
        description: 'Vigilant sentries patrolling the castle corridors.',
        stealthProfiles: ['Guard Patrol', 'Watchful Sentry'],
        messages: ['Did you hear something?', 'All clear in sector seven.', 'Stay alert, men!'],
        encounterScript: '',
    },
    // Horror Stealth
    'horror_stalker': {
        name: 'The Stalker',
        imagePath: '',
        type: 'stealth',
        description: 'A relentless hunter that tracks by sound and smell.',
        stealthProfiles: ['Shadow Run', 'Impossible Infiltration'],
        messages: ['*sniffing sounds*', 'I can smell your fear...', 'You cannot hide from me!'],
        encounterScript: '',
    },
    // Sci-Fi Stealth
    'scifi_sensors': {
        name: 'Security Grid',
        imagePath: '',
        type: 'stealth',
        description: 'An automated sensor network scanning for intruders.',
        stealthProfiles: ['Watchful Sentry', 'Shadow Run'],
        messages: ['MOTION DETECTED. SCANNING...', 'THERMAL SIGNATURES ANALYZED.', 'SECTOR SWEEP IN PROGRESS.'],
        encounterScript: '',
    },
    // Cyberpunk Stealth
    'cyber_patrol': {
        name: 'Corp Security',
        imagePath: '',
        type: 'stealth',
        description: 'Corporate security forces with state-of-the-art surveillance.',
        stealthProfiles: ['Guard Patrol', 'Shadow Run'],
        messages: ['Sweep the perimeter.', 'Thermal scan clear... wait.', 'Something tripped the sensors.'],
        encounterScript: '',
    },
    // Western Stealth
    'western_posse': {
        name: 'Sheriff\'s Posse',
        imagePath: '',
        type: 'stealth',
        description: 'A group of lawmen searching for fugitives.',
        stealthProfiles: ['Simple Sneak', 'Guard Patrol'],
        messages: ['Fan out! They\'re here somewhere!', 'Check behind those barrels!', 'We\'ll smoke \'em out!'],
        encounterScript: '',
    },
    // Action Stealth
    'action_patrol': {
        name: 'Guard Patrol',
        imagePath: '',
        type: 'stealth',
        description: 'Military guards with NVGs and motion sensors.',
        stealthProfiles: ['Watchful Sentry', 'Impossible Infiltration'],
        messages: ['Movement. Sector four.', 'Checking blind spots.', 'Stay frosty. We got activity.'],
        encounterScript: '',
    },

    // ===== PUZZLE COMBAT MINIONS =====
    // Fantasy Puzzle
    'fantasy_golem': {
        name: 'Puzzle Golem',
        imagePath: '',
        type: 'puzzle',
        description: 'An ancient construct that only allows passage to those who solve its riddles.',
        puzzleProfiles: ['Simple Riddle', 'Memory Trial'],
        messages: ['Solve my puzzle or be destroyed.', 'Your mind shall be tested.', 'Only the clever may pass.'],
        encounterScript: '',
    },
    // Horror Puzzle
    'horror_mirror': {
        name: 'Puzzle Box',
        imagePath: '',
        type: 'puzzle',
        description: 'A sinister device that must be solved to prevent something terrible.',
        puzzleProfiles: ['Pattern Maze', 'Logic Lock'],
        messages: ['The box... you opened it...', 'Solve it or suffer eternal torment!', 'Your mind against the void...'],
        encounterScript: '',
    },
    // Sci-Fi Puzzle
    'scifi_terminal_puzzle': {
        name: 'Security Terminal',
        imagePath: '',
        type: 'puzzle',
        description: 'A locked terminal requiring a sequence bypass to access.',
        puzzleProfiles: ['Memory Trial', 'Pattern Maze'],
        messages: ['ACCESS DENIED. INITIATING SEQUENCE TEST.', 'AUTHENTICATE VIA PATTERN RECOGNITION.', 'UNAUTHORIZED ACCESS ATTEMPT LOGGED.'],
        encounterScript: '',
    },
    // Cyberpunk Puzzle
    'cyber_ice': {
        name: 'Black ICE',
        imagePath: '',
        type: 'puzzle',
        description: 'Lethal intrusion countermeasures requiring precise mental navigation.',
        puzzleProfiles: ['Logic Lock', 'Mind Shatter'],
        messages: ['ICE DETECTED. BEGINNING BREACH.', 'Neural firewall engaged.', 'Crack the code or fry your brain.'],
        encounterScript: '',
    },
    // Western Puzzle
    'western_safe': {
        name: 'Bank Vault',
        imagePath: '',
        type: 'puzzle',
        description: 'A complex combination lock protecting the town\'s valuables.',
        puzzleProfiles: ['Simple Riddle', 'Memory Trial'],
        messages: ['Four turns left, three right...', 'Listen for the click...', 'One wrong move and the alarm sounds.'],
        encounterScript: '',
    },
    // Action Puzzle
    'action_bomb': {
        name: 'Bomb Defusal',
        imagePath: '',
        type: 'puzzle',
        description: 'A ticking bomb that must be disarmed following a specific sequence.',
        puzzleProfiles: ['Pattern Maze', 'Mind Shatter'],
        messages: ['60 seconds on the clock!', 'Follow the sequence exactly!', 'No pressure... just don\'t mess up.'],
        encounterScript: '',
    },

    // ===== NEGOTIATION COMBAT MINIONS =====
    // Fantasy Negotiation
    'fantasy_diplomat': {
        name: 'Royal Emissary',
        imagePath: '',
        type: 'negotiation',
        description: 'A noble diplomat who might grant passage for the right price or persuasion.',
        negotiationProfiles: ['Friendly Chat', 'Noble Audience'],
        messages: ['Perhaps we can reach an arrangement.', 'The crown demands respect.', 'State your business, traveler.'],
        encounterScript: '',
    },
    // Horror Negotiation
    'horror_pact': {
        name: 'Dark Bargainer',
        imagePath: '',
        type: 'negotiation',
        description: 'An otherworldly entity offering terrible deals.',
        negotiationProfiles: ['Dark Pact', 'Guard Bribery'],
        messages: ['I offer you... a deal.', 'Your soul is of interest to me.', 'Everything has a price...'],
        encounterScript: '',
    },
    // Sci-Fi Negotiation
    'scifi_bureaucrat': {
        name: 'Station Administrator',
        imagePath: '',
        type: 'negotiation',
        description: 'A by-the-book official who controls access to restricted areas.',
        negotiationProfiles: ['Friendly Chat', 'Merchant Haggle'],
        messages: ['AUTHORIZATION REQUIRED.', 'Perhaps we can expedite your paperwork.', 'Regulations must be followed... usually.'],
        encounterScript: '',
    },
    // Cyberpunk Negotiation
    'cyber_fixer_deal': {
        name: 'Connected Fixer',
        imagePath: '',
        type: 'negotiation',
        description: 'A well-connected middleman who can make things happen... for a price.',
        negotiationProfiles: ['Merchant Haggle', 'Guard Bribery'],
        messages: ['Everything\'s negotiable in Night City.', 'I know people who know people.', 'What\'s this worth to you, choom?'],
        encounterScript: '',
    },
    // Western Negotiation
    'western_mayor': {
        name: 'Corrupt Mayor',
        imagePath: '',
        type: 'negotiation',
        description: 'The town\'s crooked leader who can be persuaded with the right approach.',
        negotiationProfiles: ['Friendly Chat', 'Guard Bribery'],
        messages: ['This town runs on my schedule.', 'Perhaps we can help each other.', 'Gold speaks louder than words.'],
        encounterScript: '',
    },
    // Action Negotiation
    'action_commander_deal': {
        name: 'Field Commander',
        imagePath: '',
        type: 'negotiation',
        description: 'An enemy officer who might be convinced to stand down.',
        negotiationProfiles: ['Merchant Haggle', 'Noble Audience'],
        messages: ['You want to avoid bloodshed? Talk.', 'I have orders... but orders can change.', 'Make it worth my while.'],
        encounterScript: '',
    },
};

const DEFAULT_TRAPS = {
    // ===== FANTASY TRAPS =====
    'spike_trap': {
        name: 'Spike Trap',
        imagePath: '',
        message: 'Sharp spikes shoot up from ancient pressure plates!',
        script: '/setvar key=trapdmg {{roll:2d4}} | /mazedamage amount={{getvar::trapdmg}} source="spike trap" | /echo {{user}} took {{getvar::trapdmg}} damage from the spikes!',
        avoidChance: 25,
        avoidMessage: 'You leap back just as the spikes shoot up!',
        avoidScript: '/echo {{user}} narrowly avoided the spike trap!',
    },
    'poison_dart': {
        name: 'Poison Dart',
        imagePath: '',
        message: 'Darts fly from hidden slits in the wall!',
        script: '/setvar key=trapdmg {{roll:1d6+2}} | /mazedamage amount={{getvar::trapdmg}} source="poison dart" | /echo {{user}} was struck by poisoned darts for {{getvar::trapdmg}} damage!',
        avoidChance: 30,
        avoidMessage: 'You duck just in time as darts whistle overhead!',
        avoidScript: '/echo {{user}} dodged the poison darts!',
    },
    'magic_rune': {
        name: 'Magic Rune',
        imagePath: '',
        message: 'An arcane glyph flares to life beneath your feet!',
        script: '/setvar key=trapdmg {{roll:2d6}} | /mazedamage amount={{getvar::trapdmg}} source="magic rune" | /echo The rune explodes! {{user}} takes {{getvar::trapdmg}} arcane damage!',
        avoidChance: 20,
        avoidMessage: 'You sense the magic and step aside as the rune flares!',
        avoidScript: '/echo {{user}} sensed the magical trap and avoided it!',
    },
    // ===== HORROR TRAPS =====
    'ghostly_grasp': {
        name: 'Ghostly Grasp',
        imagePath: '',
        message: 'Spectral hands reach up from the floor!',
        script: '/setvar key=trapdmg {{roll:1d6+1}} | /mazedamage amount={{getvar::trapdmg}} source="ghostly grasp" | /echo Icy fingers drain {{getvar::trapdmg}} life from {{user}}!',
        avoidChance: 25,
        avoidMessage: 'The spectral hands grasp at empty air as you pull away!',
        avoidScript: '/echo {{user}} escaped the ghostly grasp!',
    },
    'blood_pool': {
        name: 'Blood Pool',
        imagePath: '',
        message: 'The floor gives way to a pool of viscous crimson!',
        script: '/setvar key=trapdmg {{roll:2d4}} | /mazedamage amount={{getvar::trapdmg}} source="blood pool" | /echo The cursed blood burns {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 20,
        avoidMessage: 'You grab the edge and pull yourself back before falling in!',
        avoidScript: '/echo {{user}} narrowly avoided falling into the blood pool!',
    },
    'cursed_mirror': {
        name: 'Cursed Mirror',
        imagePath: '',
        message: 'Your reflection grins and reaches through the glass!',
        script: '/setvar key=trapdmg {{roll:2d6}} | /mazedamage amount={{getvar::trapdmg}} source="cursed mirror" | /echo Your doppelganger claws {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 15,
        avoidMessage: 'You avert your eyes just as your reflection reaches out!',
        avoidScript: '/echo {{user}} refused to look at the cursed mirror!',
    },
    // ===== SCI-FI TRAPS =====
    'laser_grid': {
        name: 'Laser Grid',
        imagePath: '',
        message: 'Red laser beams crisscross the corridor!',
        script: '/setvar key=trapdmg {{roll:2d4+2}} | /mazedamage amount={{getvar::trapdmg}} source="laser grid" | /echo Security lasers burn {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 30,
        avoidMessage: 'You contort through the laser grid without triggering it!',
        avoidScript: '/echo {{user}} gracefully navigated the laser grid!',
    },
    'gas_leak': {
        name: 'Gas Leak',
        imagePath: '',
        message: 'A ruptured pipe sprays toxic coolant!',
        script: '/setvar key=trapdmg {{roll:1d8+1}} | /mazedamage amount={{getvar::trapdmg}} source="gas leak" | /echo Toxic gas burns {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 25,
        avoidMessage: 'You hold your breath and rush past the gas leak!',
        avoidScript: '/echo {{user}} held their breath and avoided the toxic gas!',
    },
    'gravity_trap': {
        name: 'Gravity Trap',
        imagePath: '',
        message: 'The gravity plating malfunctions violently!',
        script: '/setvar key=trapdmg {{roll:2d6}} | /mazedamage amount={{getvar::trapdmg}} source="gravity trap" | /echo {{user}} slams into the ceiling for {{getvar::trapdmg}} damage!',
        avoidChance: 20,
        avoidMessage: 'You grab a handhold as the gravity fluctuates!',
        avoidScript: '/echo {{user}} braced themselves against the gravity shift!',
    },
    // ===== CYBERPUNK TRAPS =====
    'electric_floor': {
        name: 'Electric Floor',
        imagePath: '',
        message: 'The chrome flooring crackles with lethal voltage!',
        script: '/setvar key=trapdmg {{roll:2d4+3}} | /mazedamage amount={{getvar::trapdmg}} source="electric floor" | /echo Electricity surges through {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 25,
        avoidMessage: 'You leap to a non-conductive surface just in time!',
        avoidScript: '/echo {{user}} jumped clear of the electric floor!',
    },
    'neural_spike': {
        name: 'Neural Spike',
        imagePath: '',
        message: 'A hidden ICE program attacks your neural interface!',
        script: '/setvar key=trapdmg {{roll:2d6}} | /mazedamage amount={{getvar::trapdmg}} source="neural spike" | /echo The ICE fries your synapses for {{getvar::trapdmg}} damage!',
        avoidChance: 20,
        avoidMessage: 'Your firewall blocks the ICE attack!',
        avoidScript: '/echo Your cyberdeck deflected the neural spike!',
    },
    'security_turret': {
        name: 'Security Turret',
        imagePath: '',
        message: 'An automated turret drops from the ceiling!',
        script: '/setvar key=trapdmg {{roll:3d4}} | /mazedamage amount={{getvar::trapdmg}} source="security turret" | /echo The turret peppers {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 30,
        avoidMessage: 'You dive behind cover as the turret opens fire!',
        avoidScript: '/echo {{user}} took cover before the turret could lock on!',
    },
    // ===== WESTERN TRAPS =====
    'bear_trap': {
        name: 'Bear Trap',
        imagePath: '',
        message: 'A rusted bear trap snaps shut on your leg!',
        script: '/setvar key=trapdmg {{roll:2d4+2}} | /mazedamage amount={{getvar::trapdmg}} source="bear trap" | /echo The iron jaws bite {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 25,
        avoidMessage: 'You spot the bear trap and step around it!',
        avoidScript: '/echo {{user}} carefully avoided the bear trap!',
    },
    'dynamite': {
        name: 'Dynamite',
        imagePath: '',
        message: 'A tripwire ignites a bundle of dynamite!',
        script: '/setvar key=trapdmg {{roll:3d6}} | /mazedamage amount={{getvar::trapdmg}} source="dynamite" | /echo BOOM! {{user}} takes {{getvar::trapdmg}} explosion damage!',
        avoidChance: 20,
        avoidMessage: 'You cut the tripwire before it triggers the dynamite!',
        avoidScript: '/echo {{user}} disarmed the dynamite trap!',
    },
    'snake_pit': {
        name: 'Snake Pit',
        imagePath: '',
        message: 'The floor collapses into a writhing pit of rattlesnakes!',
        script: '/setvar key=trapdmg {{roll:2d4+1}} | /mazedamage amount={{getvar::trapdmg}} source="snake pit" | /echo The snakes strike {{user}} for {{getvar::trapdmg}} venom damage!',
        avoidChance: 25,
        avoidMessage: 'You jump back as the floor crumbles away!',
        avoidScript: '/echo {{user}} leapt clear of the snake pit!',
    },
    // ===== ACTION TRAPS =====
    'tripwire': {
        name: 'Tripwire',
        imagePath: '',
        message: 'Your foot catches a nearly invisible wire!',
        script: '/setvar key=trapdmg {{roll:2d6+2}} | /mazedamage amount={{getvar::trapdmg}} source="tripwire" | /echo The explosive detonates! {{user}} takes {{getvar::trapdmg}} damage!',
        avoidChance: 30,
        avoidMessage: 'You spot the tripwire and step over it!',
        avoidScript: '/echo {{user}} spotted and avoided the tripwire!',
    },
    'flashbang': {
        name: 'Flashbang',
        imagePath: '',
        message: 'A proximity sensor triggers a flashbang grenade!',
        script: '/setvar key=trapdmg {{roll:1d6+2}} | /mazedamage amount={{getvar::trapdmg}} source="flashbang" | /echo The blast disorients {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 25,
        avoidMessage: 'You shield your eyes and ears as the flashbang detonates!',
        avoidScript: '/echo {{user}} braced for the flashbang!',
    },
    'claymore': {
        name: 'Claymore',
        imagePath: '',
        message: 'You step into the kill zone of a claymore mine!',
        script: '/setvar key=trapdmg {{roll:4d6}} | /mazedamage amount={{getvar::trapdmg}} source="claymore" | /echo Steel balls shred {{user}} for {{getvar::trapdmg}} damage!',
        avoidChance: 15,
        avoidMessage: 'You freeze and slowly back out of the kill zone!',
        avoidScript: '/echo {{user}} carefully retreated from the claymore!',
    },
};

// Default merchant item pools - configurable item pools that merchants can offer
const DEFAULT_MERCHANT_ITEM_POOLS = {
    'Common Goods': {
        description: 'Basic supplies and common items',
        items: [
            { id: 'key', name: 'Key', description: 'Opens locked doors', icon: '', weight: 30 },
            { id: 'stealth', name: 'Stealth Cloak', description: 'Slip past one encounter', icon: '', weight: 25 },
            { id: 'strike', name: 'Strike', description: 'Power attack in combat', icon: '', weight: 25 },
            { id: 'healingPotion', name: 'Healing Potion', description: 'Restores health', icon: '', weight: 20 },
        ],
    },
    'Adventurer Supplies': {
        description: 'Essential gear for dungeon delvers',
        items: [
            { id: 'key', name: 'Key', description: 'Opens locked doors', icon: '', weight: 20 },
            { id: 'stealth', name: 'Stealth Cloak', description: 'Slip past one encounter', icon: '', weight: 20 },
            { id: 'strike', name: 'Strike', description: 'Power attack in combat', icon: '', weight: 20 },
            { id: 'execute', name: 'Grandstrike', description: 'Devastating finishing blow', icon: '', weight: 10 },
            { id: 'floorKey', name: 'Floor Key', description: 'Access the next floor', icon: '', weight: 10 },
            { id: 'healingPotion', name: 'Healing Potion', description: 'Restores health', icon: '', weight: 20 },
        ],
    },
    'Rare Artifacts': {
        description: 'Magical items of significant power',
        items: [
            { id: 'execute', name: 'Grandstrike', description: 'Devastating finishing blow', icon: '', weight: 15 },
            { id: 'floorKey', name: 'Floor Key', description: 'Access the next floor', icon: '', weight: 15 },
            { id: 'portalStone', name: 'Portal Stone', description: 'Teleport to safety', icon: '', weight: 15 },
            { id: 'minionBane', name: 'Minion Bane', description: 'Instantly defeats a minion', icon: '', weight: 15 },
            { id: 'greaterHealing', name: 'Greater Healing', description: 'Fully restores health', icon: '', weight: 20 },
            { id: 'mapFragment', name: 'Map Fragment', description: 'Reveals the maze', icon: '', weight: 20 },
        ],
    },
    'Dark Market': {
        description: 'Forbidden wares from the underworld',
        items: [
            { id: 'minionBane', name: 'Minion Bane', description: 'Instantly defeats a minion', icon: '', weight: 20 },
            { id: 'voidWalk', name: 'Void Walk', description: 'Phase through walls', icon: '', weight: 15 },
            { id: 'timeShard', name: 'Time Shard', description: 'Manipulate time', icon: '', weight: 15 },
            { id: 'execute', name: 'Grandstrike', description: 'Devastating finishing blow', icon: '', weight: 20 },
            { id: 'elixir', name: 'Elixir', description: 'Powerful restorative', icon: '', weight: 15 },
            { id: 'revivalCharm', name: 'Revival Charm', description: 'Return from defeat', icon: '', weight: 15 },
        ],
    },
    'Frontier Trading Post': {
        description: 'Supplies for the open frontier',
        items: [
            { id: 'key', name: 'Key', description: 'Opens locked doors', icon: '', weight: 20 },
            { id: 'strike', name: 'Strike', description: 'Power attack in combat', icon: '', weight: 25 },
            { id: 'stealth', name: 'Stealth Cloak', description: 'Slip past one encounter', icon: '', weight: 15 },
            { id: 'healingPotion', name: 'Healing Potion', description: 'Restores health', icon: '', weight: 25 },
            { id: 'execute', name: 'Grandstrike', description: 'Devastating finishing blow', icon: '', weight: 15 },
        ],
    },
    'Black Market Tech': {
        description: 'Cutting-edge contraband tech',
        items: [
            { id: 'voidWalk', name: 'Phase Implant', description: 'Phase through walls', icon: '', weight: 15 },
            { id: 'minionBane', name: 'EMP Grenade', description: 'Instantly defeats a minion', icon: '', weight: 20 },
            { id: 'mapFragment', name: 'Scanner Chip', description: 'Reveals the maze', icon: '', weight: 20 },
            { id: 'portalStone', name: 'Teleport Beacon', description: 'Teleport to safety', icon: '', weight: 15 },
            { id: 'execute', name: 'Overcharge Cell', description: 'Devastating finishing blow', icon: '', weight: 15 },
            { id: 'timeShard', name: 'Stasis Field', description: 'Manipulate time', icon: '', weight: 15 },
        ],
    },
};

// Default minion profile (a saved set of minions)
// Minion profiles are collections of minion IDs that can be used together
const DEFAULT_MINION_PROFILES = {
    // Original packs with just basic minion types
    'Fantasy Pack': {
        minions: ['fantasy_herald', 'fantasy_guardian', 'fantasy_oracle', 'fantasy_merchant'],
    },
    'Horror Pack': {
        minions: ['horror_spirit', 'horror_revenant', 'horror_gambler', 'horror_graverobber'],
    },
    'Sci-Fi Pack': {
        minions: ['scifi_ai', 'scifi_bot', 'scifi_matrix', 'scifi_terminal'],
    },
    'Cyberpunk Pack': {
        minions: ['cyber_fixer', 'cyber_enforcer', 'cyber_casino', 'cyber_market'],
    },
    'Western Pack': {
        minions: ['western_crier', 'western_outlaw', 'western_gambler', 'western_trader'],
    },
    'Action Pack': {
        minions: ['action_intel', 'action_combatant', 'action_supply', 'action_dealer'],
    },
    // Extended packs with all combat types
    'Fantasy Extended': {
        minions: [
            'fantasy_herald', 'fantasy_guardian', 'fantasy_oracle', 'fantasy_merchant',
            'fantasy_knight', 'fantasy_mage', 'fantasy_assassin', 'fantasy_sphinx',
            'fantasy_patrol', 'fantasy_golem', 'fantasy_diplomat'
        ],
    },
    'Horror Extended': {
        minions: [
            'horror_spirit', 'horror_revenant', 'horror_gambler', 'horror_graverobber',
            'horror_wraith', 'horror_butcher', 'horror_crawler', 'horror_demon',
            'horror_stalker', 'horror_mirror', 'horror_pact'
        ],
    },
    'Sci-Fi Extended': {
        minions: [
            'scifi_ai', 'scifi_bot', 'scifi_matrix', 'scifi_terminal',
            'scifi_commander', 'scifi_mech', 'scifi_drone', 'scifi_quantum',
            'scifi_sensors', 'scifi_terminal_puzzle', 'scifi_bureaucrat'
        ],
    },
    'Cyberpunk Extended': {
        minions: [
            'cyber_fixer', 'cyber_enforcer', 'cyber_casino', 'cyber_market',
            'cyber_samurai', 'cyber_boss', 'cyber_netrunner', 'cyber_ripperdoc',
            'cyber_patrol', 'cyber_ice', 'cyber_fixer_deal'
        ],
    },
    'Western Extended': {
        minions: [
            'western_crier', 'western_outlaw', 'western_gambler', 'western_trader',
            'western_sheriff', 'western_bandit', 'western_quickdraw', 'western_dealer',
            'western_posse', 'western_safe', 'western_mayor'
        ],
    },
    'Action Extended': {
        minions: [
            'action_intel', 'action_combatant', 'action_supply', 'action_dealer',
            'action_soldier', 'action_warlord', 'action_sniper', 'action_defuser',
            'action_patrol', 'action_bomb', 'action_commander_deal'
        ],
    },
    // Turn-Based Focus packs (testing priority)
    'Fantasy Turn-Based': {
        minions: ['fantasy_herald', 'fantasy_knight', 'fantasy_mage', 'fantasy_merchant'],
    },
    'Horror Turn-Based': {
        minions: ['horror_spirit', 'horror_wraith', 'horror_butcher', 'horror_graverobber'],
    },
    'Sci-Fi Turn-Based': {
        minions: ['scifi_ai', 'scifi_commander', 'scifi_mech', 'scifi_terminal'],
    },
    'Cyberpunk Turn-Based': {
        minions: ['cyber_fixer', 'cyber_samurai', 'cyber_boss', 'cyber_market'],
    },
    'Western Turn-Based': {
        minions: ['western_crier', 'western_sheriff', 'western_bandit', 'western_trader'],
    },
    'Action Turn-Based': {
        minions: ['action_intel', 'action_soldier', 'action_warlord', 'action_dealer'],
    },
};

// Trap profiles are collections of trap IDs that can be used together
const DEFAULT_TRAP_PROFILES = {
    'Fantasy Traps': {
        traps: ['spike_trap', 'poison_dart', 'magic_rune'],
    },
    'Horror Traps': {
        traps: ['ghostly_grasp', 'blood_pool', 'cursed_mirror'],
    },
    'Sci-Fi Traps': {
        traps: ['laser_grid', 'gas_leak', 'gravity_trap'],
    },
    'Cyberpunk Traps': {
        traps: ['electric_floor', 'neural_spike', 'security_turret'],
    },
    'Western Traps': {
        traps: ['bear_trap', 'dynamite', 'snake_pit'],
    },
    'Action Traps': {
        traps: ['tripwire', 'flashbang', 'claymore'],
    },
};

const DEFAULT_MAZE_PROFILE = {
    // ===== FANTASY THEME =====
    'Dungeon Crawl - Easy': {
        gridSize: 6, floors: 1, difficulty: 'easy', theme: 'fantasy', mapStyle: 'dungeon', mapVisibility: 'showAll',
        winCommand: '/echo Congratulations! You escaped the dungeon!',
        loseCommand: '/echo The dungeon claims another victim...',
        winMessage: 'You found the exit and escaped the ancient dungeon!',
        winImage: '',
        mainMinion: 'fantasy_guardian',
        mainMinionIntroMessage: 'Welcome to my dungeon, adventurer. Find the exit... if you can!',
        mainMinionRandomChance: 15,
        mainMinionRandomMessages: ['Still wandering, I see...', 'Many have tried. Few have succeeded.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Dungeon Guardian',
        minionEncounters: [
            { minionId: 'fantasy_herald', percent: 2 },
            { minionId: 'fantasy_guardian', percent: 1 },
            { minionId: 'fantasy_oracle', percent: 1 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 1 }, { trapId: 'poison_dart', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 10, chestLockedPercent: 20, chestLockedBonusPercent: 50, chestMimicPercent: 5,
        chestLootMin: 2, chestLootMax: 4,
        chestKeyChance: 40, chestStrikeChance: 50, chestStealthChance: 20, chestExecuteChance: 2,
        lockedChestKeyChance: 30, lockedChestStrikeChance: 60, lockedChestStealthChance: 30, lockedChestExecuteChance: 5,
        startingInventory: { key: 2, strike: 2, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        // HP Settings - Easy: generous healing, safe rest
        hpEnabled: true, maxHP: 130, battlebarDamageMultiplier: 0.7, onDeath: 'respawn', respawnHPPercent: 75,
        safeRoomCount: 4, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 30, restCooldown: 2, restInterruptChance: 0, restInterruptScript: '',
        storyConfig: { mainStory: 'You descend into a small dungeon. Perfect for adventurers just starting out...' },
        findEarly: { radius: 5, items: ['lantern', 'torch', 'healingPotion', 'mapFragment'], itemsPerChest: 2 },
        fairness: { enabled: true, keyPityThreshold: 3, healingPityThreshold: 4, lowHpThreshold: 0.4, mercyUnlock: true, mercyUnlockThreshold: 2 },
    },
    'Dungeon Crawl - Hard': {
        gridSize: 12, floors: 2, difficulty: 'hard', theme: 'fantasy', mapStyle: 'dungeon', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Glory! You have conquered the depths!',
        loseCommand: '/echo The abyss swallows another soul...',
        winMessage: 'Through blood and steel, you found the exit!',
        winImage: '',
        mainMinion: 'fantasy_guardian',
        mainMinionIntroMessage: 'You dare challenge my domain? Prove your worth!',
        mainMinionRandomChance: 25,
        mainMinionRandomMessages: ['Your bones will join the others...', 'The deeper you go, the darker it gets.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Knight\'s Challenge',
        minionEncounters: [
            { minionId: 'fantasy_herald', percent: 4 },
            { minionId: 'fantasy_guardian', percent: 4 },
            { minionId: 'fantasy_oracle', percent: 2 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 3 }, { trapId: 'poison_dart', percent: 3 }, { trapId: 'magic_rune', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 6, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 20,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 40, chestStealthChance: 15, chestExecuteChance: 3,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 8,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        // HP Settings - Hard: less forgiving
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.3, onDeath: 'respawnPenalty', respawnHPPercent: 50,
        safeRoomCount: 2, safeRoomHealPercent: 75, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 25, restInterruptScript: '',
        storyConfig: { mainStory: 'The ancient fortress looms before you. Two floors of deadly challenges await...' },
        findEarly: { radius: 3, items: ['torch', 'healingPotion'], itemsPerChest: 1 },
    },
    'Enchanted Forest - Medium': {
        gridSize: 10, floors: 1, difficulty: 'normal', theme: 'fantasy', mapStyle: 'forest', mapVisibility: 'fogOfWar',
        winCommand: '/echo You emerge from the mystical woods!',
        loseCommand: '/echo The forest claims you as its own...',
        winMessage: 'You found your way through the enchanted grove!',
        winImage: '',
        mainMinion: 'fantasy_oracle',
        mainMinionIntroMessage: 'The spirits of the forest watch you, traveler...',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['The trees whisper your name...', 'Nature is not always kind.'],
        mainMinionExitType: 'prizewheel', mainMinionExitProfile: 'Blessing Wheel',
        minionEncounters: [
            { minionId: 'fantasy_herald', percent: 3 },
            { minionId: 'fantasy_oracle', percent: 2 },
            { minionId: 'fantasy_merchant', percent: 1 },
        ],
        trapEncounters: [{ trapId: 'magic_rune', percent: 2 }, { trapId: 'poison_dart', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 8, chestLockedPercent: 30, chestLockedBonusPercent: 50, chestMimicPercent: 10,
        chestLootMin: 1, chestLootMax: 3,
        chestKeyChance: 35, chestStrikeChance: 45, chestStealthChance: 20, chestExecuteChance: 2,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 6,
        startingInventory: { key: 1, strike: 1, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        // HP Settings - Medium: balanced
        hpEnabled: true, maxHP: 100, battlebarDamageMultiplier: 1.0, onDeath: 'respawn', respawnHPPercent: 50,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 20, restCooldown: 3, restInterruptChance: 10, restInterruptScript: '',
        storyConfig: { mainStory: 'Ancient trees tower overhead as you enter the enchanted forest...' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'mapFragment'], itemsPerChest: 1 },
    },
    // ===== HORROR THEME =====
    'Haunted Manor - Easy': {
        gridSize: 7, floors: 1, difficulty: 'easy', theme: 'horror', mapStyle: 'apartment', mapVisibility: 'showAll',
        winCommand: '/echo You escape the haunted manor!',
        loseCommand: '/echo The spirits claim another soul...',
        winMessage: 'You escaped the haunted manor... but the nightmares will follow.',
        winImage: '',
        mainMinion: 'horror_revenant',
        mainMinionIntroMessage: 'Welcome to my home... you will never leave...',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['I can smell your fear...', 'The walls are watching...'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Horror Encounter',
        minionEncounters: [
            { minionId: 'horror_spirit', percent: 3 },
            { minionId: 'horror_gambler', percent: 2 },
        ],
        trapEncounters: [{ trapId: 'ghostly_grasp', percent: 2 }, { trapId: 'blood_pool', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 10, chestLockedPercent: 20, chestLockedBonusPercent: 50, chestMimicPercent: 10,
        chestLootMin: 2, chestLootMax: 4,
        chestKeyChance: 40, chestStrikeChance: 50, chestStealthChance: 25, chestExecuteChance: 2,
        lockedChestKeyChance: 30, lockedChestStrikeChance: 55, lockedChestStealthChance: 30, lockedChestExecuteChance: 5,
        startingInventory: { key: 2, strike: 2, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        // HP Settings - Easy: more forgiving horror
        hpEnabled: true, maxHP: 130, battlebarDamageMultiplier: 0.7, onDeath: 'respawn', respawnHPPercent: 75,
        safeRoomCount: 4, safeRoomHealPercent: 100, safeRoomUseLLM: true,
        restEnabled: true, restHealPercent: 30, restCooldown: 2, restInterruptChance: 15, restInterruptScript: '',
        storyConfig: { mainStory: 'The manor door creaks open. Something draws you inside...' },
        findEarly: { radius: 5, items: ['lantern', 'torch', 'healingPotion', 'mapFragment'], itemsPerChest: 2 },
    },
    'Haunted Manor - Nightmare': {
        gridSize: 12, floors: 3, difficulty: 'nightmare', theme: 'horror', mapStyle: 'highrise', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Against all odds, you survived!',
        loseCommand: '/echo Your screams echo for eternity...',
        winMessage: 'You escaped... but at what cost?',
        winImage: '',
        mainMinion: 'horror_revenant',
        mainMinionIntroMessage: 'There is no escape. There never was.',
        mainMinionRandomChance: 30,
        mainMinionRandomMessages: ['YOU CANNOT RUN!', 'DEATH IS ONLY THE BEGINNING!', 'JOIN US...'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Nightmare Battle',
        minionEncounters: [
            { minionId: 'horror_spirit', percent: 5 },
            { minionId: 'horror_revenant', percent: 4 },
            { minionId: 'horror_gambler', percent: 3 },
        ],
        trapEncounters: [{ trapId: 'ghostly_grasp', percent: 4 }, { trapId: 'blood_pool', percent: 3 }, { trapId: 'cursed_mirror', percent: 3 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 5, chestLockedPercent: 50, chestLockedBonusPercent: 70, chestMimicPercent: 25,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 25, chestStrikeChance: 35, chestStealthChance: 20, chestExecuteChance: 5,
        lockedChestKeyChance: 20, lockedChestStrikeChance: 50, lockedChestStealthChance: 30, lockedChestExecuteChance: 10,
        startingInventory: { key: 0, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        // HP Settings - Nightmare: brutal horror survival
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.4, onDeath: 'gameover', respawnHPPercent: 25,
        safeRoomCount: 2, safeRoomHealPercent: 60, safeRoomUseLLM: true,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 40, restInterruptScript: '',
        storyConfig: { mainStory: 'Three floors of pure terror. No supplies. No mercy. Good luck...' },
        findEarly: { radius: 2, items: ['torch'], itemsPerChest: 1 },
    },
    // ===== SCI-FI THEME =====
    'Space Station - Medium': {
        gridSize: 10, floors: 2, difficulty: 'normal', theme: 'scifi', mapStyle: 'spacestation', mapVisibility: 'fogOfWar',
        winCommand: '/echo Mission complete. Extraction successful.',
        loseCommand: '/echo Hull breach detected. Life signs terminated.',
        winMessage: 'You reached the escape pods and evacuated safely!',
        winImage: '',
        mainMinion: 'scifi_bot',
        mainMinionIntroMessage: 'UNAUTHORIZED PERSONNEL DETECTED. INITIATING LOCKDOWN.',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['SCANNING... THREAT LEVEL ELEVATED.', 'SECURITY PROTOCOLS ACTIVE.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Security Drone',
        minionEncounters: [
            { minionId: 'scifi_ai', percent: 3 },
            { minionId: 'scifi_bot', percent: 2 },
            { minionId: 'scifi_matrix', percent: 1 },
        ],
        trapEncounters: [{ trapId: 'laser_grid', percent: 3 }, { trapId: 'gas_leak', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 8, chestLockedPercent: 30, chestLockedBonusPercent: 50, chestMimicPercent: 10,
        chestLootMin: 1, chestLootMax: 3,
        chestKeyChance: 35, chestStrikeChance: 45, chestStealthChance: 20, chestExecuteChance: 3,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 7,
        startingInventory: { key: 1, strike: 1, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        // HP Settings - Medium: standard sci-fi survival
        hpEnabled: true, maxHP: 100, battlebarDamageMultiplier: 1.0, onDeath: 'respawn', respawnHPPercent: 50,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 20, restCooldown: 3, restInterruptChance: 15, restInterruptScript: '',
        storyConfig: { mainStory: 'The station alarms blare. Find the escape pods before it\'s too late...' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'mapFragment'], itemsPerChest: 1 },
    },
    'Space Station - Hard': {
        gridSize: 14, floors: 3, difficulty: 'hard', theme: 'scifi', mapStyle: 'spacestation', mapVisibility: 'hideUnexplored',
        winCommand: '/echo EXTRACTION COMPLETE. WELL DONE, OPERATIVE.',
        loseCommand: '/echo MISSION FAILED. ASSET TERMINATED.',
        winMessage: 'Against impossible odds, you escaped the derelict station!',
        winImage: '',
        mainMinion: 'scifi_bot',
        mainMinionIntroMessage: 'CRITICAL ALERT: HOSTILE AI HAS TAKEN CONTROL.',
        mainMinionRandomChance: 25,
        mainMinionRandomMessages: ['RESISTANCE IS FUTILE.', 'ALL SECTORS COMPROMISED.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'System Override',
        minionEncounters: [
            { minionId: 'scifi_ai', percent: 4 },
            { minionId: 'scifi_bot', percent: 4 },
            { minionId: 'scifi_matrix', percent: 2 },
        ],
        trapEncounters: [{ trapId: 'laser_grid', percent: 3 }, { trapId: 'gas_leak', percent: 3 }, { trapId: 'gravity_trap', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 6, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 15,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 40, chestStealthChance: 15, chestExecuteChance: 4,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 50, lockedChestStealthChance: 25, lockedChestExecuteChance: 8,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        // HP Settings - Hard: challenging sci-fi
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.3, onDeath: 'respawnPenalty', respawnHPPercent: 40,
        safeRoomCount: 2, safeRoomHealPercent: 75, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 25, restInterruptScript: '',
        storyConfig: { mainStory: 'Three decks. Rogue AI. Failing life support. Move fast or die...' },
        findEarly: { radius: 3, items: ['torch', 'healingPotion'], itemsPerChest: 1 },
    },
    // ===== CYBERPUNK THEME =====
    'Neon Streets - Medium': {
        gridSize: 10, floors: 1, difficulty: 'normal', theme: 'cyberpunk', mapStyle: 'neotokyo', mapVisibility: 'fogOfWar',
        winCommand: '/echo Run complete. Payout received, choom.',
        loseCommand: '/echo Flatlined. Your chrome belongs to the corp now.',
        winMessage: 'You made it through the neon jungle!',
        winImage: '',
        mainMinion: 'cyber_enforcer',
        mainMinionIntroMessage: 'You picked the wrong sector to run through, meat.',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['Corp knows you\'re here.', 'No one escapes the grid.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Street Fight',
        minionEncounters: [
            { minionId: 'cyber_fixer', percent: 3 },
            { minionId: 'cyber_enforcer', percent: 2 },
            { minionId: 'cyber_casino', percent: 1 },
        ],
        trapEncounters: [{ trapId: 'electric_floor', percent: 3 }, { trapId: 'neural_spike', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 8, chestLockedPercent: 30, chestLockedBonusPercent: 50, chestMimicPercent: 10,
        chestLootMin: 1, chestLootMax: 3,
        chestKeyChance: 35, chestStrikeChance: 45, chestStealthChance: 20, chestExecuteChance: 3,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 7,
        startingInventory: { key: 1, strike: 1, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        // HP Settings - Medium: standard cyberpunk run
        hpEnabled: true, maxHP: 100, battlebarDamageMultiplier: 1.0, onDeath: 'respawn', respawnHPPercent: 50,
        safeRoomCount: 2, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 20, restCooldown: 3, restInterruptChance: 20, restInterruptScript: '',
        storyConfig: { mainStory: 'Neon lights flicker overhead as you enter the dangerous megacity streets...' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'mapFragment'], itemsPerChest: 1 },
    },
    'Neon Streets - Nightmare': {
        gridSize: 14, floors: 2, difficulty: 'nightmare', theme: 'cyberpunk', mapStyle: 'city', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Preem run, choom. You\'re a legend now.',
        loseCommand: '/echo Game over. Insert credit to continue... just kidding.',
        winMessage: 'You survived the corporate kill squads and made it out!',
        winImage: '',
        mainMinion: 'cyber_enforcer',
        mainMinionIntroMessage: 'Corporate has authorized lethal force. There\'s nowhere to run.',
        mainMinionRandomChance: 30,
        mainMinionRandomMessages: ['Your biosigns are being tracked.', 'Every exit is covered.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Elite Combat',
        minionEncounters: [
            { minionId: 'cyber_fixer', percent: 5 },
            { minionId: 'cyber_enforcer', percent: 4 },
            { minionId: 'cyber_casino', percent: 3 },
        ],
        trapEncounters: [{ trapId: 'electric_floor', percent: 4 }, { trapId: 'neural_spike', percent: 3 }, { trapId: 'security_turret', percent: 3 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 5, chestLockedPercent: 50, chestLockedBonusPercent: 70, chestMimicPercent: 20,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 25, chestStrikeChance: 35, chestStealthChance: 20, chestExecuteChance: 5,
        lockedChestKeyChance: 20, lockedChestStrikeChance: 50, lockedChestStealthChance: 30, lockedChestExecuteChance: 10,
        startingInventory: { key: 0, strike: 0, stealth: 0, execute: 0, healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        // HP Settings - Nightmare: brutal cyberpunk survival
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.4, onDeath: 'gameover', respawnHPPercent: 25,
        safeRoomCount: 2, safeRoomHealPercent: 60, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 35, restInterruptScript: '',
        storyConfig: { mainStory: 'Two sectors of corporate hell. No gear. No backup. Pure nightmare mode...' },
        findEarly: { radius: 2, items: ['torch'], itemsPerChest: 1 },
    },
    // ===== WESTERN THEME =====
    'Wild Frontier - Easy': {
        gridSize: 8, floors: 1, difficulty: 'easy', theme: 'western', mapStyle: 'outpost', mapVisibility: 'showAll',
        winCommand: '/echo You ride off into the sunset, partner.',
        loseCommand: '/echo This town wasn\'t big enough for the both of ya.',
        winMessage: 'You cleared the outpost and rode on to new adventures!',
        winImage: '',
        mainMinion: 'western_outlaw',
        mainMinionIntroMessage: 'Howdy, stranger. This here\'s my territory.',
        mainMinionRandomChance: 15,
        mainMinionRandomMessages: ['Keep walking, partner.', 'Outlaws don\'t take kindly to trespassers.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Showdown',
        minionEncounters: [
            { minionId: 'western_crier', percent: 2 },
            { minionId: 'western_gambler', percent: 2 },
        ],
        trapEncounters: [{ trapId: 'bear_trap', percent: 2 }, { trapId: 'snake_pit', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 10, chestLockedPercent: 20, chestLockedBonusPercent: 50, chestMimicPercent: 5,
        chestLootMin: 2, chestLootMax: 4,
        chestKeyChance: 40, chestStrikeChance: 50, chestStealthChance: 15, chestExecuteChance: 2,
        lockedChestKeyChance: 30, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 5,
        startingInventory: { key: 2, strike: 2, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        // HP Settings - Easy: relaxed frontier adventure
        hpEnabled: true, maxHP: 130, battlebarDamageMultiplier: 0.7, onDeath: 'respawn', respawnHPPercent: 75,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 30, restCooldown: 2, restInterruptChance: 5, restInterruptScript: '',
        storyConfig: { mainStory: 'Dust swirls as you enter the frontier outpost. Adventure awaits...' },
        findEarly: { radius: 5, items: ['lantern', 'torch', 'healingPotion', 'mapFragment'], itemsPerChest: 2 },
    },
    // ===== ACTION THEME =====
    'Tactical Ops - Hard': {
        gridSize: 12, floors: 2, difficulty: 'hard', theme: 'action', mapStyle: 'arena', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Mission accomplished. Outstanding work, operator.',
        loseCommand: '/echo KIA. Mission failed.',
        winMessage: 'Objective secured! Extraction complete!',
        winImage: '',
        mainMinion: 'action_combatant',
        mainMinionIntroMessage: 'Multiple hostiles in the AO. Weapons hot.',
        mainMinionRandomChance: 25,
        mainMinionRandomMessages: ['Contact left!', 'Stay frosty, operator.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Elite Combat',
        minionEncounters: [
            { minionId: 'action_intel', percent: 4 },
            { minionId: 'action_combatant', percent: 4 },
            { minionId: 'action_supply', percent: 2 },
        ],
        trapEncounters: [{ trapId: 'tripwire', percent: 3 }, { trapId: 'flashbang', percent: 3 }, { trapId: 'claymore', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 6, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 15,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 45, chestStealthChance: 15, chestExecuteChance: 4,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 8,
        startingInventory: { key: 1, strike: 0, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        // HP Settings - Hard: tactical combat
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.3, onDeath: 'respawnPenalty', respawnHPPercent: 40,
        safeRoomCount: 2, safeRoomHealPercent: 75, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 30, restInterruptScript: '',
        storyConfig: { mainStory: 'Tactical insertion complete. Two floors of hostiles between you and extraction...' },
        findEarly: { radius: 3, items: ['torch', 'healingPotion'], itemsPerChest: 1 },
    },
    // ===== COMEDY THEME =====
    'Comedy Dungeon - Easy': {
        gridSize: 6, floors: 1, difficulty: 'easy', theme: 'comedy', mapStyle: 'maze', mapVisibility: 'showAll',
        winCommand: '/echo You win! The crowd goes mild!',
        loseCommand: '/echo Wah wah wahhh... Game Over, buddy.',
        winMessage: 'Congratulations! You found the extremely obvious exit!',
        winImage: '',
        mainMinion: 'fantasy_oracle',
        mainMinionIntroMessage: 'Welcome to the World\'s Okayest Dungeon! Try not to trip.',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['Having fun yet?', 'This is fine. Everything is fine.', 'Bruh.'],
        mainMinionExitType: 'prizewheel', mainMinionExitProfile: 'Gambler\'s Wheel',
        minionEncounters: [
            { minionId: 'fantasy_herald', percent: 3 },
            { minionId: 'fantasy_merchant', percent: 2 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 1 }, { trapId: 'magic_rune', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 10, chestLockedPercent: 20, chestLockedBonusPercent: 50, chestMimicPercent: 5,
        chestLootMin: 2, chestLootMax: 4,
        chestKeyChance: 45, chestStrikeChance: 55, chestStealthChance: 20, chestExecuteChance: 3,
        lockedChestKeyChance: 35, lockedChestStrikeChance: 60, lockedChestStealthChance: 25, lockedChestExecuteChance: 5,
        startingInventory: { key: 2, strike: 2, stealth: 1, execute: 0, healingPotion: 3, greaterHealing: 1, elixir: 0, revivalCharm: 0 },
        // HP Settings - Easy: comedy mode, very forgiving
        hpEnabled: true, maxHP: 150, battlebarDamageMultiplier: 0.5, onDeath: 'respawn', respawnHPPercent: 100,
        safeRoomCount: 5, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 50, restCooldown: 1, restInterruptChance: 0, restInterruptScript: '',
        storyConfig: { mainStory: 'Welcome to a dungeon that doesn\'t take itself too seriously. Enjoy!' },
        findEarly: { radius: 5, items: ['lantern', 'torch', 'healingPotion', 'mapFragment'], itemsPerChest: 2 },
    },
    // ===== TURN-BASED TESTING MAZES (PRIORITY) =====
    'Turn-Based Arena - Easy': {
        gridSize: 7, floors: 1, difficulty: 'easy', theme: 'fantasy', mapStyle: 'arena', mapVisibility: 'showAll',
        winCommand: '/echo You are victorious! The crowd roars with approval!',
        loseCommand: '/echo The arena claims another challenger...',
        winMessage: 'You conquered the arena through tactical combat!',
        winImage: '',
        mainMinion: 'fantasy_knight',
        mainMinionIntroMessage: 'Welcome to the arena, warrior. Prove yourself in battle!',
        mainMinionRandomChance: 25,
        mainMinionRandomMessages: ['Another challenger approaches!', 'The crowd demands blood!'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Skeleton Warrior',
        minionEncounters: [
            { minionId: 'fantasy_herald', percent: 2 },
            { minionId: 'fantasy_knight', percent: 4 },
            { minionId: 'fantasy_mage', percent: 3 },
            { minionId: 'fantasy_merchant', percent: 1 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 10, chestLockedPercent: 20, chestLockedBonusPercent: 50, chestMimicPercent: 5,
        chestLootMin: 2, chestLootMax: 4,
        chestKeyChance: 40, chestStrikeChance: 50, chestStealthChance: 20, chestExecuteChance: 2,
        lockedChestKeyChance: 30, lockedChestStrikeChance: 60, lockedChestStealthChance: 30, lockedChestExecuteChance: 5,
        startingInventory: { key: 2, strike: 2, stealth: 1, execute: 0, healingPotion: 3, greaterHealing: 1, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 130, battlebarDamageMultiplier: 0.7, onDeath: 'respawn', respawnHPPercent: 75,
        safeRoomCount: 4, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 30, restCooldown: 2, restInterruptChance: 0, restInterruptScript: '',
        storyConfig: { mainStory: 'The arena gates open. Fight your way to glory through turn-based combat!' },
        findEarly: { radius: 5, items: ['lantern', 'torch', 'healingPotion', 'mapFragment'], itemsPerChest: 2 },
    },
    'Turn-Based Arena - Hard': {
        gridSize: 12, floors: 2, difficulty: 'hard', theme: 'fantasy', mapStyle: 'arena', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Champion! You have proven yourself against all odds!',
        loseCommand: '/echo Even champions fall eventually...',
        winMessage: 'You fought through two floors of warriors to claim victory!',
        winImage: '',
        mainMinion: 'fantasy_knight',
        mainMinionIntroMessage: 'The Grand Champion awaits. Can you defeat me?',
        mainMinionRandomChance: 30,
        mainMinionRandomMessages: ['Your skills are impressive, but not enough!', 'The arena never forgives weakness!'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Boss Battle',
        minionEncounters: [
            { minionId: 'fantasy_knight', percent: 5 },
            { minionId: 'fantasy_mage', percent: 4 },
            { minionId: 'fantasy_assassin', percent: 2 },
            { minionId: 'fantasy_diplomat', percent: 1 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 2 }, { trapId: 'poison_dart', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 6, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 15,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 40, chestStealthChance: 15, chestExecuteChance: 3,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 8,
        startingInventory: { key: 1, strike: 1, stealth: 0, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.3, onDeath: 'respawnPenalty', respawnHPPercent: 50,
        safeRoomCount: 2, safeRoomHealPercent: 75, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 25, restInterruptScript: '',
        storyConfig: { mainStory: 'Two floors of increasingly difficult turn-based battles await. Prepare for war!' },
        findEarly: { radius: 3, items: ['torch', 'healingPotion'], itemsPerChest: 1 },
    },
    // ===== MIXED COMBAT TESTING MAZES =====
    'Combat Gauntlet - Medium': {
        gridSize: 10, floors: 1, difficulty: 'normal', theme: 'fantasy', mapStyle: 'dungeon', mapVisibility: 'fogOfWar',
        winCommand: '/echo You mastered every combat style and emerged victorious!',
        loseCommand: '/echo The gauntlet proved too challenging...',
        winMessage: 'You faced every type of challenge and conquered them all!',
        winImage: '',
        mainMinion: 'fantasy_golem',
        mainMinionIntroMessage: 'The Gauntlet tests all forms of combat. Prove your worth!',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['Every step brings a new challenge!', 'Adapt or perish!'],
        mainMinionExitType: 'puzzle', mainMinionExitProfile: 'Logic Lock',
        minionEncounters: [
            { minionId: 'fantasy_knight', percent: 3 },
            { minionId: 'fantasy_assassin', percent: 2 },
            { minionId: 'fantasy_sphinx', percent: 2 },
            { minionId: 'fantasy_patrol', percent: 2 },
            { minionId: 'fantasy_golem', percent: 2 },
            { minionId: 'fantasy_diplomat', percent: 1 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 2 }, { trapId: 'magic_rune', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 8, chestLockedPercent: 30, chestLockedBonusPercent: 50, chestMimicPercent: 10,
        chestLootMin: 1, chestLootMax: 3,
        chestKeyChance: 35, chestStrikeChance: 45, chestStealthChance: 20, chestExecuteChance: 3,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 7,
        startingInventory: { key: 2, strike: 1, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 100, battlebarDamageMultiplier: 1.0, onDeath: 'respawn', respawnHPPercent: 50,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 20, restCooldown: 3, restInterruptChance: 10, restInterruptScript: '',
        storyConfig: { mainStory: 'The Combat Gauntlet tests every skill: combat, reflexes, stealth, puzzles, and diplomacy!' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'mapFragment'], itemsPerChest: 1 },
    },
    'Cyberpunk Heist - Hard': {
        gridSize: 12, floors: 2, difficulty: 'hard', theme: 'cyberpunk', mapStyle: 'highrise', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Preem job, choom. The data is ours.',
        loseCommand: '/echo Flatlined. Your body will never be found.',
        winMessage: 'You infiltrated the corp tower and extracted the data!',
        winImage: '',
        mainMinion: 'cyber_boss',
        mainMinionIntroMessage: 'You think you can steal from me? The entire tower is now hunting you.',
        mainMinionRandomChance: 25,
        mainMinionRandomMessages: ['Initiating building-wide lockdown.', 'Your biosigns are being tracked.'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Boss Battle',
        minionEncounters: [
            { minionId: 'cyber_samurai', percent: 3 },
            { minionId: 'cyber_netrunner', percent: 3 },
            { minionId: 'cyber_patrol', percent: 3 },
            { minionId: 'cyber_ice', percent: 2 },
            { minionId: 'cyber_fixer_deal', percent: 1 },
        ],
        trapEncounters: [{ trapId: 'electric_floor', percent: 3 }, { trapId: 'neural_spike', percent: 3 }, { trapId: 'security_turret', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 6, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 15,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 40, chestStealthChance: 15, chestExecuteChance: 4,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 50, lockedChestStealthChance: 25, lockedChestExecuteChance: 8,
        startingInventory: { key: 1, strike: 0, stealth: 1, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.3, onDeath: 'respawnPenalty', respawnHPPercent: 40,
        safeRoomCount: 2, safeRoomHealPercent: 75, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 30, restInterruptScript: '',
        storyConfig: { mainStory: 'Infiltrate the megacorp tower. Fight, hack, sneak, and negotiate your way to the data vault!' },
        findEarly: { radius: 3, items: ['torch', 'healingPotion'], itemsPerChest: 1 },
    },
    'Horror Survival - Nightmare': {
        gridSize: 14, floors: 3, difficulty: 'nightmare', theme: 'horror', mapStyle: 'hospital', mapVisibility: 'hideUnexplored',
        winCommand: '/echo You escaped... but the nightmares will never end.',
        loseCommand: '/echo They found you. You are one of them now.',
        winMessage: 'Against all odds, you escaped the nightmare hospital!',
        winImage: '',
        mainMinion: 'horror_butcher',
        mainMinionIntroMessage: 'You should not have come here. Now you will never leave.',
        mainMinionRandomChance: 12,
        mainMinionRandomMessages: ['I can hear your heartbeat...', 'THERE IS NO ESCAPE!', 'Your fear sustains me...'],
        mainMinionExitType: 'turnbased', mainMinionExitProfile: 'Vampire Lord',
        minionEncounters: [
            { minionId: 'horror_wraith', percent: 3 },
            { minionId: 'horror_butcher', percent: 2 },
            { minionId: 'horror_crawler', percent: 3 },
            { minionId: 'horror_stalker', percent: 3 },
            { minionId: 'horror_mirror', percent: 2 },
            { minionId: 'horror_pact', percent: 1 },
        ],
        trapEncounters: [{ trapId: 'ghostly_grasp', percent: 3 }, { trapId: 'blood_pool', percent: 3 }, { trapId: 'cursed_mirror', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 8, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 20,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 35, chestStealthChance: 25, chestExecuteChance: 5,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 45, lockedChestStealthChance: 30, lockedChestExecuteChance: 8,
        startingInventory: { key: 1, strike: 0, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 1 },
        hpEnabled: true, maxHP: 100, battlebarDamageMultiplier: 1.3, onDeath: 'gameover', respawnHPPercent: 25,
        safeRoomCount: 3, safeRoomHealPercent: 75, safeRoomUseLLM: true,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 35, restInterruptScript: '',
        storyConfig: { mainStory: 'Three floors of pure terror. Every corner hides something worse. Survive if you can...' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'stealth'], itemsPerChest: 1 },
    },
    // ===== v1.4.0 BSP ZONE TESTING =====
    'Zone Test - Fantasy': {
        gridSize: 10, floors: 1, difficulty: 'normal', theme: 'fantasy', mapStyle: 'dungeon', mapVisibility: 'hideUnexplored',
        winCommand: '/echo You cleared all zones and escaped!',
        loseCommand: '/echo The zones remain unconquered...',
        winMessage: 'You unlocked every zone and found the exit!',
        winImage: '',
        mainMinion: 'fantasy_guardian',
        mainMinionIntroMessage: 'This dungeon is divided into zones. Clear rooms to unlock the next!',
        mainMinionRandomChance: 15,
        mainMinionRandomMessages: ['More rooms to clear...', 'The next zone awaits!'],
        mainMinionExitType: 'messenger', mainMinionExitProfile: '',
        minionEncounters: [
            { minionId: 'fantasy_herald', percent: 5 },
            { minionId: 'fantasy_guardian', percent: 4 },
            { minionId: 'fantasy_knight', percent: 3 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 12, chestLockedPercent: 25, chestLockedBonusPercent: 50, chestMimicPercent: 5,
        chestLootMin: 2, chestLootMax: 3,
        chestKeyChance: 40, chestStrikeChance: 50, chestStealthChance: 20, chestExecuteChance: 2,
        lockedChestKeyChance: 30, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 5,
        startingInventory: { key: 2, strike: 2, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 120, battlebarDamageMultiplier: 0.8, onDeath: 'respawn', respawnHPPercent: 75,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 25, restCooldown: 2, restInterruptChance: 0, restInterruptScript: '',
        storyConfig: { mainStory: 'The dungeon is divided into three zones. Clear rooms in each zone to unlock the next!' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'mapFragment'], itemsPerChest: 2 },
        bspConfig: { zoneCount: 3, secretDensity: 0, zonesRequireClear: true, secretHints: true, floorComplexityScaling: false },
    },
    'Secret Passage Test': {
        gridSize: 8, floors: 1, difficulty: 'easy', theme: 'fantasy', mapStyle: 'dungeon', mapVisibility: 'hideUnexplored',
        winCommand: '/echo You found all the secrets!',
        loseCommand: '/echo Some secrets remain hidden...',
        winMessage: 'You discovered hidden passages and escaped!',
        winImage: '',
        mainMinion: 'fantasy_oracle',
        mainMinionIntroMessage: 'This dungeon has many secrets. Bump into walls to find hidden passages!',
        mainMinionRandomChance: 15,
        mainMinionRandomMessages: ['There are secrets everywhere...', 'The walls have ears... and doors!'],
        mainMinionExitType: 'messenger', mainMinionExitProfile: '',
        minionEncounters: [
            { minionId: 'fantasy_herald', percent: 3 },
        ],
        trapEncounters: [],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 15, chestLockedPercent: 30, chestLockedBonusPercent: 60, chestMimicPercent: 0,
        chestLootMin: 2, chestLootMax: 4,
        chestKeyChance: 40, chestStrikeChance: 50, chestStealthChance: 20, chestExecuteChance: 2,
        lockedChestKeyChance: 30, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 5,
        startingInventory: { key: 3, strike: 2, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 150, battlebarDamageMultiplier: 0.5, onDeath: 'respawn', respawnHPPercent: 100,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 50, restCooldown: 1, restInterruptChance: 0, restInterruptScript: '',
        storyConfig: { mainStory: 'A dungeon full of secrets! Bump into walls repeatedly to discover hidden passages.' },
        findEarly: { radius: 5, items: ['torch', 'lantern', 'mapFragment'], itemsPerChest: 2 },
        bspConfig: { zoneCount: 1, secretDensity: 0.08, zonesRequireClear: false, secretHints: true, floorComplexityScaling: false },
    },
    'BSP Full Feature Test': {
        gridSize: 12, floors: 2, difficulty: 'normal', theme: 'fantasy', mapStyle: 'dungeon', mapVisibility: 'hideUnexplored',
        winCommand: '/echo Complete mastery of zones and secrets!',
        loseCommand: '/echo The dungeon remains unconquered...',
        winMessage: 'You cleared all zones, found secrets, and conquered both floors!',
        winImage: '',
        mainMinion: 'fantasy_guardian',
        mainMinionIntroMessage: 'Welcome to the ultimate test: zones, secrets, and multi-floor progression!',
        mainMinionRandomChance: 20,
        mainMinionRandomMessages: ['Have you found all the secrets?', 'The next zone awaits...', 'Deeper floors hold greater challenges.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'Dungeon Guardian',
        minionEncounters: [
            { minionId: 'fantasy_herald', percent: 3 },
            { minionId: 'fantasy_guardian', percent: 4 },
            { minionId: 'fantasy_knight', percent: 3 },
            { minionId: 'fantasy_oracle', percent: 2 },
        ],
        trapEncounters: [{ trapId: 'spike_trap', percent: 2 }, { trapId: 'poison_dart', percent: 1 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 10, chestLockedPercent: 30, chestLockedBonusPercent: 50, chestMimicPercent: 10,
        chestLootMin: 1, chestLootMax: 3,
        chestKeyChance: 35, chestStrikeChance: 45, chestStealthChance: 20, chestExecuteChance: 3,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 7,
        startingInventory: { key: 2, strike: 1, stealth: 1, execute: 0, healingPotion: 2, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 100, battlebarDamageMultiplier: 1.0, onDeath: 'respawn', respawnHPPercent: 50,
        safeRoomCount: 3, safeRoomHealPercent: 100, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 20, restCooldown: 3, restInterruptChance: 10, restInterruptScript: '',
        storyConfig: { mainStory: 'Two floors with 4 zones each, secret passages, and complexity scaling. The ultimate BSP test!' },
        findEarly: { radius: 4, items: ['torch', 'healingPotion', 'mapFragment'], itemsPerChest: 1 },
        bspConfig: { zoneCount: 4, secretDensity: 0.05, zonesRequireClear: true, secretHints: true, floorComplexityScaling: true },
    },
    'Sci-Fi Zone Run': {
        gridSize: 10, floors: 2, difficulty: 'hard', theme: 'scifi', mapStyle: 'spacestation', mapVisibility: 'hideUnexplored',
        winCommand: '/echo EXTRACTION COMPLETE. ALL ZONES SECURED.',
        loseCommand: '/echo CONTAINMENT FAILED. OPERATIVE LOST.',
        winMessage: 'You cleared all security zones and reached extraction!',
        winImage: '',
        mainMinion: 'scifi_bot',
        mainMinionIntroMessage: 'ALERT: Station divided into security zones. Clear hostiles to unlock progression.',
        mainMinionRandomChance: 25,
        mainMinionRandomMessages: ['SECTOR LOCKDOWN ACTIVE.', 'ZONE ACCESS DENIED. CLEAR MORE HOSTILES.'],
        mainMinionExitType: 'battlebar', mainMinionExitProfile: 'System Override',
        minionEncounters: [
            { minionId: 'scifi_ai', percent: 4 },
            { minionId: 'scifi_bot', percent: 4 },
            { minionId: 'scifi_matrix', percent: 2 },
        ],
        trapEncounters: [{ trapId: 'laser_grid', percent: 3 }, { trapId: 'gas_leak', percent: 2 }],
        onBattlebarLoss: 'respawn',
        chestTilePercent: 6, chestLockedPercent: 40, chestLockedBonusPercent: 60, chestMimicPercent: 15,
        chestLootMin: 1, chestLootMax: 2,
        chestKeyChance: 30, chestStrikeChance: 45, chestStealthChance: 20, chestExecuteChance: 5,
        lockedChestKeyChance: 25, lockedChestStrikeChance: 55, lockedChestStealthChance: 25, lockedChestExecuteChance: 10,
        startingInventory: { key: 1, strike: 1, stealth: 0, execute: 0, healingPotion: 1, greaterHealing: 0, elixir: 0, revivalCharm: 0 },
        hpEnabled: true, maxHP: 80, battlebarDamageMultiplier: 1.2, onDeath: 'respawn', respawnHPPercent: 40,
        safeRoomCount: 2, safeRoomHealPercent: 80, safeRoomUseLLM: false,
        restEnabled: true, restHealPercent: 15, restCooldown: 4, restInterruptChance: 20, restInterruptScript: '',
        storyConfig: { mainStory: 'Two decks, three security zones per deck. Clear hostiles to unlock zone progression. Find hidden maintenance shafts!' },
        findEarly: { radius: 3, items: ['torch', 'healingPotion'], itemsPerChest: 1 },
        bspConfig: { zoneCount: 3, secretDensity: 0.03, zonesRequireClear: true, secretHints: true, floorComplexityScaling: true },
    },
};

let extensionSettings = {};

// Runtime wheel state
let currentWheel = {
    segments: [],
    isOpen: false,
    isSpinning: false,
    pendingRespin: false,
    hasRespun: false,
};

// Runtime battlebar state
let currentBattlebar = {
    isOpen: false,
    profile: null,
    hits: 0,
    misses: 0,
    arrowPosition: 0,
    arrowDirection: 1,
    zoneStart: 0,
    zoneEnd: 0,
    animationId: null,
    lastFrameTime: 0,
    isVictory: false,
    isDefeat: false,
};

// Runtime turn-based combat state
let currentTurnBased = {
    isOpen: false,
    profile: null,
    profileName: '',
    playerHP: 0,
    playerMaxHP: 0,
    enemyHP: 0,
    enemyMaxHP: 0,
    currentTurn: 'player',
    turnCount: 0,
    isDefending: false,
    isVictory: false,
    isDefeat: false,
    isMazeEncounter: false,
    combatLog: [],
};

// Runtime QTE combat state
let currentQTE = {
    isOpen: false,
    profile: null,
    profileName: '',
    sequence: [],           // Array of keys to press
    currentIndex: 0,        // Current position in sequence
    currentTimeWindow: 0,   // Current time window in ms
    promptStartTime: 0,     // When current prompt started
    timeoutId: null,        // Timeout for current prompt
    successes: 0,           // Number of successful presses
    perfects: 0,            // Number of perfect timing presses
    misses: 0,              // Number of missed prompts
    combo: 0,               // Current combo counter
    maxCombo: 0,            // Best combo achieved
    isComplete: false,      // QTE sequence finished
    isSuccess: false,       // Did player pass the QTE
    combatLog: [],          // Event log
};

// Runtime Dice combat state
let currentDice = {
    isOpen: false,
    profile: null,
    profileName: '',
    diceResults: [],        // Individual die results
    total: 0,               // Sum of dice + modifier
    rawTotal: 0,            // Sum without modifier
    threshold: 0,           // Target to beat
    modifier: 0,            // Applied modifier
    rerollsRemaining: 0,    // Rerolls left
    isCriticalSuccess: false,
    isCriticalFail: false,
    isSuccess: false,
    isComplete: false,
    combatLog: [],
};

// Runtime Stealth encounter state
let currentStealth = {
    isOpen: false,
    profile: null,
    profileName: '',
    currentSection: 0,      // Current section (0-indexed)
    sectionsToPass: 0,      // Total sections to complete
    detection: 0,           // Current detection level
    detectionThreshold: 100,// Max detection before caught
    isSuccess: false,       // Successfully infiltrated
    isCaught: false,        // Was detected
    isComplete: false,      // Encounter finished
    actionsTaken: 0,        // Total actions taken
    combatLog: [],
};

// Runtime Puzzle encounter state
let currentPuzzle = {
    isOpen: false,
    profile: null,
    profileName: '',
    puzzleType: 'sequence',  // sequence, memory, pattern, logic
    gridSize: 3,            // Grid dimension (3x3, 4x4, etc.)
    grid: [],               // The puzzle grid cells
    sequence: [],           // The correct sequence to input
    playerSequence: [],     // Player's current input
    currentStep: 0,         // Current step in sequence
    timeLimit: 0,           // Time limit in seconds
    timeRemaining: 0,       // Remaining time
    timerInterval: null,    // Timer interval reference
    hintsRemaining: 0,      // Hints left to use
    hintsUsed: 0,           // Total hints used
    wrongGuesses: 0,        // Wrong guesses made
    wrongGuessesAllowed: 3, // Max wrong guesses
    score: 0,               // Current score
    isShowingSequence: false, // True during sequence display phase
    isSuccess: false,       // Puzzle solved
    isFailed: false,        // Puzzle failed
    isComplete: false,      // Encounter finished
    combatLog: [],
};

// Runtime Negotiation encounter state
let currentNegotiation = {
    isOpen: false,
    profile: null,
    profileName: '',
    favor: 50,              // Current favor/disposition (0-100)
    favorThreshold: 75,     // Favor needed to succeed
    turnsRemaining: 0,      // Turns left
    turnsUsed: 0,           // Total turns taken
    lastAction: '',         // Last action taken
    lastResult: '',         // Result of last action
    isSuccess: false,       // Negotiation succeeded
    isFailed: false,        // Negotiation failed
    isComplete: false,      // Encounter finished
    combatLog: [],
};

// v1.4.8: Track LLM generation state for visual indicator
let isLLMGenerating = false;

// Runtime maze state
let currentMaze = {
    isOpen: false,
    profile: null,
    profileName: null,
    grid: [],
    size: 10,
    playerX: 0,
    playerY: 0,
    exitX: 0,
    exitY: 0,
    visited: new Set(),
    isVictory: false,
    currentMinion: null,
    // Encounter system
    isPaused: false,              // True during encounters
    pendingEncounter: null,       // Current encounter being processed
    exitEncounterDone: false,     // Has exit boss been defeated
    // v1.2.0 Multi-floor system
    currentFloor: 0,              // Current floor index (0-based)
    totalFloors: 1,               // Total number of floors
    floors: [],                   // Array of floor grids
    // Inventory system
    inventory: {
        key: 0,
        stealth: 0,
        strike: 0,
        execute: 0,
        // v1.2.0 new items
        floorKey: 0,
        portalStone: 0,
        minionBane: 0,
        mapFragment: 0,
        timeShard: 0,
        voidWalk: 0,
        // v1.3.0 HP System items
        healingPotion: 0,
        greaterHealing: 0,
        elixir: 0,
        revivalCharm: 0,
        heartCrystal: 0,
        // v1.3.2 Visibility items
        torch: 0,           // Temporary +2 visibility radius (3 moves)
        lantern: 0,         // Passive +1 visibility radius while held
        revealScroll: 0,    // Reveals entire floor for 1 move
        sightPotion: 0,     // Permanent +1 visibility buff (consumed)
        crystalBall: 0,     // Reveals all minions on current floor
    },
    // v1.3.2 Visibility system
    visibility: {
        baseRadius: 1,          // Default visibility radius
        tempBonus: 0,           // From torch (decrements each move)
        tempMovesLeft: 0,       // Moves remaining for temp bonus
        permBonus: 0,           // From consumed sightPotion
        floorRevealed: false,   // Reveal scroll active this move
    },
    pendingConfirmation: null,    // { type, minionId, x, y, canSlipAway }
    pendingChest: null,           // { chestData, x, y } for Open/Ignore flow
    voidWalkActive: false,        // v1.2.0: Void Walk active for next move
    messageLog: [],               // v1.2.1: Persistent message history
    // v1.3.0 HP System
    hpEnabled: true,
    hp: {
        current: 100,
        max: 100,
        maxBonus: 0,
        reviveCharges: 0,
    },
};

// Last game results (for macros and tracking)
const lastResults = {
    wheel: {},      // { profileName: { segmentName, command, timestamp } }
    battlebar: {}, // { profileName: { result: 'win'|'lose', hits, misses, timestamp } }
    maze: {},       // { profileName: { result: 'win', timestamp } }
};

// Track processed messages to avoid reprocessing macros
const processedMacroMessages = new WeakSet();

// =============================================================================
// LLM MESSAGE GENERATION
// =============================================================================

/**
 * Generate a minion message using the LLM
 * @param {object} options - Generation options
 * @param {string} options.minionName - Name of the minion speaking
 * @param {string} options.minionDescription - Description of the minion character
 * @param {string} options.baseMessage - Base message/template to expand
 * @param {string} options.mainStory - Main story context (optional)
 * @param {string} options.currentMilestone - Current milestone story update (optional)
 * @param {string} options.minionType - Type of minion (messenger, battlebar, prizewheel, merchant, turnbased, qte, dice, stealth, puzzle, negotiation)
 * @returns {Promise<string>} Generated message or fallback to baseMessage
 */
async function generateMinionMessage(options) {
    const { minionName, minionDescription, baseMessage, mainStory, currentMilestone, minionType } = options;

    // If no baseMessage, nothing to generate
    if (!baseMessage) return '';

    // Check if LLM generation is enabled
    if (extensionSettings.llmEnabled === false) {
        console.log('[MazeMaster] LLM generation disabled, using base message');
        return baseMessage;
    }

    // Check if generateQuietPrompt is available
    if (typeof generateQuietPrompt !== 'function') {
        console.log('[MazeMaster] generateQuietPrompt not available, using base message');
        return baseMessage;
    }

    // Build the context prompt
    let contextParts = [];

    if (mainStory) {
        contextParts.push(`Story Setting: ${mainStory}`);
    }

    if (currentMilestone) {
        contextParts.push(`Current Progress: ${currentMilestone}`);
    }

    // Use custom description if provided, otherwise fall back to type-based role
    const minionRole = minionDescription || {
        messenger: 'a mysterious messenger who delivers cryptic hints',
        battlebar: 'a guardian who challenges travelers to combat',
        prizewheel: 'a fortune teller who offers games of chance',
        merchant: 'a wandering trader who barters for rare items',
    }[minionType] || 'a mysterious figure';

    // Get the player's name for personalization
    const playerName = getCurrentPersonaName();

    const prompt = `You are ${minionName}, ${minionRole}.
The player's name is ${playerName}.

${contextParts.length > 0 ? contextParts.join('\n') + '\n\n' : ''}The player has encountered you in a maze. Based on this message template: "${baseMessage}"

Write a short, atmospheric response (1-2 sentences max, under 100 characters if possible). Stay in character. Be mysterious and engaging. You may address the player by name if appropriate. Do not use quotation marks around your response.`;

    try {
        console.log('[MazeMaster] Generating LLM message for:', minionName);

        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,  // v1.2.0: Disable lorebooks during maze generation
            max_length: 80, // Keep responses short
        });

        if (response && response.trim()) {
            // Clean up the response - remove quotes, trim
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            console.log('[MazeMaster] Generated message:', cleaned);
            return cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] LLM generation failed:', error);
    }

    // Fallback to base message
    return baseMessage;
}

/**
 * Generate a trap message using the LLM
 * @param {object} options - Generation options
 * @param {string} options.trapName - Name of the trap
 * @param {string} options.baseMessage - Base message to expand
 * @param {string} options.mainStory - Main story context (optional)
 * @returns {Promise<string>} Generated message or fallback to baseMessage
 */
async function generateTrapMessage(options) {
    const { trapName, baseMessage, mainStory } = options;

    if (!baseMessage) return '';

    if (extensionSettings.llmEnabled === false) {
        return baseMessage;
    }

    if (typeof generateQuietPrompt !== 'function') {
        return baseMessage;
    }

    const playerName = getCurrentPersonaName();

    const prompt = `The player ${playerName} has triggered a trap called "${trapName}" in a maze.

${mainStory ? `Story Setting: ${mainStory}\n\n` : ''}Based on this trap description: "${baseMessage}"

Write a short, dramatic narration of the trap being triggered (1-2 sentences, under 100 characters). Make it visceral and immediate. You may reference the player by name. Do not use quotation marks.`;

    try {
        console.log('[MazeMaster] Generating LLM message for trap:', trapName);

        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,  // v1.2.0: Disable lorebooks during maze generation
            max_length: 80,
        });

        if (response && response.trim()) {
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            console.log('[MazeMaster] Generated trap message:', cleaned);
            return cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] Trap LLM generation failed:', error);
    }

    return baseMessage;
}

/**
 * Generate a battlebar stage message using the LLM
 * @param {object} options - Generation options
 * @param {string} options.battlebarName - Name of the battlebar/fight
 * @param {string} options.description - Description of the battlebar encounter
 * @param {string} options.stageMessage - Current stage message
 * @param {string} options.mainStory - Main story context (optional)
 * @param {number} options.currentHits - Current hit count
 * @param {number} options.hitsToWin - Hits needed to win
 * @returns {Promise<string>} Generated message or fallback to stageMessage
 */
async function generateBattlebarMessage(options) {
    const { battlebarName, description, stageMessage, mainStory, currentHits, hitsToWin } = options;

    if (!stageMessage) return '';

    if (extensionSettings.llmEnabled === false) {
        return stageMessage;
    }

    if (typeof generateQuietPrompt !== 'function') {
        return stageMessage;
    }

    const progress = currentHits !== undefined && hitsToWin ? `Progress: ${currentHits}/${hitsToWin} hits` : '';
    const battleDesc = description || 'a challenging combat encounter';
    const playerName = getCurrentPersonaName();

    const prompt = `The player ${playerName} is in a battle called "${battlebarName}" - ${battleDesc}.

${mainStory ? `Story Setting: ${mainStory}\n\n` : ''}${progress ? progress + '\n\n' : ''}Based on this stage message: "${stageMessage}"

Write a short, intense combat narration (1-2 sentences, under 100 characters). Make it exciting and dramatic. You may reference the player by name. Do not use quotation marks.`;

    try {
        console.log('[MazeMaster] Generating LLM message for battlebar:', battlebarName);

        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,  // v1.2.0: Disable lorebooks during maze generation
            max_length: 80,
        });

        if (response && response.trim()) {
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            console.log('[MazeMaster] Generated battlebar message:', cleaned);
            return cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] Battlebar LLM generation failed:', error);
    }

    return stageMessage;
}

/**
 * Generate a chest message using the LLM
 * @param {object} options - Generation options
 * @param {string} options.chestType - Type of chest ('normal' or 'locked')
 * @param {string} options.baseMessage - Base message to expand
 * @param {string} options.mainStory - Main story context (optional)
 * @param {boolean} options.hasKey - Whether player has a key (for locked chests)
 * @returns {Promise<string>} Generated message or fallback to baseMessage
 */
async function generateChestMessage(options) {
    const { chestType, baseMessage, mainStory, hasKey } = options;

    if (!baseMessage) return '';

    if (extensionSettings.llmEnabled === false) {
        return baseMessage;
    }

    if (typeof generateQuietPrompt !== 'function') {
        return baseMessage;
    }

    const chestDesc = chestType === 'locked'
        ? (hasKey ? 'a locked treasure chest - the player has a key to open it' : 'a locked treasure chest - the player lacks the key')
        : 'a treasure chest waiting to be opened';
    const playerName = getCurrentPersonaName();

    const prompt = `The player ${playerName} has discovered ${chestDesc} in a maze.

${mainStory ? `Story Setting: ${mainStory}\n\n` : ''}Based on this chest discovery message: "${baseMessage}"

Write a short, atmospheric description of finding the chest (1-2 sentences, under 100 characters). Make it feel rewarding and mysterious. You may reference the player by name. Do not use quotation marks.`;

    try {
        console.log('[MazeMaster] Generating LLM message for chest');

        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,  // v1.2.0: Disable lorebooks during maze generation
            max_length: 80,
        });

        if (response && response.trim()) {
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            console.log('[MazeMaster] Generated chest message:', cleaned);
            return cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] Chest LLM generation failed:', error);
    }

    return baseMessage;
}

/**
 * Generate LLM-enhanced room description
 * @param {Object} options - Room context for LLM generation
 * @returns {Promise<string>} Enhanced description or original
 */
async function generateEnhancedRoomDescription(options) {
    const { roomName, roomType, baseDescription, theme, sessionNotes } = options;

    // Check if LLM generation is available
    if (typeof generateQuietPrompt !== 'function') {
        console.log('[MazeMaster] generateQuietPrompt not available');
        return baseDescription;
    }

    // Check if LLM is globally enabled
    if (extensionSettings.llmEnabled === false) {
        return baseDescription;
    }

    // Get additional context
    const profile = currentMaze?.profile || {};
    const mainStory = profile.storyConfig?.mainStory || '';
    const currentFloor = (currentMaze?.currentFloor || 0) + 1;
    const totalFloors = currentMaze?.totalFloors || 1;
    const playerName = getCurrentPersonaName();

    // Truncate session notes to last ~500 chars for context
    const recentNotes = sessionNotes
        ? sessionNotes.slice(-500).split('\n').slice(-5).join('\n')
        : '';

    const prompt = `You are the narrator for a ${theme} dungeon crawler game.
Player: ${playerName}
Floor: ${currentFloor}/${totalFloors}
${mainStory ? `Story: ${mainStory}\n` : ''}
${recentNotes ? `Recent events:\n${recentNotes}\n` : ''}
The player enters "${roomName}" (a ${roomType || 'standard'} room).
Base description: "${baseDescription}"

Write a vivid, atmospheric description (2-3 sentences max). Reference recent events if relevant. Stay in theme. Do not use quotation marks.`;

    try {
        console.log('[MazeMaster] Generating enhanced room description for:', roomName);

        const response = await generateQuietPrompt(prompt, {
            quietToLoud: false,
            skipWIAN: true,
            skipWI: true,
            max_length: 150,
        });

        if (response && response.trim()) {
            let cleaned = response.trim();
            cleaned = cleaned.replace(/^["']|["']$/g, '');
            cleaned = cleaned.replace(/^["""''']|["""''']$/g, '');
            console.log('[MazeMaster] Enhanced description:', cleaned);
            return cleaned;
        }
    } catch (error) {
        console.error('[MazeMaster] Room description LLM failed:', error);
    }

    return baseDescription;
}

/**
 * Enhance room description on first entry and cache it
 * @param {number} x - Room X coordinate
 * @param {number} y - Room Y coordinate
 */
async function enhanceRoomOnEntry(x, y) {
    console.log('[MazeMaster] enhanceRoomOnEntry called:', { x, y });

    if (!currentMaze?.isOpen || !currentMaze.profile) {
        console.log('[MazeMaster] Enhancement skipped: maze not open or no profile');
        return;
    }

    // Check if LLM enhancement is enabled for this maze
    if (!currentMaze.profile.llmEnhanceRooms) {
        console.log('[MazeMaster] Enhancement skipped: llmEnhanceRooms disabled in profile', currentMaze.profile.llmEnhanceRooms);
        return;
    }

    const floor = currentMaze.currentFloor || 0;
    const roomKey = `${floor}:${x},${y}`;

    // Check if already enhanced
    if (currentMaze.enhancedRooms?.[roomKey]) {
        console.log('[MazeMaster] Room already enhanced:', roomKey);
        return;
    }

    const cell = currentMaze.grid[y]?.[x];
    if (!cell || !cell.roomInfo) {
        console.log('[MazeMaster] Enhancement skipped: no cell or roomInfo at', { x, y, hasCell: !!cell, hasRoomInfo: !!cell?.roomInfo });
        return;
    }

    console.log('[MazeMaster] Proceeding with room enhancement for:', roomKey);

    const baseDescription = cell.roomInfo.description || '...';
    const roomName = cell.roomInfo.name || 'Unknown Room';
    const roomType = cell.roomInfo.type || 'standard';
    const theme = currentMaze.profile.theme || 'fantasy';

    // Show generating indicator
    showGeneratingIndicator(true);

    try {
        const enhanced = await generateEnhancedRoomDescription({
            roomName,
            roomType,
            baseDescription,
            theme,
            sessionNotes: currentMaze.sessionNotes || '',
        });

        // Store enhanced description
        if (!currentMaze.enhancedRooms) currentMaze.enhancedRooms = {};
        currentMaze.enhancedRooms[roomKey] = enhanced;

        // Update cell's roomInfo for immediate display
        cell.roomInfo.enhancedDescription = enhanced;

        // Add to session notes (include enhanced description for future LLM context)
        addSessionNote(`${roomName}: ${enhanced}`, 'Explore');

        // Update room info display
        updateRoomInfoBox();

        console.log('[MazeMaster] Room enhanced and cached:', roomKey);
    } catch (error) {
        console.error('[MazeMaster] Room enhancement failed:', error);
    } finally {
        showGeneratingIndicator(false);
    }
}

/**
 * Get current story milestone based on maze progress
 * @returns {string|null} Current milestone text or null
 */
function getCurrentMilestone() {
    if (!currentMaze.isOpen || !currentMaze.profile) return null;

    const storyConfig = currentMaze.profile.storyConfig;
    if (!storyConfig || !storyConfig.milestones || storyConfig.milestones.length === 0) return null;

    // Calculate maze progress percentage
    const totalCells = currentMaze.size * currentMaze.size;
    const visitedCount = currentMaze.visited?.size || 0;
    const progressPercent = (visitedCount / totalCells) * 100;

    // Find the highest milestone that has been reached
    let currentMilestoneText = null;
    for (const milestone of storyConfig.milestones) {
        if (progressPercent >= milestone.percent) {
            currentMilestoneText = milestone.storyUpdate;
        }
    }

    return currentMilestoneText;
}

/**
 * Get the main story from the current maze profile
 * @returns {string|null} Main story text or null
 */
function getMainStory() {
    if (!currentMaze.isOpen || !currentMaze.profile) return null;
    return currentMaze.profile.storyConfig?.mainStory || null;
}

// =============================================================================
// SETTINGS
// =============================================================================

/**
 * Force-update all factory default assets (traps, minions, profiles, etc.)
 * This overwrites saved versions with the latest code defaults
 */
function resetFactoryDefaults() {
    console.log('[MazeMaster] Resetting all factory defaults to version', FACTORY_DEFAULTS_VERSION);

    // Reset factory traps
    for (const [id, trap] of Object.entries(DEFAULT_TRAPS)) {
        extensionSettings.traps[id] = JSON.parse(JSON.stringify(trap));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_TRAPS).length, 'factory traps');

    // Reset factory minions
    for (const [id, minion] of Object.entries(DEFAULT_MINIONS)) {
        extensionSettings.minions[id] = JSON.parse(JSON.stringify(minion));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_MINIONS).length, 'factory minions');

    // Reset factory wheel profiles
    for (const [name, profile] of Object.entries(DEFAULT_WHEEL_PROFILES)) {
        extensionSettings.profiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_WHEEL_PROFILES).length, 'factory wheel profiles');

    // Reset factory battlebar profiles
    for (const [name, profile] of Object.entries(DEFAULT_BATTLEBAR_PROFILES)) {
        extensionSettings.battlebarProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_BATTLEBAR_PROFILES).length, 'factory battlebar profiles');

    // Reset factory turn-based profiles
    for (const [name, profile] of Object.entries(DEFAULT_TURNBASED_PROFILES)) {
        extensionSettings.turnbasedProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_TURNBASED_PROFILES).length, 'factory turn-based profiles');

    // Reset factory QTE profiles
    for (const [name, profile] of Object.entries(DEFAULT_QTE_PROFILES)) {
        extensionSettings.qteProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_QTE_PROFILES).length, 'factory QTE profiles');

    // Reset factory Dice profiles
    for (const [name, profile] of Object.entries(DEFAULT_DICE_PROFILES)) {
        extensionSettings.diceProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_DICE_PROFILES).length, 'factory Dice profiles');

    // Reset factory Stealth profiles
    for (const [name, profile] of Object.entries(DEFAULT_STEALTH_PROFILES)) {
        extensionSettings.stealthProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_STEALTH_PROFILES).length, 'factory Stealth profiles');

    // Reset factory Puzzle profiles
    for (const [name, profile] of Object.entries(DEFAULT_PUZZLE_PROFILES)) {
        extensionSettings.puzzleProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_PUZZLE_PROFILES).length, 'factory Puzzle profiles');

    // Reset factory Negotiation profiles
    for (const [name, profile] of Object.entries(DEFAULT_NEGOTIATION_PROFILES)) {
        extensionSettings.negotiationProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_NEGOTIATION_PROFILES).length, 'factory Negotiation profiles');

    // Reset factory maze profiles
    for (const [name, profile] of Object.entries(DEFAULT_MAZE_PROFILE)) {
        extensionSettings.mazeProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_MAZE_PROFILE).length, 'factory maze profiles');

    // Reset factory minion profiles (packs)
    for (const [name, profile] of Object.entries(DEFAULT_MINION_PROFILES)) {
        extensionSettings.minionProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_MINION_PROFILES).length, 'factory minion profiles');

    // Reset factory trap profiles (packs)
    for (const [name, profile] of Object.entries(DEFAULT_TRAP_PROFILES)) {
        extensionSettings.trapProfiles[name] = JSON.parse(JSON.stringify(profile));
    }
    console.log('[MazeMaster] Reset', Object.keys(DEFAULT_TRAP_PROFILES).length, 'factory trap profiles');

    // Update the stored version
    extensionSettings.factoryDefaultsVersion = FACTORY_DEFAULTS_VERSION;

    console.log('[MazeMaster] Factory defaults reset complete');
}

function loadSettings() {
    const context = SillyTavern.getContext();

    // Initialize settings if they don't exist
    if (!context.extensionSettings[MODULE_NAME]) {
        context.extensionSettings[MODULE_NAME] = JSON.parse(JSON.stringify(defaultSettings));
    }

    // Get reference to stored settings
    extensionSettings = context.extensionSettings[MODULE_NAME];

    // Check if factory defaults need to be reset (version changed)
    const storedVersion = extensionSettings.factoryDefaultsVersion || 0;
    if (storedVersion < FACTORY_DEFAULTS_VERSION) {
        console.log(`[MazeMaster] Factory defaults version changed: ${storedVersion} -> ${FACTORY_DEFAULTS_VERSION}`);
        // Ensure storage objects exist before reset
        if (!extensionSettings.traps) extensionSettings.traps = {};
        if (!extensionSettings.minions) extensionSettings.minions = {};
        if (!extensionSettings.profiles) extensionSettings.profiles = {};
        if (!extensionSettings.battlebarProfiles) extensionSettings.battlebarProfiles = {};
        if (!extensionSettings.turnbasedProfiles) extensionSettings.turnbasedProfiles = {};
        if (!extensionSettings.qteProfiles) extensionSettings.qteProfiles = {};
        if (!extensionSettings.diceProfiles) extensionSettings.diceProfiles = {};
        if (!extensionSettings.stealthProfiles) extensionSettings.stealthProfiles = {};
        if (!extensionSettings.puzzleProfiles) extensionSettings.puzzleProfiles = {};
        if (!extensionSettings.negotiationProfiles) extensionSettings.negotiationProfiles = {};
        if (!extensionSettings.mazeProfiles) extensionSettings.mazeProfiles = {};
        if (!extensionSettings.minionProfiles) extensionSettings.minionProfiles = {};
        if (!extensionSettings.trapProfiles) extensionSettings.trapProfiles = {};
        resetFactoryDefaults();
        saveSettingsDebounced();
    }

    // Fill in any missing defaults
    for (const key in defaultSettings) {
        if (extensionSettings[key] === undefined) {
            extensionSettings[key] = JSON.parse(JSON.stringify(defaultSettings[key]));
        }
    }

    // Ensure profiles objects exist
    if (!extensionSettings.profiles) {
        extensionSettings.profiles = {};
    }
    if (!extensionSettings.battlebarProfiles) {
        extensionSettings.battlebarProfiles = {};
    }
    if (!extensionSettings.mazeProfiles) {
        extensionSettings.mazeProfiles = {};
    }
    if (!extensionSettings.minions) {
        extensionSettings.minions = {};
    }
    if (!extensionSettings.traps) {
        extensionSettings.traps = {};
    }
    if (!extensionSettings.savedMazes) {
        extensionSettings.savedMazes = {};
    }
    if (!extensionSettings.minionProfiles) {
        extensionSettings.minionProfiles = {};
    }
    if (!extensionSettings.trapProfiles) {
        extensionSettings.trapProfiles = {};
    }

    // Always merge in default example data (won't overwrite existing profiles with same name)
    let needsSave = false;

    // Merge default wheel profiles
    for (const [name, profile] of Object.entries(DEFAULT_WHEEL_PROFILES)) {
        if (!extensionSettings.profiles[name]) {
            extensionSettings.profiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default wheel profile: ${name}`);
        }
    }

    // Migration: Fix broken wheel profiles with duplicate/empty triggers
    for (const [name, defaultProfile] of Object.entries(DEFAULT_WHEEL_PROFILES)) {
        const savedProfile = extensionSettings.profiles[name];
        if (savedProfile?.segments?.length > 0) {
            const triggers = savedProfile.segments.map(s => s.trigger);
            const uniqueTriggers = new Set(triggers);
            // If all triggers are the same (broken), or any are empty, replace with default
            if (uniqueTriggers.size === 1 || triggers.some(t => !t || t === '')) {
                extensionSettings.profiles[name] = JSON.parse(JSON.stringify(defaultProfile));
                needsSave = true;
                console.log(`[MazeMaster] Fixed broken wheel profile: ${name}`);
            }
        }
    }

    if (!extensionSettings.currentProfile) {
        extensionSettings.currentProfile = 'Blessing Wheel';
    }

    // Merge default battlebar profiles
    for (const [name, profile] of Object.entries(DEFAULT_BATTLEBAR_PROFILES)) {
        if (!extensionSettings.battlebarProfiles[name]) {
            extensionSettings.battlebarProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default battlebar profile: ${name}`);
        }
    }
    if (!extensionSettings.currentBattlebarProfile) {
        extensionSettings.currentBattlebarProfile = 'Training Dummy';
    }

    // Update existing battlebar profiles with any missing fields from defaults
    const defaultBbTemplate = DEFAULT_BATTLEBAR_PROFILES['Training Dummy'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.battlebarProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultBbTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to battlebar profile: ${name}`);
            }
        }
    }

    // Initialize turn-based profiles storage
    if (!extensionSettings.turnbasedProfiles) {
        extensionSettings.turnbasedProfiles = {};
        needsSave = true;
    }

    // Merge default turn-based profiles
    for (const [name, profile] of Object.entries(DEFAULT_TURNBASED_PROFILES)) {
        if (!extensionSettings.turnbasedProfiles[name]) {
            extensionSettings.turnbasedProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default turn-based profile: ${name}`);
        }
    }
    if (!extensionSettings.currentTurnbasedProfile) {
        extensionSettings.currentTurnbasedProfile = 'Training Bout';
    }

    // Update existing turn-based profiles with any missing fields from defaults
    const defaultTbTemplate = DEFAULT_TURNBASED_PROFILES['Training Bout'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.turnbasedProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultTbTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to turn-based profile: ${name}`);
            }
        }
    }

    // Initialize QTE profiles storage
    if (!extensionSettings.qteProfiles) {
        extensionSettings.qteProfiles = {};
        needsSave = true;
    }

    // Merge default QTE profiles
    for (const [name, profile] of Object.entries(DEFAULT_QTE_PROFILES)) {
        if (!extensionSettings.qteProfiles[name]) {
            extensionSettings.qteProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default QTE profile: ${name}`);
        }
    }
    if (!extensionSettings.currentQteProfile) {
        extensionSettings.currentQteProfile = 'Reaction Test';
    }

    // Update existing QTE profiles with any missing fields from defaults
    const defaultQteTemplate = DEFAULT_QTE_PROFILES['Reaction Test'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.qteProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultQteTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to QTE profile: ${name}`);
            }
        }
    }

    // Initialize Dice profiles storage
    if (!extensionSettings.diceProfiles) {
        extensionSettings.diceProfiles = {};
        needsSave = true;
    }

    // Merge default Dice profiles
    for (const [name, profile] of Object.entries(DEFAULT_DICE_PROFILES)) {
        if (!extensionSettings.diceProfiles[name]) {
            extensionSettings.diceProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default Dice profile: ${name}`);
        }
    }
    if (!extensionSettings.currentDiceProfile) {
        extensionSettings.currentDiceProfile = 'Lucky Roll';
    }

    // Update existing Dice profiles with any missing fields from defaults
    const defaultDiceTemplate = DEFAULT_DICE_PROFILES['Lucky Roll'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.diceProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultDiceTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to Dice profile: ${name}`);
            }
        }
    }

    // Initialize Stealth profiles storage
    if (!extensionSettings.stealthProfiles) {
        extensionSettings.stealthProfiles = {};
        needsSave = true;
    }

    // Merge default Stealth profiles
    for (const [name, profile] of Object.entries(DEFAULT_STEALTH_PROFILES)) {
        if (!extensionSettings.stealthProfiles[name]) {
            extensionSettings.stealthProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default Stealth profile: ${name}`);
        }
    }
    if (!extensionSettings.currentStealthProfile) {
        extensionSettings.currentStealthProfile = 'Simple Sneak';
    }

    // Update existing Stealth profiles with any missing fields from defaults
    const defaultStealthTemplate = DEFAULT_STEALTH_PROFILES['Simple Sneak'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.stealthProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultStealthTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to Stealth profile: ${name}`);
            }
        }
    }

    // Initialize Puzzle profiles storage
    if (!extensionSettings.puzzleProfiles) {
        extensionSettings.puzzleProfiles = {};
        needsSave = true;
    }

    // Merge default Puzzle profiles
    for (const [name, profile] of Object.entries(DEFAULT_PUZZLE_PROFILES)) {
        if (!extensionSettings.puzzleProfiles[name]) {
            extensionSettings.puzzleProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default Puzzle profile: ${name}`);
        }
    }
    if (!extensionSettings.currentPuzzleProfile) {
        extensionSettings.currentPuzzleProfile = 'Simple Riddle';
    }

    // Update existing Puzzle profiles with any missing fields from defaults
    const defaultPuzzleTemplate = DEFAULT_PUZZLE_PROFILES['Simple Riddle'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.puzzleProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultPuzzleTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to Puzzle profile: ${name}`);
            }
        }
    }

    // Initialize Negotiation profiles storage
    if (!extensionSettings.negotiationProfiles) {
        extensionSettings.negotiationProfiles = {};
        needsSave = true;
    }

    // Merge default Negotiation profiles
    for (const [name, profile] of Object.entries(DEFAULT_NEGOTIATION_PROFILES)) {
        if (!extensionSettings.negotiationProfiles[name]) {
            extensionSettings.negotiationProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default Negotiation profile: ${name}`);
        }
    }
    if (!extensionSettings.currentNegotiationProfile) {
        extensionSettings.currentNegotiationProfile = 'Friendly Chat';
    }

    // Update existing Negotiation profiles with any missing fields from defaults
    const defaultNegotiationTemplate = DEFAULT_NEGOTIATION_PROFILES['Friendly Chat'];
    for (const [name, savedProfile] of Object.entries(extensionSettings.negotiationProfiles)) {
        for (const [key, defaultValue] of Object.entries(defaultNegotiationTemplate)) {
            if (savedProfile[key] === undefined) {
                savedProfile[key] = JSON.parse(JSON.stringify(defaultValue));
                needsSave = true;
                console.log(`[MazeMaster] Added missing field "${key}" to Negotiation profile: ${name}`);
            }
        }
    }

    // Initialize Merchant Item Pools storage
    if (!extensionSettings.merchantItemPools) {
        extensionSettings.merchantItemPools = {};
        needsSave = true;
    }

    // Merge default Merchant Item Pools
    for (const [name, pool] of Object.entries(DEFAULT_MERCHANT_ITEM_POOLS)) {
        if (!extensionSettings.merchantItemPools[name]) {
            extensionSettings.merchantItemPools[name] = JSON.parse(JSON.stringify(pool));
            needsSave = true;
            console.log(`[MazeMaster] Added default Merchant Item Pool: ${name}`);
        }
    }

    // Merge default minions
    for (const [id, minion] of Object.entries(DEFAULT_MINIONS)) {
        if (!extensionSettings.minions[id]) {
            extensionSettings.minions[id] = JSON.parse(JSON.stringify(minion));
            needsSave = true;
            console.log(`[MazeMaster] Added default minion: ${id}`);
        }
    }

    // Merge default traps
    for (const [id, trap] of Object.entries(DEFAULT_TRAPS)) {
        if (!extensionSettings.traps[id]) {
            extensionSettings.traps[id] = JSON.parse(JSON.stringify(trap));
            needsSave = true;
            console.log(`[MazeMaster] Added default trap: ${id}`);
        }
    }

    // Merge default minion profiles (saved sets of minions)
    for (const [name, profile] of Object.entries(DEFAULT_MINION_PROFILES)) {
        if (!extensionSettings.minionProfiles[name]) {
            extensionSettings.minionProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default minion profile: ${name}`);
        }
    }

    // Merge default trap profiles (saved sets of traps)
    for (const [name, profile] of Object.entries(DEFAULT_TRAP_PROFILES)) {
        if (!extensionSettings.trapProfiles[name]) {
            extensionSettings.trapProfiles[name] = JSON.parse(JSON.stringify(profile));
            needsSave = true;
            console.log(`[MazeMaster] Added default trap profile: ${name}`);
        }
    }

    // Merge default maze profile (and update existing with missing or empty fields)
    for (const [name, defaultProfile] of Object.entries(DEFAULT_MAZE_PROFILE)) {
        if (!extensionSettings.mazeProfiles[name]) {
            extensionSettings.mazeProfiles[name] = JSON.parse(JSON.stringify(defaultProfile));
            needsSave = true;
            console.log(`[MazeMaster] Added default maze profile: ${name}`);
        } else {
            // Update existing profile with any missing or empty fields from default
            const existing = extensionSettings.mazeProfiles[name];
            for (const [key, value] of Object.entries(defaultProfile)) {
                // Check if the existing value is empty/missing
                const isEmptyArray = Array.isArray(existing[key]) && existing[key].length === 0;
                const isEmptyObject = typeof existing[key] === 'object' && existing[key] !== null &&
                    !Array.isArray(existing[key]) && Object.keys(existing[key]).length === 0;
                // gridSize specifically must be a positive number
                const isInvalidGridSize = key === 'gridSize' && (!existing[key] || existing[key] < 5);
                const isEmpty = existing[key] === undefined || isEmptyArray || isEmptyObject || isInvalidGridSize;

                // Also check if startingInventory has all zero values (treat as empty)
                const isZeroInventory = key === 'startingInventory' && existing[key] &&
                    typeof existing[key] === 'object' &&
                    (existing[key].key || 0) === 0 &&
                    (existing[key].stealth || 0) === 0 &&
                    (existing[key].strike || 0) === 0 &&
                    (existing[key].execute || 0) === 0;

                if ((isEmpty || isZeroInventory) && value && (Array.isArray(value) ? value.length > 0 : true)) {
                    existing[key] = JSON.parse(JSON.stringify(value));
                    needsSave = true;
                    console.log(`[MazeMaster] Added missing/empty field '${key}' to maze profile: ${name}`);
                }
            }
        }
    }
    if (!extensionSettings.currentMazeProfile) {
        extensionSettings.currentMazeProfile = 'Dungeon Crawl';
    }

    // Save to ensure structure is persisted
    if (needsSave) {
        saveSettingsDebounced();
    }

    console.log('[MazeMaster] Loaded settings:', extensionSettings);
}

function getProfileNames() {
    return Object.keys(extensionSettings.profiles || {});
}

function getProfile(name) {
    return extensionSettings.profiles[name];
}

function saveProfile(name, segments, randomize = false, difficulty = 1) {
    extensionSettings.profiles[name] = { segments, randomize, difficulty };
    saveSettingsDebounced();
    console.log('[MazeMaster] Profile saved:', name, extensionSettings.profiles[name]);
}

function deleteProfile(name) {
    delete extensionSettings.profiles[name];
    if (extensionSettings.currentProfile === name) {
        const remaining = getProfileNames();
        extensionSettings.currentProfile = remaining[0] || 'default';
    }
    saveSettingsDebounced();
}

// Battlebar profile functions
function getBattlebarProfileNames() {
    return Object.keys(extensionSettings.battlebarProfiles || {});
}

function getBattlebarProfile(name) {
    return extensionSettings.battlebarProfiles[name];
}

function saveBattlebarProfile(name, profileData) {
    extensionSettings.battlebarProfiles[name] = {
        mainTitle: profileData.mainTitle || '',
        description: profileData.description || '',
        difficulty: profileData.difficulty || 3,
        hitsToWin: profileData.hitsToWin || 5,
        missesToLose: profileData.missesToLose || 3,
        hitCommand: profileData.hitCommand || '',
        missCommand: profileData.missCommand || '',
        winCommand: profileData.winCommand || '',
        loseCommand: profileData.loseCommand || '',
        images: profileData.images || [],
        // Item drop chances (maze only)
        keyDropChance: profileData.keyDropChance ?? 40,
        strikeDropChance: profileData.strikeDropChance ?? 20,
        stealthDropChance: profileData.stealthDropChance ?? 10,
    };
    saveSettingsDebounced();
    console.log('[MazeMaster] Battlebar profile saved:', name, extensionSettings.battlebarProfiles[name]);
}

function deleteBattlebarProfile(name) {
    delete extensionSettings.battlebarProfiles[name];
    if (extensionSettings.currentBattlebarProfile === name) {
        const remaining = getBattlebarProfileNames();
        extensionSettings.currentBattlebarProfile = remaining[0] || 'default';
    }
    saveSettingsDebounced();
}

// Turn-Based profile functions (stub for now)
function getTurnbasedProfileNames() {
    return Object.keys(extensionSettings.turnbasedProfiles || {});
}

function getTurnbasedProfile(name) {
    return extensionSettings.turnbasedProfiles?.[name];
}

function saveTurnbasedProfile(name, profileData) {
    if (!extensionSettings.turnbasedProfiles) {
        extensionSettings.turnbasedProfiles = {};
    }
    extensionSettings.turnbasedProfiles[name] = { ...profileData };
    saveSettingsDebounced();
}

function deleteTurnbasedProfile(name) {
    delete extensionSettings.turnbasedProfiles?.[name];
    if (extensionSettings.currentTurnbasedProfile === name) {
        const remaining = getTurnbasedProfileNames();
        extensionSettings.currentTurnbasedProfile = remaining[0] || '';
    }
    saveSettingsDebounced();
}

// QTE profile functions
function getQteProfileNames() {
    return Object.keys(extensionSettings.qteProfiles || {});
}

function getQteProfile(name) {
    return extensionSettings.qteProfiles?.[name];
}

function saveQteProfile(name, profileData) {
    if (!extensionSettings.qteProfiles) {
        extensionSettings.qteProfiles = {};
    }
    extensionSettings.qteProfiles[name] = { ...profileData };
    saveSettingsDebounced();
}

function deleteQteProfile(name) {
    delete extensionSettings.qteProfiles?.[name];
    if (extensionSettings.currentQteProfile === name) {
        const remaining = getQteProfileNames();
        extensionSettings.currentQteProfile = remaining[0] || '';
    }
    saveSettingsDebounced();
}

// Dice profile functions
function getDiceProfileNames() {
    return Object.keys(extensionSettings.diceProfiles || {});
}

function getDiceProfile(name) {
    return extensionSettings.diceProfiles?.[name];
}

function saveDiceProfile(name, profileData) {
    if (!extensionSettings.diceProfiles) {
        extensionSettings.diceProfiles = {};
    }
    extensionSettings.diceProfiles[name] = { ...profileData };
    saveSettingsDebounced();
}

function deleteDiceProfile(name) {
    delete extensionSettings.diceProfiles?.[name];
    if (extensionSettings.currentDiceProfile === name) {
        const remaining = getDiceProfileNames();
        extensionSettings.currentDiceProfile = remaining[0] || '';
    }
    saveSettingsDebounced();
}

// Stealth profile functions
function getStealthProfileNames() {
    return Object.keys(extensionSettings.stealthProfiles || {});
}

function getStealthProfile(name) {
    return extensionSettings.stealthProfiles?.[name];
}

function saveStealthProfile(name, profileData) {
    if (!extensionSettings.stealthProfiles) {
        extensionSettings.stealthProfiles = {};
    }
    extensionSettings.stealthProfiles[name] = { ...profileData };
    saveSettingsDebounced();
}

function deleteStealthProfile(name) {
    delete extensionSettings.stealthProfiles?.[name];
    if (extensionSettings.currentStealthProfile === name) {
        const remaining = getStealthProfileNames();
        extensionSettings.currentStealthProfile = remaining[0] || '';
    }
    saveSettingsDebounced();
}

// Puzzle profile functions
function getPuzzleProfileNames() {
    return Object.keys(extensionSettings.puzzleProfiles || {});
}

function getPuzzleProfile(name) {
    return extensionSettings.puzzleProfiles?.[name];
}

function savePuzzleProfile(name, profileData) {
    if (!extensionSettings.puzzleProfiles) {
        extensionSettings.puzzleProfiles = {};
    }
    extensionSettings.puzzleProfiles[name] = { ...profileData };
    saveSettingsDebounced();
}

function deletePuzzleProfile(name) {
    delete extensionSettings.puzzleProfiles?.[name];
    if (extensionSettings.currentPuzzleProfile === name) {
        const remaining = getPuzzleProfileNames();
        extensionSettings.currentPuzzleProfile = remaining[0] || '';
    }
    saveSettingsDebounced();
}

// Negotiation profile functions
function getNegotiationProfileNames() {
    return Object.keys(extensionSettings.negotiationProfiles || {});
}

function getNegotiationProfile(name) {
    return extensionSettings.negotiationProfiles?.[name];
}

function saveNegotiationProfile(name, profileData) {
    if (!extensionSettings.negotiationProfiles) {
        extensionSettings.negotiationProfiles = {};
    }
    extensionSettings.negotiationProfiles[name] = { ...profileData };
    saveSettingsDebounced();
}

function deleteNegotiationProfile(name) {
    delete extensionSettings.negotiationProfiles?.[name];
    if (extensionSettings.currentNegotiationProfile === name) {
        const remaining = getNegotiationProfileNames();
        extensionSettings.currentNegotiationProfile = remaining[0] || '';
    }
    saveSettingsDebounced();
}

// Maze profile functions
function getMazeProfileNames() {
    return Object.keys(extensionSettings.mazeProfiles || {});
}

function getMazeProfile(name) {
    return extensionSettings.mazeProfiles[name];
}

function saveMazeProfile(name, profileData) {
    extensionSettings.mazeProfiles[name] = {
        gridSize: profileData.gridSize || 10,
        difficulty: profileData.difficulty || 'normal',
        theme: profileData.theme || 'fantasy',
        mapStyle: profileData.mapStyle || 'maze',
        floors: profileData.floors || 1,
        mapVisibility: profileData.mapVisibility || 'fogOfWar',
        winCommand: profileData.winCommand || '',
        winImage: profileData.winImage || '',
        winMessage: profileData.winMessage || '',
        // Main minion settings
        mainMinion: profileData.mainMinion || '',
        mainMinionIntroMessage: profileData.mainMinionIntroMessage || '',
        mainMinionRandomChance: profileData.mainMinionRandomChance || 15,
        mainMinionRandomMessages: profileData.mainMinionRandomMessages || [],
        mainMinionExitType: profileData.mainMinionExitType || 'messenger',
        mainMinionExitProfile: profileData.mainMinionExitProfile || '',
        // Encounter settings (percent-based)
        minionEncounters: profileData.minionEncounters || [], // { minionId, percent }
        onBattlebarLoss: profileData.onBattlebarLoss || 'continue',
        loseCommand: profileData.loseCommand || '',
        // Chest tile settings
        chestImage: profileData.chestImage || '',
        chestTilePercent: profileData.chestTilePercent || 10,
        chestLockedPercent: profileData.chestLockedPercent || 30,
        chestLockedBonusPercent: profileData.chestLockedBonusPercent || 50,
        chestMimicPercent: profileData.chestMimicPercent || 15,
        // Chest loot settings
        chestLootMin: profileData.chestLootMin || 1,
        chestLootMax: profileData.chestLootMax || 2,
        // Regular chest loot chances
        chestKeyChance: profileData.chestKeyChance || 30,
        chestStrikeChance: profileData.chestStrikeChance || 50,
        chestStealthChance: profileData.chestStealthChance || 0,
        // Locked chest loot chances
        lockedChestKeyChance: profileData.lockedChestKeyChance || 40,
        lockedChestStrikeChance: profileData.lockedChestStrikeChance || 60,
        lockedChestStealthChance: profileData.lockedChestStealthChance || 30,
        // Execute chances (rare)
        chestExecuteChance: profileData.chestExecuteChance || 0,
        lockedChestExecuteChance: profileData.lockedChestExecuteChance || 5,
        // Starting inventory (combat + HP items)
        startingInventory: profileData.startingInventory || {
            key: 0, stealth: 0, strike: 0, execute: 0,
            healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0
        },
        // Trap encounters
        trapEncounters: profileData.trapEncounters || [],
        // Story milestones
        storyConfig: profileData.storyConfig || { mainStory: '', milestones: [] },
        // HP System settings (v1.3.0)
        hpEnabled: profileData.hpEnabled !== false,
        maxHP: profileData.maxHP || 100,
        battlebarDamageMultiplier: profileData.battlebarDamageMultiplier ?? 1.0,
        battlebarDifficultyMultiplier: profileData.battlebarDifficultyMultiplier ?? 1.0,
        onDeath: profileData.onDeath || 'respawn',
        respawnHPPercent: profileData.respawnHPPercent || 50,
        // Safe room settings
        safeRoomCount: profileData.safeRoomCount ?? 3,
        safeRoomHealPercent: profileData.safeRoomHealPercent ?? 100,
        safeRoomUseLLM: profileData.safeRoomUseLLM || false,
        // Rest mechanic settings
        restEnabled: profileData.restEnabled !== false,
        restHealPercent: profileData.restHealPercent ?? 20,
        restCooldown: profileData.restCooldown ?? 3,
        restInterruptChance: profileData.restInterruptChance ?? 0,
        restInterruptScript: profileData.restInterruptScript || '',
    };
    saveSettingsDebounced();
    console.log('[MazeMaster] Maze profile saved:', name, extensionSettings.mazeProfiles[name]);
}

function deleteMazeProfile(name) {
    delete extensionSettings.mazeProfiles[name];
    if (extensionSettings.currentMazeProfile === name) {
        const remaining = getMazeProfileNames();
        extensionSettings.currentMazeProfile = remaining[0] || 'default';
    }
    saveSettingsDebounced();
}

// Minion functions
function getMinionNames() {
    return Object.keys(extensionSettings.minions || {});
}

function getMinion(name) {
    return extensionSettings.minions[name];
}

function saveMinion(id, minionData) {
    extensionSettings.minions[id] = {
        name: minionData.name || 'Unknown',
        imagePath: minionData.imagePath || '',
        description: minionData.description || '', // For LLM generation
        type: minionData.type || 'messenger', // 'messenger' | 'battlebar' | 'prizewheel' | 'merchant' | 'turnbased' | 'qte' | 'dice' | 'stealth' | 'puzzle' | 'negotiation'
        battlebarProfiles: minionData.battlebarProfiles || [], // For battlebar type
        wheelProfiles: minionData.wheelProfiles || [], // For prizewheel type
        messages: minionData.messages || [], // For messenger type
        encounterScript: minionData.encounterScript || '', // Optional STScript to run on encounter
        merchantItemCount: minionData.merchantItemCount || { min: 1, max: 3 }, // For merchant type
        // Movement settings for maze encounters
        movement: minionData.movement || {
            type: 'stationary', // 'stationary' | 'patrol' | 'chase'
            patrolRadius: 3,
            chaseRange: 5,
            speed: 1, // moves per player move (1 = every move, 2 = every other move)
        },
    };
    saveSettingsDebounced();
    console.log('[MazeMaster] Minion saved:', id, extensionSettings.minions[id]);
}

function deleteMinion(id) {
    delete extensionSettings.minions[id];
    saveSettingsDebounced();
}

function getDefaultMinion() {
    return {
        name: 'The Maze',
        imagePath: '',
        message: 'Find your way to the exit...',
    };
}

// =============================================================================
// TRAP FUNCTIONS
// =============================================================================

function getTrapNames() {
    return Object.keys(extensionSettings.traps || {});
}

function getTrap(id) {
    return extensionSettings.traps?.[id];
}

function saveTrap(id, trapData) {
    if (!extensionSettings.traps) extensionSettings.traps = {};
    extensionSettings.traps[id] = {
        name: trapData.name || 'Unknown Trap',
        imagePath: trapData.imagePath || '',
        message: trapData.message || 'You triggered a trap!',
        script: trapData.script || '', // STScript to execute when triggered
        avoidChance: trapData.avoidChance ?? 0, // % chance to avoid (0-100)
        avoidMessage: trapData.avoidMessage || '', // Message when avoided
        avoidScript: trapData.avoidScript || '', // STScript to execute when avoided
    };
    saveSettingsDebounced();
    console.log('[MazeMaster] Trap saved:', id, extensionSettings.traps[id]);
}

function deleteTrap(id) {
    delete extensionSettings.traps[id];
    saveSettingsDebounced();
}

// =============================================================================
// WHEEL LOGIC
// =============================================================================

function loadWheelFromProfile(profileName) {
    const profile = getProfile(profileName);
    if (!profile || !profile.segments || profile.segments.length === 0) {
        return { error: `Profile "${profileName}" not found or empty` };
    }

    currentWheel.segments = profile.segments.map((seg, i) => ({
        ...seg,
        units: SIZE_UNITS[seg.size] || 1,
        color: WHEEL_COLORS[i % WHEEL_COLORS.length],
    }));
    currentWheel.isOpen = false;
    currentWheel.isSpinning = false;
    currentWheel.pendingRespin = false;
    currentWheel.hasRespun = false;

    return { success: true, count: currentWheel.segments.length };
}

function validateWheelBalance() {
    const halfCount = currentWheel.segments.filter(s => s.size === 'halfseg').length;
    const doubleCount = currentWheel.segments.filter(s => s.size === 'doubleseg').length;

    if (halfCount !== doubleCount) {
        console.error(`[MazeMaster] Wheel balance error: ${halfCount} halfseg(s) but ${doubleCount} doubleseg(s). They must be equal.`);
        return { valid: false, error: `Wheel unbalanced: ${halfCount} halfseg(s)  ${doubleCount} doubleseg(s)` };
    }
    return { valid: true };
}

function getTotalUnits() {
    return currentWheel.segments.reduce((sum, s) => sum + s.units, 0);
}

function selectWinner() {
    const totalUnits = getTotalUnits();
    let random = Math.random() * totalUnits;

    for (const segment of currentWheel.segments) {
        random -= segment.units;
        if (random <= 0) {
            return segment;
        }
    }
    return currentWheel.segments[currentWheel.segments.length - 1];
}

function clearWheel() {
    currentWheel.segments = [];
    currentWheel.isOpen = false;
    currentWheel.isSpinning = false;
    currentWheel.pendingRespin = false;
    currentWheel.hasRespun = false;
}

// =============================================================================
// WHEEL MODAL & CANVAS
// =============================================================================

function getWheelModalHtml() {
    return `
        <div id="mazemaster_wheel_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.95);">
            <div class="mazemaster-wheel-container">
                <div class="mazemaster-wheel-pointer"></div>
                <canvas id="mazemaster_wheel_canvas" width="400" height="400"></canvas>
                <button id="mazemaster_spin_btn" class="mazemaster-spin-btn">
                    <i class="fa-solid fa-play"></i> SPIN
                </button>
            </div>
        </div>
    `;
}

function getWheelStyles() {
    return `
        .mazemaster-wheel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: flex-start;
            justify-content: center;
            z-index: 10002;
            overflow-y: auto;
            padding: 10px 0;
            -webkit-overflow-scrolling: touch;
        }

        .mazemaster-wheel-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 25px;
            margin: auto;
            background: #1a1a2e;
            border-radius: 15px;
            border: 2px solid #333;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .mazemaster-wheel-pointer {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 30px solid #fff;
            z-index: 10;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        #mazemaster_wheel_canvas {
            border-radius: 50%;
            box-shadow: 0 0 30px rgba(0,0,0,0.5), inset 0 0 20px rgba(255,255,255,0.1);
            transition: transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99);
        }

        .mazemaster-spin-btn {
            padding: 15px 40px;
            font-size: 1.2em;
            font-weight: bold;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .mazemaster-spin-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.6);
        }

        .mazemaster-spin-btn:disabled {
            background: #555;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .mazemaster-spin-btn.respin {
            background: linear-gradient(135deg, #f39c12, #d68910);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
        }

        .mazemaster-spin-btn.respin:hover {
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.6);
        }
    `;
}

function drawWheel(canvas) {
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(centerX, centerY) - 10;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const totalUnits = getTotalUnits();
    let currentAngle = -Math.PI / 2;

    for (const segment of currentWheel.segments) {
        const segmentAngle = (segment.units / totalUnits) * 2 * Math.PI;

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + segmentAngle);
        ctx.closePath();
        ctx.fillStyle = segment.color;
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 2;
        ctx.stroke();

        const textAngle = currentAngle + segmentAngle / 2;
        const textRadius = radius * 0.55;
        const textX = centerX + Math.cos(textAngle) * textRadius;
        const textY = centerY + Math.sin(textAngle) * textRadius;

        ctx.save();
        ctx.translate(textX, textY);
        // Rotate text to be radial (pointing outward from center)
        ctx.rotate(textAngle);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 3;

        let displayText = segment.text || segment.trigger;
        if (displayText.length > 12) {
            displayText = displayText.substring(0, 10) + '...';
        }
        ctx.fillText(displayText, 0, 0);
        ctx.restore();

        currentAngle += segmentAngle;
    }

    ctx.beginPath();
    ctx.arc(centerX, centerY, 20, 0, 2 * Math.PI);
    ctx.fillStyle = '#333';
    ctx.fill();
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 3;
    ctx.stroke();
}

function showWheelModal() {
    const existing = document.getElementById('mazemaster_wheel_modal');
    if (existing) existing.remove();

    if (!document.getElementById('mazemaster_wheel_styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_wheel_styles';
        styleEl.textContent = getWheelStyles();
        document.head.appendChild(styleEl);
    }

    const modalContainer = document.createElement('div');
    modalContainer.innerHTML = getWheelModalHtml();
    document.body.appendChild(modalContainer.firstElementChild);

    const canvas = document.getElementById('mazemaster_wheel_canvas');
    if (canvas) {
        drawWheel(canvas);
    }

    const spinBtn = document.getElementById('mazemaster_spin_btn');
    if (spinBtn) {
        spinBtn.addEventListener('click', handleSpinClick);
    }

    currentWheel.isOpen = true;
}

function closeWheelModal() {
    const modal = document.getElementById('mazemaster_wheel_modal');
    if (modal) modal.remove();
    currentWheel.isOpen = false;

    // Handle maze integration if this was a maze encounter
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (encounterType === 'exit_wheel') {
                    // Exit wheel completed - win the maze
                    currentMaze.exitEncounterDone = true;
                    currentMaze.isPaused = false;
                    handleMazeWin();
                    return;
                } else if (encounterType === 'wheel') {
                    // Regular wheel encounter - resume maze
                    resumeMaze();
                    return;
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeWheelModal:', err);
        }

        // Fallback: ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

async function handleSpinClick() {
    const spinBtn = document.getElementById('mazemaster_spin_btn');
    if (!spinBtn || currentWheel.isSpinning) return;

    spinBtn.disabled = true;
    spinBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Spinning...';

    currentWheel.isSpinning = true;
    currentWheel.pendingRespin = false;

    const winner = selectWinner();
    const canvas = document.getElementById('mazemaster_wheel_canvas');

    if (!canvas) {
        currentWheel.isSpinning = false;
        return;
    }

    // Calculate winning angle
    const totalUnits = getTotalUnits();
    let winnerStartAngle = 0;
    for (const segment of currentWheel.segments) {
        if (segment === winner) break;
        winnerStartAngle += (segment.units / totalUnits) * 360;
    }
    const winnerMidAngle = winnerStartAngle + ((winner.units / totalUnits) * 360) / 2;

    const fullRotations = 5 + Math.floor(Math.random() * 3);
    const currentRotation = parseFloat(canvas.style.transform?.match(/rotate\((\d+\.?\d*)deg\)/)?.[1] || 0);
    const finalAngle = currentRotation + fullRotations * 360 + (360 - winnerMidAngle);

    canvas.style.transition = 'transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99)';
    canvas.style.transform = `rotate(${finalAngle}deg)`;

    await new Promise(resolve => setTimeout(resolve, 4200));

    currentWheel.isSpinning = false;

    // Execute command
    const wheelCmd = extensionSettings.profiles[extensionSettings.currentProfile]?.segments
        ?.find(s => s.trigger === winner.trigger);

    if (wheelCmd && wheelCmd.command) {
        console.log(`[MazeMaster] Executing command for "${winner.text}": ${wheelCmd.command}`);
        await executeWithTimeout(wheelCmd.command);
    }

    // Store result for macros
    lastResults.wheel[extensionSettings.currentProfile] = {
        segmentName: winner.text,
        command: wheelCmd?.command || '',
        timestamp: Date.now(),
    };

    // Check for respin (only one respin allowed per wheel session)
    if (winner.respin && !currentWheel.hasRespun) {
        currentWheel.pendingRespin = true;
        currentWheel.hasRespun = true; // Mark that we've used our one respin
        spinBtn.disabled = false;
        spinBtn.className = 'mazemaster-spin-btn respin';
        spinBtn.innerHTML = '<i class="fa-solid fa-rotate"></i> RESPIN';
    } else {
        closeWheelModal();
        clearWheel();
    }
}

// =============================================================================
// SLASH COMMANDS
// =============================================================================

function registerSlashCommands() {
    // Wheel command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'wheel',
        callback: async (args) => {
            // Try specified profile, then current, then first available, then default
            let profileName = args.profile;
            if (!profileName) {
                // Check if current profile exists
                const current = extensionSettings.currentProfile;
                if (current && getProfile(current)) {
                    profileName = current;
                } else {
                    // Use first available profile or fallback
                    const available = getProfileNames();
                    profileName = available.length > 0 ? available[0] : 'Blessing Wheel';
                }
            }

            console.log('[MazeMaster] /wheel command - loading profile:', profileName);
            const result = loadWheelFromProfile(profileName);
            if (result.error) {
                console.error('[MazeMaster] /wheel error:', result.error);
                return `Error: ${result.error}`;
            }

            const validation = validateWheelBalance();
            if (!validation.valid) {
                return `Error: ${validation.error}`;
            }

            extensionSettings.currentProfile = profileName;
            showWheelModal();
            return `Wheel "${profileName}" opened with ${result.count} segments. Click SPIN!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the wheel profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
                defaultValue: 'default',
            }),
        ],
        helpString: 'Open a wheel by profile name. Example: /wheel profile="mywheel"',
    }));

    // Battlebar command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'battlebar',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentBattlebarProfile || 'Training Dummy';
            const result = startBattlebar(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Battlebar "${profileName}" started! Press SPACE when the arrow is in the green zone.`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the battlebar profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
                defaultValue: 'default',
            }),
        ],
        helpString: 'Start a battlebar challenge. Example: /battlebar profile="boss1"',
    }));

    // Maze command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'maze',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentMazeProfile || 'default';
            const result = startMaze(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Maze "${profileName}" started! Use arrow keys to navigate.`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the maze profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a maze game. Example: /maze profile="dungeon1"',
    }));

    // Mazeminion command - sets the current minion display in an active maze
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazeminion',
        callback: async (args) => {
            if (!currentMaze.isOpen) {
                return 'No maze is currently open.';
            }

            const minionName = args.name;
            const message = args.message || '';

            // Check if this is a configured minion
            const minion = getMinion(minionName);
            if (minion) {
                currentMaze.currentMinion = {
                    name: minion.name,
                    imagePath: minion.imagePath,
                    message: message,
                };
            } else {
                // Custom minion name
                currentMaze.currentMinion = {
                    name: minionName || 'Unknown',
                    imagePath: '',
                    message: message,
                };
            }

            updateMazeHero();
            return '';
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'name',
                description: 'Minion name (from config) or custom name',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'message',
                description: 'Message to display',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Set the minion display in an active maze. Example: /mazeminion name="Goblin" message="You shall not pass!"',
    }));

    // Mazestats command - get current session stats as JSON
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazestats',
        callback: async () => {
            if (!currentMaze.isOpen) {
                return JSON.stringify({ error: 'No maze is currently open.' });
            }

            const stats = {
                moves: currentMaze.stats?.moves || 0,
                encountersTotal: currentMaze.stats?.encountersTotal || 0,
                encountersWon: currentMaze.stats?.encountersWon || 0,
                chestsOpened: currentMaze.stats?.chestsOpened || 0,
                trapsTriggered: currentMaze.stats?.trapsTriggered || 0,
                teleportsUsed: currentMaze.stats?.teleportsUsed || 0,
                itemsCollected: currentMaze.stats?.itemsCollected || {},
                exploration: getExplorationPercent(),
                elapsedTime: getElapsedTime(),
                difficulty: currentMaze.profile?.difficulty || 'normal',
            };

            return JSON.stringify(stats);
        },
        helpString: 'Get current maze session statistics as JSON. Example: /mazestats',
    }));

    // Mazeexplore command - get exploration percentage
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazeexplore',
        callback: async () => {
            if (!currentMaze.isOpen) {
                return 'No maze is currently open.';
            }

            const percent = getExplorationPercent();
            return String(percent);
        },
        helpString: 'Get current maze exploration percentage (0-100). Example: /mazeexplore',
    }));

    // Mazeobjective command - get objective progress
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazeobjective',
        callback: async (args) => {
            if (!currentMaze.isOpen) {
                return JSON.stringify({ error: 'No maze is currently open.' });
            }

            const objectives = currentMaze.profile?.objectives || [];
            const progress = currentMaze.objectiveProgress || {};

            if (args.id) {
                // Get specific objective
                const obj = objectives.find(o => o.id === args.id);
                if (!obj) {
                    return JSON.stringify({ error: `Objective "${args.id}" not found.` });
                }
                const prog = progress[args.id] || { current: 0, completed: false };
                return JSON.stringify({
                    id: obj.id,
                    type: obj.type,
                    target: obj.target,
                    description: obj.description,
                    current: prog.current,
                    required: obj.count,
                    completed: prog.completed,
                    isRequired: obj.required,
                });
            } else {
                // Get all objectives
                const allProgress = objectives.map(obj => {
                    const prog = progress[obj.id] || { current: 0, completed: false };
                    return {
                        id: obj.id,
                        type: obj.type,
                        description: obj.description,
                        current: prog.current,
                        required: obj.count,
                        completed: prog.completed,
                        isRequired: obj.required,
                    };
                });
                return JSON.stringify(allProgress);
            }
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'id',
                description: 'Specific objective ID to get (optional, returns all if omitted)',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Get maze objective progress. Example: /mazeobjective id="collect_keys" or /mazeobjective (for all)',
    }));

    // Mazedifficulty command - set difficulty for next maze
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazedifficulty',
        callback: async (args) => {
            const tier = args.tier?.toLowerCase();
            const validTiers = ['easy', 'normal', 'hard', 'nightmare'];

            if (!tier) {
                // Return current difficulty setting
                const currentProfile = extensionSettings.mazeProfiles?.[extensionSettings.currentMazeProfile || 'default'];
                return currentProfile?.difficulty || 'normal';
            }

            if (!validTiers.includes(tier)) {
                return `Error: Invalid difficulty tier. Valid options: ${validTiers.join(', ')}`;
            }

            // Update the current maze profile's difficulty
            const profileName = extensionSettings.currentMazeProfile || 'default';
            if (extensionSettings.mazeProfiles?.[profileName]) {
                extensionSettings.mazeProfiles[profileName].difficulty = tier;
                saveSettings();
                return `Difficulty set to "${tier}" for profile "${profileName}".`;
            } else {
                return `Error: Profile "${profileName}" not found.`;
            }
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'tier',
                description: 'Difficulty tier: easy, normal, hard, or nightmare',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Get or set maze difficulty. Example: /mazedifficulty tier="hard" or /mazedifficulty (to get current)',
    }));

    // v1.2.0: Persona stats command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazepersonastats',
        callback: async (args) => {
            const personaName = args.persona || getCurrentPersonaName();
            const stats = extensionSettings.mazeStats?.personas?.[personaName];

            if (!stats) {
                return JSON.stringify({ error: `No stats found for persona "${personaName}".` });
            }

            return JSON.stringify({
                persona: personaName,
                totalGames: stats.totalGames || 0,
                wins: stats.wins || 0,
                losses: stats.losses || 0,
                totalMoves: stats.totalMoves || 0,
                bestTime: stats.bestTime,
                profileStats: stats.profileStats || {},
            });
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'persona',
                description: 'Name of the persona to get stats for (default: current persona)',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Get maze stats for a specific persona. Example: /mazepersonastats persona="Alice"',
    }));

    // v1.2.0: Floor command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazefloor',
        callback: async () => {
            if (!currentMaze.isOpen) {
                return JSON.stringify({ error: 'No maze is currently open.' });
            }

            return JSON.stringify({
                current: (currentMaze.currentFloor || 0) + 1,
                total: currentMaze.totalFloors || 1,
            });
        },
        helpString: 'Get current floor information in an active maze. Example: /mazefloor',
    }));

    // v1.2.0: Theme command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazetheme',
        callback: async (args) => {
            const theme = args.theme?.toLowerCase();
            const validThemes = ['fantasy', 'horror', 'scifi', 'action'];

            if (!theme) {
                // Return current theme
                const profileName = extensionSettings.currentMazeProfile || 'default';
                const currentProfile = extensionSettings.mazeProfiles?.[profileName];
                return currentProfile?.theme || 'fantasy';
            }

            if (!validThemes.includes(theme)) {
                return `Error: Invalid theme. Valid options: ${validThemes.join(', ')}`;
            }

            const profileName = extensionSettings.currentMazeProfile || 'default';
            if (extensionSettings.mazeProfiles?.[profileName]) {
                extensionSettings.mazeProfiles[profileName].theme = theme;
                saveSettings();
                return `Theme set to "${theme}" for profile "${profileName}".`;
            } else {
                return `Error: Profile "${profileName}" not found.`;
            }
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'theme',
                description: 'Theme: fantasy, horror, scifi, or action',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Get or set maze theme. Example: /mazetheme theme="horror" or /mazetheme (to get current)',
    }));

    // v1.2.0: Map style command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazemapstyle',
        callback: async (args) => {
            const style = args.style?.toLowerCase();
            const validStyles = ['maze', 'dungeon', 'city', 'forest', 'spaceship'];

            if (!style) {
                // Return current map style
                const profileName = extensionSettings.currentMazeProfile || 'default';
                const currentProfile = extensionSettings.mazeProfiles?.[profileName];
                return currentProfile?.mapStyle || 'maze';
            }

            if (!validStyles.includes(style)) {
                return `Error: Invalid map style. Valid options: ${validStyles.join(', ')}`;
            }

            const profileName = extensionSettings.currentMazeProfile || 'default';
            if (extensionSettings.mazeProfiles?.[profileName]) {
                extensionSettings.mazeProfiles[profileName].mapStyle = style;
                saveSettings();
                return `Map style set to "${style}" for profile "${profileName}".`;
            } else {
                return `Error: Profile "${profileName}" not found.`;
            }
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'style',
                description: 'Map style: maze, dungeon, city, forest, or spaceship',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Get or set maze map style. Example: /mazemapstyle style="dungeon" or /mazemapstyle (to get current)',
    }));

    // v1.3.0: Item management commands
    const ITEM_INDEX = {
        // Core items (1-4)
        1: 'key', 2: 'stealth', 3: 'strike', 4: 'execute',
        // Special items (5-10)
        5: 'floorKey', 6: 'portalStone', 7: 'minionBane', 8: 'mapFragment', 9: 'timeShard', 10: 'voidWalk',
        // HP items (11-15)
        11: 'healingPotion', 12: 'greaterHealing', 13: 'elixir', 14: 'revivalCharm', 15: 'heartCrystal',
        // Visibility items (16-20)
        16: 'torch', 17: 'lantern', 18: 'revealScroll', 19: 'sightPotion', 20: 'crystalBall',
        // Name aliases
        'key': 'key', 'stealth': 'stealth', 'strike': 'strike', 'execute': 'execute',
        'floorkey': 'floorKey', 'portalstone': 'portalStone', 'minionbane': 'minionBane',
        'mapfragment': 'mapFragment', 'timeshard': 'timeShard', 'voidwalk': 'voidWalk',
        'healingpotion': 'healingPotion', 'greaterhealing': 'greaterHealing', 'elixir': 'elixir',
        'revivalcharm': 'revivalCharm', 'heartcrystal': 'heartCrystal',
        'torch': 'torch', 'lantern': 'lantern', 'revealscroll': 'revealScroll',
        'sightpotion': 'sightPotion', 'crystalball': 'crystalBall',
        // Short aliases
        'hp': 'healingPotion', 'ghp': 'greaterHealing', 'potion': 'healingPotion',
        'light': 'torch', 'scroll': 'revealScroll', 'sight': 'sightPotion', 'ball': 'crystalBall',
    };

    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazeitem',
        callback: async (args) => {
            if (!currentMaze.isOpen) {
                return 'Error: No maze is currently open.';
            }

            const action = args.action?.toLowerCase();
            const itemInput = args.item?.toString().toLowerCase();
            const amount = parseInt(args.amount) || 1;

            if (!action || !['add', 'remove', 'list'].includes(action)) {
                return 'Error: action must be "add", "remove", or "list". Example: /mazeitem action="add" item="key" amount=1';
            }

            if (action === 'list') {
                const items = [
                    '1=key, 2=stealth, 3=strike, 4=execute',
                    '5=floorKey, 6=portalStone, 7=minionBane, 8=mapFragment, 9=timeShard, 10=voidWalk',
                    '11=healingPotion, 12=greaterHealing, 13=elixir, 14=revivalCharm, 15=heartCrystal',
                    '16=torch, 17=lantern, 18=revealScroll, 19=sightPotion, 20=crystalBall',
                ];
                return `Available items:\n${items.join('\n')}`;
            }

            if (!itemInput) {
                return 'Error: item is required. Use item number (1-15) or name. Use /mazeitem action="list" to see all items.';
            }

            const itemName = ITEM_INDEX[itemInput];
            if (!itemName) {
                return `Error: Unknown item "${itemInput}". Use /mazeitem action="list" to see available items.`;
            }

            if (action === 'add') {
                await addToInventory(itemName, amount);
                return `Added ${amount}x ${itemName} to inventory.`;
            } else if (action === 'remove') {
                const current = currentMaze.inventory[itemName] || 0;
                const toRemove = Math.min(amount, current);
                if (toRemove > 0) {
                    await removeFromInventory(itemName, toRemove);
                    return `Removed ${toRemove}x ${itemName} from inventory.`;
                } else {
                    return `No ${itemName} in inventory to remove.`;
                }
            }
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'action',
                description: 'Action: add, remove, or list',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: true,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'item',
                description: 'Item number (1-15) or name',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'amount',
                description: 'Amount to add/remove (default: 1)',
                typeList: [ARGUMENT_TYPE.NUMBER],
                isRequired: false,
            }),
        ],
        helpString: 'Manage maze inventory. Examples: /mazeitem action="add" item="key" amount=3, /mazeitem action="remove" item="11", /mazeitem action="list"',
    }));

    // v1.3.0: HP commands
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazehp',
        callback: async (args) => {
            if (!currentMaze.isOpen) {
                return JSON.stringify({ error: 'No maze is currently open.' });
            }

            if (!currentMaze.hpEnabled || !currentMaze.hp) {
                return JSON.stringify({ error: 'HP system is not enabled for this maze.' });
            }

            // If set argument provided, set HP
            if (args.set !== undefined) {
                const newHP = parseInt(args.set);
                if (isNaN(newHP) || newHP < 0) {
                    return 'Error: set must be a positive number.';
                }
                const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;
                currentMaze.hp.current = Math.min(newHP, maxTotal);
                updateHPDisplay();
                return `HP set to ${currentMaze.hp.current}/${maxTotal}`;
            }

            // Return current HP status
            const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;
            return JSON.stringify({
                current: currentMaze.hp.current,
                max: maxTotal,
                percent: Math.round((currentMaze.hp.current / maxTotal) * 100),
                reviveCharges: currentMaze.hp.reviveCharges,
            });
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'set',
                description: 'Set HP to this value',
                typeList: [ARGUMENT_TYPE.NUMBER],
                isRequired: false,
            }),
        ],
        helpString: 'Get or set player HP. Examples: /mazehp (get status), /mazehp set=50',
    }));

    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazeheal',
        callback: async (args) => {
            if (!currentMaze.isOpen) {
                return 'Error: No maze is currently open.';
            }

            if (!currentMaze.hpEnabled || !currentMaze.hp) {
                return 'Error: HP system is not enabled for this maze.';
            }

            const amount = parseInt(args.amount) || 25;
            const isPercent = args.percent === 'true' || args.percent === true;

            await healPlayer(amount, isPercent, 'command');
            return `Healed ${amount}${isPercent ? '%' : ''} HP.`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'amount',
                description: 'Amount to heal (default: 25)',
                typeList: [ARGUMENT_TYPE.NUMBER],
                isRequired: false,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'percent',
                description: 'If true, amount is percentage of max HP',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Heal the player. Examples: /mazeheal amount=50, /mazeheal amount=25 percent=true',
    }));

    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'mazedamage',
        callback: async (args) => {
            if (!currentMaze.isOpen) {
                return 'Error: No maze is currently open.';
            }

            if (!currentMaze.hpEnabled || !currentMaze.hp) {
                return 'Error: HP system is not enabled for this maze.';
            }

            const amount = parseInt(args.amount) || 10;
            const source = args.source || 'command';

            await applyDamage(amount, source);
            return `Dealt ${amount} damage (source: ${source}).`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'amount',
                description: 'Amount of damage (default: 10)',
                typeList: [ARGUMENT_TYPE.NUMBER],
                isRequired: false,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'source',
                description: 'Damage source for hooks (default: command)',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Deal damage to the player. Examples: /mazedamage amount=25, /mazedamage amount=10 source="trap"',
    }));

    // Turn-Based combat command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'turnbased',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentTurnbasedProfile || 'Training Bout';
            const result = startTurnBased(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Turn-based combat "${profileName}" started!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the turn-based combat profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a turn-based combat encounter. Example: /turnbased profile="Dungeon Skirmish"',
    }));

    // QTE combat command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'qte',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentQteProfile || 'Reaction Test';
            const result = startQTE(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `QTE "${profileName}" started! Press the keys as they appear!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the QTE profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a Quick-Time Event challenge. Example: /qte profile="Combat Flurry"',
    }));

    // Dice combat command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'dice',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentDiceProfile || 'Lucky Roll';
            const result = startDice(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Dice challenge "${profileName}" started! Click to roll!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the dice profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a dice roll challenge. Example: /dice profile="Skill Check"',
    }));

    // Stealth encounter command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'stealth',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentStealthProfile || 'Simple Sneak';
            const result = startStealth(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Stealth encounter "${profileName}" started! Sneak past the guards!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the stealth profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a stealth encounter. Example: /stealth profile="Guard Patrol"',
    }));

    // Puzzle encounter command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'puzzle',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentPuzzleProfile || 'Simple Riddle';
            const result = startPuzzle(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Puzzle "${profileName}" started! Solve the sequence!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the puzzle profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a puzzle encounter. Example: /puzzle profile="Memory Trial"',
    }));

    // Negotiation encounter command
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'negotiate',
        callback: async (args) => {
            const profileName = args.profile || extensionSettings.currentNegotiationProfile || 'Friendly Chat';
            const result = startNegotiation(profileName);
            if (result.error) {
                return `Error: ${result.error}`;
            }
            return `Negotiation "${profileName}" started! Convince them to help!`;
        },
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'profile',
                description: 'Name of the negotiation profile to use',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
        ],
        helpString: 'Start a negotiation encounter. Example: /negotiate profile="Merchant Haggle"',
    }));

    console.log('[MazeMaster] Slash commands registered');
}

// =============================================================================
// TURN-BASED COMBAT MODAL & GAME LOGIC
// =============================================================================

function getTurnBasedModalHtml() {
    return `
        <div id="mazemaster_turnbased_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-tb-container">
                <div id="tb_main_title" class="mazemaster-tb-main-title">Combat!</div>

                <div class="mazemaster-tb-combatants">
                    <div class="mazemaster-tb-combatant tb-player">
                        <div class="tb-combatant-name">You</div>
                        <div class="tb-hp-bar-container">
                            <div class="tb-hp-bar tb-hp-player" id="tb_player_hp_bar"></div>
                        </div>
                        <div class="tb-hp-text"><span id="tb_player_hp">100</span>/<span id="tb_player_max_hp">100</span> HP</div>
                    </div>
                    <div class="mazemaster-tb-vs">VS</div>
                    <div class="mazemaster-tb-combatant tb-enemy">
                        <div class="tb-combatant-name" id="tb_enemy_name">Enemy</div>
                        <div class="tb-hp-bar-container">
                            <div class="tb-hp-bar tb-hp-enemy" id="tb_enemy_hp_bar"></div>
                        </div>
                        <div class="tb-hp-text"><span id="tb_enemy_hp">100</span>/<span id="tb_enemy_max_hp">100</span> HP</div>
                    </div>
                </div>

                <div class="mazemaster-tb-turn-indicator">
                    <span id="tb_turn_text">Your Turn</span> - Turn <span id="tb_turn_count">1</span>
                </div>

                <div class="mazemaster-tb-log" id="tb_combat_log">
                    <div class="tb-log-entry">Combat begins!</div>
                </div>

                <div class="mazemaster-tb-actions" id="tb_action_buttons">
                    <button id="tb_attack_btn" class="mazemaster-tb-btn tb-btn-attack">
                        <i class="fa-solid fa-sword"></i> Attack
                    </button>
                    <button id="tb_defend_btn" class="mazemaster-tb-btn tb-btn-defend">
                        <i class="fa-solid fa-shield"></i> Defend
                    </button>
                    <button id="tb_item_btn" class="mazemaster-tb-btn tb-btn-item">
                        <i class="fa-solid fa-flask"></i> Item
                    </button>
                    <button id="tb_flee_btn" class="mazemaster-tb-btn tb-btn-flee">
                        <i class="fa-solid fa-person-running"></i> Flee
                    </button>
                </div>

                <div class="mazemaster-tb-result" id="tb_result_panel" style="display: none;">
                    <div id="tb_result_text" class="tb-result-text"></div>
                    <button id="tb_close_btn" class="mazemaster-tb-btn tb-btn-close">
                        <i class="fa-solid fa-check"></i> Close
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getTurnBasedStyles() {
    return `
        .mazemaster-tb-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 25px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            border: 2px solid #4a7c59;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(74, 124, 89, 0.3);
            width: 500px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .mazemaster-tb-main-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .mazemaster-tb-combatants {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            gap: 20px;
        }

        .mazemaster-tb-combatant {
            flex: 1;
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .tb-combatant-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
        }

        .tb-hp-bar-container {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .tb-hp-bar {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .tb-hp-player {
            background: linear-gradient(90deg, #2ecc71 0%, #27ae60 100%);
        }

        .tb-hp-enemy {
            background: linear-gradient(90deg, #e74c3c 0%, #c0392b 100%);
        }

        .tb-hp-text {
            font-size: 0.9em;
            color: #aaa;
        }

        .mazemaster-tb-vs {
            font-size: 1.5em;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .mazemaster-tb-turn-indicator {
            font-size: 1.1em;
            color: #3498db;
            padding: 8px 20px;
            background: rgba(52, 152, 219, 0.2);
            border-radius: 20px;
            border: 1px solid rgba(52, 152, 219, 0.5);
        }

        .mazemaster-tb-log {
            width: 100%;
            height: 120px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.9em;
            color: #ccc;
        }

        .tb-log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .tb-log-entry:last-child {
            border-bottom: none;
        }

        .tb-log-damage { color: #e74c3c; }
        .tb-log-heal { color: #2ecc71; }
        .tb-log-defend { color: #3498db; }
        .tb-log-crit { color: #f39c12; font-weight: bold; }
        .tb-log-flee { color: #9b59b6; }

        .mazemaster-tb-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .mazemaster-tb-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mazemaster-tb-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .mazemaster-tb-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .tb-btn-attack {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .tb-btn-defend {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .tb-btn-item {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        .tb-btn-flee {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }

        .tb-btn-close {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 15px 40px;
        }

        .mazemaster-tb-result {
            text-align: center;
        }

        .tb-result-text {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .tb-result-victory { color: #2ecc71; }
        .tb-result-defeat { color: #e74c3c; }
        .tb-result-fled { color: #9b59b6; }

        .tb-combatant.defending {
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.6);
        }

        .tb-hp-bar.flash-damage {
            animation: tb-flash-damage 0.3s ease;
        }

        .tb-hp-bar.flash-heal {
            animation: tb-flash-heal 0.3s ease;
        }

        @keyframes tb-flash-damage {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5) saturate(2); }
        }

        @keyframes tb-flash-heal {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5) hue-rotate(60deg); }
        }
    `;
}

function startTurnBased(profileName, enemyNameOverride = null) {
    console.log('[MazeMaster] startTurnBased called with profile:', profileName);
    const profile = getTurnbasedProfile(profileName);
    console.log('[MazeMaster] Retrieved profile:', profile);
    if (!profile) {
        console.error(`[MazeMaster] Turn-based profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    // Determine player HP - use maze HP if in a maze with HP enabled, otherwise use profile defaults
    let playerHP = profile.playerHP || 100;
    let playerMaxHP = profile.playerHP || 100;
    let isMazeEncounter = false;

    if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
        isMazeEncounter = true;
        playerHP = currentMaze.hp.current;
        playerMaxHP = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
        console.log('[MazeMaster] Using maze HP for combat:', playerHP, '/', playerMaxHP);
    } else {
        console.log('[MazeMaster] Using profile HP for combat:', playerHP, '/', playerMaxHP);
    }

    // Initialize combat state
    console.log('[MazeMaster] Initializing turn-based combat state');
    currentTurnBased = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        playerHP: playerHP,
        playerMaxHP: playerMaxHP,
        enemyHP: profile.enemyHP || 100,
        enemyMaxHP: profile.enemyHP || 100,
        currentTurn: profile.turnOrder === 'enemy_first' ? 'enemy' : 'player',
        turnCount: 1,
        isDefending: false,
        isVictory: false,
        isDefeat: false,
        isMazeEncounter: isMazeEncounter,
        combatLog: ['Combat begins!'],
        // v1.3.1: Enemy name override from minion encounter
        enemyNameOverride: enemyNameOverride,
    };

    // Pause maze if active
    if (currentMaze.isOpen) {
        currentMaze.isPaused = true;
    }

    showTurnBasedModal();
    updateTurnBasedDisplay();

    // If enemy goes first, process their turn after a short delay
    if (currentTurnBased.currentTurn === 'enemy') {
        setTimeout(() => processEnemyTurn(), 1000);
    }

    console.log(`[MazeMaster] Turn-based combat started: ${profileName}`);
    return { success: true };
}

function showTurnBasedModal() {
    console.log('[MazeMaster] showTurnBasedModal called');
    // Remove existing modal if any
    const existing = document.getElementById('mazemaster_turnbased_modal');
    if (existing) {
        console.log('[MazeMaster] Removing existing turn-based modal');
        existing.remove();
    }

    // Add styles if not present
    if (!document.getElementById('mazemaster_tb_styles')) {
        console.log('[MazeMaster] Adding turn-based styles');
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_tb_styles';
        styleEl.textContent = getTurnBasedStyles();
        document.head.appendChild(styleEl);
    }

    // Add modal
    console.log('[MazeMaster] Inserting turn-based modal HTML');
    document.body.insertAdjacentHTML('beforeend', getTurnBasedModalHtml());

    // Verify modal was added
    const modalCheck = document.getElementById('mazemaster_turnbased_modal');
    console.log('[MazeMaster] Modal element exists:', !!modalCheck);

    // Update enemy name and title - use enemyNameOverride for both if available
    const titleEl = document.getElementById('tb_main_title');
    const enemyNameEl = document.getElementById('tb_enemy_name');
    console.log('[MazeMaster] Title element:', titleEl, 'Enemy name element:', enemyNameEl);
    const displayName = currentTurnBased.enemyNameOverride || currentTurnBased.profile.mainTitle || 'Combat!';
    if (titleEl) titleEl.textContent = displayName;
    if (enemyNameEl) enemyNameEl.textContent = currentTurnBased.enemyNameOverride || currentTurnBased.profile.enemyName || 'Enemy';

    // Attach event handlers
    console.log('[MazeMaster] Attaching turn-based event handlers');
    document.getElementById('tb_attack_btn')?.addEventListener('click', handleTBAttack);
    document.getElementById('tb_defend_btn')?.addEventListener('click', handleTBDefend);
    document.getElementById('tb_item_btn')?.addEventListener('click', handleTBItem);
    document.getElementById('tb_flee_btn')?.addEventListener('click', handleTBFlee);
    document.getElementById('tb_close_btn')?.addEventListener('click', closeTurnBasedModal);
    console.log('[MazeMaster] Turn-based modal setup complete');
}

function updateTurnBasedDisplay() {
    // Update HP bars
    const playerHPPercent = (currentTurnBased.playerHP / currentTurnBased.playerMaxHP) * 100;
    const enemyHPPercent = (currentTurnBased.enemyHP / currentTurnBased.enemyMaxHP) * 100;

    const playerHPBar = document.getElementById('tb_player_hp_bar');
    const enemyHPBar = document.getElementById('tb_enemy_hp_bar');
    if (playerHPBar) playerHPBar.style.width = `${playerHPPercent}%`;
    if (enemyHPBar) enemyHPBar.style.width = `${enemyHPPercent}%`;

    // Update HP text
    const playerHPEl = document.getElementById('tb_player_hp');
    const playerMaxHPEl = document.getElementById('tb_player_max_hp');
    const enemyHPEl = document.getElementById('tb_enemy_hp');
    const enemyMaxHPEl = document.getElementById('tb_enemy_max_hp');
    if (playerHPEl) playerHPEl.textContent = Math.max(0, currentTurnBased.playerHP);
    if (playerMaxHPEl) playerMaxHPEl.textContent = currentTurnBased.playerMaxHP;
    if (enemyHPEl) enemyHPEl.textContent = Math.max(0, currentTurnBased.enemyHP);
    if (enemyMaxHPEl) enemyMaxHPEl.textContent = currentTurnBased.enemyMaxHP;

    // Update turn indicator
    const turnTextEl = document.getElementById('tb_turn_text');
    const turnCountEl = document.getElementById('tb_turn_count');
    if (turnTextEl) turnTextEl.textContent = currentTurnBased.currentTurn === 'player' ? 'Your Turn' : 'Enemy Turn';
    if (turnCountEl) turnCountEl.textContent = currentTurnBased.turnCount;

    // Update combat log
    const logEl = document.getElementById('tb_combat_log');
    if (logEl) {
        logEl.innerHTML = currentTurnBased.combatLog.map(entry => {
            let className = 'tb-log-entry';
            if (entry.includes('damage') || entry.includes('hit')) className += ' tb-log-damage';
            if (entry.includes('heal') || entry.includes('restored')) className += ' tb-log-heal';
            if (entry.includes('defend') || entry.includes('block')) className += ' tb-log-defend';
            if (entry.includes('CRITICAL')) className += ' tb-log-crit';
            if (entry.includes('flee') || entry.includes('escape')) className += ' tb-log-flee';
            return `<div class="${className}">${entry}</div>`;
        }).join('');
        logEl.scrollTop = logEl.scrollHeight;
    }

    // Update defending visual
    const playerCombatant = document.querySelector('.tb-player');
    if (playerCombatant) {
        playerCombatant.classList.toggle('defending', currentTurnBased.isDefending);
    }

    // Enable/disable action buttons based on turn
    const actionBtns = document.querySelectorAll('.mazemaster-tb-btn');
    actionBtns.forEach(btn => {
        if (btn.id !== 'tb_close_btn') {
            btn.disabled = currentTurnBased.currentTurn !== 'player' || currentTurnBased.isVictory || currentTurnBased.isDefeat;
        }
    });
}

function addTBLogEntry(message) {
    currentTurnBased.combatLog.push(message);
    // Keep log at reasonable size
    if (currentTurnBased.combatLog.length > 50) {
        currentTurnBased.combatLog.shift();
    }
    updateTurnBasedDisplay();
}

function flashHPBar(isPlayer, isDamage) {
    const barId = isPlayer ? 'tb_player_hp_bar' : 'tb_enemy_hp_bar';
    const bar = document.getElementById(barId);
    if (bar) {
        bar.classList.remove('flash-damage', 'flash-heal');
        void bar.offsetWidth; // Trigger reflow
        bar.classList.add(isDamage ? 'flash-damage' : 'flash-heal');
    }
}

function calculateDamage(attack, defense, critChance, critMultiplier) {
    let baseDamage = Math.max(1, attack - defense);
    // Add some variance (+/- 20%)
    baseDamage = Math.round(baseDamage * (0.8 + Math.random() * 0.4));

    let isCrit = false;
    if (Math.random() * 100 < critChance) {
        baseDamage = Math.round(baseDamage * critMultiplier);
        isCrit = true;
    }

    return { damage: baseDamage, isCrit };
}

async function handleTBAttack() {
    if (currentTurnBased.currentTurn !== 'player') return;

    const profile = currentTurnBased.profile;
    currentTurnBased.isDefending = false;

    // Calculate damage
    const { damage, isCrit } = calculateDamage(
        profile.playerAttack || 15,
        profile.enemyDefense || 5,
        profile.critChance || 10,
        profile.critMultiplier || 2.0
    );

    currentTurnBased.enemyHP = Math.max(0, currentTurnBased.enemyHP - damage);
    flashHPBar(false, true);

    if (isCrit) {
        addTBLogEntry(`CRITICAL HIT! You deal ${damage} damage!`);
    } else {
        addTBLogEntry(`You attack for ${damage} damage!`);
    }

    // Execute STScript hook
    if (profile.onAttack) {
        await executeWithTimeout(profile.onAttack);
    }

    // Check for victory
    if (currentTurnBased.enemyHP <= 0) {
        await handleTurnBasedWin();
        return;
    }

    // Switch to enemy turn
    currentTurnBased.currentTurn = 'enemy';
    updateTurnBasedDisplay();
    setTimeout(() => processEnemyTurn(), 1000);
}

async function handleTBDefend() {
    if (currentTurnBased.currentTurn !== 'player') return;

    currentTurnBased.isDefending = true;
    addTBLogEntry('You take a defensive stance.');

    // Execute STScript hook
    if (currentTurnBased.profile.onDefend) {
        await executeWithTimeout(currentTurnBased.profile.onDefend);
    }

    // Switch to enemy turn
    currentTurnBased.currentTurn = 'enemy';
    updateTurnBasedDisplay();
    setTimeout(() => processEnemyTurn(), 1000);
}

async function handleTBItem() {
    if (currentTurnBased.currentTurn !== 'player') return;

    // Check if we have healing potions in maze inventory
    if (currentMaze.isOpen && currentMaze.inventory && currentMaze.inventory.healingPotion > 0) {
        const healAmount = Math.round(currentTurnBased.playerMaxHP * 0.25);
        currentTurnBased.playerHP = Math.min(currentTurnBased.playerMaxHP, currentTurnBased.playerHP + healAmount);
        currentMaze.inventory.healingPotion--;
        flashHPBar(true, false);
        addTBLogEntry(`You use a Healing Potion and restore ${healAmount} HP!`);

        // Execute STScript hook
        if (currentTurnBased.profile.onItem) {
            await executeWithTimeout(currentTurnBased.profile.onItem);
        }

        currentTurnBased.isDefending = false;
        currentTurnBased.currentTurn = 'enemy';
        updateTurnBasedDisplay();
        setTimeout(() => processEnemyTurn(), 1000);
    } else {
        addTBLogEntry('No items available!');
    }
}

async function handleTBFlee() {
    if (currentTurnBased.currentTurn !== 'player') return;

    const fleeChance = currentTurnBased.profile.fleeChance || 30;
    const roll = Math.random() * 100;

    if (roll < fleeChance) {
        addTBLogEntry('You successfully flee from combat!');

        // Execute STScript hook
        if (currentTurnBased.profile.onFlee) {
            await executeWithTimeout(currentTurnBased.profile.onFlee);
        }

        currentTurnBased.isVictory = false;
        currentTurnBased.isDefeat = false;
        showTurnBasedResult('fled');
    } else {
        addTBLogEntry(`Failed to escape! (${Math.round(roll)} vs ${fleeChance})`);
        currentTurnBased.isDefending = false;
        currentTurnBased.currentTurn = 'enemy';
        updateTurnBasedDisplay();
        setTimeout(() => processEnemyTurn(), 1000);
    }
}

async function processEnemyTurn() {
    if (currentTurnBased.currentTurn !== 'enemy') return;
    if (currentTurnBased.isVictory || currentTurnBased.isDefeat) return;

    const profile = currentTurnBased.profile;

    // Execute turn start hook
    if (profile.onTurnStart) {
        await executeWithTimeout(profile.onTurnStart);
    }

    // Calculate damage
    let { damage, isCrit } = calculateDamage(
        profile.enemyAttack || 12,
        profile.playerDefense || 5,
        profile.critChance || 10,
        profile.critMultiplier || 2.0
    );

    // Reduce damage if defending
    if (currentTurnBased.isDefending) {
        damage = Math.round(damage * 0.5);
        addTBLogEntry(`Your defense reduces the damage!`);
    }

    currentTurnBased.playerHP = Math.max(0, currentTurnBased.playerHP - damage);
    flashHPBar(true, true);

    const enemyName = currentTurnBased.enemyNameOverride || profile.enemyName || 'Enemy';
    if (isCrit) {
        addTBLogEntry(`CRITICAL! ${enemyName} deals ${damage} damage!`);
    } else {
        addTBLogEntry(`${enemyName} attacks for ${damage} damage!`);
    }

    // Execute STScript hook
    if (profile.onPlayerHit) {
        await executeWithTimeout(profile.onPlayerHit);
    }

    // Check for defeat
    if (currentTurnBased.playerHP <= 0) {
        await handleTurnBasedLoss();
        return;
    }

    // Next turn
    currentTurnBased.currentTurn = 'player';
    currentTurnBased.turnCount++;
    currentTurnBased.isDefending = false;
    updateTurnBasedDisplay();
}

async function handleTurnBasedWin() {
    currentTurnBased.isVictory = true;
    currentTurnBased.currentTurn = 'none';

    const profile = currentTurnBased.profile;
    addTBLogEntry('Victory! The enemy is defeated!');

    // Execute STScript hook
    if (profile.onWin) {
        await executeWithTimeout(profile.onWin);
    }

    // Handle item drops if in maze
    if (currentMaze.isOpen && currentMaze.pendingEncounter) {
        if (Math.random() * 100 < (profile.keyDropChance || 40)) {
            addToInventory('key');
            addTBLogEntry('You found a Key!');
        }
        if (Math.random() * 100 < (profile.strikeDropChance || 20)) {
            addToInventory('strike');
            addTBLogEntry('You found a Strike!');
        }
        if (Math.random() * 100 < (profile.healingPotionDropChance || 20)) {
            addToInventory('healingPotion');
            addTBLogEntry('You found a Healing Potion!');
        }
    }

    // Store result
    lastResults.turnbased = lastResults.turnbased || {};
    lastResults.turnbased[currentTurnBased.profileName] = {
        result: 'win',
        turnsPlayed: currentTurnBased.turnCount,
        timestamp: Date.now(),
    };

    showTurnBasedResult('victory');
}

async function handleTurnBasedLoss() {
    currentTurnBased.isDefeat = true;
    currentTurnBased.currentTurn = 'none';

    const profile = currentTurnBased.profile;
    addTBLogEntry('Defeat... You have fallen.');

    // Execute STScript hook
    if (profile.onLose) {
        await executeWithTimeout(profile.onLose);
    }

    // Apply maze HP damage
    let playerDied = false;
    if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
        const damage = profile.damage || 25;
        const mazeMultiplier = currentMaze.profile?.battlebarDamageMultiplier ?? 1.0;
        const actualDamage = Math.round(damage * mazeMultiplier);
        const survived = await applyDamage(actualDamage, 'turnbased');
        playerDied = !survived;
    }

    // Store result
    lastResults.turnbased = lastResults.turnbased || {};
    lastResults.turnbased[currentTurnBased.profileName] = {
        result: 'lose',
        turnsPlayed: currentTurnBased.turnCount,
        timestamp: Date.now(),
    };

    // If player died, close modal and let death handling take over
    if (playerDied) {
        closeTurnBasedModal();
        return;
    }

    showTurnBasedResult('defeat');
}

function showTurnBasedResult(result) {
    const actionsEl = document.getElementById('tb_action_buttons');
    const resultPanel = document.getElementById('tb_result_panel');
    const resultText = document.getElementById('tb_result_text');

    if (actionsEl) actionsEl.style.display = 'none';
    if (resultPanel) resultPanel.style.display = 'block';

    if (resultText) {
        if (result === 'victory') {
            resultText.textContent = 'Victory!';
            resultText.className = 'tb-result-text tb-result-victory';
        } else if (result === 'defeat') {
            resultText.textContent = 'Defeat...';
            resultText.className = 'tb-result-text tb-result-defeat';
        } else if (result === 'fled') {
            resultText.textContent = 'Escaped!';
            resultText.className = 'tb-result-text tb-result-fled';
        }
    }

    updateTurnBasedDisplay();
}

async function closeTurnBasedModal() {
    const modal = document.getElementById('mazemaster_turnbased_modal');
    if (modal) modal.remove();

    const wasVictory = currentTurnBased.isVictory;
    const wasDefeat = currentTurnBased.isDefeat;
    const isMazeEncounter = currentTurnBased.isMazeEncounter;

    // Persist HP back to maze if this was a maze encounter
    if (isMazeEncounter && currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
        const previousHP = currentMaze.hp.current;
        currentMaze.hp.current = Math.max(0, currentTurnBased.playerHP);
        console.log('[MazeMaster] Persisting combat HP to maze:', previousHP, '->', currentMaze.hp.current);

        // Update maze HP display
        updateHPDisplay();

        // Check if player died in combat (defeat case)
        if (wasDefeat && currentMaze.hp.current <= 0) {
            console.log('[MazeMaster] Player died in turn-based combat');
            // The maze loss will be handled below or by existing defeat logic
        }
    }

    currentTurnBased.isOpen = false;

    // Handle maze integration
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasVictory) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);
                    if (encounterType === 'exit_turnbased') {
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    }
                } else if (wasDefeat) {
                    // Player was defeated - handle maze loss if HP depleted
                    if (isMazeEncounter && currentMaze.hp && currentMaze.hp.current <= 0) {
                        currentMaze.pendingEncounter = null;
                        handleMazeLoss();
                        return; // handleMazeLoss takes over
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeTurnBasedModal:', err);
        }

        // Always ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

// =============================================================================
// QTE MODAL & GAME LOGIC
// =============================================================================

// Key display mapping for visual prompts
const QTE_KEY_DISPLAY = {
    'W': { label: 'W', icon: 'fa-arrow-up', color: '#3498db' },
    'A': { label: 'A', icon: 'fa-arrow-left', color: '#e74c3c' },
    'S': { label: 'S', icon: 'fa-arrow-down', color: '#2ecc71' },
    'D': { label: 'D', icon: 'fa-arrow-right', color: '#f39c12' },
    'SPACE': { label: 'SPACE', icon: 'fa-square', color: '#9b59b6' },
    'E': { label: 'E', icon: 'fa-hand', color: '#1abc9c' },
    'Q': { label: 'Q', icon: 'fa-shield', color: '#e67e22' },
};

function getQTEModalHtml() {
    return `
        <div id="mazemaster_qte_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-qte-container">
                <div id="qte_main_title" class="mazemaster-qte-main-title">QTE!</div>

                <div class="mazemaster-qte-progress">
                    <div class="qte-progress-bar" id="qte_progress_bar"></div>
                    <div class="qte-progress-text"><span id="qte_current_index">0</span>/<span id="qte_total_count">0</span></div>
                </div>

                <div class="mazemaster-qte-prompt-area">
                    <div class="qte-timer-ring" id="qte_timer_ring">
                        <svg viewBox="0 0 100 100">
                            <circle class="qte-timer-bg" cx="50" cy="50" r="45"/>
                            <circle class="qte-timer-fill" id="qte_timer_circle" cx="50" cy="50" r="45"/>
                        </svg>
                        <div class="qte-key-prompt" id="qte_key_prompt">
                            <i class="fa-solid fa-hourglass-start"></i>
                            <span>GET READY</span>
                        </div>
                    </div>
                </div>

                <div class="mazemaster-qte-stats">
                    <span class="qte-stat qte-stat-combo">
                        Combo: <span id="qte_combo">0</span>x
                    </span>
                    <span class="qte-stat qte-stat-perfects">
                        Perfect: <span id="qte_perfects">0</span>
                    </span>
                    <span class="qte-stat qte-stat-misses">
                        Miss: <span id="qte_misses">0</span>
                    </span>
                </div>

                <div class="mazemaster-qte-log" id="qte_combat_log">
                    <div class="qte-log-entry">Prepare yourself...</div>
                </div>

                <div class="mazemaster-qte-result" id="qte_result_panel" style="display: none;">
                    <div id="qte_result_text" class="qte-result-text"></div>
                    <div id="qte_result_stats" class="qte-result-stats"></div>
                    <button id="qte_close_btn" class="mazemaster-qte-btn qte-btn-close">
                        <i class="fa-solid fa-check"></i> Close
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getQTEStyles() {
    return `
        .mazemaster-qte-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 25px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            border: 2px solid #9b59b6;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(155, 89, 182, 0.3);
            width: 450px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .mazemaster-qte-main-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .mazemaster-qte-progress {
            width: 100%;
            position: relative;
        }

        .qte-progress-bar {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .qte-progress-bar::after {
            content: '';
            display: block;
            height: 100%;
            width: var(--progress, 0%);
            background: linear-gradient(90deg, #9b59b6, #3498db);
            transition: width 0.3s ease;
        }

        .qte-progress-text {
            position: absolute;
            right: 0;
            top: -20px;
            font-size: 0.9em;
            color: #aaa;
        }

        .mazemaster-qte-prompt-area {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 180px;
            width: 100%;
        }

        .qte-timer-ring {
            position: relative;
            width: 160px;
            height: 160px;
        }

        .qte-timer-ring svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        .qte-timer-bg {
            fill: none;
            stroke: #333;
            stroke-width: 8;
        }

        .qte-timer-fill {
            fill: none;
            stroke: #9b59b6;
            stroke-width: 8;
            stroke-linecap: round;
            stroke-dasharray: 283;
            stroke-dashoffset: 0;
            transition: stroke-dashoffset 0.1s linear;
        }

        .qte-timer-fill.warning {
            stroke: #f39c12;
        }

        .qte-timer-fill.critical {
            stroke: #e74c3c;
        }

        .qte-key-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .qte-key-prompt i {
            font-size: 2.5em;
            color: #fff;
        }

        .qte-key-prompt span {
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .qte-key-prompt.success {
            animation: qte-success-pulse 0.3s ease;
        }

        .qte-key-prompt.fail {
            animation: qte-fail-shake 0.3s ease;
        }

        .qte-key-prompt.perfect {
            animation: qte-perfect-glow 0.4s ease;
        }

        @keyframes qte-success-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        @keyframes qte-fail-shake {
            0%, 100% { transform: translate(-50%, -50%); }
            25% { transform: translate(calc(-50% - 10px), -50%); }
            75% { transform: translate(calc(-50% + 10px), -50%); }
        }

        @keyframes qte-perfect-glow {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5) drop-shadow(0 0 20px gold); }
            100% { filter: brightness(1); }
        }

        .mazemaster-qte-stats {
            display: flex;
            gap: 20px;
            font-size: 1em;
            font-weight: bold;
        }

        .qte-stat-combo { color: #f39c12; }
        .qte-stat-perfects { color: #2ecc71; }
        .qte-stat-misses { color: #e74c3c; }

        .mazemaster-qte-log {
            width: 100%;
            height: 80px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.85em;
            color: #ccc;
        }

        .qte-log-entry {
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .qte-log-entry:last-child { border-bottom: none; }
        .qte-log-success { color: #2ecc71; }
        .qte-log-perfect { color: #f1c40f; font-weight: bold; }
        .qte-log-miss { color: #e74c3c; }
        .qte-log-combo { color: #3498db; }

        .mazemaster-qte-result {
            text-align: center;
            padding: 15px;
        }

        .qte-result-text {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .qte-result-text.success { color: #2ecc71; }
        .qte-result-text.fail { color: #e74c3c; }

        .qte-result-stats {
            font-size: 0.95em;
            color: #aaa;
            margin-bottom: 15px;
        }

        .mazemaster-qte-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mazemaster-qte-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .qte-btn-close {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 15px 40px;
            margin: 0 auto;
        }
    `;
}

function startQTE(profileName) {
    console.log('[MazeMaster] startQTE called with profile:', profileName);
    const profile = getQteProfile(profileName);
    console.log('[MazeMaster] QTE profile retrieved:', profile);
    if (!profile) {
        console.error(`[MazeMaster] QTE profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    // Generate sequence
    const sequenceLength = Math.floor(
        Math.random() * (profile.sequenceLengthMax - profile.sequenceLengthMin + 1) + profile.sequenceLengthMin
    );
    const sequence = [];
    for (let i = 0; i < sequenceLength; i++) {
        const randomKey = profile.allowedKeys[Math.floor(Math.random() * profile.allowedKeys.length)];
        sequence.push(randomKey);
    }

    // Initialize QTE state
    currentQTE = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        sequence: sequence,
        currentIndex: 0,
        currentTimeWindow: profile.timeWindowBase,
        promptStartTime: 0,
        timeoutId: null,
        successes: 0,
        perfects: 0,
        misses: 0,
        combo: 0,
        maxCombo: 0,
        isComplete: false,
        isSuccess: false,
        combatLog: ['Prepare yourself...'],
    };

    // Pause maze if active
    if (currentMaze.isOpen) {
        currentMaze.isPaused = true;
    }

    showQTEModal();

    // Execute start hook
    if (profile.onStart) {
        executeWithTimeout(profile.onStart);
    }

    // Start after a brief countdown
    setTimeout(() => {
        addQTELogEntry('GO!');
        showNextQTEPrompt();
    }, 1000);

    console.log(`[MazeMaster] QTE started: ${profileName}, sequence length: ${sequenceLength}`);
    return { success: true };
}

function showQTEModal() {
    const existing = document.getElementById('mazemaster_qte_modal');
    if (existing) existing.remove();

    if (!document.getElementById('mazemaster_qte_styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_qte_styles';
        styleEl.textContent = getQTEStyles();
        document.head.appendChild(styleEl);
    }

    document.body.insertAdjacentHTML('beforeend', getQTEModalHtml());

    // Update title
    const titleEl = document.getElementById('qte_main_title');
    if (titleEl) titleEl.textContent = currentQTE.profile.mainTitle || 'QTE!';

    // Update total count
    const totalEl = document.getElementById('qte_total_count');
    if (totalEl) totalEl.textContent = currentQTE.sequence.length;

    // Attach close button handler
    document.getElementById('qte_close_btn')?.addEventListener('click', closeQTEModal);

    // Attach keyboard handler
    document.addEventListener('keydown', handleQTEKeydown);

    updateQTEDisplay();
}

function updateQTEDisplay() {
    // Update progress bar
    const progressBar = document.getElementById('qte_progress_bar');
    const progress = (currentQTE.currentIndex / currentQTE.sequence.length) * 100;
    if (progressBar) progressBar.style.setProperty('--progress', `${progress}%`);

    // Update current index
    const indexEl = document.getElementById('qte_current_index');
    if (indexEl) indexEl.textContent = currentQTE.currentIndex;

    // Update stats
    const comboEl = document.getElementById('qte_combo');
    const perfectsEl = document.getElementById('qte_perfects');
    const missesEl = document.getElementById('qte_misses');
    if (comboEl) comboEl.textContent = currentQTE.combo;
    if (perfectsEl) perfectsEl.textContent = currentQTE.perfects;
    if (missesEl) missesEl.textContent = currentQTE.misses;

    // Update combat log
    const logEl = document.getElementById('qte_combat_log');
    if (logEl) {
        logEl.innerHTML = currentQTE.combatLog.map(entry => {
            let className = 'qte-log-entry';
            if (entry.includes('Success') || entry.includes('Hit')) className += ' qte-log-success';
            if (entry.includes('PERFECT')) className += ' qte-log-perfect';
            if (entry.includes('Miss') || entry.includes('Too slow')) className += ' qte-log-miss';
            if (entry.includes('Combo')) className += ' qte-log-combo';
            return `<div class="${className}">${entry}</div>`;
        }).join('');
        logEl.scrollTop = logEl.scrollHeight;
    }
}

function addQTELogEntry(message) {
    currentQTE.combatLog.push(message);
    if (currentQTE.combatLog.length > 30) {
        currentQTE.combatLog.shift();
    }
    updateQTEDisplay();
}

function showNextQTEPrompt() {
    if (currentQTE.currentIndex >= currentQTE.sequence.length) {
        handleQTEComplete();
        return;
    }

    const key = currentQTE.sequence[currentQTE.currentIndex];
    const keyInfo = QTE_KEY_DISPLAY[key] || { label: key, icon: 'fa-keyboard', color: '#fff' };

    // Update the prompt display
    const promptEl = document.getElementById('qte_key_prompt');
    if (promptEl) {
        promptEl.innerHTML = `
            <i class="fa-solid ${keyInfo.icon}" style="color: ${keyInfo.color}"></i>
            <span>${keyInfo.label}</span>
        `;
        promptEl.classList.remove('success', 'fail', 'perfect');
    }

    // Reset and start timer animation
    const timerCircle = document.getElementById('qte_timer_circle');
    if (timerCircle) {
        timerCircle.style.strokeDashoffset = '0';
        timerCircle.classList.remove('warning', 'critical');
    }

    // Store prompt start time
    currentQTE.promptStartTime = performance.now();

    // Execute prompt hook
    if (currentQTE.profile.onPrompt) {
        executeWithTimeout(currentQTE.profile.onPrompt);
    }

    // Set timeout for this prompt
    if (currentQTE.timeoutId) clearTimeout(currentQTE.timeoutId);
    currentQTE.timeoutId = setTimeout(() => handleQTEMiss(), currentQTE.currentTimeWindow);

    // Animate timer
    animateQTETimer();
}

function animateQTETimer() {
    const timerCircle = document.getElementById('qte_timer_circle');
    if (!timerCircle || !currentQTE.isOpen || currentQTE.isComplete) return;

    const elapsed = performance.now() - currentQTE.promptStartTime;
    const progress = elapsed / currentQTE.currentTimeWindow;
    const dashOffset = 283 * progress; // 283 is the circumference (2 * PI * 45)

    timerCircle.style.strokeDashoffset = dashOffset;

    // Color changes based on time remaining
    if (progress > 0.75) {
        timerCircle.classList.add('critical');
        timerCircle.classList.remove('warning');
    } else if (progress > 0.5) {
        timerCircle.classList.add('warning');
        timerCircle.classList.remove('critical');
    }

    if (progress < 1 && currentQTE.isOpen && !currentQTE.isComplete) {
        requestAnimationFrame(animateQTETimer);
    }
}

function handleQTEKeydown(e) {
    if (!currentQTE.isOpen || currentQTE.isComplete) return;

    // Get the expected key
    const expectedKey = currentQTE.sequence[currentQTE.currentIndex];
    let pressedKey = e.key.toUpperCase();

    // Handle space key
    if (e.key === ' ') pressedKey = 'SPACE';

    // Check if this is an allowed key
    if (!currentQTE.profile.allowedKeys.includes(pressedKey)) {
        return; // Ignore keys not in the allowed set
    }

    e.preventDefault();

    if (pressedKey === expectedKey) {
        handleQTESuccess();
    } else {
        handleQTEMiss();
    }
}

async function handleQTESuccess() {
    // Clear timeout
    if (currentQTE.timeoutId) {
        clearTimeout(currentQTE.timeoutId);
        currentQTE.timeoutId = null;
    }

    // Calculate timing
    const reactionTime = performance.now() - currentQTE.promptStartTime;
    const perfectWindow = currentQTE.currentTimeWindow * (currentQTE.profile.perfectWindowPercent / 100);
    const isPerfect = reactionTime <= perfectWindow;

    // Update stats
    currentQTE.successes++;
    currentQTE.combo++;
    currentQTE.maxCombo = Math.max(currentQTE.maxCombo, currentQTE.combo);

    // Animate success
    const promptEl = document.getElementById('qte_key_prompt');

    if (isPerfect) {
        currentQTE.perfects++;
        promptEl?.classList.add('perfect');
        addQTELogEntry(`PERFECT! (${Math.round(reactionTime)}ms)`);

        // Execute perfect hook
        if (currentQTE.profile.onPerfect) {
            await executeWithTimeout(currentQTE.profile.onPerfect);
        }
    } else {
        promptEl?.classList.add('success');
        addQTELogEntry(`Success! (${Math.round(reactionTime)}ms)`);

        // Execute success hook
        if (currentQTE.profile.onSuccess) {
            await executeWithTimeout(currentQTE.profile.onSuccess);
        }
    }

    // Log combo milestones
    if (currentQTE.combo > 1 && currentQTE.combo % 3 === 0) {
        addQTELogEntry(`Combo x${currentQTE.combo}!`);
    }

    // Move to next prompt
    currentQTE.currentIndex++;
    updateQTEDisplay();

    // Scale time window for difficulty
    if (currentQTE.profile.difficultyScaling) {
        currentQTE.currentTimeWindow = Math.max(
            currentQTE.profile.timeWindowMin,
            currentQTE.currentTimeWindow * currentQTE.profile.difficultyScaling
        );
    }

    // Brief delay before next prompt
    setTimeout(() => showNextQTEPrompt(), 400);
}

async function handleQTEMiss() {
    // Clear timeout
    if (currentQTE.timeoutId) {
        clearTimeout(currentQTE.timeoutId);
        currentQTE.timeoutId = null;
    }

    // Update stats
    currentQTE.misses++;
    currentQTE.combo = 0;

    // Animate failure
    const promptEl = document.getElementById('qte_key_prompt');
    promptEl?.classList.add('fail');

    const expectedKey = currentQTE.sequence[currentQTE.currentIndex];
    addQTELogEntry(`Miss! Expected: ${expectedKey}`);

    // Execute miss hook
    if (currentQTE.profile.onMiss) {
        await executeWithTimeout(currentQTE.profile.onMiss);
    }

    // Move to next prompt
    currentQTE.currentIndex++;
    updateQTEDisplay();

    // Brief delay before next prompt
    setTimeout(() => showNextQTEPrompt(), 400);
}

async function handleQTEComplete() {
    currentQTE.isComplete = true;

    // Determine success based on success rate
    const successRate = currentQTE.successes / currentQTE.sequence.length;
    currentQTE.isSuccess = successRate >= 0.5; // Pass if 50% or more successful

    // Remove keyboard handler
    document.removeEventListener('keydown', handleQTEKeydown);

    const profile = currentQTE.profile;

    if (currentQTE.isSuccess) {
        addQTELogEntry('QTE Complete - Success!');

        // Execute complete hook
        if (profile.onComplete) {
            await executeWithTimeout(profile.onComplete);
        }

        // Handle item drops if in maze
        if (currentMaze.isOpen && currentMaze.pendingEncounter) {
            if (Math.random() * 100 < (profile.keyDropChance || 30)) {
                addToInventory('key');
                addQTELogEntry('You found a Key!');
            }
            if (Math.random() * 100 < (profile.strikeDropChance || 15)) {
                addToInventory('strike');
                addQTELogEntry('You found a Strike!');
            }
            if (Math.random() * 100 < (profile.healingPotionDropChance || 15)) {
                addToInventory('healingPotion');
                addQTELogEntry('You found a Healing Potion!');
            }
        }

        // Store result
        lastResults.qte = lastResults.qte || {};
        lastResults.qte[currentQTE.profileName] = {
            result: 'success',
            successRate: successRate,
            perfects: currentQTE.perfects,
            maxCombo: currentQTE.maxCombo,
            timestamp: Date.now(),
        };
    } else {
        addQTELogEntry('QTE Failed...');

        // Execute fail hook
        if (profile.onFail) {
            await executeWithTimeout(profile.onFail);
        }

        // Apply maze HP damage
        let playerDied = false;
        if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
            const damage = profile.damage || 20;
            const mazeMultiplier = currentMaze.profile?.battlebarDamageMultiplier ?? 1.0;
            const actualDamage = Math.round(damage * mazeMultiplier);
            const survived = await applyDamage(actualDamage, 'qte');
            playerDied = !survived;
        }

        // Store result
        lastResults.qte = lastResults.qte || {};
        lastResults.qte[currentQTE.profileName] = {
            result: 'fail',
            successRate: successRate,
            perfects: currentQTE.perfects,
            maxCombo: currentQTE.maxCombo,
            timestamp: Date.now(),
        };

        // If player died, close modal and let death handling take over
        if (playerDied) {
            closeQTEModal();
            return;
        }
    }

    showQTEResult();
}

function showQTEResult() {
    const promptArea = document.querySelector('.mazemaster-qte-prompt-area');
    const statsArea = document.querySelector('.mazemaster-qte-stats');
    const logArea = document.querySelector('.mazemaster-qte-log');
    const resultPanel = document.getElementById('qte_result_panel');
    const resultText = document.getElementById('qte_result_text');
    const resultStats = document.getElementById('qte_result_stats');

    if (promptArea) promptArea.style.display = 'none';
    if (statsArea) statsArea.style.display = 'none';
    if (logArea) logArea.style.display = 'none';
    if (resultPanel) resultPanel.style.display = 'block';

    const successRate = Math.round((currentQTE.successes / currentQTE.sequence.length) * 100);

    if (resultText) {
        if (currentQTE.isSuccess) {
            resultText.textContent = currentQTE.perfects === currentQTE.sequence.length ? 'PERFECT!' : 'Success!';
            resultText.className = 'qte-result-text success';
        } else {
            resultText.textContent = 'Failed...';
            resultText.className = 'qte-result-text fail';
        }
    }

    if (resultStats) {
        resultStats.innerHTML = `
            <div>Hits: ${currentQTE.successes}/${currentQTE.sequence.length} (${successRate}%)</div>
            <div>Perfect: ${currentQTE.perfects} | Max Combo: ${currentQTE.maxCombo}x</div>
        `;
    }
}

async function closeQTEModal() {
    // Clear any pending timeout
    if (currentQTE.timeoutId) {
        clearTimeout(currentQTE.timeoutId);
        currentQTE.timeoutId = null;
    }

    // Remove keyboard handler
    document.removeEventListener('keydown', handleQTEKeydown);

    const modal = document.getElementById('mazemaster_qte_modal');
    if (modal) modal.remove();

    const wasSuccess = currentQTE.isSuccess;
    currentQTE.isOpen = false;

    // Handle maze integration
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasSuccess) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);
                    // Heal player on successful QTE completion (skill reward)
                    if (currentMaze.hp && currentMaze.profile?.hpEnabled !== false) {
                        const healPercent = currentMaze.profile.skillEncounterHealPercent || 25;
                        const maxTotal = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
                        const healAmount = Math.floor(maxTotal * (healPercent / 100));
                        if (currentMaze.hp.current < maxTotal && healAmount > 0) {
                            await healPlayer(healAmount, false, 'QTE success');
                            addMazeLogMessage(`Quick reflexes! Recovered ${healAmount} HP.`, 'heal');
                        }
                    }

                    if (encounterType === 'exit_qte') {
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeQTEModal:', err);
        }

        // Always ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

// =============================================================================
// DICE COMBAT MODAL & GAME LOGIC
// =============================================================================

// Dice type configuration
const DICE_TYPES = {
    'd4': { sides: 4, icon: 'fa-dice-d4', color: '#e74c3c' },
    'd6': { sides: 6, icon: 'fa-dice-d6', color: '#3498db' },
    'd8': { sides: 8, icon: 'fa-dice', color: '#2ecc71' },
    'd10': { sides: 10, icon: 'fa-dice-d10', color: '#f39c12' },
    'd12': { sides: 12, icon: 'fa-dice-d12', color: '#9b59b6' },
    'd20': { sides: 20, icon: 'fa-dice-d20', color: '#e67e22' },
    'd100': { sides: 100, icon: 'fa-percent', color: '#1abc9c' },
};

function getDiceModalHtml() {
    return `
        <div id="mazemaster_dice_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-dice-container">
                <div id="dice_main_title" class="mazemaster-dice-main-title">Roll the Dice!</div>
                <div id="dice_description" class="mazemaster-dice-description"></div>

                <div class="mazemaster-dice-info">
                    <span class="dice-info-item">
                        <i class="fa-solid fa-bullseye"></i>
                        Target: <span id="dice_threshold">0</span>
                    </span>
                    <span class="dice-info-item">
                        <i class="fa-solid fa-plus-minus"></i>
                        Modifier: <span id="dice_modifier">+0</span>
                    </span>
                    <span class="dice-info-item">
                        <i class="fa-solid fa-rotate"></i>
                        Rerolls: <span id="dice_rerolls">0</span>
                    </span>
                </div>

                <div class="mazemaster-dice-roll-area" id="dice_roll_area">
                    <div class="dice-waiting">
                        <i class="fa-solid fa-dice fa-3x"></i>
                        <div>Click to Roll!</div>
                    </div>
                </div>

                <div class="mazemaster-dice-result" id="dice_result_display" style="display: none;">
                    <div class="dice-result-total">
                        <span id="dice_result_total">0</span>
                    </div>
                    <div class="dice-result-breakdown" id="dice_result_breakdown"></div>
                </div>

                <div class="mazemaster-dice-log" id="dice_combat_log">
                    <div class="dice-log-entry">Ready to roll...</div>
                </div>

                <div class="mazemaster-dice-actions" id="dice_actions">
                    <button id="dice_roll_btn" class="mazemaster-dice-btn dice-btn-roll">
                        <i class="fa-solid fa-dice"></i> Roll
                    </button>
                </div>

                <div class="mazemaster-dice-final" id="dice_final_panel" style="display: none;">
                    <div id="dice_final_text" class="dice-final-text"></div>
                    <button id="dice_close_btn" class="mazemaster-dice-btn dice-btn-close">
                        <i class="fa-solid fa-check"></i> Close
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getDiceStyles() {
    return `
        .mazemaster-dice-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 25px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            border: 2px solid #f39c12;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(243, 156, 18, 0.3);
            width: 420px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .mazemaster-dice-main-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .mazemaster-dice-description {
            font-size: 0.9em;
            color: #aaa;
            text-align: center;
            max-width: 350px;
        }

        .mazemaster-dice-info {
            display: flex;
            gap: 20px;
            font-size: 0.95em;
            color: #ddd;
        }

        .dice-info-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dice-info-item i {
            color: #f39c12;
        }

        .mazemaster-dice-roll-area {
            width: 100%;
            min-height: 120px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mazemaster-dice-roll-area:hover {
            background: rgba(243, 156, 18, 0.2);
        }

        .dice-waiting {
            text-align: center;
            color: #888;
        }

        .dice-waiting i {
            margin-bottom: 10px;
            animation: dice-pulse 2s ease-in-out infinite;
        }

        @keyframes dice-pulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        .dice-rolling {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .dice-single {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            animation: dice-roll 0.5s ease-out;
        }

        .dice-single.critical-success {
            background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%);
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.5);
        }

        .dice-single.critical-fail {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
        }

        @keyframes dice-roll {
            0% { transform: rotateX(0deg) rotateY(0deg) scale(0.5); opacity: 0; }
            50% { transform: rotateX(180deg) rotateY(180deg) scale(1.2); }
            100% { transform: rotateX(360deg) rotateY(360deg) scale(1); opacity: 1; }
        }

        .mazemaster-dice-result {
            text-align: center;
        }

        .dice-result-total {
            font-size: 3em;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .dice-result-total.success { color: #2ecc71; }
        .dice-result-total.fail { color: #e74c3c; }
        .dice-result-total.critical-success {
            color: #f1c40f;
            animation: critical-glow 1s ease-in-out infinite;
        }
        .dice-result-total.critical-fail {
            color: #c0392b;
            animation: critical-shake 0.5s ease-in-out;
        }

        @keyframes critical-glow {
            0%, 100% { text-shadow: 0 0 10px rgba(241, 196, 15, 0.5); }
            50% { text-shadow: 0 0 30px rgba(241, 196, 15, 1); }
        }

        @keyframes critical-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .dice-result-breakdown {
            font-size: 0.9em;
            color: #888;
            margin-top: 5px;
        }

        .mazemaster-dice-log {
            width: 100%;
            height: 60px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.85em;
            color: #ccc;
        }

        .dice-log-entry { padding: 2px 0; }
        .dice-log-success { color: #2ecc71; }
        .dice-log-fail { color: #e74c3c; }
        .dice-log-critical { color: #f1c40f; font-weight: bold; }
        .dice-log-reroll { color: #3498db; }

        .mazemaster-dice-actions {
            display: flex;
            gap: 10px;
        }

        .mazemaster-dice-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mazemaster-dice-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .mazemaster-dice-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .dice-btn-roll {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
        }

        .dice-btn-reroll {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .dice-btn-close {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 15px 40px;
        }

        .mazemaster-dice-final {
            text-align: center;
            padding: 15px;
        }

        .dice-final-text {
            font-size: 1.6em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .dice-final-text.success { color: #2ecc71; }
        .dice-final-text.fail { color: #e74c3c; }
    `;
}

function rollDie(sides) {
    return Math.floor(Math.random() * sides) + 1;
}

function startDice(profileName) {
    console.log('[MazeMaster] startDice called with profile:', profileName);
    const profile = getDiceProfile(profileName);
    console.log('[MazeMaster] Dice profile retrieved:', profile);
    if (!profile) {
        console.error(`[MazeMaster] Dice profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    const diceConfig = DICE_TYPES[profile.diceType] || DICE_TYPES['d6'];

    // Initialize dice state
    currentDice = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        diceResults: [],
        total: 0,
        rawTotal: 0,
        threshold: profile.threshold,
        modifier: profile.modifier || 0,
        rerollsRemaining: profile.rerollsAllowed || 0,
        isCriticalSuccess: false,
        isCriticalFail: false,
        isSuccess: false,
        isComplete: false,
        combatLog: ['Ready to roll...'],
    };

    // Pause maze if active
    if (currentMaze.isOpen) {
        currentMaze.isPaused = true;
    }

    showDiceModal();

    // Execute start hook
    if (profile.onStart) {
        executeWithTimeout(profile.onStart);
    }

    console.log(`[MazeMaster] Dice started: ${profileName}`);
    return { success: true };
}

function showDiceModal() {
    const existing = document.getElementById('mazemaster_dice_modal');
    if (existing) existing.remove();

    if (!document.getElementById('mazemaster_dice_styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_dice_styles';
        styleEl.textContent = getDiceStyles();
        document.head.appendChild(styleEl);
    }

    document.body.insertAdjacentHTML('beforeend', getDiceModalHtml());

    const profile = currentDice.profile;

    // Update UI
    document.getElementById('dice_main_title').textContent = profile.mainTitle || 'Roll the Dice!';
    document.getElementById('dice_description').textContent = profile.description || '';

    const thresholdText = profile.thresholdType === 'beat' ? `> ${profile.threshold}` : ` ${profile.threshold}`;
    document.getElementById('dice_threshold').textContent = thresholdText;

    const modText = profile.modifier >= 0 ? `+${profile.modifier}` : `${profile.modifier}`;
    document.getElementById('dice_modifier').textContent = modText;
    document.getElementById('dice_rerolls').textContent = currentDice.rerollsRemaining;

    // Event handlers
    document.getElementById('dice_roll_area')?.addEventListener('click', performDiceRoll);
    document.getElementById('dice_roll_btn')?.addEventListener('click', performDiceRoll);
    document.getElementById('dice_close_btn')?.addEventListener('click', closeDiceModal);

    updateDiceDisplay();
}

function updateDiceDisplay() {
    document.getElementById('dice_rerolls').textContent = currentDice.rerollsRemaining;

    // Update combat log
    const logEl = document.getElementById('dice_combat_log');
    if (logEl) {
        logEl.innerHTML = currentDice.combatLog.map(entry => {
            let className = 'dice-log-entry';
            if (entry.includes('Success') || entry.includes('passed')) className += ' dice-log-success';
            if (entry.includes('Failed') || entry.includes('failed')) className += ' dice-log-fail';
            if (entry.includes('Critical') || entry.includes('CRITICAL')) className += ' dice-log-critical';
            if (entry.includes('Reroll')) className += ' dice-log-reroll';
            return `<div class="${className}">${entry}</div>`;
        }).join('');
        logEl.scrollTop = logEl.scrollHeight;
    }
}

function addDiceLogEntry(message) {
    currentDice.combatLog.push(message);
    if (currentDice.combatLog.length > 20) {
        currentDice.combatLog.shift();
    }
    updateDiceDisplay();
}

async function performDiceRoll() {
    if (currentDice.isComplete) return;

    const profile = currentDice.profile;
    const diceConfig = DICE_TYPES[profile.diceType] || DICE_TYPES['d6'];
    const diceCount = profile.diceCount || 1;

    // Roll the dice
    const results = [];
    for (let i = 0; i < diceCount; i++) {
        results.push(rollDie(diceConfig.sides));
    }

    currentDice.diceResults = results;
    currentDice.rawTotal = results.reduce((sum, val) => sum + val, 0);
    currentDice.total = currentDice.rawTotal + currentDice.modifier;

    // Animate dice roll
    const rollArea = document.getElementById('dice_roll_area');
    rollArea.innerHTML = `<div class="dice-rolling">${results.map(r => `<div class="dice-single">${r}</div>`).join('')}</div>`;

    // Log the roll
    const diceNotation = `${diceCount}${profile.diceType}`;
    const modStr = currentDice.modifier !== 0 ? (currentDice.modifier > 0 ? ` + ${currentDice.modifier}` : ` - ${Math.abs(currentDice.modifier)}`) : '';
    addDiceLogEntry(`Rolled ${diceNotation}: [${results.join(', ')}]${modStr} = ${currentDice.total}`);

    // Execute roll hook
    if (profile.onRoll) {
        await executeWithTimeout(profile.onRoll);
    }

    // Check for criticals
    currentDice.isCriticalSuccess = currentDice.rawTotal >= profile.criticalSuccess;
    currentDice.isCriticalFail = currentDice.rawTotal <= profile.criticalFail;

    // Check success/failure
    if (profile.thresholdType === 'beat') {
        currentDice.isSuccess = currentDice.total > currentDice.threshold;
    } else {
        currentDice.isSuccess = currentDice.total >= currentDice.threshold;
    }

    // Show result display
    setTimeout(() => {
        showDiceResult();
    }, 600);
}

async function showDiceResult() {
    const profile = currentDice.profile;
    const resultDisplay = document.getElementById('dice_result_display');
    const totalEl = document.getElementById('dice_result_total');
    const breakdownEl = document.getElementById('dice_result_breakdown');
    const actionsEl = document.getElementById('dice_actions');

    resultDisplay.style.display = 'block';
    totalEl.textContent = currentDice.total;

    // Style based on result
    let resultClass = currentDice.isSuccess ? 'success' : 'fail';
    if (currentDice.isCriticalSuccess) resultClass = 'critical-success';
    if (currentDice.isCriticalFail) resultClass = 'critical-fail';
    totalEl.className = 'dice-result-total ' + resultClass;

    // Update dice visuals for crits
    const diceEls = document.querySelectorAll('.dice-single');
    if (currentDice.isCriticalSuccess) {
        diceEls.forEach(el => el.classList.add('critical-success'));
    } else if (currentDice.isCriticalFail) {
        diceEls.forEach(el => el.classList.add('critical-fail'));
    }

    // Breakdown text
    const thresholdText = profile.thresholdType === 'beat' ? `needed > ${currentDice.threshold}` : `needed  ${currentDice.threshold}`;
    breakdownEl.textContent = thresholdText;

    // Handle criticals
    if (currentDice.isCriticalSuccess) {
        addDiceLogEntry('CRITICAL SUCCESS!');
        if (profile.onCriticalSuccess) {
            await executeWithTimeout(profile.onCriticalSuccess);
        }
    } else if (currentDice.isCriticalFail) {
        addDiceLogEntry('CRITICAL FAILURE!');
        if (profile.onCriticalFail) {
            await executeWithTimeout(profile.onCriticalFail);
        }
    }

    // Handle success/fail hooks
    if (currentDice.isSuccess) {
        addDiceLogEntry('Roll passed!');
        if (profile.onSuccess) {
            await executeWithTimeout(profile.onSuccess);
        }
    } else {
        addDiceLogEntry('Roll failed...');
        if (profile.onFail) {
            await executeWithTimeout(profile.onFail);
        }
    }

    // Update actions - show reroll button if available
    if (currentDice.rerollsRemaining > 0 && !currentDice.isSuccess) {
        const rerollCostText = profile.rerollCost === 'none' ? '' : ` (costs 1 ${profile.rerollCost})`;
        actionsEl.innerHTML = `
            <button id="dice_reroll_btn" class="mazemaster-dice-btn dice-btn-reroll">
                <i class="fa-solid fa-rotate"></i> Reroll${rerollCostText}
            </button>
            <button id="dice_accept_btn" class="mazemaster-dice-btn dice-btn-close">
                <i class="fa-solid fa-check"></i> Accept
            </button>
        `;
        document.getElementById('dice_reroll_btn')?.addEventListener('click', handleDiceReroll);
        document.getElementById('dice_accept_btn')?.addEventListener('click', finalizeDiceResult);
    } else {
        // Auto-finalize if no rerolls or success
        setTimeout(() => finalizeDiceResult(), 1000);
    }
}

async function handleDiceReroll() {
    const profile = currentDice.profile;

    // Check reroll cost
    if (profile.rerollCost !== 'none') {
        const itemKey = profile.rerollCost; // 'strike', 'key', etc.
        if (currentMaze.isOpen && currentMaze.inventory) {
            if ((currentMaze.inventory[itemKey] || 0) <= 0) {
                addDiceLogEntry(`Not enough ${itemKey}s to reroll!`);
                return;
            }
            currentMaze.inventory[itemKey]--;
            addDiceLogEntry(`Spent 1 ${itemKey} to reroll`);
        }
    }

    currentDice.rerollsRemaining--;
    addDiceLogEntry(`Rerolling... (${currentDice.rerollsRemaining} left)`);

    // Execute reroll hook
    if (profile.onReroll) {
        await executeWithTimeout(profile.onReroll);
    }

    // Reset result display
    document.getElementById('dice_result_display').style.display = 'none';

    // Perform new roll
    await performDiceRoll();
}

async function finalizeDiceResult() {
    currentDice.isComplete = true;
    const profile = currentDice.profile;

    const actionsEl = document.getElementById('dice_actions');
    actionsEl.style.display = 'none';

    const finalPanel = document.getElementById('dice_final_panel');
    const finalText = document.getElementById('dice_final_text');

    if (currentDice.isSuccess) {
        if (currentDice.isCriticalSuccess) {
            finalText.textContent = 'CRITICAL SUCCESS!';
        } else {
            finalText.textContent = 'Success!';
        }
        finalText.className = 'dice-final-text success';

        // Execute complete hook
        if (profile.onComplete) {
            await executeWithTimeout(profile.onComplete);
        }

        // Handle item drops if in maze
        if (currentMaze.isOpen && currentMaze.pendingEncounter) {
            if (Math.random() * 100 < (profile.keyDropChance || 25)) {
                addToInventory('key');
                addDiceLogEntry('You found a Key!');
            }
            if (Math.random() * 100 < (profile.strikeDropChance || 12)) {
                addToInventory('strike');
                addDiceLogEntry('You found a Strike!');
            }
            if (Math.random() * 100 < (profile.healingPotionDropChance || 15)) {
                addToInventory('healingPotion');
                addDiceLogEntry('You found a Healing Potion!');
            }
        }

        // Store result
        lastResults.dice = lastResults.dice || {};
        lastResults.dice[currentDice.profileName] = {
            result: 'success',
            total: currentDice.total,
            rawTotal: currentDice.rawTotal,
            isCritical: currentDice.isCriticalSuccess,
            timestamp: Date.now(),
        };
    } else {
        if (currentDice.isCriticalFail) {
            finalText.textContent = 'CRITICAL FAILURE!';
        } else {
            finalText.textContent = 'Failed...';
        }
        finalText.className = 'dice-final-text fail';

        // Execute lose hook
        if (profile.onLose) {
            await executeWithTimeout(profile.onLose);
        }

        // Apply maze HP damage
        let playerDied = false;
        if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
            let damage = profile.damage || 20;
            if (currentDice.isCriticalFail) {
                damage = Math.round(damage * 1.5); // Extra damage on crit fail
            }
            const mazeMultiplier = currentMaze.profile?.battlebarDamageMultiplier ?? 1.0;
            const actualDamage = Math.round(damage * mazeMultiplier);
            const survived = await applyDamage(actualDamage, 'dice');
            playerDied = !survived;
        }

        // Store result
        lastResults.dice = lastResults.dice || {};
        lastResults.dice[currentDice.profileName] = {
            result: 'fail',
            total: currentDice.total,
            rawTotal: currentDice.rawTotal,
            isCritical: currentDice.isCriticalFail,
            timestamp: Date.now(),
        };

        // If player died, close modal and let death handling take over
        if (playerDied) {
            closeDiceModal();
            return;
        }
    }

    finalPanel.style.display = 'block';
}

async function closeDiceModal() {
    const modal = document.getElementById('mazemaster_dice_modal');
    if (modal) modal.remove();

    const wasSuccess = currentDice.isSuccess;
    currentDice.isOpen = false;

    // Handle maze integration
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasSuccess) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);
                    if (encounterType === 'exit_dice') {
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeDiceModal:', err);
        }

        // Always ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

// =============================================================================
// STEALTH ENCOUNTER MODAL & GAME LOGIC
// =============================================================================

function getStealthModalHtml() {
    return `
        <div id="mazemaster_stealth_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-stealth-container">
                <div id="stealth_main_title" class="mazemaster-stealth-main-title">Stealth</div>
                <div id="stealth_description" class="mazemaster-stealth-description"></div>

                <div class="mazemaster-stealth-progress">
                    <div class="stealth-sections">
                        <span>Progress: </span>
                        <span id="stealth_section_display"></span>
                    </div>
                </div>

                <div class="mazemaster-stealth-detection">
                    <div class="stealth-detection-label">
                        <i class="fa-solid fa-eye"></i>
                        <span>Detection</span>
                    </div>
                    <div class="stealth-detection-bar">
                        <div class="stealth-detection-fill" id="stealth_detection_bar"></div>
                    </div>
                    <div class="stealth-detection-text">
                        <span id="stealth_detection_value">0</span>/<span id="stealth_detection_max">100</span>
                    </div>
                </div>

                <div class="mazemaster-stealth-guard" id="stealth_guard_area">
                    <i class="fa-solid fa-user-shield fa-3x"></i>
                    <div id="stealth_guard_name">Guard</div>
                    <div id="stealth_guard_status">Unaware</div>
                </div>

                <div class="mazemaster-stealth-log" id="stealth_combat_log">
                    <div class="stealth-log-entry">You begin your infiltration...</div>
                </div>

                <div class="mazemaster-stealth-actions" id="stealth_actions">
                    <button id="stealth_advance_btn" class="mazemaster-stealth-btn stealth-btn-advance" title="Move forward - risky but progresses">
                        <i class="fa-solid fa-forward"></i> Advance
                    </button>
                    <button id="stealth_hide_btn" class="mazemaster-stealth-btn stealth-btn-hide" title="Stay hidden - reduces detection">
                        <i class="fa-solid fa-mask"></i> Hide
                    </button>
                    <button id="stealth_distract_btn" class="mazemaster-stealth-btn stealth-btn-distract" title="Create a distraction - may reduce detection significantly">
                        <i class="fa-solid fa-volume-high"></i> Distract
                    </button>
                    <button id="stealth_wait_btn" class="mazemaster-stealth-btn stealth-btn-wait" title="Wait patiently - small detection reduction">
                        <i class="fa-solid fa-hourglass-half"></i> Wait
                    </button>
                </div>

                <div class="mazemaster-stealth-result" id="stealth_result_panel" style="display: none;">
                    <div id="stealth_result_text" class="stealth-result-text"></div>
                    <button id="stealth_close_btn" class="mazemaster-stealth-btn stealth-btn-close">
                        <i class="fa-solid fa-check"></i> Close
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getStealthStyles() {
    return `
        .mazemaster-stealth-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 25px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1a 100%);
            border-radius: 15px;
            border: 2px solid #1abc9c;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(26, 188, 156, 0.3);
            width: 450px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .mazemaster-stealth-main-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .mazemaster-stealth-description {
            font-size: 0.9em;
            color: #aaa;
            text-align: center;
            max-width: 380px;
        }

        .mazemaster-stealth-progress {
            width: 100%;
            text-align: center;
        }

        .stealth-sections {
            font-size: 1.1em;
            color: #1abc9c;
        }

        #stealth_section_display {
            font-weight: bold;
        }

        .mazemaster-stealth-detection {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stealth-detection-label {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #e74c3c;
            min-width: 90px;
        }

        .stealth-detection-bar {
            flex: 1;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
        }

        .stealth-detection-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #27ae60, #f39c12, #e74c3c);
            transition: width 0.3s ease;
        }

        .stealth-detection-text {
            min-width: 60px;
            text-align: right;
            color: #ddd;
        }

        .mazemaster-stealth-guard {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            width: 100%;
        }

        .mazemaster-stealth-guard i {
            color: #7f8c8d;
            transition: all 0.3s ease;
        }

        .mazemaster-stealth-guard.alert i {
            color: #f39c12;
            animation: guard-alert 1s ease infinite;
        }

        .mazemaster-stealth-guard.detected i {
            color: #e74c3c;
            animation: guard-detected 0.5s ease infinite;
        }

        @keyframes guard-alert {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        @keyframes guard-detected {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        #stealth_guard_name {
            font-size: 1.1em;
            font-weight: bold;
            color: #ddd;
        }

        #stealth_guard_status {
            font-size: 0.9em;
            color: #888;
        }

        #stealth_guard_status.alert { color: #f39c12; }
        #stealth_guard_status.detected { color: #e74c3c; font-weight: bold; }

        .mazemaster-stealth-log {
            width: 100%;
            height: 80px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.85em;
            color: #ccc;
        }

        .stealth-log-entry { padding: 2px 0; }
        .stealth-log-success { color: #1abc9c; }
        .stealth-log-fail { color: #e74c3c; }
        .stealth-log-warning { color: #f39c12; }
        .stealth-log-action { color: #3498db; }

        .mazemaster-stealth-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 100%;
        }

        .mazemaster-stealth-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .mazemaster-stealth-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .mazemaster-stealth-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .stealth-btn-advance {
            background: linear-gradient(135deg, #1abc9c 0%, #16a085 100%);
            color: white;
        }

        .stealth-btn-hide {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }

        .stealth-btn-distract {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
        }

        .stealth-btn-wait {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .stealth-btn-close {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 15px 40px;
        }

        .mazemaster-stealth-result {
            text-align: center;
            padding: 15px;
        }

        .stealth-result-text {
            font-size: 1.6em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .stealth-result-text.success { color: #1abc9c; }
        .stealth-result-text.fail { color: #e74c3c; }
    `;
}

function startStealth(profileName) {
    console.log('[MazeMaster] startStealth called with profile:', profileName);
    const profile = getStealthProfile(profileName);
    console.log('[MazeMaster] Retrieved stealth profile:', profile);
    if (!profile) {
        console.error(`[MazeMaster] Stealth profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    console.log('[MazeMaster] Initializing stealth state with config:', {
        sectionsToPass: profile.sectionsToPass,
        detectionThreshold: profile.detectionThreshold
    });
    // Initialize stealth state
    currentStealth = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        currentSection: 0,
        sectionsToPass: profile.sectionsToPass,
        detection: 0,
        detectionThreshold: profile.detectionThreshold,
        isSuccess: false,
        isCaught: false,
        isComplete: false,
        actionsTaken: 0,
        combatLog: ['You begin your infiltration...'],
    };
    console.log('[MazeMaster] currentStealth initialized:', currentStealth);

    // Pause maze if active
    if (currentMaze.isOpen) {
        currentMaze.isPaused = true;
        console.log('[MazeMaster] Maze paused for stealth');
    }

    console.log('[MazeMaster] Calling showStealthModal...');
    showStealthModal();

    // Execute start hook
    if (profile.onStart) {
        executeWithTimeout(profile.onStart);
    }

    console.log(`[MazeMaster] Stealth started: ${profileName}`);
    return { success: true };
}

function showStealthModal() {
    console.log('[MazeMaster] showStealthModal called');
    const existing = document.getElementById('mazemaster_stealth_modal');
    if (existing) {
        console.log('[MazeMaster] Removing existing stealth modal');
        existing.remove();
    }

    if (!document.getElementById('mazemaster_stealth_styles')) {
        console.log('[MazeMaster] Adding stealth styles to document');
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_stealth_styles';
        styleEl.textContent = getStealthStyles();
        document.head.appendChild(styleEl);
    }

    console.log('[MazeMaster] Inserting stealth modal HTML');
    document.body.insertAdjacentHTML('beforeend', getStealthModalHtml());

    const modalEl = document.getElementById('mazemaster_stealth_modal');
    console.log('[MazeMaster] Stealth modal element after insert:', modalEl);

    const profile = currentStealth.profile;
    console.log('[MazeMaster] Updating stealth UI with profile:', profile?.name);

    // Update UI
    const titleEl = document.getElementById('stealth_main_title');
    const descEl = document.getElementById('stealth_description');
    console.log('[MazeMaster] Stealth UI elements - title:', titleEl, 'desc:', descEl);

    if (titleEl) titleEl.textContent = profile.mainTitle || 'Stealth';
    if (descEl) descEl.textContent = profile.description || '';
    document.getElementById('stealth_guard_name').textContent = profile.guardName || 'Guard';
    document.getElementById('stealth_detection_max').textContent = currentStealth.detectionThreshold;

    // Event handlers
    console.log('[MazeMaster] Attaching stealth event handlers');
    document.getElementById('stealth_advance_btn')?.addEventListener('click', () => handleStealthAction('advance'));
    document.getElementById('stealth_hide_btn')?.addEventListener('click', () => handleStealthAction('hide'));
    document.getElementById('stealth_distract_btn')?.addEventListener('click', () => handleStealthAction('distract'));
    document.getElementById('stealth_wait_btn')?.addEventListener('click', () => handleStealthAction('wait'));
    document.getElementById('stealth_close_btn')?.addEventListener('click', closeStealthModal);

    console.log('[MazeMaster] Calling updateStealthDisplay');
    updateStealthDisplay();
    console.log('[MazeMaster] showStealthModal complete');
}

function updateStealthDisplay() {
    // Update section progress
    const sectionDisplay = document.getElementById('stealth_section_display');
    if (sectionDisplay) {
        let sections = '';
        for (let i = 0; i < currentStealth.sectionsToPass; i++) {
            if (i < currentStealth.currentSection) {
                sections += ' ';
            } else {
                sections += ' ';
            }
        }
        sectionDisplay.textContent = sections.trim();
    }

    // Update detection bar
    const detectionBar = document.getElementById('stealth_detection_bar');
    const detectionValue = document.getElementById('stealth_detection_value');
    const detectionPercent = (currentStealth.detection / currentStealth.detectionThreshold) * 100;
    if (detectionBar) detectionBar.style.width = `${Math.min(detectionPercent, 100)}%`;
    if (detectionValue) detectionValue.textContent = Math.round(currentStealth.detection);

    // Update guard status
    const guardArea = document.getElementById('stealth_guard_area');
    const guardStatus = document.getElementById('stealth_guard_status');
    if (guardArea && guardStatus) {
        guardArea.classList.remove('alert', 'detected');
        if (detectionPercent >= 80) {
            guardArea.classList.add('detected');
            guardStatus.textContent = 'ALERT!';
            guardStatus.className = 'detected';
        } else if (detectionPercent >= 50) {
            guardArea.classList.add('alert');
            guardStatus.textContent = 'Suspicious';
            guardStatus.className = 'alert';
        } else if (detectionPercent >= 25) {
            guardStatus.textContent = 'Cautious';
            guardStatus.className = '';
        } else {
            guardStatus.textContent = 'Unaware';
            guardStatus.className = '';
        }
    }

    // Update combat log
    const logEl = document.getElementById('stealth_combat_log');
    if (logEl) {
        logEl.innerHTML = currentStealth.combatLog.map(entry => {
            let className = 'stealth-log-entry';
            if (entry.includes('success') || entry.includes('passed') || entry.includes('clear')) className += ' stealth-log-success';
            if (entry.includes('spotted') || entry.includes('caught') || entry.includes('failed')) className += ' stealth-log-fail';
            if (entry.includes('suspicion') || entry.includes('alert') || entry.includes('detection')) className += ' stealth-log-warning';
            if (entry.includes('You ')) className += ' stealth-log-action';
            return `<div class="${className}">${entry}</div>`;
        }).join('');
        logEl.scrollTop = logEl.scrollHeight;
    }
}

function addStealthLogEntry(message) {
    currentStealth.combatLog.push(message);
    if (currentStealth.combatLog.length > 30) {
        currentStealth.combatLog.shift();
    }
    updateStealthDisplay();
}

async function handleStealthAction(action) {
    if (currentStealth.isComplete) return;

    const profile = currentStealth.profile;
    currentStealth.actionsTaken++;
    let success = false;
    let detectionChange = 0;

    switch (action) {
        case 'advance':
            success = Math.random() * 100 < profile.advanceSuccessChance;
            if (success) {
                currentStealth.currentSection++;
                addStealthLogEntry('You advance quietly... clear!');
                if (profile.onAdvance) await executeWithTimeout(profile.onAdvance);
            } else {
                detectionChange = profile.baseDetectionRate;
                addStealthLogEntry(`You made noise! (+${detectionChange} detection)`);
                if (profile.onDetectionIncrease) await executeWithTimeout(profile.onDetectionIncrease);
            }
            break;

        case 'hide':
            detectionChange = -profile.hideRecovery;
            addStealthLogEntry(`You hide in the shadows... (-${profile.hideRecovery} detection)`);
            if (profile.onHide) await executeWithTimeout(profile.onHide);
            success = true;
            break;

        case 'distract':
            success = Math.random() * 100 < profile.distractSuccessChance;
            if (success) {
                detectionChange = -profile.distractReduction;
                addStealthLogEntry(`Distraction worked! (-${profile.distractReduction} detection)`);
                if (profile.onDistract) await executeWithTimeout(profile.onDistract);
            } else {
                detectionChange = Math.round(profile.baseDetectionRate * 0.5);
                addStealthLogEntry(`Distraction failed! (+${detectionChange} detection)`);
                if (profile.onDetectionIncrease) await executeWithTimeout(profile.onDetectionIncrease);
            }
            break;

        case 'wait':
            detectionChange = -profile.waitRecovery;
            addStealthLogEntry(`You wait patiently... (-${profile.waitRecovery} detection)`);
            if (profile.onWait) await executeWithTimeout(profile.onWait);
            success = true;
            break;
    }

    // Apply detection change
    currentStealth.detection = Math.max(0, currentStealth.detection + detectionChange);

    updateStealthDisplay();

    // Check for caught
    if (currentStealth.detection >= currentStealth.detectionThreshold) {
        await handleStealthCaught();
        return;
    }

    // Check for success
    if (currentStealth.currentSection >= currentStealth.sectionsToPass) {
        await handleStealthSuccess();
    }
}

async function handleStealthSuccess() {
    currentStealth.isComplete = true;
    currentStealth.isSuccess = true;

    addStealthLogEntry('Infiltration successful!');

    const profile = currentStealth.profile;

    // Execute complete hook
    if (profile.onComplete) {
        await executeWithTimeout(profile.onComplete);
    }

    // Handle item drops if in maze
    if (currentMaze.isOpen && currentMaze.pendingEncounter) {
        if (Math.random() * 100 < (profile.keyDropChance || 20)) {
            addToInventory('key');
            addStealthLogEntry('You found a Key!');
        }
        if (Math.random() * 100 < (profile.stealthDropChance || 15)) {
            addToInventory('stealth');
            addStealthLogEntry('You found a Stealth item!');
        }
        if (Math.random() * 100 < (profile.healingPotionDropChance || 15)) {
            addToInventory('healingPotion');
            addStealthLogEntry('You found a Healing Potion!');
        }
    }

    // Store result
    lastResults.stealth = lastResults.stealth || {};
    lastResults.stealth[currentStealth.profileName] = {
        result: 'success',
        actionsTaken: currentStealth.actionsTaken,
        finalDetection: currentStealth.detection,
        timestamp: Date.now(),
    };

    showStealthResult();
}

async function handleStealthCaught() {
    currentStealth.isComplete = true;
    currentStealth.isCaught = true;

    addStealthLogEntry('You\'ve been caught!');

    const profile = currentStealth.profile;

    // Execute caught hook
    if (profile.onCaught) {
        await executeWithTimeout(profile.onCaught);
    }

    // Apply maze HP damage
    let playerDied = false;
    if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
        const damage = profile.damage || 25;
        const mazeMultiplier = currentMaze.profile?.battlebarDamageMultiplier ?? 1.0;
        const actualDamage = Math.round(damage * mazeMultiplier);
        const survived = await applyDamage(actualDamage, 'stealth');
        playerDied = !survived;
    }

    // Store result
    lastResults.stealth = lastResults.stealth || {};
    lastResults.stealth[currentStealth.profileName] = {
        result: 'caught',
        actionsTaken: currentStealth.actionsTaken,
        finalDetection: currentStealth.detection,
        timestamp: Date.now(),
    };

    // If player died, close stealth modal and let death handling take over
    if (playerDied) {
        closeStealthModal();
        return;
    }

    showStealthResult();
}

function showStealthResult() {
    const actionsEl = document.getElementById('stealth_actions');
    const resultPanel = document.getElementById('stealth_result_panel');
    const resultText = document.getElementById('stealth_result_text');

    if (actionsEl) actionsEl.style.display = 'none';
    if (resultPanel) resultPanel.style.display = 'block';

    if (resultText) {
        if (currentStealth.isSuccess) {
            resultText.textContent = 'Infiltration Successful!';
            resultText.className = 'stealth-result-text success';
        } else {
            resultText.textContent = 'Caught!';
            resultText.className = 'stealth-result-text fail';
        }
    }
}

async function closeStealthModal() {
    const modal = document.getElementById('mazemaster_stealth_modal');
    if (modal) modal.remove();

    const wasSuccess = currentStealth.isSuccess;
    currentStealth.isOpen = false;

    // Handle maze integration
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasSuccess) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);
                    // Heal player on successful stealth completion (skill reward)
                    if (currentMaze.hp && currentMaze.profile?.hpEnabled !== false) {
                        const healPercent = currentMaze.profile.skillEncounterHealPercent || 25;
                        const maxTotal = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
                        const healAmount = Math.floor(maxTotal * (healPercent / 100));
                        if (currentMaze.hp.current < maxTotal && healAmount > 0) {
                            await healPlayer(healAmount, false, 'Stealth success');
                            addMazeLogMessage(`Silent and deadly! Recovered ${healAmount} HP.`, 'heal');
                        }
                    }

                    if (encounterType === 'exit_stealth') {
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeStealthModal:', err);
        }

        // Always ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

// =============================================================================
// PUZZLE MODAL & GAME LOGIC
// =============================================================================

function getPuzzleModalHtml() {
    return `
        <div id="mazemaster_puzzle_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-puzzle-container">
                <div id="puzzle_main_title" class="puzzle-main-title">Puzzle</div>
                <div id="puzzle_description" class="puzzle-description"></div>

                <div class="puzzle-stats-row">
                    <div class="puzzle-stat">
                        <span class="puzzle-stat-label">Progress:</span>
                        <span id="puzzle_progress">0/0</span>
                    </div>
                    <div class="puzzle-stat">
                        <span class="puzzle-stat-label">Time:</span>
                        <span id="puzzle_timer">--</span>
                    </div>
                    <div class="puzzle-stat">
                        <span class="puzzle-stat-label">Hints:</span>
                        <span id="puzzle_hints">0</span>
                    </div>
                    <div class="puzzle-stat">
                        <span class="puzzle-stat-label">Mistakes:</span>
                        <span id="puzzle_mistakes">0/0</span>
                    </div>
                </div>

                <div class="puzzle-instruction" id="puzzle_instruction">Watch the sequence...</div>

                <div id="puzzle_grid_container" class="puzzle-grid-container">
                    <!-- Grid will be generated here -->
                </div>

                <div id="puzzle_actions" class="puzzle-actions">
                    <button id="puzzle_hint_btn" class="puzzle-btn puzzle-hint-btn">
                        <i class="fa-solid fa-lightbulb"></i> Use Hint
                    </button>
                    <button id="puzzle_reset_btn" class="puzzle-btn puzzle-reset-btn">
                        <i class="fa-solid fa-redo"></i> Show Sequence
                    </button>
                </div>

                <div id="puzzle_result_panel" class="puzzle-result-panel" style="display:none;">
                    <div id="puzzle_result_text" class="puzzle-result-text"></div>
                    <button id="puzzle_close_btn" class="puzzle-btn puzzle-close-btn">
                        <i class="fa-solid fa-check"></i> Continue
                    </button>
                </div>

                <div id="puzzle_combat_log" class="puzzle-combat-log"></div>
            </div>
        </div>
    `;
}

function getPuzzleStyles() {
    return `
        .mazemaster-puzzle-container {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            border: 2px solid #3d5a80;
            border-radius: 15px;
            padding: 25px;
            min-width: 450px;
            max-width: 550px;
            box-shadow: 0 0 40px rgba(61, 90, 128, 0.4);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0e0;
        }

        .puzzle-main-title {
            text-align: center;
            font-size: 1.8em;
            font-weight: bold;
            color: #9b59b6;
            text-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
            margin-bottom: 8px;
        }

        .puzzle-description {
            text-align: center;
            font-size: 0.95em;
            color: #bbb;
            margin-bottom: 15px;
            font-style: italic;
        }

        .puzzle-stats-row {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .puzzle-stat {
            text-align: center;
        }

        .puzzle-stat-label {
            color: #888;
            font-size: 0.85em;
            display: block;
        }

        .puzzle-stat span:not(.puzzle-stat-label) {
            color: #9b59b6;
            font-weight: bold;
            font-size: 1.1em;
        }

        .puzzle-instruction {
            text-align: center;
            font-size: 1.1em;
            color: #f1c40f;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(241, 196, 15, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(241, 196, 15, 0.3);
        }

        .puzzle-grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .puzzle-grid {
            display: grid;
            gap: 8px;
            padding: 15px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            border: 2px solid #3d5a80;
        }

        .puzzle-cell {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
            border: 2px solid #3d5a80;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
        }

        .puzzle-cell:hover:not(.disabled) {
            background: linear-gradient(135deg, #3d5a80 0%, #2c3e50 100%);
            transform: scale(1.05);
        }

        .puzzle-cell.highlighted {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            border-color: #bb6bd9;
            box-shadow: 0 0 20px rgba(155, 89, 182, 0.6);
            animation: puzzle-pulse 0.5s ease;
        }

        .puzzle-cell.correct {
            background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            border-color: #2ecc71;
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.5);
        }

        .puzzle-cell.wrong {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            border-color: #e74c3c;
            animation: puzzle-shake 0.3s ease;
        }

        .puzzle-cell.hint {
            background: linear-gradient(135deg, #f39c12 0%, #d68910 100%);
            border-color: #f1c40f;
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.5);
        }

        .puzzle-cell.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        @keyframes puzzle-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes puzzle-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .puzzle-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .puzzle-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .puzzle-hint-btn {
            background: linear-gradient(135deg, #f39c12 0%, #d68910 100%);
            color: white;
        }

        .puzzle-hint-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.5);
        }

        .puzzle-hint-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .puzzle-reset-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .puzzle-reset-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.5);
        }

        .puzzle-close-btn {
            background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .puzzle-close-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(39, 174, 96, 0.5);
        }

        .puzzle-result-panel {
            text-align: center;
            padding: 20px;
        }

        .puzzle-result-text {
            font-size: 1.6em;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .puzzle-result-text.success { color: #2ecc71; }
        .puzzle-result-text.fail { color: #e74c3c; }

        .puzzle-combat-log {
            max-height: 100px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            font-size: 0.9em;
        }

        .puzzle-log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .puzzle-log-entry:last-child { border-bottom: none; }
        .puzzle-log-success { color: #2ecc71; }
        .puzzle-log-fail { color: #e74c3c; }
        .puzzle-log-warning { color: #f39c12; }
        .puzzle-log-info { color: #3498db; }
    `;
}

function startPuzzle(profileName) {
    console.log('[MazeMaster] startPuzzle called with profile:', profileName);
    const profile = getPuzzleProfile(profileName);
    console.log('[MazeMaster] Retrieved puzzle profile:', profile);
    if (!profile) {
        console.error(`[MazeMaster] Puzzle profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    // Generate the puzzle sequence
    const gridSize = profile.gridSize || 3;
    const sequenceLength = profile.sequenceLength || 4;
    const sequence = [];
    const totalCells = gridSize * gridSize;

    console.log('[MazeMaster] Generating puzzle with gridSize:', gridSize, 'sequenceLength:', sequenceLength);
    for (let i = 0; i < sequenceLength; i++) {
        sequence.push(Math.floor(Math.random() * totalCells));
    }
    console.log('[MazeMaster] Generated sequence:', sequence);

    // Initialize puzzle state
    currentPuzzle = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        puzzleType: profile.puzzleType || 'sequence',
        gridSize: gridSize,
        grid: [],
        sequence: sequence,
        playerSequence: [],
        currentStep: 0,
        timeLimit: profile.timeLimit || 0,
        timeRemaining: profile.timeLimit || 0,
        timerInterval: null,
        hintsRemaining: profile.hintsAllowed || 0,
        hintsUsed: 0,
        wrongGuesses: 0,
        wrongGuessesAllowed: profile.wrongGuessesAllowed || 3,
        score: 100,
        isShowingSequence: false,
        isSuccess: false,
        isFailed: false,
        isComplete: false,
        combatLog: ['The puzzle awaits...'],
    };
    console.log('[MazeMaster] currentPuzzle initialized:', currentPuzzle);

    // Pause maze if active
    if (currentMaze.isOpen) {
        currentMaze.isPaused = true;
        console.log('[MazeMaster] Maze paused for puzzle');
    }

    console.log('[MazeMaster] Calling showPuzzleModal...');
    showPuzzleModal();

    // Execute start hook
    if (profile.onStart) {
        executeWithTimeout(profile.onStart);
    }

    console.log(`[MazeMaster] Puzzle started: ${profileName}`);
    return { success: true };
}

function showPuzzleModal() {
    console.log('[MazeMaster] showPuzzleModal called');
    const existing = document.getElementById('mazemaster_puzzle_modal');
    if (existing) {
        console.log('[MazeMaster] Removing existing puzzle modal');
        existing.remove();
    }

    if (!document.getElementById('mazemaster_puzzle_styles')) {
        console.log('[MazeMaster] Adding puzzle styles to document');
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_puzzle_styles';
        styleEl.textContent = getPuzzleStyles();
        document.head.appendChild(styleEl);
    }

    console.log('[MazeMaster] Inserting puzzle modal HTML');
    document.body.insertAdjacentHTML('beforeend', getPuzzleModalHtml());

    const modalEl = document.getElementById('mazemaster_puzzle_modal');
    console.log('[MazeMaster] Puzzle modal element after insert:', modalEl);

    const profile = currentPuzzle.profile;
    console.log('[MazeMaster] Updating puzzle UI with profile:', profile?.name);

    // Update UI
    const titleEl = document.getElementById('puzzle_main_title');
    const descEl = document.getElementById('puzzle_description');
    console.log('[MazeMaster] Puzzle UI elements - title:', titleEl, 'desc:', descEl);

    if (titleEl) titleEl.textContent = profile.mainTitle || 'Puzzle';
    if (descEl) descEl.textContent = profile.description || '';
    document.getElementById('puzzle_hints').textContent = currentPuzzle.hintsRemaining;
    document.getElementById('puzzle_mistakes').textContent = `${currentPuzzle.wrongGuesses}/${currentPuzzle.wrongGuessesAllowed}`;
    document.getElementById('puzzle_progress').textContent = `${currentPuzzle.currentStep}/${currentPuzzle.sequence.length}`;

    // Generate grid
    console.log('[MazeMaster] Generating puzzle grid');
    generatePuzzleGrid();

    // Event handlers
    console.log('[MazeMaster] Attaching puzzle event handlers');
    document.getElementById('puzzle_hint_btn')?.addEventListener('click', usePuzzleHint);
    document.getElementById('puzzle_reset_btn')?.addEventListener('click', showPuzzleSequence);
    document.getElementById('puzzle_close_btn')?.addEventListener('click', closePuzzleModal);

    // Start timer if applicable
    if (currentPuzzle.timeLimit > 0) {
        console.log('[MazeMaster] Starting puzzle timer with limit:', currentPuzzle.timeLimit);
        startPuzzleTimer();
    } else {
        document.getElementById('puzzle_timer').textContent = '';
    }

    // Show sequence after a brief delay
    console.log('[MazeMaster] Scheduling sequence display in 500ms');
    setTimeout(() => showPuzzleSequence(), 500);
    console.log('[MazeMaster] showPuzzleModal complete');
}

function generatePuzzleGrid() {
    const container = document.getElementById('puzzle_grid_container');
    if (!container) return;

    const gridSize = currentPuzzle.gridSize;
    const grid = document.createElement('div');
    grid.className = 'puzzle-grid';
    grid.style.gridTemplateColumns = `repeat(${gridSize}, 60px)`;

    for (let i = 0; i < gridSize * gridSize; i++) {
        const cell = document.createElement('div');
        cell.className = 'puzzle-cell';
        cell.dataset.index = i;
        cell.textContent = i + 1;
        cell.addEventListener('click', () => handlePuzzleCellClick(i));
        grid.appendChild(cell);
        currentPuzzle.grid.push(cell);
    }

    container.innerHTML = '';
    container.appendChild(grid);
}

async function showPuzzleSequence() {
    if (currentPuzzle.isComplete) return;

    currentPuzzle.isShowingSequence = true;
    const instruction = document.getElementById('puzzle_instruction');
    if (instruction) instruction.textContent = 'Watch carefully...';

    // Disable cells during sequence
    currentPuzzle.grid.forEach(cell => cell.classList.add('disabled'));

    // Show each step in the sequence
    for (let i = 0; i < currentPuzzle.sequence.length; i++) {
        const cellIndex = currentPuzzle.sequence[i];
        const cell = currentPuzzle.grid[cellIndex];

        await new Promise(resolve => setTimeout(resolve, 600));
        cell.classList.add('highlighted');

        await new Promise(resolve => setTimeout(resolve, 400));
        cell.classList.remove('highlighted');
    }

    await new Promise(resolve => setTimeout(resolve, 300));

    currentPuzzle.isShowingSequence = false;
    if (instruction) instruction.textContent = 'Repeat the sequence!';

    // Enable cells
    currentPuzzle.grid.forEach(cell => cell.classList.remove('disabled'));

    addPuzzleLogEntry('Sequence shown. Your turn!');
}

function handlePuzzleCellClick(index) {
    if (currentPuzzle.isComplete || currentPuzzle.isShowingSequence) return;

    const cell = currentPuzzle.grid[index];
    const expectedIndex = currentPuzzle.sequence[currentPuzzle.currentStep];
    const profile = currentPuzzle.profile;

    if (index === expectedIndex) {
        // Correct!
        cell.classList.add('correct');
        setTimeout(() => cell.classList.remove('correct'), 300);

        currentPuzzle.currentStep++;
        currentPuzzle.playerSequence.push(index);

        document.getElementById('puzzle_progress').textContent =
            `${currentPuzzle.currentStep}/${currentPuzzle.sequence.length}`;

        addPuzzleLogEntry(`Step ${currentPuzzle.currentStep} correct!`);

        if (profile.onCorrectMove) {
            executeWithTimeout(profile.onCorrectMove);
        }

        // Check for win
        if (currentPuzzle.currentStep >= currentPuzzle.sequence.length) {
            handlePuzzleSuccess();
        }
    } else {
        // Wrong!
        cell.classList.add('wrong');
        setTimeout(() => cell.classList.remove('wrong'), 300);

        currentPuzzle.wrongGuesses++;
        currentPuzzle.score -= (profile.wrongGuessPenalty || 10);

        document.getElementById('puzzle_mistakes').textContent =
            `${currentPuzzle.wrongGuesses}/${currentPuzzle.wrongGuessesAllowed}`;

        addPuzzleLogEntry(`Wrong! Mistakes: ${currentPuzzle.wrongGuesses}/${currentPuzzle.wrongGuessesAllowed}`);

        if (profile.onWrongMove) {
            executeWithTimeout(profile.onWrongMove);
        }

        // Check for fail
        if (currentPuzzle.wrongGuesses >= currentPuzzle.wrongGuessesAllowed) {
            handlePuzzleFail();
        }
    }
}

function usePuzzleHint() {
    if (currentPuzzle.isComplete || currentPuzzle.hintsRemaining <= 0) return;

    currentPuzzle.hintsRemaining--;
    currentPuzzle.hintsUsed++;
    currentPuzzle.score -= (currentPuzzle.profile.hintPenalty || 10);

    document.getElementById('puzzle_hints').textContent = currentPuzzle.hintsRemaining;

    // Highlight the next correct cell briefly
    const nextIndex = currentPuzzle.sequence[currentPuzzle.currentStep];
    const cell = currentPuzzle.grid[nextIndex];
    cell.classList.add('hint');
    setTimeout(() => cell.classList.remove('hint'), 1000);

    addPuzzleLogEntry(`Hint used! ${currentPuzzle.hintsRemaining} remaining.`);

    if (currentPuzzle.profile.onHint) {
        executeWithTimeout(currentPuzzle.profile.onHint);
    }

    // Disable button if no hints left
    if (currentPuzzle.hintsRemaining <= 0) {
        const btn = document.getElementById('puzzle_hint_btn');
        if (btn) btn.disabled = true;
    }
}

function startPuzzleTimer() {
    const timerEl = document.getElementById('puzzle_timer');

    currentPuzzle.timerInterval = setInterval(() => {
        currentPuzzle.timeRemaining--;

        if (timerEl) {
            const mins = Math.floor(currentPuzzle.timeRemaining / 60);
            const secs = currentPuzzle.timeRemaining % 60;
            timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;

            if (currentPuzzle.timeRemaining <= 10) {
                timerEl.style.color = '#e74c3c';
            }
        }

        if (currentPuzzle.timeRemaining <= 0) {
            clearInterval(currentPuzzle.timerInterval);
            addPuzzleLogEntry('Time\'s up!');
            handlePuzzleFail();
        }
    }, 1000);
}

async function handlePuzzleSuccess() {
    currentPuzzle.isComplete = true;
    currentPuzzle.isSuccess = true;

    if (currentPuzzle.timerInterval) {
        clearInterval(currentPuzzle.timerInterval);
    }

    addPuzzleLogEntry('Puzzle solved!');

    const profile = currentPuzzle.profile;

    // Execute complete hook
    if (profile.onComplete) {
        await executeWithTimeout(profile.onComplete);
    }

    // Handle item drops if in maze
    if (currentMaze.isOpen && currentMaze.pendingEncounter) {
        if (Math.random() * 100 < (profile.keyDropChance || 20)) {
            addToInventory('key');
            addPuzzleLogEntry('You found a Key!');
        }
        if (Math.random() * 100 < (profile.stealthDropChance || 15)) {
            addToInventory('stealth');
            addPuzzleLogEntry('You found a Stealth item!');
        }
        if (Math.random() * 100 < (profile.healingPotionDropChance || 15)) {
            addToInventory('healingPotion');
            addPuzzleLogEntry('You found a Healing Potion!');
        }
    }

    // Store result
    lastResults.puzzle = lastResults.puzzle || {};
    lastResults.puzzle[currentPuzzle.profileName] = {
        result: 'success',
        score: currentPuzzle.score,
        hintsUsed: currentPuzzle.hintsUsed,
        wrongGuesses: currentPuzzle.wrongGuesses,
        timeRemaining: currentPuzzle.timeRemaining,
        timestamp: Date.now(),
    };

    showPuzzleResult();
}

async function handlePuzzleFail() {
    currentPuzzle.isComplete = true;
    currentPuzzle.isFailed = true;

    if (currentPuzzle.timerInterval) {
        clearInterval(currentPuzzle.timerInterval);
    }

    addPuzzleLogEntry('Puzzle failed!');

    const profile = currentPuzzle.profile;

    // Execute fail hook - STScript handles any damage/consequences
    if (profile.onFail) {
        await executeWithTimeout(profile.onFail);
    }

    // Store result
    lastResults.puzzle = lastResults.puzzle || {};
    lastResults.puzzle[currentPuzzle.profileName] = {
        result: 'fail',
        score: currentPuzzle.score,
        hintsUsed: currentPuzzle.hintsUsed,
        wrongGuesses: currentPuzzle.wrongGuesses,
        timestamp: Date.now(),
    };

    showPuzzleResult();
}

function showPuzzleResult() {
    const actionsEl = document.getElementById('puzzle_actions');
    const resultPanel = document.getElementById('puzzle_result_panel');
    const resultText = document.getElementById('puzzle_result_text');
    const instruction = document.getElementById('puzzle_instruction');

    if (actionsEl) actionsEl.style.display = 'none';
    if (instruction) instruction.style.display = 'none';
    if (resultPanel) resultPanel.style.display = 'block';

    // Disable all cells
    currentPuzzle.grid.forEach(cell => cell.classList.add('disabled'));

    if (resultText) {
        if (currentPuzzle.isSuccess) {
            resultText.textContent = currentPuzzle.profile.successMessage || 'Puzzle Solved!';
            resultText.className = 'puzzle-result-text success';
        } else {
            resultText.textContent = currentPuzzle.profile.failMessage || 'Puzzle Failed!';
            resultText.className = 'puzzle-result-text fail';
        }
    }
}

function addPuzzleLogEntry(message) {
    currentPuzzle.combatLog.push(message);
    if (currentPuzzle.combatLog.length > 20) {
        currentPuzzle.combatLog.shift();
    }

    const logEl = document.getElementById('puzzle_combat_log');
    if (logEl) {
        logEl.innerHTML = currentPuzzle.combatLog.map(entry => {
            let className = 'puzzle-log-entry';
            if (entry.includes('correct') || entry.includes('solved') || entry.includes('found')) className += ' puzzle-log-success';
            if (entry.includes('Wrong') || entry.includes('failed') || entry.includes('Time')) className += ' puzzle-log-fail';
            if (entry.includes('Hint')) className += ' puzzle-log-warning';
            if (entry.includes('turn') || entry.includes('shown')) className += ' puzzle-log-info';
            return `<div class="${className}">${entry}</div>`;
        }).join('');
        logEl.scrollTop = logEl.scrollHeight;
    }
}

async function closePuzzleModal() {
    if (currentPuzzle.timerInterval) {
        clearInterval(currentPuzzle.timerInterval);
    }

    const modal = document.getElementById('mazemaster_puzzle_modal');
    if (modal) modal.remove();

    const wasSuccess = currentPuzzle.isSuccess;
    currentPuzzle.isOpen = false;

    // Handle maze integration
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasSuccess) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);
                    // Heal player on successful puzzle completion (skill reward)
                    if (currentMaze.hp && currentMaze.profile?.hpEnabled !== false) {
                        const healPercent = currentMaze.profile.skillEncounterHealPercent || 25;
                        const maxTotal = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
                        const healAmount = Math.floor(maxTotal * (healPercent / 100));
                        if (currentMaze.hp.current < maxTotal && healAmount > 0) {
                            await healPlayer(healAmount, false, 'Puzzle success');
                            addMazeLogMessage(`Brilliant mind! Recovered ${healAmount} HP.`, 'heal');
                        }
                    }

                    if (encounterType === 'exit_puzzle') {
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closePuzzleModal:', err);
        }

        // Always ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

// =============================================================================
// NEGOTIATION MODAL & GAME LOGIC
// =============================================================================

function getNegotiationModalHtml() {
    return `
        <div id="mazemaster_negotiation_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-negotiate-container">
                <div id="negotiate_main_title" class="negotiate-main-title">Negotiation</div>
                <div id="negotiate_description" class="negotiate-description"></div>

                <div class="negotiate-npc-area">
                    <div class="negotiate-npc-name" id="negotiate_npc_name">NPC</div>
                    <div class="negotiate-disposition" id="negotiate_disposition">Neutral</div>
                </div>

                <div class="negotiate-stats-row">
                    <div class="negotiate-stat">
                        <span class="negotiate-stat-label">Favor:</span>
                        <div class="negotiate-favor-bar-container">
                            <div class="negotiate-favor-bar" id="negotiate_favor_bar"></div>
                        </div>
                        <span id="negotiate_favor_value">50</span>/<span id="negotiate_favor_max">75</span>
                    </div>
                    <div class="negotiate-stat">
                        <span class="negotiate-stat-label">Turns:</span>
                        <span id="negotiate_turns">0/0</span>
                    </div>
                </div>

                <div id="negotiate_actions" class="negotiate-actions">
                    <button id="negotiate_persuade_btn" class="negotiate-btn negotiate-persuade-btn">
                        <i class="fa-solid fa-comment"></i> Persuade
                    </button>
                    <button id="negotiate_intimidate_btn" class="negotiate-btn negotiate-intimidate-btn">
                        <i class="fa-solid fa-hand-fist"></i> Intimidate
                    </button>
                    <button id="negotiate_flatter_btn" class="negotiate-btn negotiate-flatter-btn">
                        <i class="fa-solid fa-heart"></i> Flatter
                    </button>
                    <button id="negotiate_bribe_btn" class="negotiate-btn negotiate-bribe-btn">
                        <i class="fa-solid fa-coins"></i> Bribe
                    </button>
                    <button id="negotiate_insult_btn" class="negotiate-btn negotiate-insult-btn" style="display:none;">
                        <i class="fa-solid fa-face-angry"></i> Insult
                    </button>
                </div>

                <div id="negotiate_result_panel" class="negotiate-result-panel" style="display:none;">
                    <div id="negotiate_result_text" class="negotiate-result-text"></div>
                    <button id="negotiate_close_btn" class="negotiate-btn negotiate-close-btn">
                        <i class="fa-solid fa-check"></i> Continue
                    </button>
                </div>

                <div id="negotiate_combat_log" class="negotiate-combat-log"></div>
            </div>
        </div>
    `;
}

function getNegotiationStyles() {
    return `
        .mazemaster-negotiate-container {
            background: linear-gradient(135deg, #2c1810 0%, #1a0f0a 50%, #0f0705 100%);
            border: 2px solid #8b4513;
            border-radius: 15px;
            padding: 25px;
            min-width: 450px;
            max-width: 550px;
            box-shadow: 0 0 40px rgba(139, 69, 19, 0.4);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0e0;
        }

        .negotiate-main-title {
            text-align: center;
            font-size: 1.8em;
            font-weight: bold;
            color: #daa520;
            text-shadow: 0 0 10px rgba(218, 165, 32, 0.5);
            margin-bottom: 8px;
        }

        .negotiate-description {
            text-align: center;
            font-size: 0.95em;
            color: #bbb;
            margin-bottom: 15px;
            font-style: italic;
        }

        .negotiate-npc-area {
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            margin-bottom: 15px;
            border: 1px solid #8b4513;
        }

        .negotiate-npc-name {
            font-size: 1.3em;
            font-weight: bold;
            color: #daa520;
            margin-bottom: 5px;
        }

        .negotiate-disposition {
            font-size: 1em;
            padding: 5px 15px;
            border-radius: 15px;
            display: inline-block;
        }

        .negotiate-disposition.hostile { background: #e74c3c; color: white; }
        .negotiate-disposition.unfriendly { background: #e67e22; color: white; }
        .negotiate-disposition.neutral { background: #7f8c8d; color: white; }
        .negotiate-disposition.friendly { background: #27ae60; color: white; }
        .negotiate-disposition.enthusiastic { background: #2ecc71; color: white; }

        .negotiate-stats-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .negotiate-stat {
            text-align: center;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .negotiate-stat-label {
            color: #888;
            font-size: 0.9em;
        }

        .negotiate-favor-bar-container {
            width: 150px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #555;
        }

        .negotiate-favor-bar {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c 0%, #f39c12 50%, #27ae60 100%);
            transition: width 0.3s ease;
            width: 50%;
        }

        .negotiate-actions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .negotiate-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .negotiate-persuade-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .negotiate-intimidate-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .negotiate-flatter-btn {
            background: linear-gradient(135deg, #e91e63 0%, #c2185b 100%);
            color: white;
        }

        .negotiate-bribe-btn {
            background: linear-gradient(135deg, #f39c12 0%, #d68910 100%);
            color: white;
        }

        .negotiate-insult-btn {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
            grid-column: span 2;
        }

        .negotiate-btn:hover:not(:disabled) {
            transform: scale(1.03);
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        .negotiate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .negotiate-close-btn {
            background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
            width: 100%;
        }

        .negotiate-result-panel {
            text-align: center;
            padding: 20px;
        }

        .negotiate-result-text {
            font-size: 1.6em;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .negotiate-result-text.success { color: #2ecc71; }
        .negotiate-result-text.fail { color: #e74c3c; }

        .negotiate-combat-log {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            font-size: 0.9em;
        }

        .negotiate-log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .negotiate-log-entry:last-child { border-bottom: none; }
        .negotiate-log-success { color: #2ecc71; }
        .negotiate-log-fail { color: #e74c3c; }
        .negotiate-log-warning { color: #f39c12; }
        .negotiate-log-info { color: #3498db; }
        .negotiate-log-action { color: #daa520; }
    `;
}

function startNegotiation(profileName) {
    console.log('[MazeMaster] startNegotiation called with profile:', profileName);
    const profile = getNegotiationProfile(profileName);
    console.log('[MazeMaster] Retrieved negotiation profile:', profile);
    if (!profile) {
        console.error(`[MazeMaster] Negotiation profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    console.log('[MazeMaster] Initializing negotiation state with config:', {
        startingFavor: profile.startingFavor,
        favorThreshold: profile.favorThreshold,
        turnsAllowed: profile.turnsAllowed
    });
    // Initialize negotiation state
    currentNegotiation = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        favor: profile.startingFavor || 50,
        favorThreshold: profile.favorThreshold || 75,
        turnsRemaining: profile.turnsAllowed || 5,
        turnsUsed: 0,
        lastAction: '',
        lastResult: '',
        isSuccess: false,
        isFailed: false,
        isComplete: false,
        combatLog: ['The negotiation begins...'],
    };
    console.log('[MazeMaster] currentNegotiation initialized:', currentNegotiation);

    // Pause maze if active
    if (currentMaze.isOpen) {
        currentMaze.isPaused = true;
        console.log('[MazeMaster] Maze paused for negotiation');
    }

    console.log('[MazeMaster] Calling showNegotiationModal...');
    showNegotiationModal();

    // Execute start hook
    if (profile.onStart) {
        executeWithTimeout(profile.onStart);
    }

    console.log(`[MazeMaster] Negotiation started: ${profileName}`);
    return { success: true };
}

function showNegotiationModal() {
    console.log('[MazeMaster] showNegotiationModal called');
    const existing = document.getElementById('mazemaster_negotiation_modal');
    if (existing) {
        console.log('[MazeMaster] Removing existing negotiation modal');
        existing.remove();
    }

    if (!document.getElementById('mazemaster_negotiation_styles')) {
        console.log('[MazeMaster] Adding negotiation styles to document');
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_negotiation_styles';
        styleEl.textContent = getNegotiationStyles();
        document.head.appendChild(styleEl);
    }

    console.log('[MazeMaster] Inserting negotiation modal HTML');
    document.body.insertAdjacentHTML('beforeend', getNegotiationModalHtml());

    const modalEl = document.getElementById('mazemaster_negotiation_modal');
    console.log('[MazeMaster] Negotiation modal element after insert:', modalEl);

    const profile = currentNegotiation.profile;
    console.log('[MazeMaster] Updating negotiation UI with profile:', profile?.name);

    // Update UI
    const titleEl = document.getElementById('negotiate_main_title');
    const descEl = document.getElementById('negotiate_description');
    console.log('[MazeMaster] Negotiation UI elements - title:', titleEl, 'desc:', descEl);

    if (titleEl) titleEl.textContent = profile.mainTitle || 'Negotiation';
    if (descEl) descEl.textContent = profile.description || '';
    document.getElementById('negotiate_npc_name').textContent = profile.npcName || 'NPC';
    document.getElementById('negotiate_favor_max').textContent = currentNegotiation.favorThreshold;
    document.getElementById('negotiate_turns').textContent =
        `${currentNegotiation.turnsUsed}/${profile.turnsAllowed}`;

    // Show/hide optional buttons
    if (!profile.flattery) {
        document.getElementById('negotiate_flatter_btn').style.display = 'none';
    }
    if (profile.insult) {
        document.getElementById('negotiate_insult_btn').style.display = 'flex';
    }

    // Event handlers
    console.log('[MazeMaster] Attaching negotiation event handlers');
    document.getElementById('negotiate_persuade_btn')?.addEventListener('click', () => handleNegotiationAction('persuade'));
    document.getElementById('negotiate_intimidate_btn')?.addEventListener('click', () => handleNegotiationAction('intimidate'));
    document.getElementById('negotiate_flatter_btn')?.addEventListener('click', () => handleNegotiationAction('flatter'));
    document.getElementById('negotiate_bribe_btn')?.addEventListener('click', () => handleNegotiationAction('bribe'));
    document.getElementById('negotiate_insult_btn')?.addEventListener('click', () => handleNegotiationAction('insult'));
    document.getElementById('negotiate_close_btn')?.addEventListener('click', closeNegotiationModal);

    console.log('[MazeMaster] Calling updateNegotiationDisplay');
    updateNegotiationDisplay();
    console.log('[MazeMaster] showNegotiationModal complete');
}

function updateNegotiationDisplay() {
    // Update favor bar
    const favorBar = document.getElementById('negotiate_favor_bar');
    const favorValue = document.getElementById('negotiate_favor_value');
    const favorPercent = (currentNegotiation.favor / 100) * 100;

    if (favorBar) favorBar.style.width = `${Math.min(favorPercent, 100)}%`;
    if (favorValue) favorValue.textContent = Math.round(currentNegotiation.favor);

    // Update disposition text
    const dispositionEl = document.getElementById('negotiate_disposition');
    if (dispositionEl) {
        dispositionEl.classList.remove('hostile', 'unfriendly', 'neutral', 'friendly', 'enthusiastic');

        if (currentNegotiation.favor >= 80) {
            dispositionEl.textContent = 'Enthusiastic';
            dispositionEl.classList.add('enthusiastic');
        } else if (currentNegotiation.favor >= 60) {
            dispositionEl.textContent = 'Friendly';
            dispositionEl.classList.add('friendly');
        } else if (currentNegotiation.favor >= 40) {
            dispositionEl.textContent = 'Neutral';
            dispositionEl.classList.add('neutral');
        } else if (currentNegotiation.favor >= 20) {
            dispositionEl.textContent = 'Unfriendly';
            dispositionEl.classList.add('unfriendly');
        } else {
            dispositionEl.textContent = 'Hostile';
            dispositionEl.classList.add('hostile');
        }
    }

    // Update turns
    const turnsEl = document.getElementById('negotiate_turns');
    if (turnsEl) {
        turnsEl.textContent = `${currentNegotiation.turnsUsed}/${currentNegotiation.profile.turnsAllowed}`;
    }

    // Update combat log
    const logEl = document.getElementById('negotiate_combat_log');
    if (logEl) {
        logEl.innerHTML = currentNegotiation.combatLog.map(entry => {
            let className = 'negotiate-log-entry';
            if (entry.includes('success') || entry.includes('agrees') || entry.includes('impressed')) className += ' negotiate-log-success';
            if (entry.includes('fail') || entry.includes('refuses') || entry.includes('angry')) className += ' negotiate-log-fail';
            if (entry.includes('suspicious') || entry.includes('wary')) className += ' negotiate-log-warning';
            if (entry.includes('You ')) className += ' negotiate-log-action';
            return `<div class="${className}">${entry}</div>`;
        }).join('');
        logEl.scrollTop = logEl.scrollHeight;
    }
}

function addNegotiationLogEntry(message) {
    currentNegotiation.combatLog.push(message);
    if (currentNegotiation.combatLog.length > 30) {
        currentNegotiation.combatLog.shift();
    }
    updateNegotiationDisplay();
}

async function handleNegotiationAction(action) {
    if (currentNegotiation.isComplete) return;

    const profile = currentNegotiation.profile;
    currentNegotiation.turnsUsed++;
    currentNegotiation.turnsRemaining--;
    currentNegotiation.lastAction = action;

    let favorChange = 0;
    let success = false;
    const roll = Math.random() * 100;

    switch (action) {
        case 'persuade':
            success = roll < (profile.persuadeBonus + currentNegotiation.favor * 0.3);
            if (success) {
                favorChange = 10 + Math.floor(Math.random() * 10);
                addNegotiationLogEntry(`You make a compelling argument. (+${favorChange} favor)`);
            } else {
                favorChange = -5;
                addNegotiationLogEntry(`Your words fall flat. (${favorChange} favor)`);
            }
            if (profile.onPersuade) await executeWithTimeout(profile.onPersuade);
            break;

        case 'intimidate':
            success = roll < (profile.intimidateBonus + (100 - currentNegotiation.favor) * 0.2);
            if (success) {
                favorChange = 15 + Math.floor(Math.random() * 10);
                addNegotiationLogEntry(`They seem... persuaded by your forcefulness. (+${favorChange} favor)`);
            } else {
                favorChange = -15;
                addNegotiationLogEntry(`They don't take kindly to threats. (${favorChange} favor)`);
            }
            if (profile.onIntimidate) await executeWithTimeout(profile.onIntimidate);
            break;

        case 'flatter':
            success = roll < (profile.flatterBonus + currentNegotiation.favor * 0.4);
            if (success) {
                favorChange = 8 + Math.floor(Math.random() * 8);
                addNegotiationLogEntry(`They're flattered by your words. (+${favorChange} favor)`);
            } else {
                favorChange = -3;
                addNegotiationLogEntry(`They see through your flattery. (${favorChange} favor)`);
            }
            if (profile.onFlatter) await executeWithTimeout(profile.onFlatter);
            break;

        case 'bribe':
            const bribeCost = profile.bribeCost || 'key';
            const hasItem = currentMaze.isOpen ? (currentMaze.inventory?.[bribeCost] || 0) > 0 : true;

            if (!hasItem) {
                addNegotiationLogEntry(`You don't have anything to offer...`);
                currentNegotiation.turnsUsed--;
                currentNegotiation.turnsRemaining++;
                updateNegotiationDisplay();
                return;
            }

            if (currentMaze.isOpen && currentMaze.inventory) {
                currentMaze.inventory[bribeCost]--;
            }

            success = roll < profile.bribeBonus;
            if (success) {
                favorChange = 20 + Math.floor(Math.random() * 15);
                addNegotiationLogEntry(`The bribe is accepted with a knowing smile. (+${favorChange} favor)`);
            } else {
                favorChange = -10;
                addNegotiationLogEntry(`They pocket the bribe but remain unmoved. (${favorChange} favor)`);
            }
            if (profile.onBribe) await executeWithTimeout(profile.onBribe);
            break;

        case 'insult':
            // Risky high-reward move
            success = roll < 25; // Low success chance
            if (success) {
                favorChange = 25 + Math.floor(Math.random() * 15);
                addNegotiationLogEntry(`Surprisingly, your insult earns their respect! (+${favorChange} favor)`);
            } else {
                favorChange = -(profile.insultPenalty || 20);
                addNegotiationLogEntry(`They're deeply offended! (${favorChange} favor)`);
            }
            if (profile.onInsult) await executeWithTimeout(profile.onInsult);
            break;
    }

    // Apply favor change
    currentNegotiation.favor = Math.max(0, Math.min(100, currentNegotiation.favor + favorChange));
    currentNegotiation.lastResult = success ? 'success' : 'fail';

    updateNegotiationDisplay();

    // Check for win
    if (currentNegotiation.favor >= currentNegotiation.favorThreshold) {
        handleNegotiationSuccess();
        return;
    }

    // Check for loss (out of turns or favor too low)
    if (currentNegotiation.turnsRemaining <= 0) {
        addNegotiationLogEntry('You\'ve run out of time...');
        handleNegotiationFail();
        return;
    }

    if (currentNegotiation.favor <= 0) {
        addNegotiationLogEntry('They refuse to speak with you any further!');
        handleNegotiationFail();
        return;
    }
}

async function handleNegotiationSuccess() {
    currentNegotiation.isComplete = true;
    currentNegotiation.isSuccess = true;

    addNegotiationLogEntry('Negotiation successful!');

    const profile = currentNegotiation.profile;

    // Execute complete hook
    if (profile.onComplete) {
        await executeWithTimeout(profile.onComplete);
    }

    // Handle item drops if in maze
    if (currentMaze.isOpen && currentMaze.pendingEncounter) {
        if (Math.random() * 100 < (profile.keyDropChance || 20)) {
            addToInventory('key');
            addNegotiationLogEntry('You received a Key!');
        }
        if (Math.random() * 100 < (profile.stealthDropChance || 15)) {
            addToInventory('stealth');
            addNegotiationLogEntry('You received a Stealth item!');
        }
        if (Math.random() * 100 < (profile.healingPotionDropChance || 15)) {
            addToInventory('healingPotion');
            addNegotiationLogEntry('You received a Healing Potion!');
        }
    }

    // Store result
    lastResults.negotiation = lastResults.negotiation || {};
    lastResults.negotiation[currentNegotiation.profileName] = {
        result: 'success',
        finalFavor: currentNegotiation.favor,
        turnsUsed: currentNegotiation.turnsUsed,
        timestamp: Date.now(),
    };

    showNegotiationResult();
}

async function handleNegotiationFail() {
    currentNegotiation.isComplete = true;
    currentNegotiation.isFailed = true;

    addNegotiationLogEntry('Negotiation failed!');

    const profile = currentNegotiation.profile;

    // Execute fail hook
    if (profile.onFail) {
        await executeWithTimeout(profile.onFail);
    }

    // Apply maze HP damage
    let playerDied = false;
    if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
        const damage = profile.damage || 25;
        const mazeMultiplier = currentMaze.profile?.battlebarDamageMultiplier ?? 1.0;
        const actualDamage = Math.round(damage * mazeMultiplier);
        const survived = await applyDamage(actualDamage, 'negotiation');
        playerDied = !survived;
    }

    // Store result
    lastResults.negotiation = lastResults.negotiation || {};
    lastResults.negotiation[currentNegotiation.profileName] = {
        result: 'fail',
        finalFavor: currentNegotiation.favor,
        turnsUsed: currentNegotiation.turnsUsed,
        timestamp: Date.now(),
    };

    // If player died, close modal and let death handling take over
    if (playerDied) {
        closeNegotiationModal();
        return;
    }

    showNegotiationResult();
}

function showNegotiationResult() {
    const actionsEl = document.getElementById('negotiate_actions');
    const resultPanel = document.getElementById('negotiate_result_panel');
    const resultText = document.getElementById('negotiate_result_text');

    if (actionsEl) actionsEl.style.display = 'none';
    if (resultPanel) resultPanel.style.display = 'block';

    if (resultText) {
        if (currentNegotiation.isSuccess) {
            resultText.textContent = currentNegotiation.profile.successMessage || 'Negotiation Successful!';
            resultText.className = 'negotiate-result-text success';
        } else {
            resultText.textContent = currentNegotiation.profile.failMessage || 'Negotiation Failed!';
            resultText.className = 'negotiate-result-text fail';
        }
    }
}

async function closeNegotiationModal() {
    const modal = document.getElementById('mazemaster_negotiation_modal');
    if (modal) modal.remove();

    const wasSuccess = currentNegotiation.isSuccess;
    currentNegotiation.isOpen = false;

    // Handle maze integration
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasSuccess) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);
                    // Heal player on successful negotiation completion (skill reward)
                    if (currentMaze.hp && currentMaze.profile?.hpEnabled !== false) {
                        const healPercent = currentMaze.profile.skillEncounterHealPercent || 25;
                        const maxTotal = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
                        const healAmount = Math.floor(maxTotal * (healPercent / 100));
                        if (currentMaze.hp.current < maxTotal && healAmount > 0) {
                            await healPlayer(healAmount, false, 'Negotiation success');
                            addMazeLogMessage(`Smooth talker! Recovered ${healAmount} HP.`, 'heal');
                        }
                    }

                    if (encounterType === 'exit_negotiation') {
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeNegotiationModal:', err);
        }

        // Always ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

// =============================================================================
// MERCHANT ITEM SELECTION MODAL
// =============================================================================

// Runtime state for merchant interaction
let currentMerchantOffer = {
    isOpen: false,
    minionId: null,
    minion: null,
    offeredItems: [],
    selectedItem: null,
};

function getMerchantItemPool(poolName) {
    return extensionSettings.merchantItemPools?.[poolName] || DEFAULT_MERCHANT_ITEM_POOLS[poolName] || DEFAULT_MERCHANT_ITEM_POOLS['Common Goods'];
}

function selectRandomMerchantItems(poolName, count) {
    const pool = getMerchantItemPool(poolName);
    if (!pool || !pool.items || pool.items.length === 0) {
        return [{ id: 'key', name: 'Key', description: 'Opens locked doors', icon: '' }];
    }

    const items = pool.items;
    const totalWeight = items.reduce((sum, item) => sum + (item.weight || 10), 0);
    const selected = [];
    const usedIds = new Set();

    // Weighted random selection without duplicates
    while (selected.length < count && selected.length < items.length) {
        let roll = Math.random() * totalWeight;
        for (const item of items) {
            if (usedIds.has(item.id)) continue;
            roll -= (item.weight || 10);
            if (roll <= 0) {
                selected.push({ ...item });
                usedIds.add(item.id);
                break;
            }
        }
        // Fallback if weighted selection fails
        if (selected.length < count && !usedIds.has(items[selected.length % items.length].id)) {
            const fallbackItem = items.find(i => !usedIds.has(i.id));
            if (fallbackItem) {
                selected.push({ ...fallbackItem });
                usedIds.add(fallbackItem.id);
            }
        }
    }

    return selected;
}

function getMerchantModalHtml() {
    return `
        <div id="mazemaster_merchant_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-merchant-container">
                <div class="merchant-header">
                    <div id="merchant_title" class="merchant-title">Merchant Wares</div>
                    <div id="merchant_subtitle" class="merchant-subtitle">Choose one item to take</div>
                </div>

                <div id="merchant_items" class="merchant-items-grid">
                    <!-- Items will be dynamically inserted here -->
                </div>

                <div class="merchant-footer">
                    <button id="merchant_take_btn" class="merchant-btn merchant-take-btn" disabled>
                        <i class="fa-solid fa-hand"></i> Take Selected Item
                    </button>
                    <button id="merchant_decline_btn" class="merchant-btn merchant-decline-btn">
                        <i class="fa-solid fa-xmark"></i> Leave Without Taking
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getMerchantStyles() {
    return `
        .mazemaster-merchant-container {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f1a 100%);
            border: 2px solid #d4af37;
            border-radius: 15px;
            padding: 25px;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.3);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0e0;
        }

        .merchant-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .merchant-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #d4af37;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            margin-bottom: 5px;
        }

        .merchant-subtitle {
            font-size: 1em;
            color: #aaa;
            font-style: italic;
        }

        .merchant-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }

        .merchant-item-card {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #444;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .merchant-item-card:hover {
            border-color: #d4af37;
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(212, 175, 55, 0.3);
        }

        .merchant-item-card.selected {
            border-color: #4ade80;
            background: rgba(74, 222, 128, 0.15);
            box-shadow: 0 0 25px rgba(74, 222, 128, 0.4);
        }

        .merchant-item-card.selected::after {
            content: '';
            position: absolute;
            top: 5px;
            right: 8px;
            font-size: 1.2em;
            color: #4ade80;
        }

        .merchant-item-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
            display: block;
        }

        .merchant-item-name {
            font-size: 1.1em;
            font-weight: bold;
            color: #d4af37;
            margin-bottom: 5px;
        }

        .merchant-item-description {
            font-size: 0.85em;
            color: #888;
            line-height: 1.3;
        }

        .merchant-footer {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .merchant-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .merchant-take-btn {
            background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            color: white;
        }

        .merchant-take-btn:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .merchant-take-btn:not(:disabled):hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(39, 174, 96, 0.5);
        }

        .merchant-decline-btn {
            background: linear-gradient(135deg, #7f8c8d 0%, #5a6c7d 100%);
            color: white;
        }

        .merchant-decline-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(127, 140, 141, 0.5);
        }
    `;
}

function showMerchantModal(minionId, offeredItems) {
    const minion = getMinion(minionId);
    if (!minion) return;

    // Initialize state
    currentMerchantOffer = {
        isOpen: true,
        minionId: minionId,
        minion: minion,
        offeredItems: offeredItems,
        selectedItem: null,
    };

    // Remove existing modal if any
    const existing = document.getElementById('mazemaster_merchant_modal');
    if (existing) existing.remove();

    // Add styles
    if (!document.getElementById('mazemaster_merchant_styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_merchant_styles';
        styleEl.textContent = getMerchantStyles();
        document.head.appendChild(styleEl);
    }

    // Add modal HTML
    document.body.insertAdjacentHTML('beforeend', getMerchantModalHtml());

    // Update title based on merchant
    document.getElementById('merchant_title').textContent = minion.name || 'Merchant Wares';

    // Render offered items
    const itemsContainer = document.getElementById('merchant_items');
    itemsContainer.innerHTML = offeredItems.map((item, index) => `
        <div class="merchant-item-card" data-item-index="${index}" data-item-id="${item.id}">
            <span class="merchant-item-icon">${item.icon || ''}</span>
            <div class="merchant-item-name">${item.name}</div>
            <div class="merchant-item-description">${item.description}</div>
        </div>
    `).join('');

    // Add click handlers for item selection
    itemsContainer.querySelectorAll('.merchant-item-card').forEach(card => {
        card.addEventListener('click', () => {
            // Deselect all
            itemsContainer.querySelectorAll('.merchant-item-card').forEach(c => c.classList.remove('selected'));
            // Select clicked
            card.classList.add('selected');
            currentMerchantOffer.selectedItem = offeredItems[parseInt(card.dataset.itemIndex)];
            // Enable take button
            document.getElementById('merchant_take_btn').disabled = false;
        });
    });

    // Button handlers
    document.getElementById('merchant_take_btn').addEventListener('click', handleMerchantTake);
    document.getElementById('merchant_decline_btn').addEventListener('click', handleMerchantLeave);
}

function handleMerchantTake() {
    if (!currentMerchantOffer.selectedItem) return;

    const item = currentMerchantOffer.selectedItem;

    // Add item to inventory
    addToInventory(item.id);

    // Update message
    if (currentMaze.currentMinion) {
        currentMaze.currentMinion.message = `Enjoy your ${item.name}! A pleasure doing business!`;
        updateMazeHero();
    }

    closeMerchantModal(true);
}

function handleMerchantLeave() {
    // Update message
    if (currentMaze.currentMinion) {
        currentMaze.currentMinion.message = "Perhaps another time, then...";
        updateMazeHero();
    }

    closeMerchantModal(false);
}

function closeMerchantModal(tookItem) {
    const modal = document.getElementById('mazemaster_merchant_modal');
    if (modal) modal.remove();

    currentMerchantOffer.isOpen = false;

    // Resume maze
    if (currentMaze.pendingConfirmation) {
        currentMaze.pendingConfirmation = null;
    }

    // Show OK to continue
    const confirmEl = document.getElementById('maze_encounter_confirm');
    if (confirmEl) {
        confirmEl.innerHTML = `<button id="maze_confirm_ok" class="menu_button maze-confirm-btn">OK</button>`;
        confirmEl.style.display = 'flex';
        document.getElementById('maze_confirm_ok')?.addEventListener('click', () => {
            hideActionPopup();
            resumeMaze();
        });
    } else {
        resumeMaze();
    }
}

// =============================================================================
// BATTLEBAR MODAL & GAME LOGIC
// =============================================================================

function getBattlebarModalHtml() {
    return `
        <div id="mazemaster_battlebar_modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);">
            <div class="mazemaster-bb-container">
                <div id="bb_main_title" class="mazemaster-bb-main-title"></div>
                <div class="mazemaster-bb-image-display">
                    <img id="mazemaster_bb_img" src="" alt="">
                </div>
                <div id="bb_stage_title" class="mazemaster-bb-stage-title"></div>
                <div class="mazemaster-bb-stats">
                    <span class="bb-stat bb-stat-hits">
                        Hits: <span id="bb_current_hits">0</span>/<span id="bb_needed_hits">5</span>
                    </span>
                    <span class="bb-stat bb-stat-misses">
                        Misses: <span id="bb_current_misses">0</span>/<span id="bb_max_misses">3</span>
                    </span>
                </div>
                <div class="mazemaster-bb-bar-container">
                    <div class="mazemaster-bb-bar">
                        <div class="mazemaster-bb-zone" id="bb_zone"></div>
                        <div class="mazemaster-bb-arrow" id="bb_arrow"></div>
                    </div>
                </div>
                <div class="mazemaster-bb-instructions">
                    Press <kbd>SPACE</kbd> when the arrow is in the green zone!
                </div>
                <div class="mazemaster-bb-action-buttons">
                    <button id="mazemaster_bb_hit_btn" class="mazemaster-bb-hit-btn">
                        <i class="fa-solid fa-bullseye"></i> HIT!
                    </button>
                    <button id="mazemaster_bb_strike_btn" class="mazemaster-bb-strike-btn" style="display: none;">
                        <i class="fa-solid fa-bolt"></i> STRIKE! (<span id="bb_strike_count">0</span>)
                    </button>
                    <button id="mazemaster_bb_execute_btn" class="mazemaster-bb-execute-btn" style="display: none;">
                        <i class="fa-solid fa-star"></i> GRANDSTRIKE! (<span id="bb_execute_count">0</span>)
                    </button>
                </div>
            </div>
        </div>
    `;
}

function getBattlebarStyles() {
    return `
        .mazemaster-bb-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10010;
        }

        .mazemaster-bb-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 25px;
            background: #1a1a2e;
            border-radius: 15px;
            border: 2px solid #333;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            width: 450px;
            max-width: 95vw;
            overflow-y: auto;
        }

        .mazemaster-bb-main-title {
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            text-align: center;
        }

        .mazemaster-bb-stage-title {
            font-size: 18px;
            color: #aaa;
            text-align: center;
            min-height: 24px;
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .mazemaster-bb-image-display {
            width: min(300px, 80vw);
            height: min(300px, 40vh);
            border: 3px solid #444;
            border-radius: 10px;
            overflow: hidden;
            background: #222;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mazemaster-bb-image-display img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .mazemaster-bb-stats {
            display: flex;
            gap: 30px;
            font-size: 1.2em;
            font-weight: bold;
        }

        .bb-stat-hits {
            color: #27ae60;
        }

        .bb-stat-misses {
            color: #e74c3c;
        }

        .mazemaster-bb-bar-container {
            padding: 10px;
        }

        .mazemaster-bb-bar {
            position: relative;
            width: min(400px, 90vw);
            height: 50px;
            background: linear-gradient(to bottom, #c0392b, #a93226);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .mazemaster-bb-zone {
            position: absolute;
            height: 100%;
            background: linear-gradient(to bottom, #27ae60, #1e8449);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .mazemaster-bb-arrow {
            position: absolute;
            width: 6px;
            height: 100%;
            background: #fff;
            box-shadow: 0 0 15px #fff, 0 0 30px rgba(255, 255, 255, 0.5);
            left: 0;
            transition: none;
        }

        .mazemaster-bb-instructions {
            font-size: 1.1em;
            color: #aaa;
        }

        .mazemaster-bb-instructions kbd {
            background: #444;
            padding: 5px 15px;
            border-radius: 5px;
            font-weight: bold;
            color: #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .mazemaster-bb-bar.flash-hit {
            animation: flashHit 0.3s ease;
        }

        .mazemaster-bb-bar.flash-miss {
            animation: flashMiss 0.3s ease;
        }

        @keyframes flashHit {
            0%, 100% { box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); }
            50% { box-shadow: 0 0 30px rgba(39, 174, 96, 0.8), 0 0 60px rgba(39, 174, 96, 0.5); }
        }

        @keyframes flashMiss {
            0%, 100% { box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); }
            50% { box-shadow: 0 0 30px rgba(231, 76, 60, 0.8), 0 0 60px rgba(231, 76, 60, 0.5); }
        }

        .mazemaster-bb-hit-btn {
            width: min(100%, 90vw);
            max-width: 400px;
            padding: 20px 30px;
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            margin-top: 10px;
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .mazemaster-bb-hit-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.5);
        }

        .mazemaster-bb-hit-btn:active {
            transform: scale(0.98);
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }

        .mazemaster-bb-hit-btn i {
            margin-right: 10px;
        }

        .mazemaster-bb-hit-btn.victory {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }

        .mazemaster-bb-hit-btn.victory:hover {
            box-shadow: 0 8px 25px rgba(243, 156, 18, 0.5);
        }

        .mazemaster-bb-hit-btn.defeat {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            box-shadow: 0 6px 20px rgba(192, 57, 43, 0.4);
        }

        .mazemaster-bb-hit-btn.defeat:hover {
            box-shadow: 0 8px 25px rgba(192, 57, 43, 0.5);
        }
    `;
}

function startBattlebar(profileName, enemyNameOverride = null) {
    const profile = getBattlebarProfile(profileName);
    if (!profile) {
        return { error: `Battlebar profile "${profileName}" not found` };
    }

    // Check for Time Shard effect (slows battlebar by 50%)
    const timeShardMultiplier = getTimeShardMultiplier();
    const hasTimeShard = timeShardMultiplier < 1.0;

    currentBattlebar = {
        isOpen: true,
        profile: profile,
        hits: 0,
        misses: 0,
        arrowPosition: 0,
        arrowDirection: 1,
        zoneStart: 0,
        zoneEnd: 0,
        animationId: null,
        lastFrameTime: 0,
        isVictory: false,
        isDefeat: false,
        // v1.2.0: Time Shard speed multiplier
        speedMultiplier: timeShardMultiplier,
        // v1.3.1: Enemy name override from minion encounter
        enemyNameOverride: enemyNameOverride,
    };

    randomizeBattlebarZone();
    showBattlebarModal();
    startBattlebarAnimation();
    document.addEventListener('keydown', handleBattlebarKeydown);

    // Consume Time Shard if used
    if (hasTimeShard) {
        consumeTimeShard();
    }

    return { success: true };
}

function showBattlebarModal() {
    const existing = document.getElementById('mazemaster_battlebar_modal');
    if (existing) existing.remove();

    if (!document.getElementById('mazemaster_battlebar_styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'mazemaster_battlebar_styles';
        styleEl.textContent = getBattlebarStyles();
        document.head.appendChild(styleEl);
    }

    const modalContainer = document.createElement('div');
    modalContainer.innerHTML = getBattlebarModalHtml();
    document.body.appendChild(modalContainer.firstElementChild);

    // Update stats display
    updateBattlebarStatsDisplay();

    // Update zone position
    updateBattlebarZoneElement();

    // Show first image if available
    updateBattlebarImageDisplay();

    // Show titles
    updateBattlebarTitles();

    // Attach mobile hit button handler
    const hitBtn = document.getElementById('mazemaster_bb_hit_btn');
    if (hitBtn) {
        hitBtn.addEventListener('click', handleBattlebarHitButton);
        hitBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleBattlebarHitButton(e);
        });
    }

    // Attach Strike button handler
    const powBtn = document.getElementById('mazemaster_bb_strike_btn');
    if (powBtn) {
        powBtn.addEventListener('click', handleStrikeButton);
    }

    // Attach EXECUTE button handler
    const executeBtn = document.getElementById('mazemaster_bb_execute_btn');
    if (executeBtn) {
        executeBtn.addEventListener('click', handleExecuteButton);
    }

    // Update Strike and Execute button visibility
    updateStrikeButtonVisibility();
    updateExecuteButtonVisibility();
}

function updateBattlebarTitles() {
    const profile = currentBattlebar.profile || {};

    // Main title - use minion name override if available, otherwise profile mainTitle
    const mainTitleEl = document.getElementById('bb_main_title');
    if (mainTitleEl) {
        mainTitleEl.textContent = currentBattlebar.enemyNameOverride || profile.mainTitle || '';
    }

    // Stage title (based on current hits = current stage, from image stageMessage)
    const stageTitleEl = document.getElementById('bb_stage_title');
    if (stageTitleEl) {
        const images = profile.images || [];
        const currentStage = currentBattlebar.hits || 0;
        const currentImage = images[currentStage];
        stageTitleEl.textContent = currentImage?.stageMessage || '';
    }
}

function handleBattlebarHitButton(e) {
    e.preventDefault();
    if (!currentBattlebar.isOpen) return;

    // If in victory or defeat state, close the modal
    if (currentBattlebar.isVictory || currentBattlebar.isDefeat) {
        closeBattlebarModal();
        return;
    }

    const inZone = currentBattlebar.arrowPosition >= currentBattlebar.zoneStart
                && currentBattlebar.arrowPosition <= currentBattlebar.zoneEnd;

    console.log('[MazeMaster] Hit check:', {
        arrowPosition: currentBattlebar.arrowPosition,
        zoneStart: currentBattlebar.zoneStart,
        zoneEnd: currentBattlebar.zoneEnd,
        inZone: inZone,
    });

    if (inZone) {
        handleBattlebarHit();
    } else {
        handleBattlebarMiss();
    }
}

/**
 * Update Strike button visibility based on maze inventory
 */
function updateStrikeButtonVisibility() {
    const powBtn = document.getElementById('mazemaster_bb_strike_btn');
    const powCount = document.getElementById('bb_strike_count');

    if (powBtn && currentMaze.isOpen && currentMaze.inventory.strike > 0) {
        powBtn.style.display = '';
        if (powCount) powCount.textContent = currentMaze.inventory.strike;
    } else if (powBtn) {
        powBtn.style.display = 'none';
    }
}

/**
 * Handle Strike button click - guaranteed hit
 */
function handleStrikeButton(e) {
    e.preventDefault();
    if (!currentMaze.isOpen || currentMaze.inventory.strike <= 0) return;
    if (!currentBattlebar.isOpen) return;
    if (currentBattlebar.isVictory || currentBattlebar.isDefeat) return;

    // Use Strike - automatic hit
    removeFromInventory('strike');
    updateStrikeButtonVisibility();

    // Register as a hit
    currentBattlebar.hits++;
    updateBattlebarDisplay();

    // Check for win
    if (currentBattlebar.hits >= currentBattlebar.profile.hitsToWin) {
        handleBattlebarWin();
    }
}

/**
 * Check if current battlebar is a main minion exit encounter
 */
function isMainMinionEncounter() {
    return currentMaze.pendingEncounter && currentMaze.pendingEncounter.type === 'exit_battlebar';
}

/**
 * Update EXECUTE button visibility based on maze inventory and encounter type
 */
function updateExecuteButtonVisibility() {
    const executeBtn = document.getElementById('mazemaster_bb_execute_btn');
    const executeCount = document.getElementById('bb_execute_count');

    // Hide if not in maze, no execute, or fighting main minion
    if (executeBtn && currentMaze.isOpen && currentMaze.inventory.execute > 0 && !isMainMinionEncounter()) {
        executeBtn.style.display = '';
        if (executeCount) executeCount.textContent = currentMaze.inventory.execute;
    } else if (executeBtn) {
        executeBtn.style.display = 'none';
    }
}

/**
 * Handle EXECUTE button click - instant win (except vs main minion)
 */
function handleExecuteButton(e) {
    e.preventDefault();
    if (!currentMaze.isOpen || currentMaze.inventory.execute <= 0) return;
    if (!currentBattlebar.isOpen) return;
    if (currentBattlebar.isVictory || currentBattlebar.isDefeat) return;

    // Cannot use against main minion
    if (isMainMinionEncounter()) {
        console.log('[MazeMaster] EXECUTE cannot be used against the main minion!');
        return;
    }

    // Use EXECUTE - instant win
    removeFromInventory('execute');
    updateExecuteButtonVisibility();

    // Set hits to win threshold - instant victory
    currentBattlebar.hits = currentBattlebar.profile.hitsToWin;
    updateBattlebarDisplay();

    // Trigger win
    handleBattlebarWin();
}

async function closeBattlebarModal() {
    const wasVictory = currentBattlebar.isVictory;
    const wasDefeat = currentBattlebar.isDefeat;

    if (currentBattlebar.animationId) {
        cancelAnimationFrame(currentBattlebar.animationId);
    }
    document.removeEventListener('keydown', handleBattlebarKeydown);

    const modal = document.getElementById('mazemaster_battlebar_modal');
    if (modal) modal.remove();

    currentBattlebar.isOpen = false;
    currentBattlebar.isVictory = false;
    currentBattlebar.isDefeat = false;

    // Handle maze integration if this was a maze encounter
    if (currentMaze.isOpen) {
        try {
            if (currentMaze.pendingEncounter) {
                const encounterType = currentMaze.pendingEncounter.type;

                if (wasVictory) {
                    // v1.4.0: Mark room as cleared for zone progression
                    await markRoomCleared(currentMaze.playerX, currentMaze.playerY);
                    if (encounterType === 'exit_battlebar') {
                        // Exit boss defeated - win the maze
                        currentMaze.exitEncounterDone = true;
                        currentMaze.isPaused = false;
                        handleMazeWin();
                        return; // handleMazeWin takes over
                    } else {
                        // Regular encounter - resume maze
                        resumeMaze();
                        return;
                    }
                } else if (wasDefeat) {
                    const lossAction = currentMaze.profile.onBattlebarLoss || 'continue';

                    if (encounterType === 'exit_battlebar') {
                        // Exit boss loss - always respawn or game over (can't continue past exit)
                        if (lossAction === 'gameover') {
                            handleMazeLoss();
                            return;
                        } else {
                            respawnPlayer();
                            return;
                        }
                    } else {
                        // Regular encounter loss
                        switch (lossAction) {
                            case 'gameover':
                                handleMazeLoss();
                                return;
                            case 'respawn':
                                respawnPlayer();
                                return;
                            case 'continue':
                            default:
                                resumeMaze();
                                return;
                        }
                    }
                }
            }
        } catch (err) {
            console.error('[MazeMaster] Error in closeBattlebarModal:', err);
        }

        // Fallback: ensure maze is unpaused and encounter is cleared
        currentMaze.isPaused = false;
        currentMaze.pendingEncounter = null;
    }
}

function randomizeBattlebarZone() {
    let baseDifficulty = currentBattlebar.profile.difficulty || 5;
    // Legacy support: convert old 1-5 scale to new 1-10 scale
    if (baseDifficulty <= 5 && BATTLEBAR_DIFFICULTY_LEGACY[baseDifficulty]) {
        baseDifficulty = BATTLEBAR_DIFFICULTY_LEGACY[baseDifficulty];
    }
    // Apply maze's battlebar difficulty multiplier if in a maze
    const mazeMultiplier = currentMaze.isOpen ? (currentMaze.profile?.battlebarDifficultyMultiplier ?? 1.0) : 1.0;
    const difficulty = getBattlebarDifficultySettings(baseDifficulty, mazeMultiplier);

    const zoneWidth = difficulty.zoneWidth * 100;
    const maxStart = 100 - zoneWidth;

    currentBattlebar.zoneStart = Math.random() * maxStart;
    currentBattlebar.zoneEnd = currentBattlebar.zoneStart + zoneWidth;
    // Store effective settings for animation
    currentBattlebar.effectiveDifficulty = difficulty;

    console.log('[MazeMaster] Zone randomized:', {
        baseDifficulty,
        mazeMultiplier,
        zoneWidth: zoneWidth.toFixed(1) + '%',
        traverseTime: difficulty.traverseTime + 'ms',
        zoneStart: currentBattlebar.zoneStart.toFixed(1),
        zoneEnd: currentBattlebar.zoneEnd.toFixed(1),
    });
}

function updateBattlebarZoneElement() {
    const zone = document.getElementById('bb_zone');
    if (zone) {
        zone.style.left = `${currentBattlebar.zoneStart}%`;
        zone.style.width = `${currentBattlebar.zoneEnd - currentBattlebar.zoneStart}%`;
    }
}

function updateBattlebarArrowElement() {
    const arrow = document.getElementById('bb_arrow');
    if (arrow) {
        arrow.style.left = `${currentBattlebar.arrowPosition}%`;
    }
}

function updateBattlebarStatsDisplay() {
    const hitsEl = document.getElementById('bb_current_hits');
    const neededEl = document.getElementById('bb_needed_hits');
    const missesEl = document.getElementById('bb_current_misses');
    const maxMissesEl = document.getElementById('bb_max_misses');

    if (hitsEl) hitsEl.textContent = currentBattlebar.hits;
    if (neededEl) neededEl.textContent = currentBattlebar.profile.hitsToWin || 5;
    if (missesEl) missesEl.textContent = currentBattlebar.misses;
    if (maxMissesEl) maxMissesEl.textContent = currentBattlebar.profile.missesToLose || 3;
}

function updateBattlebarImageDisplay() {
    const imgEl = document.getElementById('mazemaster_bb_img');
    if (!imgEl) return;

    const images = currentBattlebar.profile.images || [];
    if (images.length === 0) {
        imgEl.style.display = 'none';
        return;
    }

    // Show image based on current hit count
    const imageIndex = Math.min(currentBattlebar.hits, images.length - 1);
    const currentImage = images[imageIndex];
    // Support both 'imagePath' and 'path' field names
    const imagePath = currentImage.imagePath || currentImage.path || '';
    if (imagePath) {
        imgEl.src = getExtensionImagePath(imagePath);
        imgEl.style.display = 'block';
    } else {
        imgEl.style.display = 'none';
    }
}

function startBattlebarAnimation() {
    // Use pre-calculated difficulty from randomizeBattlebarZone, or calculate fresh
    const difficulty = currentBattlebar.effectiveDifficulty || getBattlebarDifficultySettings(
        currentBattlebar.profile.difficulty || 5,
        currentMaze.isOpen ? (currentMaze.profile?.battlebarDifficultyMultiplier ?? 1.0) : 1.0
    );
    // Apply Time Shard speed multiplier if present (lower = slower)
    const baseSpeed = 100 / difficulty.traverseTime; // % per ms
    const speed = baseSpeed * (currentBattlebar.speedMultiplier || 1.0);

    function animate(timestamp) {
        if (!currentBattlebar.isOpen) return;

        if (currentBattlebar.lastFrameTime === 0) {
            currentBattlebar.lastFrameTime = timestamp;
        }

        const delta = timestamp - currentBattlebar.lastFrameTime;
        currentBattlebar.lastFrameTime = timestamp;

        // Move arrow
        currentBattlebar.arrowPosition += speed * delta * currentBattlebar.arrowDirection;

        // Bounce at edges
        if (currentBattlebar.arrowPosition >= 100) {
            currentBattlebar.arrowPosition = 100;
            currentBattlebar.arrowDirection = -1;
        } else if (currentBattlebar.arrowPosition <= 0) {
            currentBattlebar.arrowPosition = 0;
            currentBattlebar.arrowDirection = 1;
        }

        updateBattlebarArrowElement();
        currentBattlebar.animationId = requestAnimationFrame(animate);
    }

    currentBattlebar.lastFrameTime = 0;
    currentBattlebar.animationId = requestAnimationFrame(animate);
}

function handleBattlebarKeydown(e) {
    if (e.code !== 'Space' || !currentBattlebar.isOpen) return;
    e.preventDefault();

    // If in victory or defeat state, close the modal
    if (currentBattlebar.isVictory || currentBattlebar.isDefeat) {
        closeBattlebarModal();
        return;
    }

    const inZone = currentBattlebar.arrowPosition >= currentBattlebar.zoneStart
                && currentBattlebar.arrowPosition <= currentBattlebar.zoneEnd;

    if (inZone) {
        handleBattlebarHit();
    } else {
        handleBattlebarMiss();
    }
}

async function handleBattlebarHit() {
    currentBattlebar.hits++;

    // Flash green
    const bar = document.querySelector('.mazemaster-bb-bar');
    if (bar) {
        bar.classList.remove('flash-hit', 'flash-miss');
        void bar.offsetWidth; // Trigger reflow
        bar.classList.add('flash-hit');
    }

    updateBattlebarStatsDisplay();
    updateBattlebarImageDisplay();
    updateBattlebarTitles();

    // Execute hit command
    if (currentBattlebar.profile.hitCommand) {
        await executeWithTimeout(currentBattlebar.profile.hitCommand);
    }

    // Check for win
    if (currentBattlebar.hits >= (currentBattlebar.profile.hitsToWin || 5)) {
        await handleBattlebarWin();
        return;
    }

    // Randomize zone for next attempt
    randomizeBattlebarZone();
    updateBattlebarZoneElement();
}

async function handleBattlebarMiss() {
    currentBattlebar.misses++;

    // Flash red
    const bar = document.querySelector('.mazemaster-bb-bar');
    if (bar) {
        bar.classList.remove('flash-hit', 'flash-miss');
        void bar.offsetWidth;
        bar.classList.add('flash-miss');
    }

    updateBattlebarStatsDisplay();

    // Execute miss command
    if (currentBattlebar.profile.missCommand) {
        await executeWithTimeout(currentBattlebar.profile.missCommand);
    }

    // Check for loss
    if (currentBattlebar.misses >= (currentBattlebar.profile.missesToLose || 3)) {
        await handleBattlebarLoss();
        return;
    }
}

async function handleBattlebarWin() {
    const profileName = extensionSettings.currentBattlebarProfile || 'default';

    // Store result for macros
    lastResults.battlebar[profileName] = {
        result: 'win',
        hits: currentBattlebar.hits,
        misses: currentBattlebar.misses,
        timestamp: Date.now(),
    };

    // Log to session notes
    if (currentMaze?.isOpen) {
        addSessionNote(`Battlebar victory: ${currentBattlebar.profile?.mainTitle || profileName}`, 'Combat');
        // v1.4.7: Reset combat loss streak on win
        if (currentMaze.fairness) {
            currentMaze.fairness.combatLossStreak = 0;
        }
    }

    // Set victory state
    currentBattlebar.isVictory = true;

    // Handle item drops for maze encounters
    if (currentMaze.isOpen && currentMaze.pendingEncounter) {
        const profile = currentBattlebar.profile;

        // Roll for core item drops
        if (Math.random() * 100 < (profile.keyDropChance ?? 40)) {
            addToInventory('key');
        }
        if (Math.random() * 100 < (profile.strikeDropChance ?? 20)) {
            addToInventory('strike');
        }
        if (Math.random() * 100 < (profile.stealthDropChance ?? 10)) {
            addToInventory('stealth');
        }
        if (Math.random() * 100 < (profile.executeDropChance ?? 2)) {
            addToInventory('execute');
        }
        // Roll for special item drops (rarer)
        if (Math.random() * 100 < (profile.floorKeyDropChance ?? 5)) {
            addToInventory('floorKey');
        }
        if (Math.random() * 100 < (profile.portalStoneDropChance ?? 3)) {
            addToInventory('portalStone');
        }
        if (Math.random() * 100 < (profile.minionBaneDropChance ?? 4)) {
            addToInventory('minionBane');
        }
        if (Math.random() * 100 < (profile.mapFragmentDropChance ?? 8)) {
            addToInventory('mapFragment');
        }
        if (Math.random() * 100 < (profile.timeShardDropChance ?? 2)) {
            addToInventory('timeShard');
        }
        if (Math.random() * 100 < (profile.voidWalkDropChance ?? 1)) {
            addToInventory('voidWalk');
        }
        // v1.3.0: HP item drops (only if HP system is enabled)
        if (currentMaze.hpEnabled) {
            if (Math.random() * 100 < (profile.healingPotionDropChance ?? 15)) {
                addToInventory('healingPotion');
            }
            if (Math.random() * 100 < (profile.greaterHealingDropChance ?? 5)) {
                addToInventory('greaterHealing');
            }
            if (Math.random() * 100 < (profile.elixirDropChance ?? 1)) {
                addToInventory('elixir');
            }
            if (Math.random() * 100 < (profile.revivalCharmDropChance ?? 0.5)) {
                addToInventory('revivalCharm');
            }
            if (Math.random() * 100 < (profile.heartCrystalDropChance ?? 0.3)) {
                addToInventory('heartCrystal');
            }
        }
    }

    // Stop the arrow animation
    if (currentBattlebar.animationId) {
        cancelAnimationFrame(currentBattlebar.animationId);
        currentBattlebar.animationId = null;
    }

    // Hide the bar and instructions
    const barContainer = document.querySelector('.mazemaster-bb-bar-container');
    const instructions = document.querySelector('.mazemaster-bb-instructions');
    if (barContainer) barContainer.style.display = 'none';
    if (instructions) instructions.style.display = 'none';

    // Show victory image (last image in array) and its message
    const images = currentBattlebar.profile.images || [];
    const victoryImage = images.length > 0 ? images[images.length - 1] : null;

    if (victoryImage) {
        const imgEl = document.getElementById('mazemaster_bb_img');
        if (imgEl) {
            imgEl.src = '/' + victoryImage.path;
        }
    }

    // Update stage title to show victory message from last image
    const stageTitleEl = document.getElementById('bb_stage_title');
    if (stageTitleEl) {
        const victoryMessage = victoryImage?.stageMessage || 'Victory!';
        stageTitleEl.textContent = victoryMessage;
    }

    // Change button to "Close"
    const hitBtn = document.getElementById('mazemaster_bb_hit_btn');
    if (hitBtn) {
        hitBtn.innerHTML = '<i class="fa-solid fa-check"></i> Close';
        hitBtn.classList.add('victory');
    }

    // Execute win command
    if (currentBattlebar.profile.winCommand) {
        await executeWithTimeout(currentBattlebar.profile.winCommand);
    }
}

async function handleBattlebarLoss() {
    const profileName = extensionSettings.currentBattlebarProfile || 'default';

    // Store result for macros
    lastResults.battlebar[profileName] = {
        result: 'lose',
        hits: currentBattlebar.hits,
        misses: currentBattlebar.misses,
        timestamp: Date.now(),
    };

    // Log to session notes
    if (currentMaze?.isOpen) {
        addSessionNote(`Battlebar defeat: ${currentBattlebar.profile?.mainTitle || profileName}`, 'Combat');
        // v1.4.7: Increment combat loss streak
        if (currentMaze.fairness) {
            currentMaze.fairness.combatLossStreak++;
            console.log(`[MazeMaster] Fairness: Combat loss streak: ${currentMaze.fairness.combatLossStreak}`);
        }
    }

    // Set defeat state
    currentBattlebar.isDefeat = true;

    // Stop the arrow animation
    if (currentBattlebar.animationId) {
        cancelAnimationFrame(currentBattlebar.animationId);
        currentBattlebar.animationId = null;
    }

    // Hide the bar and instructions
    const barContainer = document.querySelector('.mazemaster-bb-bar-container');
    const instructions = document.querySelector('.mazemaster-bb-instructions');
    if (barContainer) barContainer.style.display = 'none';
    if (instructions) instructions.style.display = 'none';

    // HP System: Apply damage instead of immediate defeat (v1.3.0)
    if (currentMaze.isOpen && currentMaze.hpEnabled && currentMaze.hp) {
        const mazeProfile = currentMaze.profile;
        // Get base damage from battlebar profile, apply maze's damage multiplier
        const battlebarDamage = currentBattlebar.profile?.damage || 25;
        const mazeMultiplier = mazeProfile.battlebarDamageMultiplier ?? 1.0;
        const damage = Math.round(battlebarDamage * mazeMultiplier);

        const survived = await applyDamage(damage, 'battlebar');

        if (survived) {
            // Player survived - show "Wounded" instead of "Defeat"
            const stageTitleEl = document.getElementById('bb_stage_title');
            if (stageTitleEl) {
                stageTitleEl.textContent = 'Wounded!';
            }

            // Change button to "Continue"
            const hitBtn = document.getElementById('mazemaster_bb_hit_btn');
            if (hitBtn) {
                hitBtn.innerHTML = '<i class="fa-solid fa-arrow-right"></i> Continue';
                hitBtn.classList.add('wounded');
            }

            // Execute lose command but player continues
            if (currentBattlebar.profile.loseCommand) {
                await executeWithTimeout(currentBattlebar.profile.loseCommand);
            }
            return;
        }

        // Player died - death handling is done by applyDamage -> handlePlayerDeath
        // Execute lose command before closing
        if (currentBattlebar.profile.loseCommand) {
            await executeWithTimeout(currentBattlebar.profile.loseCommand);
        }

        // Close the battlebar modal immediately so the death/gameover screen can show
        currentBattlebar.isDefeat = true;
        closeBattlebarModal();
        return;
    }

    // Non-HP mode: Original behavior
    // Update stage title to show defeat
    const stageTitleEl = document.getElementById('bb_stage_title');
    if (stageTitleEl) {
        stageTitleEl.textContent = 'Defeat...';
    }

    // Change button to "Close"
    const hitBtn = document.getElementById('mazemaster_bb_hit_btn');
    if (hitBtn) {
        hitBtn.innerHTML = '<i class="fa-solid fa-times"></i> Close';
        hitBtn.classList.add('defeat');
    }

    // Execute lose command
    if (currentBattlebar.profile.loseCommand) {
        await executeWithTimeout(currentBattlebar.profile.loseCommand);
    }
}

// =============================================================================
// MAZE LOGIC
// =============================================================================

// =============================================================================
// v1.4.0 BSP GENERATION SYSTEM - Data Structures
// =============================================================================

/**
 * Theme-specific room type pools
 * Each theme has rooms categorized by size: small (2x2), medium (3x3), large (4x4+), special
 */
const THEMED_ROOM_TYPES = {
    fantasy: {
        small: ['alcove', 'guardPost', 'shrine', 'cell', 'storeroom'],
        medium: ['treasureVault', 'library', 'armory', 'chapel', 'barracks'],
        large: ['throneRoom', 'arena', 'crypt', 'greatHall', 'dungeon'],
        special: ['bossLair', 'dragonDen', 'wizardTower']
    },
    scifi: {
        small: ['airlock', 'terminal', 'cryoPod', 'storageUnit', 'junction'],
        medium: ['lab', 'serverRoom', 'medbay', 'armory', 'quarters'],
        large: ['hangar', 'reactor', 'bridge', 'hydroponics', 'cargo'],
        special: ['aiCore', 'alienNest', 'escapePod']
    },
    horror: {
        small: ['closet', 'cell', 'ritualNook', 'crawlspace', 'alcove'],
        medium: ['morgue', 'cultRoom', 'tortureChamber', 'nursery', 'study'],
        large: ['cathedral', 'asylumWard', 'abattoir', 'ritualHall', 'crypt'],
        special: ['finalGate', 'elderShrine', 'heartOfDarkness']
    },
    western: {
        small: ['storeroom', 'jailCell', 'stall', 'privy', 'closet'],
        medium: ['saloon', 'sheriffOffice', 'bankVault', 'generalStore', 'hotel'],
        large: ['townSquare', 'ranchHouse', 'goldMine', 'trainStation', 'church'],
        special: ['showdownStreet', 'outlawHideout', 'ghostTownCenter']
    },
    action: {
        small: ['checkpoint', 'ammoCache', 'commsRoom', 'bunker', 'vent'],
        medium: ['warRoom', 'armory', 'interrogation', 'motorPool', 'barracks'],
        large: ['hangar', 'trainingGround', 'commandCenter', 'missileSilo', 'prison'],
        special: ['bossArena', 'extractionZone', 'doomsdayDevice']
    },
    comedy: {
        small: ['broomCloset', 'vendingCorner', 'awkwardBathroom', 'supplyRoom', 'cubicle'],
        medium: ['breakRoom', 'conferenceDisaster', 'printerGraveyard', 'itDungeon', 'mailRoom'],
        large: ['cafeteria', 'ballPit', 'karaokeHall', 'escapeRoomInception', 'openOffice'],
        special: ['finalBossOffice', 'plotTwistRoom', 'creditsRoom']
    },
    cyberpunk: {
        small: ['jackPoint', 'stash', 'corpoCloset', 'vendingAlcove', 'maintenance'],
        medium: ['netrunnerDen', 'chopShop', 'blackMarket', 'ripperdoc', 'flophouse'],
        large: ['megacorpFloor', 'club', 'dataFortress', 'gangHQ', 'bazaar'],
        special: ['aiCore', 'finalUpload', 'skyGarden']
    }
};

/**
 * Room mechanics define special behaviors for room types
 */
const ROOM_MECHANICS = {
    // Treasure rooms
    treasureVault: { guaranteedChest: true, chestQuality: 'rare', trapDensity: 1.5, minionGuard: true },
    bankVault: { guaranteedChest: true, chestQuality: 'rare', trapDensity: 2.0, minionGuard: true },

    // Combat rooms
    arena: { waveBattle: true, waveCount: { min: 2, max: 4 }, noRetreat: true, rewardOnClear: 'special' },
    bossArena: { bossEncounter: true, lockedUntilCleared: true, specialLoot: true },
    bossLair: { bossEncounter: true, lockedUntilCleared: true, specialLoot: true },
    trainingGround: { waveBattle: true, waveCount: { min: 1, max: 2 }, noRetreat: false },

    // Knowledge rooms
    library: { revealMapOnEnter: true, revealRadius: 3, scholarNPC: true },
    serverRoom: { revealMapOnEnter: true, revealRadius: 4 },
    terminal: { revealMapOnEnter: true, revealRadius: 2 },

    // Safe havens
    shrine: { noEnemies: true, healPercent: 25 },
    chapel: { noEnemies: true, healPercent: 50, savePoint: true },
    medbay: { noEnemies: true, fullHeal: true, savePoint: true },
    ripperdoc: { noEnemies: true, fullHeal: true, merchantNPC: true },

    // Special mechanics
    crypt: { undeadOnly: true, trapDensity: 1.5 },
    reactor: { hazardDamage: 5, noRest: true },
    crawlspace: { stealthBonus: true, noLargeEnemies: true },

    // Default for unlisted types
    default: { }
};

/**
 * BSP style-specific configurations
 */
const BSP_STYLE_CONFIGS = {
    dungeon: {
        minRoomSize: 2,
        maxRoomSize: 3,
        minSplitSize: 2,
        splitVariance: 0.3,
        corridorWidth: 1,
        roomPadding: 0,
        extraConnections: 0.5,
        branchChance: 0.4,
        preferSquareRooms: false
    },
    maze: {
        minRoomSize: 2,
        maxRoomSize: 2,
        minSplitSize: 2,
        splitVariance: 0.3,
        corridorWidth: 1,
        roomPadding: 0,
        extraConnections: 0.6,
        addDeadEnds: true,
        branchChance: 0.5,
        preferSquareRooms: true
    },
    city: {
        minRoomSize: 2,
        maxRoomSize: 3,
        minSplitSize: 2,
        splitVariance: 0.25,
        corridorWidth: 1,
        roomPadding: 0,
        gridAlign: true,
        extraConnections: 0.6,
        branchChance: 0.4,
        preferSquareRooms: false
    },
    forest: {
        minRoomSize: 2,
        maxRoomSize: 3,
        minSplitSize: 2,
        splitVariance: 0.35,
        corridorWidth: 1,
        roomPadding: 0,
        windingCorridors: true,
        extraConnections: 0.5,
        branchChance: 0.5,
        preferSquareRooms: false
    },
    spaceship: {
        minRoomSize: 2,
        maxRoomSize: 3,
        minSplitSize: 2,
        splitVariance: 0.2,
        corridorWidth: 1,
        roomPadding: 0,
        extraConnections: 0.5,
        modularRooms: true,
        branchChance: 0.4,
        preferSquareRooms: true
    },
    arena: {
        minRoomSize: 2,
        maxRoomSize: 3,
        minSplitSize: 2,
        splitVariance: 0.3,
        corridorWidth: 1,
        roomPadding: 0,
        extraConnections: 0.5,
        branchChance: 0.4,
        preferSquareRooms: true
    },
    hospital: {
        minRoomSize: 2,
        maxRoomSize: 3,
        minSplitSize: 2,
        splitVariance: 0.2,
        corridorWidth: 1,
        roomPadding: 0,
        gridAlign: true,
        extraConnections: 0.5,
        branchChance: 0.4,
        preferSquareRooms: false
    }
};

// Map style aliases to BSP configs
const STYLE_TO_BSP_CONFIG = {
    'dungeon': 'dungeon',
    'maze': 'maze',
    'city': 'city',
    'neotokyo': 'city',
    'forest': 'forest',
    'spaceship': 'spaceship',
    'spacestation': 'spaceship',
    'arena': 'arena',
    'outpost': 'dungeon',
    'college': 'hospital',
    'apartment': 'city',
    'hospital': 'hospital',
    'highrise': 'city'
};

// =============================================================================
// v1.4.0 BSP GENERATION ALGORITHM
// =============================================================================

/**
 * Generate a BSP tree for dungeon layout
 * @param {number} x - Start X coordinate
 * @param {number} y - Start Y coordinate
 * @param {number} width - Area width
 * @param {number} height - Area height
 * @param {number} depth - Current recursion depth
 * @param {object} config - BSP configuration
 * @returns {object} BSP node
 */
function generateBSPTree(x, y, width, height, depth, config) {
    const node = {
        x, y, width, height,
        left: null,
        right: null,
        room: null,
        splitHorizontal: null
    };

    // Check if we should stop splitting - use minSplitSize directly, not doubled
    const minSize = config.minSplitSize || 2;
    const maxDepth = config.maxDepth || 8;

    // More aggressive splitting - only stop if we truly can't split
    // Need at least minSize+1 to split (e.g., 3 cells -> 1+2 or 2+1)
    const canSplitWidth = width >= minSize + 1;
    const canSplitHeight = height >= minSize + 1;

    if (depth >= maxDepth || (!canSplitWidth && !canSplitHeight)) {
        // This is a leaf node - generate a room here
        node.room = generateRoomInNode(node, config);
        return node;
    }

    // Decide split direction based on what's possible and aspect ratio
    const aspectRatio = width / height;
    let splitHorizontal;

    if (!canSplitWidth) {
        splitHorizontal = true; // Can only split horizontally
    } else if (!canSplitHeight) {
        splitHorizontal = false; // Can only split vertically
    } else if (aspectRatio > 1.5) {
        splitHorizontal = false; // Split vertically (too wide)
    } else if (aspectRatio < 0.67) {
        splitHorizontal = true; // Split horizontally (too tall)
    } else {
        // For square-ish areas, alternate or randomize
        splitHorizontal = Math.random() < 0.5;
    }

    node.splitHorizontal = splitHorizontal;

    // Calculate split position with variance - allow asymmetric splits
    const variance = config.splitVariance || 0.3;
    const minRatio = Math.max(0.25, 0.5 - variance);
    const maxRatio = Math.min(0.75, 0.5 + variance);
    const splitRatio = minRatio + Math.random() * (maxRatio - minRatio);

    if (splitHorizontal) {
        // Split horizontally (top/bottom)
        const splitY = Math.max(minSize, Math.min(height - minSize, Math.floor(height * splitRatio)));
        if (splitY < 1 || height - splitY < 1) {
            node.room = generateRoomInNode(node, config);
            return node;
        }
        node.left = generateBSPTree(x, y, width, splitY, depth + 1, config);
        node.right = generateBSPTree(x, y + splitY, width, height - splitY, depth + 1, config);
    } else {
        // Split vertically (left/right)
        const splitX = Math.max(minSize, Math.min(width - minSize, Math.floor(width * splitRatio)));
        if (splitX < 1 || width - splitX < 1) {
            node.room = generateRoomInNode(node, config);
            return node;
        }
        node.left = generateBSPTree(x, y, splitX, height, depth + 1, config);
        node.right = generateBSPTree(x + splitX, y, width - splitX, height, depth + 1, config);
    }

    return node;
}

/**
 * Generate a room within a BSP leaf node
 * @param {object} node - BSP leaf node
 * @param {object} config - Room generation config
 * @returns {object} Room data
 */
function generateRoomInNode(node, config) {
    const padding = config.roomPadding || 1;
    const minSize = config.minRoomSize || 2;
    const maxSize = config.maxRoomSize || 5;

    // Calculate available space for room
    const availWidth = node.width - padding * 2;
    const availHeight = node.height - padding * 2;

    if (availWidth < minSize || availHeight < minSize) {
        // Not enough space for a room
        return null;
    }

    // Determine room size
    let roomWidth = Math.min(maxSize, availWidth);
    let roomHeight = Math.min(maxSize, availHeight);

    // Add some variance to room size
    roomWidth = Math.max(minSize, Math.floor(roomWidth * (0.7 + Math.random() * 0.3)));
    roomHeight = Math.max(minSize, Math.floor(roomHeight * (0.7 + Math.random() * 0.3)));

    // Prefer square rooms if configured
    if (config.preferSquareRooms) {
        const minDim = Math.min(roomWidth, roomHeight);
        roomWidth = minDim;
        roomHeight = minDim;
    }

    // Position room within node (with some randomness)
    const maxOffsetX = availWidth - roomWidth;
    const maxOffsetY = availHeight - roomHeight;
    const offsetX = maxOffsetX > 0 ? Math.floor(Math.random() * maxOffsetX) : 0;
    const offsetY = maxOffsetY > 0 ? Math.floor(Math.random() * maxOffsetY) : 0;

    const roomX = node.x + padding + offsetX;
    const roomY = node.y + padding + offsetY;

    return {
        x: roomX,
        y: roomY,
        width: roomWidth,
        height: roomHeight,
        centerX: Math.floor(roomX + roomWidth / 2),
        centerY: Math.floor(roomY + roomHeight / 2),
        type: 'common', // Will be assigned later based on theme
        zoneId: null,
        isCleared: false,
        connections: []
    };
}

/**
 * Collect all rooms from a BSP tree
 * @param {object} node - BSP tree root
 * @returns {array} Array of rooms
 */
function collectRoomsFromBSP(node) {
    if (!node) return [];

    if (node.room) {
        return [node.room];
    }

    return [
        ...collectRoomsFromBSP(node.left),
        ...collectRoomsFromBSP(node.right)
    ];
}

/**
 * Find the nearest room in a BSP subtree to a given point
 * @param {object} node - BSP node
 * @param {number} targetX - Target X coordinate
 * @param {number} targetY - Target Y coordinate
 * @returns {object} Nearest room
 */
function findNearestRoom(node, targetX, targetY) {
    if (!node) return null;

    if (node.room) {
        return node.room;
    }

    const leftRoom = findNearestRoom(node.left, targetX, targetY);
    const rightRoom = findNearestRoom(node.right, targetX, targetY);

    if (!leftRoom) return rightRoom;
    if (!rightRoom) return leftRoom;

    const leftDist = Math.abs(leftRoom.centerX - targetX) + Math.abs(leftRoom.centerY - targetY);
    const rightDist = Math.abs(rightRoom.centerX - targetX) + Math.abs(rightRoom.centerY - targetY);

    return leftDist < rightDist ? leftRoom : rightRoom;
}

/**
 * Connect rooms in BSP tree via corridors
 * @param {object} node - BSP node (internal)
 * @param {array} grid - Map grid
 * @param {number} size - Grid size
 * @param {object} config - Configuration
 */
function connectBSPChildren(node, grid, size, config) {
    if (!node || !node.left || !node.right) return;

    // Recursively connect children first
    connectBSPChildren(node.left, grid, size, config);
    connectBSPChildren(node.right, grid, size, config);

    // Find rooms to connect from each child
    const leftRoom = findNearestRoom(node.left, node.x + node.width / 2, node.y + node.height / 2);
    const rightRoom = findNearestRoom(node.right, node.x + node.width / 2, node.y + node.height / 2);

    if (leftRoom && rightRoom) {
        // Create corridor between room centers
        carveCorridor(grid, size,
            leftRoom.centerX, leftRoom.centerY,
            rightRoom.centerX, rightRoom.centerY,
            config);

        // Track connection
        leftRoom.connections.push(rightRoom);
        rightRoom.connections.push(leftRoom);
    }
}

/**
 * Carve a corridor between two points (L-shaped or straight)
 * @param {array} grid - Map grid
 * @param {number} size - Grid size
 * @param {number} x1 - Start X
 * @param {number} y1 - Start Y
 * @param {number} x2 - End X
 * @param {number} y2 - End Y
 * @param {object} config - Configuration
 */
function carveCorridor(grid, size, x1, y1, x2, y2, config) {
    const width = config.corridorWidth || 1;

    // Randomly choose horizontal-first or vertical-first
    const horizontalFirst = Math.random() < 0.5;

    if (config.windingCorridors && Math.random() < 0.3) {
        // Add a midpoint for more interesting corridors
        const midX = Math.floor((x1 + x2) / 2) + Math.floor((Math.random() - 0.5) * 4);
        const midY = Math.floor((y1 + y2) / 2) + Math.floor((Math.random() - 0.5) * 4);
        carveCorridor(grid, size, x1, y1, midX, midY, { ...config, windingCorridors: false });
        carveCorridor(grid, size, midX, midY, x2, y2, { ...config, windingCorridors: false });
        return;
    }

    if (horizontalFirst) {
        // Horizontal then vertical
        carveHorizontalCorridor(grid, size, x1, x2, y1, width);
        carveVerticalCorridor(grid, size, y1, y2, x2, width);
    } else {
        // Vertical then horizontal
        carveVerticalCorridor(grid, size, y1, y2, x1, width);
        carveHorizontalCorridor(grid, size, x1, x2, y2, width);
    }
}

/**
 * Carve a horizontal corridor
 */
function carveHorizontalCorridor(grid, size, x1, x2, y, width) {
    const startX = Math.min(x1, x2);
    const endX = Math.max(x1, x2);

    for (let x = startX; x <= endX; x++) {
        for (let w = 0; w < width; w++) {
            const yPos = y + w;
            if (x >= 0 && x < size && yPos >= 0 && yPos < size) {
                const cell = grid[yPos][x];
                cell.corridorType = 'main';

                // Remove walls for passage
                if (x > startX) cell.walls.left = false;
                if (x < endX) cell.walls.right = false;
                if (x > 0 && x - 1 >= startX) grid[yPos][x - 1].walls.right = false;
                if (x < size - 1 && x + 1 <= endX) grid[yPos][x + 1].walls.left = false;
            }
        }
    }
}

/**
 * Carve a vertical corridor
 */
function carveVerticalCorridor(grid, size, y1, y2, x, width) {
    const startY = Math.min(y1, y2);
    const endY = Math.max(y1, y2);

    for (let y = startY; y <= endY; y++) {
        for (let w = 0; w < width; w++) {
            const xPos = x + w;
            if (xPos >= 0 && xPos < size && y >= 0 && y < size) {
                const cell = grid[y][xPos];
                cell.corridorType = 'main';

                // Remove walls for passage
                if (y > startY) cell.walls.top = false;
                if (y < endY) cell.walls.bottom = false;
                if (y > 0 && y - 1 >= startY) grid[y - 1][xPos].walls.bottom = false;
                if (y < size - 1 && y + 1 <= endY) grid[y + 1][xPos].walls.top = false;
            }
        }
    }
}

/**
 * Carve a room into the grid (remove interior walls)
 * @param {array} grid - Map grid
 * @param {object} room - Room data
 * @param {number} roomId - Room ID to assign
 */
function carveRoomIntoGrid(grid, room, roomId) {
    for (let y = room.y; y < room.y + room.height; y++) {
        for (let x = room.x; x < room.x + room.width; x++) {
            if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
                const cell = grid[y][x];
                cell.roomId = roomId;
                cell.isRoomInterior = true;

                // Remove interior walls (keep perimeter)
                if (x > room.x) cell.walls.left = false;
                if (x < room.x + room.width - 1) cell.walls.right = false;
                if (y > room.y) cell.walls.top = false;
                if (y < room.y + room.height - 1) cell.walls.bottom = false;

                // Also update adjacent cells' walls
                if (x > room.x && x > 0) grid[y][x - 1].walls.right = false;
                if (x < room.x + room.width - 1 && x < grid[0].length - 1) grid[y][x + 1].walls.left = false;
                if (y > room.y && y > 0) grid[y - 1][x].walls.bottom = false;
                if (y < room.y + room.height - 1 && y < grid.length - 1) grid[y + 1][x].walls.top = false;
            }
        }
    }
}

/**
 * Assign themed room types based on size and theme
 * @param {array} rooms - Array of rooms
 * @param {string} theme - Map theme
 */
function assignRoomTypes(rooms, theme) {
    const themeRooms = THEMED_ROOM_TYPES[theme] || THEMED_ROOM_TYPES.fantasy;

    // Ensure at least one special room for larger dungeons
    const hasSpecial = rooms.length > 5;
    let specialAssigned = false;

    rooms.forEach((room, index) => {
        const area = room.width * room.height;

        // Determine size category
        let sizeCategory;
        if (area <= 4) {
            sizeCategory = 'small';
        } else if (area <= 9) {
            sizeCategory = 'medium';
        } else {
            sizeCategory = 'large';
        }

        // Chance for special room (last room or random)
        if (hasSpecial && !specialAssigned && (index === rooms.length - 1 || Math.random() < 0.1)) {
            room.type = themeRooms.special[Math.floor(Math.random() * themeRooms.special.length)];
            specialAssigned = true;
        } else {
            const typePool = themeRooms[sizeCategory];
            room.type = typePool[Math.floor(Math.random() * typePool.length)];
        }

        // Assign mechanics
        room.mechanics = ROOM_MECHANICS[room.type] || ROOM_MECHANICS.default;
    });
}

/**
 * Generate a complete BSP-based grid
 * @param {number} size - Grid size
 * @param {string} mapStyle - Map style name
 * @param {string} theme - Theme name
 * @param {object} overrideConfig - Optional config overrides
 * @returns {object} { grid, rooms }
 */
function generateBSPGrid(size, mapStyle, theme, overrideConfig = {}) {
    // Get style-specific config
    const configName = STYLE_TO_BSP_CONFIG[mapStyle] || 'dungeon';
    const baseConfig = BSP_STYLE_CONFIGS[configName] || BSP_STYLE_CONFIGS.dungeon;
    const config = { ...baseConfig, ...overrideConfig };

    // Calculate max depth based on size - more aggressive splitting for denser mazes
    config.maxDepth = Math.max(4, Math.floor(Math.log2(size) * 1.5));

    // Initialize grid with all walls
    const grid = [];
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = {
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false,
                minion: null,
                trap: null,
                // v1.4.0 BSP properties
                roomId: null,
                zoneId: null,
                isRoomInterior: false,
                secretPassage: null,
                corridorType: null
            };
        }
    }

    // Generate BSP tree
    const root = generateBSPTree(0, 0, size, size, 0, config);

    // Collect rooms from tree
    const rooms = collectRoomsFromBSP(root).filter(r => r !== null);

    // Carve rooms into grid
    rooms.forEach((room, index) => {
        room.id = index;
        carveRoomIntoGrid(grid, room, index);
    });

    // Connect rooms via corridors
    connectBSPChildren(root, grid, size, config);

    // Assign themed room types
    assignRoomTypes(rooms, theme);

    // Add extra connections for variety
    if (config.extraConnections > 0) {
        addExtraBSPConnections(grid, rooms, size, config);
    }

    // Add dead ends if configured (for maze style)
    if (config.addDeadEnds) {
        addBSPDeadEnds(grid, rooms, size, config);
    }

    // Ensure start and exit are accessible
    ensureConnected(grid, size, 0, 0, size - 1, size - 1);

    // Ensure multiple directions from start position for interesting exploration
    ensureMultipleStartDirections(grid, rooms, size, config);

    return { grid, rooms };
}

/**
 * Ensure the start position (0,0) has multiple direction options
 * This prevents boring linear corridors from the start
 */
function ensureMultipleStartDirections(grid, rooms, size, config) {
    const startCell = grid[0][0];
    const directions = [];

    // Count current available directions
    if (!startCell.walls.right) directions.push('east');
    if (!startCell.walls.bottom) directions.push('south');
    // Note: start is at (0,0) so no north or west possible

    // If we already have 2 directions, we're good
    if (directions.length >= 2) return;

    // Find nearby rooms to connect to
    const nearbyRooms = rooms.filter(r => {
        const dist = Math.abs(r.centerX) + Math.abs(r.centerY);
        return dist > 0 && dist < size / 2;
    }).sort((a, b) => {
        const distA = Math.abs(a.centerX) + Math.abs(a.centerY);
        const distB = Math.abs(b.centerX) + Math.abs(b.centerY);
        return distA - distB;
    });

    // Try to open both east and south directions if possible
    if (!directions.includes('east') && size > 1) {
        // Open east - find a room to the east or just open the path
        const eastRoom = nearbyRooms.find(r => r.centerX > 0);
        if (eastRoom) {
            // Carve corridor from (0,0) to a point going east then to room
            let x = 0;
            const targetX = Math.min(3, eastRoom.centerX);
            while (x < targetX && x < size - 1) {
                grid[0][x].walls.right = false;
                grid[0][x + 1].walls.left = false;
                x++;
            }
            // Now connect to the room
            carveCorridor(grid, size, x, 0, eastRoom.centerX, eastRoom.centerY, config);
        } else {
            // Just open a short path east
            grid[0][0].walls.right = false;
            if (size > 1) grid[0][1].walls.left = false;
        }
    }

    if (!directions.includes('south') && size > 1) {
        // Open south - find a room to the south or just open the path
        const southRoom = nearbyRooms.find(r => r.centerY > 0 && r.centerX < size / 3);
        if (southRoom) {
            // Carve corridor from (0,0) going south then to room
            let y = 0;
            const targetY = Math.min(3, southRoom.centerY);
            while (y < targetY && y < size - 1) {
                grid[y][0].walls.bottom = false;
                grid[y + 1][0].walls.top = false;
                y++;
            }
            // Now connect to the room
            carveCorridor(grid, size, 0, y, southRoom.centerX, southRoom.centerY, config);
        } else {
            // Just open a short path south
            grid[0][0].walls.bottom = false;
            if (size > 1) grid[1][0].walls.top = false;
        }
    }
}

/**
 * Add extra random connections between rooms
 */
function addExtraBSPConnections(grid, rooms, size, config) {
    // Add room-to-room connections
    const extraCount = Math.floor(rooms.length * config.extraConnections);

    for (let i = 0; i < extraCount; i++) {
        const room1 = rooms[Math.floor(Math.random() * rooms.length)];
        const room2 = rooms[Math.floor(Math.random() * rooms.length)];

        if (room1 !== room2 && !room1.connections.includes(room2)) {
            carveCorridor(grid, size,
                room1.centerX, room1.centerY,
                room2.centerX, room2.centerY,
                config);
            room1.connections.push(room2);
            room2.connections.push(room1);
        }
    }

    // Add corridor intersections to create more branch points
    addCorridorIntersections(grid, size, config);
}

/**
 * Add intersection points along corridors to create more direction options
 */
function addCorridorIntersections(grid, size, config) {
    const intersectionCount = Math.floor(size * 1.5); // More intersections for larger maps

    for (let i = 0; i < intersectionCount; i++) {
        // Find a corridor cell (not a room interior, not on edge)
        const x = 2 + Math.floor(Math.random() * (size - 4));
        const y = 2 + Math.floor(Math.random() * (size - 4));

        const cell = grid[y][x];

        // Skip room interiors
        if (cell.isRoomInterior) continue;

        // Count current open directions
        let openDirs = 0;
        if (!cell.walls.top) openDirs++;
        if (!cell.walls.right) openDirs++;
        if (!cell.walls.bottom) openDirs++;
        if (!cell.walls.left) openDirs++;

        // If this is a corridor cell (1-2 open directions), open more directions
        if (openDirs >= 1 && openDirs <= 2) {
            // Open 1-2 additional random directions
            const closedDirs = [];
            if (cell.walls.top && y > 0) closedDirs.push('top');
            if (cell.walls.right && x < size - 1) closedDirs.push('right');
            if (cell.walls.bottom && y < size - 1) closedDirs.push('bottom');
            if (cell.walls.left && x > 0) closedDirs.push('left');

            // Shuffle and pick 1-2 to open
            const toOpen = Math.min(closedDirs.length, 1 + Math.floor(Math.random() * 2));
            for (let j = 0; j < toOpen; j++) {
                const idx = Math.floor(Math.random() * closedDirs.length);
                const dir = closedDirs.splice(idx, 1)[0];

                switch (dir) {
                    case 'top':
                        cell.walls.top = false;
                        grid[y - 1][x].walls.bottom = false;
                        break;
                    case 'right':
                        cell.walls.right = false;
                        grid[y][x + 1].walls.left = false;
                        break;
                    case 'bottom':
                        cell.walls.bottom = false;
                        grid[y + 1][x].walls.top = false;
                        break;
                    case 'left':
                        cell.walls.left = false;
                        grid[y][x - 1].walls.right = false;
                        break;
                }
            }
        }
    }
}

/**
 * Add dead-end branches for maze-like feel
 */
function addBSPDeadEnds(grid, rooms, size, config) {
    const deadEndCount = Math.floor(rooms.length * 0.5);

    for (let i = 0; i < deadEndCount; i++) {
        const room = rooms[Math.floor(Math.random() * rooms.length)];

        // Pick a random direction from room center
        const directions = [
            { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
            { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
        ];
        const dir = directions[Math.floor(Math.random() * directions.length)];

        // Carve a short dead-end branch
        const length = 2 + Math.floor(Math.random() * 3);
        let x = room.centerX + dir.dx * (Math.floor(room.width / 2) + 1);
        let y = room.centerY + dir.dy * (Math.floor(room.height / 2) + 1);

        for (let step = 0; step < length; step++) {
            if (x >= 0 && x < size && y >= 0 && y < size) {
                const cell = grid[y][x];
                cell.corridorType = 'branch';

                // Remove wall in direction of travel
                if (dir.dx > 0 && x < size - 1) {
                    cell.walls.right = false;
                    grid[y][x + 1].walls.left = false;
                } else if (dir.dx < 0 && x > 0) {
                    cell.walls.left = false;
                    grid[y][x - 1].walls.right = false;
                } else if (dir.dy > 0 && y < size - 1) {
                    cell.walls.bottom = false;
                    grid[y + 1][x].walls.top = false;
                } else if (dir.dy < 0 && y > 0) {
                    cell.walls.top = false;
                    grid[y - 1][x].walls.bottom = false;
                }

                x += dir.dx;
                y += dir.dy;
            }
        }
    }
}

// =============================================================================
// v1.4.0 ZONE SYSTEM
// =============================================================================

/**
 * Generate zones from rooms
 * @param {array} rooms - Array of rooms
 * @param {number} zoneCount - Number of zones to create
 * @param {string} theme - Theme for zone naming
 * @returns {array} Array of zones
 */
function generateZones(rooms, zoneCount, theme) {
    if (zoneCount <= 1 || rooms.length <= 1) {
        // No zones - all rooms unlocked
        rooms.forEach(room => { room.zoneId = 0; });
        return [{
            id: 0,
            name: 'Main Area',
            rooms: rooms.map((_, i) => i),
            isUnlocked: true,
            unlockCondition: null,
            gatePositions: []
        }];
    }

    // Sort rooms by distance from start (0,0)
    const sortedRooms = [...rooms].sort((a, b) => {
        const distA = a.centerX + a.centerY;
        const distB = b.centerX + b.centerY;
        return distA - distB;
    });

    // Divide rooms into zones
    const roomsPerZone = Math.ceil(sortedRooms.length / zoneCount);
    const zones = [];

    for (let z = 0; z < zoneCount; z++) {
        const startIdx = z * roomsPerZone;
        const endIdx = Math.min(startIdx + roomsPerZone, sortedRooms.length);
        const zoneRooms = sortedRooms.slice(startIdx, endIdx);

        zoneRooms.forEach(room => { room.zoneId = z; });

        zones.push({
            id: z,
            name: getZoneName(z, zoneCount, theme),
            rooms: zoneRooms.map(r => r.id),
            isUnlocked: z === 0, // First zone always unlocked
            unlockCondition: z === 0 ? null : {
                type: 'clear',
                targetZoneId: z - 1,
                requiredClears: Math.max(1, Math.floor(zoneRooms.length * 0.6))
            },
            gatePositions: []
        });
    }

    return zones;
}

/**
 * Get a themed name for a zone
 */
function getZoneName(zoneIndex, totalZones, theme) {
    const zoneNames = {
        fantasy: ['Entrance Hall', 'The Depths', 'Ancient Crypt', 'Dragon\'s Domain', 'Throne of Shadows', 'Final Sanctum'],
        scifi: ['Docking Bay', 'Crew Quarters', 'Engineering', 'Research Labs', 'Command Deck', 'Core Systems'],
        horror: ['Foyer', 'Patient Ward', 'Basement', 'Ritual Chamber', 'The Abyss', 'Heart of Darkness'],
        cyberpunk: ['Street Level', 'Lower Floors', 'Corporate Zone', 'Executive Suite', 'Server Core', 'Penthouse'],
        western: ['Town Entrance', 'Main Street', 'Back Alleys', 'Mine Tunnels', 'Hideout', 'Final Showdown'],
        action: ['Insertion Point', 'Outer Perimeter', 'Inner Complex', 'High Security', 'Command Center', 'Extraction Zone'],
        comedy: ['Lobby', 'Open Office', 'Break Room Hell', 'Management Floor', 'IT Dungeon', 'CEO\'s Lair']
    };

    const names = zoneNames[theme] || zoneNames.fantasy;
    return names[Math.min(zoneIndex, names.length - 1)];
}

/**
 * Apply zones to grid cells
 */
function applyZonesToGrid(grid, zones, rooms) {
    // Mark cells with zone IDs based on room assignments
    rooms.forEach(room => {
        for (let y = room.y; y < room.y + room.height; y++) {
            for (let x = room.x; x < room.x + room.width; x++) {
                if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
                    grid[y][x].zoneId = room.zoneId;
                }
            }
        }
    });

    // Mark corridors with zone IDs (use nearest room's zone)
    for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[0].length; x++) {
            const cell = grid[y][x];
            if (cell.corridorType && cell.zoneId === null) {
                // Find nearest room and use its zone
                let nearestRoom = null;
                let nearestDist = Infinity;
                rooms.forEach(room => {
                    const dist = Math.abs(room.centerX - x) + Math.abs(room.centerY - y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestRoom = room;
                    }
                });
                if (nearestRoom) {
                    cell.zoneId = nearestRoom.zoneId;
                }
            }
        }
    }
}

/**
 * v1.4.0: Mark a room as cleared and check zone unlocks
 * Called when player defeats a minion in a room
 * @param {number} x - Player x position
 * @param {number} y - Player y position
 */
async function markRoomCleared(x, y) {
    if (!currentMaze || !currentMaze.floorsData) return;

    const floorData = currentMaze.floorsData[currentMaze.currentFloor];
    if (!floorData || !floorData.rooms) return;

    const cell = currentMaze.grid[y]?.[x];
    if (!cell || cell.roomId === undefined || cell.roomId === null) return;

    // Find the room
    const room = floorData.rooms.find(r => r.id === cell.roomId);
    if (!room || room.isCleared) return;

    // Mark as cleared
    room.isCleared = true;
    console.log(`[MazeMaster] Room ${room.id} (${room.type}) cleared`);

    // Fire room clear hook
    await fireHook('onRoomClear', { roomId: room.id, roomType: room.type, x, y });

    // Check zone unlock conditions
    await checkZoneUnlocks();
}

/**
 * v1.4.0: Check if any zones should be unlocked
 */
async function checkZoneUnlocks() {
    if (!currentMaze || !currentMaze.floorsData) return;

    const floorData = currentMaze.floorsData[currentMaze.currentFloor];
    if (!floorData || !floorData.zones || !floorData.rooms) return;

    for (const zone of floorData.zones) {
        if (zone.isUnlocked) continue;

        const condition = zone.unlockCondition;
        if (!condition) continue;

        let shouldUnlock = false;

        switch (condition.type) {
            case 'clear':
                // Count cleared rooms in the target zone (or previous zone)
                const targetZoneId = condition.targetZoneId ?? (zone.id - 1);
                const targetZoneRooms = floorData.rooms.filter(r => r.zoneId === targetZoneId);
                const clearedCount = targetZoneRooms.filter(r => r.isCleared).length;
                const requiredClears = condition.requiredClears || 1;
                shouldUnlock = clearedCount >= requiredClears;
                break;

            case 'boss':
                // Check if boss room in target zone is cleared
                const bossRoom = floorData.rooms.find(r =>
                    r.zoneId === (condition.targetZoneId ?? (zone.id - 1)) &&
                    (r.type === 'bossLair' || r.type === 'boss-arena')
                );
                shouldUnlock = bossRoom?.isCleared === true;
                break;

            case 'key':
                // Check if player has zone key (future implementation)
                shouldUnlock = false; // TODO: implement zone keys
                break;

            case 'start':
                // Starting zone is always unlocked
                shouldUnlock = true;
                break;
        }

        if (shouldUnlock) {
            zone.isUnlocked = true;
            console.log(`[MazeMaster] Zone ${zone.id} (${zone.name}) unlocked!`);
            addMazeMessage('Zone Unlocked', `${zone.name} is now accessible!`);
            await fireHook('onZoneUnlock', { zoneId: zone.id, zoneName: zone.name });
        }
    }
}

/**
 * v1.4.0: Get current zone progress for HUD display
 * @returns {object} Zone progress info
 */
function getZoneProgress() {
    if (!currentMaze || !currentMaze.floorsData) return null;

    const floorData = currentMaze.floorsData[currentMaze.currentFloor];
    if (!floorData || !floorData.zones) return null;

    // Find current zone based on player position
    const cell = currentMaze.grid[currentMaze.playerY]?.[currentMaze.playerX];
    const currentZoneId = cell?.zoneId ?? 0;
    const currentZone = floorData.zones[currentZoneId];

    if (!currentZone) return null;

    // Count cleared rooms in current zone
    const zoneRooms = floorData.rooms.filter(r => r.zoneId === currentZoneId);
    const clearedRooms = zoneRooms.filter(r => r.isCleared).length;

    // Find next locked zone and its unlock requirement
    const nextLockedZone = floorData.zones.find(z => !z.isUnlocked);
    let unlockHint = null;

    if (nextLockedZone) {
        const condition = nextLockedZone.unlockCondition;
        if (condition?.type === 'clear') {
            const targetZoneRooms = floorData.rooms.filter(r => r.zoneId === (condition.targetZoneId ?? (nextLockedZone.id - 1)));
            const targetCleared = targetZoneRooms.filter(r => r.isCleared).length;
            unlockHint = `Clear ${condition.requiredClears - targetCleared} more room(s) to unlock ${nextLockedZone.name}`;
        }
    }

    return {
        zoneName: currentZone.name,
        zoneId: currentZoneId,
        totalRooms: zoneRooms.length,
        clearedRooms,
        isUnlocked: currentZone.isUnlocked,
        unlockHint
    };
}

// =============================================================================
// v1.4.0 SECRET PASSAGES
// =============================================================================

/**
 * Generate secret passages in the grid
 * @param {array} grid - Map grid
 * @param {number} size - Grid size
 * @param {object} config - Secret passage configuration
 */
function generateSecretPassages(grid, size, config) {
    const density = config.secretDensity || 0.02;
    const secretCount = Math.max(1, Math.floor(size * size * density));

    let placed = 0;
    let attempts = 0;
    const maxAttempts = secretCount * 10;

    while (placed < secretCount && attempts < maxAttempts) {
        attempts++;

        // Pick a random cell
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const cell = grid[y][x];

        // Skip if already has a secret or is special
        if (cell.secretPassage || cell.staircase || cell.portal) continue;

        // Find walls that could become secrets
        const wallDirections = [];
        if (cell.walls.top && y > 0) wallDirections.push('top');
        if (cell.walls.right && x < size - 1) wallDirections.push('right');
        if (cell.walls.bottom && y < size - 1) wallDirections.push('bottom');
        if (cell.walls.left && x > 0) wallDirections.push('left');

        if (wallDirections.length === 0) continue;

        // Pick a random wall direction
        const direction = wallDirections[Math.floor(Math.random() * wallDirections.length)];

        // Get target cell
        let targetX = x, targetY = y;
        if (direction === 'top') targetY--;
        if (direction === 'bottom') targetY++;
        if (direction === 'left') targetX--;
        if (direction === 'right') targetX++;

        const targetCell = grid[targetY]?.[targetX];
        if (!targetCell) continue;

        // Don't create secrets to start or exit areas
        if ((x === 0 && y === 0) || (targetX === 0 && targetY === 0)) continue;
        if ((x === size - 1 && y === size - 1) || (targetX === size - 1 && targetY === size - 1)) continue;

        // Create secret passage
        const hintLevel = config.secretHints ? Math.floor(Math.random() * 4) : 0;

        cell.secretPassage = {
            direction,
            revealed: false,
            hintLevel,
            targetCell: { x: targetX, y: targetY }
        };

        placed++;
    }

    console.log(`[MazeMaster] Placed ${placed} secret passages`);
}

/**
 * Attempt to discover a secret passage
 * @param {object} cell - Cell to check
 * @param {string} direction - Direction to check
 * @param {string} method - Discovery method: 'tap', 'item', 'passive'
 * @param {object} inventory - Player inventory
 * @returns {object} { found, revealed, hint }
 */
function attemptSecretDiscovery(cell, direction, method, inventory) {
    const secret = cell.secretPassage;

    if (!secret || secret.direction !== direction || secret.revealed) {
        return { found: false };
    }

    // Calculate discovery chance
    let chance = 0;
    switch (method) {
        case 'tap':
            chance = 0.1 + (secret.hintLevel * 0.15);
            break;
        case 'item':
            chance = 0.8 + (secret.hintLevel * 0.05);
            break;
        case 'passive':
            chance = secret.hintLevel >= 3 ? 0.5 : 0;
            break;
    }

    // Bonus from Secret Sense item
    if (inventory?.secretSense > 0) {
        chance += 0.2;
    }

    chance = Math.min(chance, 1.0);

    if (Math.random() < chance) {
        return { found: true, revealed: true };
    }

    // Return hint if available
    if (secret.hintLevel > 0 && method === 'tap') {
        return { found: false, hint: true, hintLevel: secret.hintLevel };
    }

    return { found: false };
}

/**
 * Reveal a secret passage
 */
function revealSecretPassage(grid, x, y, direction) {
    const cell = grid[y][x];
    if (!cell.secretPassage || cell.secretPassage.direction !== direction) return false;

    cell.secretPassage.revealed = true;
    cell.walls[direction] = false;

    // Open corresponding wall on target cell
    const target = cell.secretPassage.targetCell;
    const oppositeDir = { top: 'bottom', bottom: 'top', left: 'right', right: 'left' }[direction];
    if (grid[target.y]?.[target.x]) {
        grid[target.y][target.x].walls[oppositeDir] = false;
    }

    return true;
}

/**
 * v1.4.0: Try to discover a secret when bumping into a wall
 * Called from tryMazeMove when player walks into a wall
 */
function trySecretDiscovery(cell, direction) {
    if (!cell.secretPassage || cell.secretPassage.direction !== direction) {
        return { found: false, attempted: false };
    }

    if (cell.secretPassage.revealed) {
        return { found: false, attempted: false };
    }

    // Use the attemptSecretDiscovery function with 'tap' method
    const inventory = currentMaze?.inventory;
    const result = attemptSecretDiscovery(cell, direction, 'tap', inventory);

    if (result.found) {
        return { found: true, attempted: true };
    }

    // Provide hints based on hint level
    let message = 'The wall feels solid...';
    if (result.hint) {
        switch (result.hintLevel) {
            case 1:
                message = 'You notice something unusual about this wall...';
                break;
            case 2:
                message = 'There\'s a faint crack here. Try again?';
                break;
            case 3:
                message = 'This section of wall seems hollow!';
                break;
        }
    }

    return { found: false, attempted: true, message };
}

// =============================================================================
// ORIGINAL MAZE GENERATION (preserved for compatibility)
// =============================================================================

function generateMaze(size) {
    // Create grid of cells with all walls
    const grid = [];
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = {
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false,
                minion: null, // { minionId, triggered }
                trap: null // { trapId, triggered }
            };
        }
    }

    // Recursive backtracking
    const stack = [];
    let current = { x: 0, y: 0 };
    grid[0][0].visited = true;

    function getUnvisitedNeighbors(x, y) {
        const neighbors = [];
        if (y > 0 && !grid[y-1][x].visited) neighbors.push({ x, y: y-1, dir: 'top' });
        if (x < size-1 && !grid[y][x+1].visited) neighbors.push({ x: x+1, y, dir: 'right' });
        if (y < size-1 && !grid[y+1][x].visited) neighbors.push({ x, y: y+1, dir: 'bottom' });
        if (x > 0 && !grid[y][x-1].visited) neighbors.push({ x: x-1, y, dir: 'left' });
        return neighbors;
    }

    while (true) {
        const neighbors = getUnvisitedNeighbors(current.x, current.y);
        if (neighbors.length > 0) {
            const next = neighbors[Math.floor(Math.random() * neighbors.length)];
            stack.push(current);

            // Remove walls between current and next
            if (next.dir === 'top') {
                grid[current.y][current.x].walls.top = false;
                grid[next.y][next.x].walls.bottom = false;
            } else if (next.dir === 'right') {
                grid[current.y][current.x].walls.right = false;
                grid[next.y][next.x].walls.left = false;
            } else if (next.dir === 'bottom') {
                grid[current.y][current.x].walls.bottom = false;
                grid[next.y][next.x].walls.top = false;
            } else if (next.dir === 'left') {
                grid[current.y][current.x].walls.left = false;
                grid[next.y][next.x].walls.right = false;
            }

            current = { x: next.x, y: next.y };
            grid[current.y][current.x].visited = true;
        } else if (stack.length > 0) {
            current = stack.pop();
        } else {
            break;
        }
    }

    // Add extra passages for multiple pathways and dead ends
    addExtraPassages(grid, size);

    // Reset visited flags for gameplay
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            grid[y][x].visited = false;
        }
    }

    return grid;
}

// =============================================================================
// v1.2.0 MAP STYLE GENERATION ALGORITHMS
// =============================================================================

/**
 * Generate a city-style grid with streets between building blocks
 */
function generateCityGrid(size) {
    const grid = [];

    // Initialize all cells with walls
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = {
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false,
                minion: null,
                trap: null
            };
        }
    }

    // Create main street grid (every 3-4 cells)
    const streetSpacing = Math.max(3, Math.floor(size / 4));

    // Create horizontal streets
    for (let y = 0; y < size; y++) {
        if (y % streetSpacing === 1 || y === 0 || y === size - 1) {
            for (let x = 0; x < size - 1; x++) {
                grid[y][x].walls.right = false;
                grid[y][x + 1].walls.left = false;
            }
        }
    }

    // Create vertical streets
    for (let x = 0; x < size; x++) {
        if (x % streetSpacing === 1 || x === 0 || x === size - 1) {
            for (let y = 0; y < size - 1; y++) {
                grid[y][x].walls.bottom = false;
                grid[y + 1][x].walls.top = false;
            }
        }
    }

    // Add random alleys within blocks (20% chance per potential alley)
    for (let y = 0; y < size - 1; y++) {
        for (let x = 0; x < size - 1; x++) {
            if (Math.random() < 0.2) {
                const dir = Math.random() < 0.5 ? 'right' : 'bottom';
                if (dir === 'right') {
                    grid[y][x].walls.right = false;
                    grid[y][x + 1].walls.left = false;
                } else {
                    grid[y][x].walls.bottom = false;
                    grid[y + 1][x].walls.top = false;
                }
            }
        }
    }

    // Ensure start and exit are connected
    ensureConnected(grid, size, 0, 0, size - 1, size - 1);

    return grid;
}

/**
 * Generate a forest-style grid with organic winding paths
 */
function generateForestGrid(size) {
    const grid = [];

    // Initialize all cells with walls
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = {
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false,
                minion: null,
                trap: null
            };
        }
    }

    // Create main winding path from start to exit using weighted random walk
    let x = 0, y = 0;
    const visited = new Set(['0,0']);
    const path = [{ x: 0, y: 0 }];
    grid[0][0].visited = true;

    while (x !== size - 1 || y !== size - 1) {
        // Weight movement toward exit
        const directions = [];
        if (y > 0) directions.push({ dx: 0, dy: -1, weight: 0.1 });  // up (away from exit)
        if (x < size - 1) directions.push({ dx: 1, dy: 0, weight: 0.4 }); // right (toward exit)
        if (y < size - 1) directions.push({ dx: 0, dy: 1, weight: 0.4 }); // down (toward exit)
        if (x > 0) directions.push({ dx: -1, dy: 0, weight: 0.1 }); // left (away from exit)

        // Filter unvisited cells with walls
        const validDirs = directions.filter(d => {
            const nx = x + d.dx;
            const ny = y + d.dy;
            return nx >= 0 && nx < size && ny >= 0 && ny < size;
        });

        if (validDirs.length === 0) break;

        // Weighted random selection
        const totalWeight = validDirs.reduce((sum, d) => sum + d.weight, 0);
        let rand = Math.random() * totalWeight;
        let chosen = validDirs[0];
        for (const dir of validDirs) {
            rand -= dir.weight;
            if (rand <= 0) { chosen = dir; break; }
        }

        const nx = x + chosen.dx;
        const ny = y + chosen.dy;

        // Remove wall between cells
        if (chosen.dx === 1) { grid[y][x].walls.right = false; grid[ny][nx].walls.left = false; }
        if (chosen.dx === -1) { grid[y][x].walls.left = false; grid[ny][nx].walls.right = false; }
        if (chosen.dy === 1) { grid[y][x].walls.bottom = false; grid[ny][nx].walls.top = false; }
        if (chosen.dy === -1) { grid[y][x].walls.top = false; grid[ny][nx].walls.bottom = false; }

        x = nx;
        y = ny;
        visited.add(`${x},${y}`);
        path.push({ x, y });
        grid[y][x].visited = true;
    }

    // Add branch paths from main path to create exploration areas
    const branchCount = Math.floor(size * 0.8);
    for (let i = 0; i < branchCount; i++) {
        const start = path[Math.floor(Math.random() * path.length)];
        createBranchPath(grid, size, start.x, start.y, Math.floor(size / 2));
    }

    // Add clearings (open 2x2 areas)
    const clearingCount = Math.floor(size / 5);
    for (let i = 0; i < clearingCount; i++) {
        const cx = 1 + Math.floor(Math.random() * (size - 2));
        const cy = 1 + Math.floor(Math.random() * (size - 2));
        createClearing(grid, cx, cy);
    }

    // Reset visited flags
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            grid[y][x].visited = false;
        }
    }

    ensureConnected(grid, size, 0, 0, size - 1, size - 1);
    return grid;
}

/**
 * Generate a spaceship-style grid with room pods connected by corridors
 */
function generateSpaceshipGrid(size) {
    const grid = [];

    // Initialize all cells with walls
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = {
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false,
                minion: null,
                trap: null
            };
        }
    }

    // Generate room pods (2x2 or 3x3 open areas)
    const rooms = [];
    const roomCount = Math.max(4, Math.floor((size * size) / 20));

    for (let i = 0; i < roomCount * 3; i++) { // Try multiple times to place rooms
        if (rooms.length >= roomCount) break;

        const roomSize = Math.random() < 0.5 ? 2 : 3;
        const rx = Math.floor(Math.random() * (size - roomSize));
        const ry = Math.floor(Math.random() * (size - roomSize));

        // Check for overlap with existing rooms
        let overlaps = false;
        for (const room of rooms) {
            if (rx < room.x + room.size + 1 && rx + roomSize + 1 > room.x &&
                ry < room.y + room.size + 1 && ry + roomSize + 1 > room.y) {
                overlaps = true;
                break;
            }
        }

        if (!overlaps) {
            rooms.push({ x: rx, y: ry, size: roomSize });
            // Open the room
            for (let dy = 0; dy < roomSize; dy++) {
                for (let dx = 0; dx < roomSize; dx++) {
                    if (dx < roomSize - 1) {
                        grid[ry + dy][rx + dx].walls.right = false;
                        grid[ry + dy][rx + dx + 1].walls.left = false;
                    }
                    if (dy < roomSize - 1) {
                        grid[ry + dy][rx + dx].walls.bottom = false;
                        grid[ry + dy + 1][rx + dx].walls.top = false;
                    }
                }
            }
        }
    }

    // Ensure start and exit rooms exist
    if (!rooms.some(r => r.x === 0 && r.y === 0)) {
        rooms.unshift({ x: 0, y: 0, size: 2 });
        grid[0][0].walls.right = false; grid[0][1].walls.left = false;
        grid[1][0].walls.right = false; grid[1][1].walls.left = false;
        grid[0][0].walls.bottom = false; grid[1][0].walls.top = false;
        grid[0][1].walls.bottom = false; grid[1][1].walls.top = false;
    }

    // Connect rooms with corridors
    for (let i = 0; i < rooms.length - 1; i++) {
        const r1 = rooms[i];
        const r2 = rooms[i + 1];
        connectRoomsWithCorridor(grid, size, r1, r2);
    }

    // Connect last room to first to ensure full connectivity
    if (rooms.length > 2) {
        connectRoomsWithCorridor(grid, size, rooms[rooms.length - 1], rooms[0]);
    }

    ensureConnected(grid, size, 0, 0, size - 1, size - 1);
    return grid;
}

/**
 * Generate a dungeon-style grid with BSP-like chambers and hallways
 */
function generateDungeonGrid(size) {
    const grid = [];

    // Initialize all cells with walls
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = {
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false,
                minion: null,
                trap: null
            };
        }
    }

    // Create rectangular chambers
    const chambers = [];
    const minChamberSize = 2;
    const maxChamberSize = Math.max(3, Math.floor(size / 3));

    // Place chambers
    for (let attempts = 0; attempts < size * 2; attempts++) {
        const w = minChamberSize + Math.floor(Math.random() * (maxChamberSize - minChamberSize + 1));
        const h = minChamberSize + Math.floor(Math.random() * (maxChamberSize - minChamberSize + 1));
        const x = Math.floor(Math.random() * (size - w));
        const y = Math.floor(Math.random() * (size - h));

        // Check overlap
        let valid = true;
        for (const c of chambers) {
            if (x < c.x + c.w + 1 && x + w + 1 > c.x &&
                y < c.y + c.h + 1 && y + h + 1 > c.y) {
                valid = false;
                break;
            }
        }

        if (valid) {
            chambers.push({ x, y, w, h });
            // Carve out chamber
            for (let cy = y; cy < y + h; cy++) {
                for (let cx = x; cx < x + w; cx++) {
                    if (cx < x + w - 1) {
                        grid[cy][cx].walls.right = false;
                        grid[cy][cx + 1].walls.left = false;
                    }
                    if (cy < y + h - 1) {
                        grid[cy][cx].walls.bottom = false;
                        grid[cy + 1][cx].walls.top = false;
                    }
                }
            }
        }
    }

    // Ensure start chamber exists
    if (!chambers.some(c => c.x <= 1 && c.y <= 1)) {
        chambers.unshift({ x: 0, y: 0, w: 2, h: 2 });
        grid[0][0].walls.right = false; grid[0][1].walls.left = false;
        grid[1][0].walls.right = false; grid[1][1].walls.left = false;
        grid[0][0].walls.bottom = false; grid[1][0].walls.top = false;
    }

    // Connect chambers with hallways
    for (let i = 0; i < chambers.length - 1; i++) {
        const c1 = chambers[i];
        const c2 = chambers[i + 1];
        connectChambersWithHallway(grid, size, c1, c2);
    }

    // Connect first and last chambers
    if (chambers.length > 2) {
        connectChambersWithHallway(grid, size, chambers[chambers.length - 1], chambers[0]);
    }

    ensureConnected(grid, size, 0, 0, size - 1, size - 1);
    return grid;
}

/**
 * Generate grid based on map style
 * v1.4.0: Now uses BSP generation for all styles
 * @param {number} size - Grid size
 * @param {string} mapStyle - Map style name
 * @param {string} theme - Theme for room typing (default: 'fantasy')
 * @param {object} bspConfig - Optional BSP configuration overrides
 * @returns {object} { grid, rooms } - Grid and room data
 */
function generateGridByStyle(size, mapStyle, theme = 'fantasy', bspConfig = {}) {
    // v1.4.0: Use BSP generation for all styles
    console.log(`[MazeMaster] Generating BSP grid: size=${size}, style=${mapStyle}, theme=${theme}`);

    const result = generateBSPGrid(size, mapStyle, theme, bspConfig);

    // Log generation stats
    console.log(`[MazeMaster] Generated ${result.rooms.length} rooms`);

    return result;
}

/**
 * Legacy wrapper for backward compatibility
 * Returns just the grid (used by old code paths)
 */
function generateGridByStyleLegacy(size, mapStyle) {
    switch (mapStyle) {
        case 'city':
        case 'neotokyo':
            return generateCityGrid(size);
        case 'forest':
            return generateForestGrid(size);
        case 'spaceship':
        case 'spacestation':
            return generateSpaceshipGrid(size);
        case 'dungeon':
            return generateDungeonGrid(size);
        case 'outpost':
        case 'arena':
            return generateDungeonGrid(size);
        case 'college':
        case 'apartment':
        case 'hospital':
        case 'highrise':
            return generateCityGrid(size);
        case 'maze':
        default:
            return generateMaze(size);
    }
}

// Helper functions for map generation

function createBranchPath(grid, size, startX, startY, maxLength) {
    let x = startX, y = startY;
    for (let i = 0; i < maxLength; i++) {
        const dirs = [];
        if (y > 0) dirs.push({ dx: 0, dy: -1 });
        if (x < size - 1) dirs.push({ dx: 1, dy: 0 });
        if (y < size - 1) dirs.push({ dx: 0, dy: 1 });
        if (x > 0) dirs.push({ dx: -1, dy: 0 });

        if (dirs.length === 0) break;

        const chosen = dirs[Math.floor(Math.random() * dirs.length)];
        const nx = x + chosen.dx;
        const ny = y + chosen.dy;

        // Remove wall
        if (chosen.dx === 1) { grid[y][x].walls.right = false; grid[ny][nx].walls.left = false; }
        if (chosen.dx === -1) { grid[y][x].walls.left = false; grid[ny][nx].walls.right = false; }
        if (chosen.dy === 1) { grid[y][x].walls.bottom = false; grid[ny][nx].walls.top = false; }
        if (chosen.dy === -1) { grid[y][x].walls.top = false; grid[ny][nx].walls.bottom = false; }

        x = nx;
        y = ny;
    }
}

function createClearing(grid, cx, cy) {
    // Open a 2x2 area
    if (cx > 0 && cy > 0 && cx < grid[0].length - 1 && cy < grid.length - 1) {
        grid[cy][cx].walls.right = false; grid[cy][cx + 1].walls.left = false;
        grid[cy + 1][cx].walls.right = false; grid[cy + 1][cx + 1].walls.left = false;
        grid[cy][cx].walls.bottom = false; grid[cy + 1][cx].walls.top = false;
        grid[cy][cx + 1].walls.bottom = false; grid[cy + 1][cx + 1].walls.top = false;
    }
}

function connectRoomsWithCorridor(grid, size, r1, r2) {
    // Find center points of rooms
    const x1 = Math.floor(r1.x + r1.size / 2);
    const y1 = Math.floor(r1.y + r1.size / 2);
    const x2 = Math.floor(r2.x + r2.size / 2);
    const y2 = Math.floor(r2.y + r2.size / 2);

    // L-shaped corridor
    let x = x1, y = y1;

    // Move horizontally first
    while (x !== x2) {
        const nx = x < x2 ? x + 1 : x - 1;
        if (nx >= 0 && nx < size) {
            if (x < x2) { grid[y][x].walls.right = false; grid[y][nx].walls.left = false; }
            else { grid[y][x].walls.left = false; grid[y][nx].walls.right = false; }
            x = nx;
        } else break;
    }

    // Then vertically
    while (y !== y2) {
        const ny = y < y2 ? y + 1 : y - 1;
        if (ny >= 0 && ny < size) {
            if (y < y2) { grid[y][x].walls.bottom = false; grid[ny][x].walls.top = false; }
            else { grid[y][x].walls.top = false; grid[ny][x].walls.bottom = false; }
            y = ny;
        } else break;
    }
}

function connectChambersWithHallway(grid, size, c1, c2) {
    // Find edge midpoints
    const x1 = Math.floor(c1.x + c1.w / 2);
    const y1 = Math.floor(c1.y + c1.h / 2);
    const x2 = Math.floor(c2.x + c2.w / 2);
    const y2 = Math.floor(c2.y + c2.h / 2);

    // L-shaped hallway
    let x = x1, y = y1;

    // Horizontal then vertical (or vice versa randomly)
    const horizontalFirst = Math.random() < 0.5;

    if (horizontalFirst) {
        while (x !== x2) {
            const nx = x < x2 ? x + 1 : x - 1;
            if (nx >= 0 && nx < size) {
                if (x < x2) { grid[y][x].walls.right = false; grid[y][nx].walls.left = false; }
                else { grid[y][x].walls.left = false; grid[y][nx].walls.right = false; }
                x = nx;
            } else break;
        }
        while (y !== y2) {
            const ny = y < y2 ? y + 1 : y - 1;
            if (ny >= 0 && ny < size) {
                if (y < y2) { grid[y][x].walls.bottom = false; grid[ny][x].walls.top = false; }
                else { grid[y][x].walls.top = false; grid[ny][x].walls.bottom = false; }
                y = ny;
            } else break;
        }
    } else {
        while (y !== y2) {
            const ny = y < y2 ? y + 1 : y - 1;
            if (ny >= 0 && ny < size) {
                if (y < y2) { grid[y][x].walls.bottom = false; grid[ny][x].walls.top = false; }
                else { grid[y][x].walls.top = false; grid[ny][x].walls.bottom = false; }
                y = ny;
            } else break;
        }
        while (x !== x2) {
            const nx = x < x2 ? x + 1 : x - 1;
            if (nx >= 0 && nx < size) {
                if (x < x2) { grid[y][x].walls.right = false; grid[y][nx].walls.left = false; }
                else { grid[y][x].walls.left = false; grid[y][nx].walls.right = false; }
                x = nx;
            } else break;
        }
    }
}

function ensureConnected(grid, size, startX, startY, endX, endY) {
    // Use BFS to check if end is reachable from start
    const visited = new Set([`${startX},${startY}`]);
    const queue = [{ x: startX, y: startY }];

    while (queue.length > 0) {
        const { x, y } = queue.shift();
        if (x === endX && y === endY) return; // Already connected

        // Check each direction
        if (!grid[y][x].walls.top && y > 0 && !visited.has(`${x},${y - 1}`)) {
            visited.add(`${x},${y - 1}`);
            queue.push({ x, y: y - 1 });
        }
        if (!grid[y][x].walls.right && x < size - 1 && !visited.has(`${x + 1},${y}`)) {
            visited.add(`${x + 1},${y}`);
            queue.push({ x: x + 1, y });
        }
        if (!grid[y][x].walls.bottom && y < size - 1 && !visited.has(`${x},${y + 1}`)) {
            visited.add(`${x},${y + 1}`);
            queue.push({ x, y: y + 1 });
        }
        if (!grid[y][x].walls.left && x > 0 && !visited.has(`${x - 1},${y}`)) {
            visited.add(`${x - 1},${y}`);
            queue.push({ x: x - 1, y });
        }
    }

    // Not connected - carve a winding path with multiple turns
    // Create 2-4 waypoints for a more interesting route
    const waypoints = [];
    const numWaypoints = 2 + Math.floor(Math.random() * 3);

    for (let i = 1; i <= numWaypoints; i++) {
        const t = i / (numWaypoints + 1);
        // Add randomness to waypoint positions
        const baseX = startX + Math.floor((endX - startX) * t);
        const baseY = startY + Math.floor((endY - startY) * t);
        const offsetX = Math.floor((Math.random() - 0.5) * size * 0.4);
        const offsetY = Math.floor((Math.random() - 0.5) * size * 0.4);
        waypoints.push({
            x: Math.max(0, Math.min(size - 1, baseX + offsetX)),
            y: Math.max(0, Math.min(size - 1, baseY + offsetY))
        });
    }

    // Carve path through waypoints
    let x = startX, y = startY;
    const allPoints = [...waypoints, { x: endX, y: endY }];

    for (const target of allPoints) {
        // Randomly choose horizontal-first or vertical-first for each segment
        const horizontalFirst = Math.random() < 0.5;

        if (horizontalFirst) {
            // Move horizontally first
            while (x !== target.x) {
                const nx = x < target.x ? x + 1 : x - 1;
                if (nx >= 0 && nx < size) {
                    if (x < target.x) { grid[y][x].walls.right = false; grid[y][nx].walls.left = false; }
                    else { grid[y][x].walls.left = false; grid[y][nx].walls.right = false; }
                    x = nx;
                } else break;
            }
            // Then vertically
            while (y !== target.y) {
                const ny = y < target.y ? y + 1 : y - 1;
                if (ny >= 0 && ny < size) {
                    if (y < target.y) { grid[y][x].walls.bottom = false; grid[ny][x].walls.top = false; }
                    else { grid[y][x].walls.top = false; grid[ny][x].walls.bottom = false; }
                    y = ny;
                } else break;
            }
        } else {
            // Move vertically first
            while (y !== target.y) {
                const ny = y < target.y ? y + 1 : y - 1;
                if (ny >= 0 && ny < size) {
                    if (y < target.y) { grid[y][x].walls.bottom = false; grid[ny][x].walls.top = false; }
                    else { grid[y][x].walls.top = false; grid[ny][x].walls.bottom = false; }
                    y = ny;
                } else break;
            }
            // Then horizontally
            while (x !== target.x) {
                const nx = x < target.x ? x + 1 : x - 1;
                if (nx >= 0 && nx < size) {
                    if (x < target.x) { grid[y][x].walls.right = false; grid[y][nx].walls.left = false; }
                    else { grid[y][x].walls.left = false; grid[y][nx].walls.right = false; }
                    x = nx;
                } else break;
            }
        }
    }
}

/**
 * Add staircases connecting multiple floors
 */
/**
 * Check if a cell is reachable from a start point using BFS
 */
function isCellReachable(grid, size, startX, startY, targetX, targetY) {
    if (startX === targetX && startY === targetY) return true;

    const visited = new Set([`${startX},${startY}`]);
    const queue = [{ x: startX, y: startY }];

    while (queue.length > 0) {
        const { x, y } = queue.shift();
        if (x === targetX && y === targetY) return true;

        if (!grid[y][x].walls.top && y > 0 && !visited.has(`${x},${y - 1}`)) {
            visited.add(`${x},${y - 1}`);
            queue.push({ x, y: y - 1 });
        }
        if (!grid[y][x].walls.right && x < size - 1 && !visited.has(`${x + 1},${y}`)) {
            visited.add(`${x + 1},${y}`);
            queue.push({ x: x + 1, y });
        }
        if (!grid[y][x].walls.bottom && y < size - 1 && !visited.has(`${x},${y + 1}`)) {
            visited.add(`${x},${y + 1}`);
            queue.push({ x, y: y + 1 });
        }
        if (!grid[y][x].walls.left && x > 0 && !visited.has(`${x - 1},${y}`)) {
            visited.add(`${x - 1},${y}`);
            queue.push({ x: x - 1, y });
        }
    }
    return false;
}

/**
 * Check if a cell has at least one open wall (is accessible)
 */
function hasOpenWall(cell) {
    return !cell.walls.top || !cell.walls.right || !cell.walls.bottom || !cell.walls.left;
}

function addStaircasesToFloors(floors, size, requireFloorKey, exitX, exitY) {
    const totalFloors = floors.length;

    for (let f = 0; f < totalFloors - 1; f++) {
        const lowerFloor = floors[f];
        const upperFloor = floors[f + 1];

        // Find suitable positions for stairs - must be reachable and have open walls
        const validPositions = [];
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                // Skip start (0,0) and exit position
                if ((x === 0 && y === 0) || (x === exitX && y === exitY)) continue;
                // Skip cells with existing features
                const lowerCell = lowerFloor[y][x];
                const upperCell = upperFloor[y][x];
                if (lowerCell.minion || lowerCell.trap || lowerCell.chest) continue;
                if (upperCell.minion || upperCell.trap || upperCell.chest) continue;
                // Must have at least one open wall on both floors
                if (!hasOpenWall(lowerCell) || !hasOpenWall(upperCell)) continue;
                // Must be reachable from start on lower floor
                if (!isCellReachable(lowerFloor, size, 0, 0, x, y)) continue;
                validPositions.push({ x, y });
            }
        }

        if (validPositions.length < 1) {
            console.warn(`[MazeMaster] No valid staircase positions found for floor ${f} -> ${f + 1}`);
            continue;
        }

        // Pick 1-2 staircase locations per floor connection
        const staircaseCount = Math.min(2, Math.max(1, Math.floor(size / 5)));

        for (let s = 0; s < staircaseCount && validPositions.length > 0; s++) {
            const idx = Math.floor(Math.random() * validPositions.length);
            const pos = validPositions.splice(idx, 1)[0];

            // Add ascending staircase on lower floor
            lowerFloor[pos.y][pos.x].staircase = {
                direction: 'up',
                targetFloor: f + 1,
                targetX: pos.x,
                targetY: pos.y,
                requireKey: requireFloorKey,
            };

            // Add descending staircase on upper floor (same position)
            upperFloor[pos.y][pos.x].staircase = {
                direction: 'down',
                targetFloor: f,
                targetX: pos.x,
                targetY: pos.y,
                requireKey: false, // Going down doesn't require key
            };

            // Ensure the staircase position on upper floor is connected to that floor's exit
            ensureConnected(upperFloor, size, pos.x, pos.y, exitX, exitY);
            console.log(`[MazeMaster] Staircase placed at (${pos.x}, ${pos.y}) connecting floor ${f} to ${f + 1}`);
        }
    }
}

/**
 * Guarantee floor keys are available on floors that need them
 * For each floor with an ascending staircase that requires a key,
 * ensure at least one chest on that floor will drop a floor key.
 * Returns the number of keys that couldn't be placed in chests (to add to starting inventory)
 * @param {Array} floors - Array of floor grids
 * @param {number} size - Grid size
 * @returns {number} Number of floor keys to add to starting inventory
 */
function guaranteeFloorKeys(floors, size) {
    let keysNeededInInventory = 0;

    for (let f = 0; f < floors.length; f++) {
        const floor = floors[f];

        // Check if this floor has an ascending staircase that requires a key
        let needsKey = false;
        for (let y = 0; y < size && !needsKey; y++) {
            for (let x = 0; x < size && !needsKey; x++) {
                const cell = floor[y][x];
                if (cell.staircase?.direction === 'up' && cell.staircase?.requireKey) {
                    needsKey = true;
                }
            }
        }

        if (!needsKey) continue;

        // Find chests on this floor to guarantee a floor key
        const chestsOnFloor = [];
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const cell = floor[y][x];
                if (cell.chest && !cell.chest.guaranteedFloorKey) {
                    chestsOnFloor.push({ x, y, cell });
                }
            }
        }

        if (chestsOnFloor.length > 0) {
            // Pick a random chest to guarantee the floor key
            const chosenIdx = Math.floor(Math.random() * chestsOnFloor.length);
            const chosen = chestsOnFloor[chosenIdx];
            chosen.cell.chest.guaranteedFloorKey = true;
            console.log(`[MazeMaster] Floor ${f}: Guaranteed floor key in chest at (${chosen.x}, ${chosen.y})`);
        } else {
            // No chest available - need to add to starting inventory
            keysNeededInInventory++;
            console.log(`[MazeMaster] Floor ${f}: No chest found - adding floor key to starting inventory`);
        }
    }

    return keysNeededInInventory;
}

/**
 * Enforce wall consistency - ensure both sides of each wall match
 * If cell A has no right wall, cell B (to the right) should have no left wall
 * This fixes rendering/movement mismatches caused by asymmetric wall data
 */
function enforceWallConsistency(grid, size) {
    let fixes = 0;
    console.log('[MazeMaster] Running wall consistency check...');

    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const cell = grid[y][x];

            // Check right neighbor - walls must be symmetric
            if (x < size - 1) {
                const rightCell = grid[y][x + 1];
                const rightWallMismatch = cell.walls.right !== rightCell.walls.left;
                if (rightWallMismatch) {
                    console.log(`[MazeMaster] Wall mismatch at (${x},${y}) right: ${cell.walls.right} vs (${x+1},${y}) left: ${rightCell.walls.left}`);
                    // If either says open, make both open
                    if (!cell.walls.right || !rightCell.walls.left) {
                        cell.walls.right = false;
                        rightCell.walls.left = false;
                    } else {
                        // Both say closed but somehow different? Keep closed
                        cell.walls.right = true;
                        rightCell.walls.left = true;
                    }
                    fixes++;
                }
            }

            // Check bottom neighbor - walls must be symmetric
            if (y < size - 1) {
                const bottomCell = grid[y + 1][x];
                const bottomWallMismatch = cell.walls.bottom !== bottomCell.walls.top;
                if (bottomWallMismatch) {
                    console.log(`[MazeMaster] Wall mismatch at (${x},${y}) bottom: ${cell.walls.bottom} vs (${x},${y+1}) top: ${bottomCell.walls.top}`);
                    // If either says open, make both open
                    if (!cell.walls.bottom || !bottomCell.walls.top) {
                        cell.walls.bottom = false;
                        bottomCell.walls.top = false;
                    } else {
                        cell.walls.bottom = true;
                        bottomCell.walls.top = true;
                    }
                    fixes++;
                }
            }
        }
    }
    console.log(`[MazeMaster] Wall consistency check complete. Fixed ${fixes} mismatch(es)`);
}

/**
 * Add extra passages to create alternate pathways (sparingly to keep maze challenging)
 */
function addExtraPassages(grid, size) {
    // Calculate how many extra passages based on grid size (~3% of cells)
    // Lower = more challenging maze, higher = more alternate routes
    const extraCount = Math.floor(size * size * 0.03);

    for (let i = 0; i < extraCount; i++) {
        // Pick random cell (not on edge to avoid border issues)
        const x = 1 + Math.floor(Math.random() * (size - 2));
        const y = 1 + Math.floor(Math.random() * (size - 2));

        // Pick random direction
        const directions = ['top', 'right', 'bottom', 'left'];
        const dir = directions[Math.floor(Math.random() * 4)];

        // Remove wall if it exists (creates alternate path)
        removeWallBetweenCells(grid, x, y, dir, size);
    }
}

/**
 * Remove wall between a cell and its neighbor in a given direction
 */
function removeWallBetweenCells(grid, x, y, dir, size) {
    const cell = grid[y][x];
    if (dir === 'top' && y > 0) {
        cell.walls.top = false;
        grid[y-1][x].walls.bottom = false;
    } else if (dir === 'right' && x < size - 1) {
        cell.walls.right = false;
        grid[y][x+1].walls.left = false;
    } else if (dir === 'bottom' && y < size - 1) {
        cell.walls.bottom = false;
        grid[y+1][x].walls.top = false;
    } else if (dir === 'left' && x > 0) {
        cell.walls.left = false;
        grid[y][x-1].walls.right = false;
    }
}

/**
 * Normalize tile distribution from percentages to counts
 * Applies difficulty scaling multipliers
 */
function normalizeTileDistribution(profile, totalValidCells) {
    const result = {
        minionPlacements: [],
        trapPlacements: [],
        chestCount: 0,
    };

    // Get difficulty settings for scaling
    const difficulty = getDifficultySettings(profile);
    const encounterMult = difficulty.encounterDensityMult || 1.0;
    const trapMult = difficulty.trapFrequencyMult || 1.0;

    // Calculate raw percentages
    const chestPercent = profile.chestTilePercent || 0;
    const minionEncounters = profile.minionEncounters || [];
    const trapEncounters = profile.trapEncounters || [];

    // Apply difficulty multipliers to percentages
    let totalMinionPercent = minionEncounters.reduce((sum, e) => sum + ((e.percent || 0) * encounterMult), 0);
    let totalTrapPercent = trapEncounters.reduce((sum, e) => sum + ((e.percent || 0) * trapMult), 0);

    // Calculate total allocation
    const totalPercent = chestPercent + totalMinionPercent + totalTrapPercent;

    // Scale down proportionally if over 100%
    let scale = 1;
    if (totalPercent > 100) {
        scale = 100 / totalPercent;
        console.log(`[MazeMaster] Distribution over 100% (${totalPercent}%), scaling down by ${scale.toFixed(2)}`);
    }

    // Calculate chest count
    result.chestCount = Math.floor(totalValidCells * (chestPercent * scale) / 100);

    // Convert minion percentages to counts (with difficulty scaling)
    // Use Math.round to ensure small percentages still produce encounters
    for (const encounter of minionEncounters) {
        const scaledPercent = (encounter.percent || 0) * encounterMult * scale;
        const count = Math.round(totalValidCells * scaledPercent / 100);
        if (count > 0) {
            result.minionPlacements.push({ minionId: encounter.minionId, count });
        }
    }

    // Convert trap percentages to counts (with difficulty scaling)
    for (const encounter of trapEncounters) {
        const scaledPercent = (encounter.percent || 0) * trapMult * scale;
        const count = Math.round(totalValidCells * scaledPercent / 100);
        if (count > 0) {
            result.trapPlacements.push({ trapId: encounter.trapId, count });
        }
    }

    return result;
}

/**
 * Determine chest type based on profile settings
 */
function determineChestType(profile) {
    const roll = Math.random() * 100;
    if (roll < (profile.chestMimicPercent || 0)) return 'mimic';
    if (roll < (profile.chestMimicPercent || 0) + (profile.chestLockedPercent || 0)) return 'locked';
    return 'normal';
}

/**
 * Place tiles (chests and minions) on the maze based on profile configuration
 */
function placeTiles(grid, profile, size) {
    // Collect all valid cells (not start, not exit)
    const validCells = [];
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            if ((x === 0 && y === 0) || (x === size-1 && y === size-1)) continue;
            validCells.push({ x, y });
        }
    }

    // Shuffle valid cells
    shuffleArray(validCells);

    const distribution = normalizeTileDistribution(profile, validCells.length);
    let cellIndex = 0;

    // Place chests first
    for (let i = 0; i < distribution.chestCount && cellIndex < validCells.length; i++) {
        const cell = validCells[cellIndex++];
        const chestType = determineChestType(profile);
        grid[cell.y][cell.x].chest = { type: chestType, opened: false };
    }

    // Place minions
    const minionStartIndex = cellIndex;
    for (const placement of distribution.minionPlacements) {
        for (let i = 0; i < placement.count && cellIndex < validCells.length; i++) {
            const cell = validCells[cellIndex++];
            grid[cell.y][cell.x].minion = { minionId: placement.minionId, triggered: false };
        }
    }
    const minionCount = cellIndex - minionStartIndex;

    // Place traps
    const trapStartIndex = cellIndex;
    for (const placement of distribution.trapPlacements) {
        for (let i = 0; i < placement.count && cellIndex < validCells.length; i++) {
            const cell = validCells[cellIndex++];
            grid[cell.y][cell.x].trap = { trapId: placement.trapId, triggered: false };
        }
    }
    const trapCount = cellIndex - trapStartIndex;

    // Place portals (use remaining valid cells for random placement)
    const remainingCells = validCells.slice(cellIndex);
    const placedPortals = placePortals(grid, profile, size, remainingCells);

    // Place safe rooms on empty cells (HP system feature)
    const safeRoomCount = profile.safeRoomCount ?? 3;
    if (safeRoomCount > 0) {
        // Find truly empty cells (no chest, minion, trap, portal, staircase)
        const emptyCells = [];
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                if ((x === 0 && y === 0) || (x === size-1 && y === size-1)) continue;
                const cell = grid[y][x];
                if (!cell.chest && !cell.minion && !cell.trap && !cell.portal && !cell.staircase) {
                    emptyCells.push({ x, y });
                }
            }
        }
        shuffleArray(emptyCells);

        const actualCount = Math.min(safeRoomCount, emptyCells.length);
        for (let i = 0; i < actualCount; i++) {
            const cellPos = emptyCells[i];
            grid[cellPos.y][cellPos.x].safeRoom = { exhausted: false };
        }
        console.log(`[MazeMaster] Placed ${actualCount} safe rooms`);
    }

    console.log(`[MazeMaster] Placed ${distribution.chestCount} chests, ${minionCount} minions, ${trapCount} traps`);

    // v1.3.2: Apply "Find Early" guaranteed items to nearby chests
    applyFindEarlyItems(grid, profile, size);

    return { placedPortals: placedPortals || [] };
}

/**
 * Apply "Find Early" guaranteed items to chests near the starting position
 * @param {Array} grid - The maze grid
 * @param {Object} profile - Maze profile with findEarly config
 * @param {number} size - Grid size
 */
function applyFindEarlyItems(grid, profile, size) {
    const findEarly = profile.findEarly;
    if (!findEarly || !findEarly.items || findEarly.items.length === 0) return;

    const radius = findEarly.radius || 4;  // Manhattan distance from start (0,0)
    const items = [...findEarly.items];     // Copy to avoid mutation

    // Find all chests within radius of start (0,0)
    const nearbyChests = [];
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const manhattanDist = x + y;  // Distance from (0,0)
            if (manhattanDist <= radius && manhattanDist > 0) {
                const cell = grid[y][x];
                if (cell.chest && !cell.chest.opened) {
                    nearbyChests.push({ x, y, dist: manhattanDist });
                }
            }
        }
    }

    // Sort by distance (closest first)
    nearbyChests.sort((a, b) => a.dist - b.dist);

    // Distribute guaranteed items across nearby chests
    let itemIndex = 0;
    for (const chestPos of nearbyChests) {
        if (itemIndex >= items.length) break;

        const chest = grid[chestPos.y][chestPos.x].chest;
        if (!chest.guaranteedItems) chest.guaranteedItems = [];

        // Add 1-2 items per chest depending on config
        const itemsPerChest = findEarly.itemsPerChest || 1;
        for (let i = 0; i < itemsPerChest && itemIndex < items.length; i++) {
            chest.guaranteedItems.push(items[itemIndex]);
            itemIndex++;
        }
    }

    if (itemIndex > 0) {
        console.log(`[MazeMaster] Find Early: Assigned ${itemIndex} guaranteed items to ${nearbyChests.length} nearby chests`);
    }
}

/**
 * Helper: Shuffle array in place (Fisher-Yates)
 */
function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

/**
 * Helper: Get random element from array
 */
function getRandomFromArray(arr) {
    if (!arr || arr.length === 0) return null;
    return arr[Math.floor(Math.random() * arr.length)];
}

/**
 * Helper: Promise-based delay
 */
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function getCellSize(gridSize) {
    // Delegate to the current renderer
    return RendererRegistry.getRenderer().getCellSize(gridSize);
}

function startMaze(profileName) {
    const profile = getMazeProfileWithDefaults(profileName);
    if (!profile) {
        console.error(`[MazeMaster] Maze profile "${profileName}" not found`);
        return { error: `Profile "${profileName}" not found` };
    }

    // Close current chat to prevent context bleed (if enabled)
    if (extensionSettings.closeChatOnStart !== false) {
        try {
            const context = SillyTavern.getContext();
            if (context && typeof context.clearChat === 'function') {
                context.clearChat();
                console.log('[MazeMaster] Closed current chat to prevent context bleed');
            } else if (typeof doNewChat === 'function') {
                // Alternative: Start a new chat
                doNewChat();
                console.log('[MazeMaster] Started new chat to prevent context bleed');
            }
        } catch (e) {
            console.warn('[MazeMaster] Could not close chat:', e);
        }
    }

    const size = profile.gridSize || 10;
    const mapStyle = profile.mapStyle || 'maze';
    const totalFloors = Math.max(1, Math.min(10, profile.floors || 1));

    // Generate all floors
    const floors = [];

    // Randomize exit position based on difficulty and floor count
    // For multi-floor mazes or hard difficulties, make exit less predictable
    let exitX, exitY;
    const difficulty = profile.difficulty || 'normal';
    const isHardOrMultiFloor = totalFloors > 1 || difficulty === 'hard' || difficulty === 'nightmare';

    if (isHardOrMultiFloor) {
        // Pick exit from corners/edges that aren't the start
        const exitOptions = [];
        // Add corners (excluding start 0,0)
        exitOptions.push({ x: size - 1, y: 0 });        // Top-right
        exitOptions.push({ x: 0, y: size - 1 });        // Bottom-left
        exitOptions.push({ x: size - 1, y: size - 1 }); // Bottom-right

        // For very hard, add some mid-edge positions too
        if (difficulty === 'nightmare' || totalFloors >= 3) {
            exitOptions.push({ x: Math.floor(size / 2), y: size - 1 }); // Bottom-middle
            exitOptions.push({ x: size - 1, y: Math.floor(size / 2) }); // Right-middle
        }

        const chosen = exitOptions[Math.floor(Math.random() * exitOptions.length)];
        exitX = chosen.x;
        exitY = chosen.y;
        console.log(`[MazeMaster] Randomized exit position: (${exitX}, ${exitY}) for ${difficulty} maze with ${totalFloors} floor(s)`);
    } else {
        // Easy/normal single-floor: classic bottom-right
        exitX = size - 1;
        exitY = size - 1;
    }

    // v1.4.0: Store all floor data including BSP rooms
    const floorsData = [];

    for (let f = 0; f < totalFloors; f++) {
        // v1.4.0: Get BSP configuration from profile
        const bspConfig = profile.bspConfig || {};

        // v1.4.0: Per-floor complexity scaling
        if (bspConfig.floorComplexityScaling !== false && totalFloors > 1) {
            const depthRatio = f / Math.max(1, totalFloors - 1);
            bspConfig.maxDepth = (bspConfig.maxDepth || 4) + Math.floor(depthRatio * 2);
            bspConfig.secretDensity = (bspConfig.secretDensity || 0.02) * (1 + depthRatio);
        }

        // v1.4.0: Generate BSP grid with rooms
        const theme = profile.theme || 'fantasy';
        const bspResult = generateGridByStyle(size, mapStyle, theme, bspConfig);
        const floorGrid = bspResult.grid;
        const floorRooms = bspResult.rooms;

        // v1.4.0: Generate zones if enabled
        const zoneCount = bspConfig.zoneCount || 1;
        const floorZones = generateZones(floorRooms, zoneCount, theme);
        applyZonesToGrid(floorGrid, floorZones, floorRooms);

        // v1.4.0: Add secret passages if enabled
        if (bspConfig.secretDensity > 0) {
            generateSecretPassages(floorGrid, size, {
                secretDensity: bspConfig.secretDensity,
                secretHints: bspConfig.secretHints !== false
            });
        }

        // Ensure wall consistency (both sides of each wall match)
        enforceWallConsistency(floorGrid, size);
        placeTiles(floorGrid, profile, size);
        // v1.2.1: Generate room names for each cell
        generateRoomInfoForGrid(floorGrid, profile, size, exitX, exitY);

        floors.push(floorGrid);
        floorsData.push({
            grid: floorGrid,
            rooms: floorRooms,
            zones: floorZones
        });
    }

    // Add staircases between floors
    let guaranteedFloorKeysNeeded = 0;
    if (totalFloors > 1) {
        addStaircasesToFloors(floors, size, profile.requireFloorKey || false, exitX, exitY);

        // Guarantee floor keys are available when requireFloorKey is enabled
        if (profile.requireFloorKey) {
            guaranteedFloorKeysNeeded = guaranteeFloorKeys(floors, size);
        }

        // For multi-floor mazes: Block the exit area on floor 0 to force stair usage
        // Add walls around the exit on the starting floor
        const startFloor = floors[0];
        if (startFloor[exitY] && startFloor[exitY][exitX]) {
            // Wall off the exit cell on floor 0 so player MUST use stairs
            startFloor[exitY][exitX].walls = { top: true, right: true, bottom: true, left: true };
            console.log(`[MazeMaster] Blocked exit area on floor 0 at (${exitX}, ${exitY}) - must use stairs`);
        }
    }

    // Use first floor as active grid
    const grid = floors[0];

    // Get starting inventory config with difficulty scaling
    const baseStartInv = profile.startingInventory || { key: 0, stealth: 0, strike: 0, execute: 0 };
    const difficultySettings = getDifficultySettings(profile);
    const invMult = difficultySettings.inventoryStartMult || 1.0;
    const startInv = {
        key: Math.floor((baseStartInv.key || 0) * invMult),
        stealth: Math.floor((baseStartInv.stealth || 0) * invMult),
        strike: Math.floor((baseStartInv.strike || 0) * invMult),
        execute: Math.floor((baseStartInv.execute || 0) * invMult),
        // v1.2.0 new items - add guaranteed floor keys if chests weren't available
        floorKey: Math.floor((baseStartInv.floorKey || 0) * invMult) + guaranteedFloorKeysNeeded,
        portalStone: Math.floor((baseStartInv.portalStone || 0) * invMult),
        minionBane: Math.floor((baseStartInv.minionBane || 0) * invMult),
        mapFragment: Math.floor((baseStartInv.mapFragment || 0) * invMult),
        timeShard: Math.floor((baseStartInv.timeShard || 0) * invMult),
        voidWalk: Math.floor((baseStartInv.voidWalk || 0) * invMult),
    };

    // Determine initial minion display (main story, main minion intro, or default)
    let initialMinion = getDefaultMinion();
    const mainMinion = profile.mainMinion ? getMinion(profile.mainMinion) : null;

    // Use main story if available, otherwise use main minion intro
    if (profile.storyConfig?.mainStory) {
        initialMinion = {
            name: mainMinion?.name || 'Story',
            role: 'Narrator',
            imagePath: mainMinion?.imagePath || '',
            message: profile.storyConfig.mainStory,
        };
    } else if (mainMinion) {
        initialMinion = {
            name: mainMinion.name,
            role: 'Main Minion',
            imagePath: mainMinion.imagePath,
            message: profile.mainMinionIntroMessage || 'Welcome to my maze...',
        };
    }

    currentMaze = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        grid: grid,
        size: size,
        playerX: 0,
        playerY: 0,
        playerDirection: 'south',  // Last movement direction for sprite facing
        exitX: size - 1,
        exitY: size - 1,
        visited: new Set(['0:0,0']),  // Format: "floor:x,y"
        isVictory: false,
        currentMinion: initialMinion,
        // Encounter system
        isPaused: false,
        pendingEncounter: null,
        exitEncounterDone: false,
        pendingConfirmation: null,
        pendingChest: null,
        // Inventory
        inventory: {
            key: startInv.key || 0,
            stealth: startInv.stealth || 0,
            strike: startInv.strike || 0,
            execute: startInv.execute || 0,
            // v1.2.0 new items
            floorKey: startInv.floorKey || 0,
            portalStone: startInv.portalStone || 0,
            minionBane: startInv.minionBane || 0,
            mapFragment: startInv.mapFragment || 0,
            timeShard: startInv.timeShard || 0,
            voidWalk: startInv.voidWalk || 0,
            // v1.3.0 HP items
            healingPotion: 0,
            greaterHealing: 0,
            elixir: 0,
            revivalCharm: 0,
            heartCrystal: 0,
            // v1.3.2 Visibility items
            torch: 0,
            lantern: 0,
            revealScroll: 0,
            sightPotion: 0,
            crystalBall: 0,
            // v1.4.0 Secret detection item
            secretSense: 0,
        },
        // v1.3.2 Visibility system
        visibility: {
            baseRadius: 1,
            tempBonus: 0,
            tempMovesLeft: 0,
            permBonus: 0,
            floorRevealed: false,
        },
        // Story milestones
        shownMilestones: new Set(),
        // Statistics tracking
        stats: initSessionStats(),
        explorationComplete: false,
        // Moving enemies
        moveCount: 0,
        movingMinions: [],
        // Teleport tiles
        portals: [],
        // Quest/Objective system
        objectiveProgress: initObjectives(profile),
        allObjectivesComplete: false,
        // v1.2.0 Multi-floor
        currentFloor: 0,
        totalFloors: totalFloors,
        floors: floors,
        floorsData: floorsData,  // v1.4.0: BSP rooms, zones per floor
        voidWalkActive: false,
        messageLog: [],  // v1.2.1: Persistent message history
        // v1.3.0 HP System
        hpEnabled: profile.hpEnabled !== false,
        hp: initHP(profile),
        restCooldown: 0,
        // v1.4.6: Session Notes (auto-populated adventure log)
        sessionNotes: '',
        // v1.4.7: Fairness system - tracks luck for pity mechanics
        fairness: {
            chestsWithoutKey: 0,        // Chests opened without finding a key
            combatLossStreak: 0,        // Consecutive combat losses
            chestsWithoutHealing: 0,    // Chests without healing items
            lockedChestsSkipped: 0,     // Locked chests skipped due to no key
            lastHealingFoundFloor: 0,   // Floor where last healing was found
        },
        // v1.4.8: LLM Enhanced Room Descriptions
        enhancedRooms: {},  // Map of "floor:x,y" -> enhanced description
    };

    // Add initial session note
    addSessionNote(`Adventure begins: ${profileName}`);
    addSessionNote(`Floor 1/${profile.floors || 1} - ${size}x${size} ${profile.theme || 'fantasy'} ${profile.mapStyle || 'dungeon'}`);

    // Initialize moving minions after maze state is created
    currentMaze.movingMinions = initMovingMinions(grid, size);

    showMazeModal();

    // v1.3.2: Apply initial visibility radius at spawn
    applyVisibilityAtPosition(0, 0, size);

    renderMazeGrid();
    updatePlayerPosition(false); // Set initial position without animation
    updateMazeHero();
    updateRestButton(); // Initialize rest button state
    updateRoomInfoBox();  // v1.2.1: Update room info display
    updateInventoryDisplay();
    updateStatsDisplay();
    updateHPDisplay();  // v1.3.0: Initialize HP display
    updateObjectivesDisplay();
    startStatsTimer();

    // v1.2.0: Update multi-floor UI
    updateFloorIndicator();
    updateDpadFloorButtons();

    document.addEventListener('keydown', handleMazeKeydown, { capture: true });

    // v1.4.8: Enhance starting room description
    enhanceRoomOnEntry(0, 0);

    console.log(`[MazeMaster] Maze "${profileName}" started (${size}x${size}, ${totalFloors} floor${totalFloors > 1 ? 's' : ''})`);
    return { success: true };
}

function showMazeModal() {
    // Remove existing modal if any
    const existing = document.getElementById('mazemaster_maze_modal');
    if (existing) existing.remove();

    const cellSize = getCellSize(currentMaze.size);

    const modal = document.createElement('div');
    modal.id = 'mazemaster_maze_modal';
    modal.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.95);';
    modal.innerHTML = `
        <div class="mazemaster-maze-overlay">
            <div class="mazemaster-maze-container">
                <!-- TOP PANEL: Info & Controls -->
                <div class="mazemaster-maze-top">
                    <!-- Left Column: Message Box, Stats, Inventory -->
                    <div class="mazemaster-maze-left-column">
                        <!-- Hero Section (Message Box) -->
                        <div class="mazemaster-maze-hero">
                            <div class="mazemaster-maze-hero-content">
                                <div class="mazemaster-maze-hero-avatar">
                                    <img id="maze_minion_img" src="" alt="" style="display: none;">
                                    <div id="maze_generating_indicator" class="maze-generating-indicator">
                                        <i class="fa-solid fa-comment-dots"></i>
                                    </div>
                                </div>
                                <div class="maze-hero-text">
                                    <div id="maze_minion_name" class="maze-minion-name"></div>
                                    <div id="maze_minion_role" class="maze-minion-role"></div>
                                    <div id="maze_message_log" class="maze-message-log"></div>
                                </div>
                            </div>
                        </div>

                    <!-- ROW 2: Stats and Inventory -->
                    <div class="mazemaster-maze-info-stack">
                        <!-- Stats Bar -->
                        <div class="mazemaster-maze-stats-bar">
                            <div class="stats-item stats-persona" title="Current Persona">
                                <i class="fa-solid fa-user"></i>
                                <span id="maze_stat_persona">${getCurrentPersonaName()}</span>
                            </div>
                            <div class="stats-item" title="Moves">
                                <i class="fa-solid fa-shoe-prints"></i>
                                <span id="maze_stat_moves">0</span>
                            </div>
                            <div class="stats-item" title="Time Elapsed">
                                <i class="fa-solid fa-clock"></i>
                                <span id="maze_stat_time">0:00</span>
                            </div>
                            <div class="stats-item" title="Exploration">
                                <i class="fa-solid fa-map"></i>
                                <span id="maze_stat_explore">0%</span>
                            </div>
                            <div class="stats-item" title="Difficulty">
                                <i class="fa-solid fa-skull"></i>
                                <span id="maze_stat_difficulty">${getDifficultySettings(currentMaze.profile).name}</span>
                            </div>
                            <div class="stats-item maze-floor-indicator" title="Current Floor" style="${currentMaze.totalFloors <= 1 ? 'display:none;' : ''}">
                                <i class="fa-solid fa-layer-group"></i>
                                <span><span id="maze_floor_current">${currentMaze.currentFloor + 1}</span>/<span id="maze_floor_total">${currentMaze.totalFloors}</span></span>
                            </div>
                            <div class="stats-item maze-zone-indicator" id="maze_zone_display" title="Current Zone" style="display: none;">
                                <i class="fa-solid fa-map-pin"></i>
                                <span id="maze_zone_name">Zone 1</span>
                                <span id="maze_zone_progress" style="font-size: 0.8em; opacity: 0.7;"></span>
                            </div>
                        </div>
                    </div>

                    <!-- Objectives Section (if any) -->
                    <div class="maze-objectives-section ${(currentMaze.profile?.objectives?.length || 0) === 0 ? 'hidden' : ''}">
                        <div class="objectives-header">
                            <i class="fa-solid fa-list-check"></i>
                            <span>Objectives</span>
                        </div>
                        <div id="maze_objectives_list" class="objectives-list">
                            <!-- Populated by updateObjectivesDisplay() -->
                        </div>
                    </div>
                    </div>

                    <!-- ROOM INFO BOX (right side, full height) -->
                    <div class="mazemaster-maze-room-info" id="maze_room_info">
                        <div class="room-info-content">
                            <div class="room-info-name" id="room_info_name">Unknown Room</div>
                            <div class="room-info-desc" id="room_info_desc">...</div>
                            <div class="room-info-section">
                                <div class="room-info-label"><i class="fa-solid fa-users"></i> Occupants</div>
                                <div id="room_info_occupants">None</div>
                            </div>
                            <div class="room-info-section">
                                <div class="room-info-label"><i class="fa-solid fa-skull"></i> Defeated</div>
                                <div id="room_info_defeated">None</div>
                            </div>
                            <div class="room-info-section room-info-exits-section">
                                <div class="room-info-label"><i class="fa-solid fa-compass"></i> Exits</div>
                                <div id="room_info_exits" class="room-info-exits-list">None</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Power Button (top right corner) -->
                <button id="maze_power_btn" class="maze-power-btn" title="Exit Maze">
                    <i class="fa-solid fa-power-off"></i>
                </button>

                <!-- Inventory Info Button (below power button) -->
                <div class="maze-inventory-info-wrapper" id="maze_inventory_wrapper">
                    <button id="maze_inventory_btn" class="maze-info-btn" title="Inventory">
                        <i class="fa-solid fa-info"></i>
                    </button>
                    <div class="maze-inventory-dropdown hidden" id="maze_inventory_menu">
                        <!-- Dungeon Items -->
                        <div class="inventory-menu-section">
                            <div class="inventory-menu-header">Dungeon Items</div>
                            <div class="inventory-menu-item" data-item="key" title="Unlock locked chests">
                                <i class="fa-solid fa-key" style="color: #f1c40f;"></i>
                                <span class="item-name">Skeleton Key</span>
                                <span class="item-count" id="maze_inv_key">${currentMaze.inventory.key}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="floorKey" title="Unlock staircases">
                                <i class="fa-solid fa-stairs" style="color: #9b59b6;"></i>
                                <span class="item-name">Floor Key</span>
                                <span class="item-count" id="maze_inv_floorKey">${currentMaze.inventory.floorKey}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="portalStone" data-usable="true" title="Teleport to any revealed portal">
                                <i class="fa-solid fa-gem" style="color: #3498db;"></i>
                                <span class="item-name">Portal Stone</span>
                                <span class="item-count" id="maze_inv_portalStone">${currentMaze.inventory.portalStone}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="mapFragment" data-usable="true" title="Reveal 3x3 area around you">
                                <i class="fa-solid fa-scroll" style="color: #e67e22;"></i>
                                <span class="item-name">Map Fragment</span>
                                <span class="item-count" id="maze_inv_mapFragment">${currentMaze.inventory.mapFragment}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="voidWalk" data-usable="true" title="Phase through one wall">
                                <i class="fa-solid fa-ghost" style="color: #1abc9c;"></i>
                                <span class="item-name">Void Walk</span>
                                <span class="item-count" id="maze_inv_voidWalk">${currentMaze.inventory.voidWalk}</span>
                            </div>
                        </div>
                        <!-- Combat Items -->
                        <div class="inventory-menu-section">
                            <div class="inventory-menu-header">Combat Items</div>
                            <div class="inventory-menu-item" data-item="stealth" title="Sneak past enemies">
                                <i class="fa-solid fa-user-ninja" style="color: #95a5a6;"></i>
                                <span class="item-name">Shadow Cloak</span>
                                <span class="item-count" id="maze_inv_stealth">${currentMaze.inventory.stealth}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="strike" title="Combat boost">
                                <i class="fa-solid fa-bolt" style="color: #f39c12;"></i>
                                <span class="item-name">Battle Surge</span>
                                <span class="item-count" id="maze_inv_pow">${currentMaze.inventory.strike}</span>
                            </div>
                            <div class="inventory-menu-item execute" data-item="execute" title="Instant victory!">
                                <i class="fa-solid fa-star" style="color: #e74c3c;"></i>
                                <span class="item-name">Death Blow</span>
                                <span class="item-count" id="maze_inv_execute">${currentMaze.inventory.execute}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="minionBane" title="Auto-defeat next minion">
                                <i class="fa-solid fa-skull-crossbones" style="color: #8e44ad;"></i>
                                <span class="item-name">Minion Bane</span>
                                <span class="item-count" id="maze_inv_minionBane">${currentMaze.inventory.minionBane}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="timeShard" title="Slow next battlebar by 50%">
                                <i class="fa-solid fa-hourglass-half" style="color: #2980b9;"></i>
                                <span class="item-name">Time Shard</span>
                                <span class="item-count" id="maze_inv_timeShard">${currentMaze.inventory.timeShard}</span>
                            </div>
                        </div>
                        <!-- HP Items (v1.3.0) -->
                        <div class="inventory-menu-section hp-items-section" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                            <div class="inventory-menu-header">Healing & Restoration</div>
                            <div class="inventory-menu-item" data-item="healingPotion" data-usable="true" data-hp-item="healingPotion" title="Restore 25% HP">
                                <i class="fa-solid fa-flask" style="color: #e74c3c;"></i>
                                <span class="item-name">Minor Elixir</span>
                                <span class="item-count" id="maze_inv_healingPotion">${currentMaze.inventory.healingPotion}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="greaterHealing" data-usable="true" data-hp-item="greaterHealing" title="Restore 50% HP">
                                <i class="fa-solid fa-flask-vial" style="color: #9b59b6;"></i>
                                <span class="item-name">Healing Draught</span>
                                <span class="item-count" id="maze_inv_greaterHealing">${currentMaze.inventory.greaterHealing}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="elixir" data-usable="true" data-hp-item="elixir" title="Full HP restore">
                                <i class="fa-solid fa-wine-bottle" style="color: #f1c40f;"></i>
                                <span class="item-name">Grand Elixir</span>
                                <span class="item-count" id="maze_inv_elixir">${currentMaze.inventory.elixir}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="revivalCharm" data-usable="true" data-hp-item="revivalCharm" title="Auto-resurrect on death">
                                <i class="fa-solid fa-feather" style="color: #3498db;"></i>
                                <span class="item-name">Phoenix Feather</span>
                                <span class="item-count" id="maze_inv_revivalCharm">${currentMaze.inventory.revivalCharm}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="heartCrystal" data-usable="true" data-hp-item="heartCrystal" title="+10 Max HP permanent">
                                <i class="fa-solid fa-gem" style="color: #e91e63;"></i>
                                <span class="item-name">Heart Crystal</span>
                                <span class="item-count" id="maze_inv_heartCrystal">${currentMaze.inventory.heartCrystal}</span>
                            </div>
                        </div>
                        <!-- Visibility Items (v1.3.2) -->
                        <div class="inventory-menu-section vis-items-section">
                            <div class="inventory-menu-header">Vision & Awareness</div>
                            <div class="inventory-menu-item" data-item="torch" data-usable="true" data-vis-item="torch" title="Temporary +2 visibility (3 moves)">
                                <i class="fa-solid fa-fire" style="color: #f39c12;"></i>
                                <span class="item-name">Torch</span>
                                <span class="item-count" id="maze_inv_torch">${currentMaze.inventory.torch}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="lantern" title="Passive +1 visibility while held">
                                <i class="fa-solid fa-lightbulb" style="color: #f1c40f;"></i>
                                <span class="item-name">Lantern</span>
                                <span class="item-count" id="maze_inv_lantern">${currentMaze.inventory.lantern}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="revealScroll" data-usable="true" data-vis-item="revealScroll" title="Reveals entire floor for 1 move">
                                <i class="fa-solid fa-scroll" style="color: #9b59b6;"></i>
                                <span class="item-name">Reveal Scroll</span>
                                <span class="item-count" id="maze_inv_revealScroll">${currentMaze.inventory.revealScroll}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="sightPotion" data-usable="true" data-vis-item="sightPotion" title="Permanent +1 visibility">
                                <i class="fa-solid fa-eye" style="color: #3498db;"></i>
                                <span class="item-name">Sight Potion</span>
                                <span class="item-count" id="maze_inv_sightPotion">${currentMaze.inventory.sightPotion}</span>
                            </div>
                            <div class="inventory-menu-item" data-item="crystalBall" data-usable="true" data-vis-item="crystalBall" title="Reveals all minions on floor">
                                <i class="fa-solid fa-circle" style="color: #8e44ad;"></i>
                                <span class="item-name">Crystal Ball</span>
                                <span class="item-count" id="maze_inv_crystalBall">${currentMaze.inventory.crystalBall}</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Session Memory Button (below inventory button) -->
                <div class="maze-memory-wrapper" id="maze_memory_wrapper">
                    <button id="maze_memory_btn" class="maze-memory-btn" title="Session Notes">
                        m
                    </button>
                </div>

                <!-- Session Memory Panel -->
                <div id="maze_memory_panel" class="maze-memory-panel" style="display: none;">
                    <div class="maze-memory-header">
                        <h3>Session Notes</h3>
                        <button id="maze_memory_close" class="maze-memory-close">&times;</button>
                    </div>
                    <div class="maze-memory-content">
                        <textarea id="maze_memory_textarea" class="maze-memory-textarea" placeholder="Write notes about your adventure...&#10;&#10;These notes are saved with this maze session."></textarea>
                    </div>
                    <div class="maze-memory-footer">
                        <button id="maze_memory_save" class="maze-memory-save-btn">Save Notes</button>
                    </div>
                </div>
                <div id="maze_memory_backdrop" class="maze-memory-backdrop" style="display: none;"></div>

                <!-- Encounter Actions (shows when needed) -->
                <div id="maze_encounter_confirm" class="maze-action-buttons">
                    <!-- Populated dynamically when encounter happens -->
                </div>

                <!-- BOTTOM PANEL: Map Area -->
                <div class="mazemaster-maze-bottom">
                    <div class="mazemaster-maze-area">
                        <div id="maze_grid_container" class="mazemaster-maze-grid-wrapper" style="position: relative;">
                            <!-- Renderer inserts grid/canvas here -->
                        </div>

                        <!-- HP Overlay (upper-right corner of map) -->
                        <div class="maze-hp-overlay" id="maze_hp_overlay" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                            <div class="hp-overlay-bar">
                                <i class="fa-solid fa-heart"></i>
                                <div class="hp-overlay-bar-bg">
                                    <div class="hp-overlay-bar-fill high" id="maze_hp_bar" style="width: 100%;"></div>
                                </div>
                                <span class="hp-overlay-text">
                                    <span id="maze_hp_current">${currentMaze.hp?.current || 100}</span>/<span id="maze_hp_max">${(currentMaze.hp?.max || 100) + (currentMaze.hp?.maxBonus || 0)}</span>
                                </span>
                            </div>
                        </div>

                        <!-- Inventory Symbols Overlay (upper-left corner of map) -->
                        <div class="maze-inventory-overlay" id="maze_inventory_overlay">
                            <div class="inv-overlay-item" data-item="key" title="Skeleton Key">
                                <i class="fa-solid fa-key" style="color: #f1c40f;"></i>
                                <span id="maze_ov_key">${currentMaze.inventory.key}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="stealth" title="Shadow Cloak">
                                <i class="fa-solid fa-user-ninja" style="color: #95a5a6;"></i>
                                <span id="maze_ov_stealth">${currentMaze.inventory.stealth}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="strike" title="Battle Surge">
                                <i class="fa-solid fa-bolt" style="color: #f39c12;"></i>
                                <span id="maze_ov_strike">${currentMaze.inventory.strike}</span>
                            </div>
                            <div class="inv-overlay-item execute" data-item="execute" title="Death Blow">
                                <i class="fa-solid fa-star" style="color: #e74c3c;"></i>
                                <span id="maze_ov_execute">${currentMaze.inventory.execute}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="floorKey" title="Floor Key" style="${currentMaze.totalFloors > 1 ? '' : 'display:none;'}">
                                <i class="fa-solid fa-stairs" style="color: #9b59b6;"></i>
                                <span id="maze_ov_floorKey">${currentMaze.inventory.floorKey}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="portalStone" title="Portal Stone">
                                <i class="fa-solid fa-gem" style="color: #3498db;"></i>
                                <span id="maze_ov_portalStone">${currentMaze.inventory.portalStone}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="minionBane" title="Minion Bane">
                                <i class="fa-solid fa-skull-crossbones" style="color: #8e44ad;"></i>
                                <span id="maze_ov_minionBane">${currentMaze.inventory.minionBane}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="mapFragment" title="Map Fragment">
                                <i class="fa-solid fa-scroll" style="color: #e67e22;"></i>
                                <span id="maze_ov_mapFragment">${currentMaze.inventory.mapFragment}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="timeShard" title="Time Shard">
                                <i class="fa-solid fa-hourglass-half" style="color: #2980b9;"></i>
                                <span id="maze_ov_timeShard">${currentMaze.inventory.timeShard}</span>
                            </div>
                            <div class="inv-overlay-item" data-item="voidWalk" title="Void Walk">
                                <i class="fa-solid fa-ghost" style="color: #1abc9c;"></i>
                                <span id="maze_ov_voidWalk">${currentMaze.inventory.voidWalk}</span>
                            </div>
                            <!-- HP Items -->
                            <div class="inv-overlay-item hp-item" data-item="healingPotion" title="Minor Elixir" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                                <i class="fa-solid fa-flask" style="color: #e74c3c;"></i>
                                <span id="maze_ov_healingPotion">${currentMaze.inventory.healingPotion}</span>
                            </div>
                            <div class="inv-overlay-item hp-item" data-item="greaterHealing" title="Healing Draught" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                                <i class="fa-solid fa-flask-vial" style="color: #9b59b6;"></i>
                                <span id="maze_ov_greaterHealing">${currentMaze.inventory.greaterHealing}</span>
                            </div>
                            <div class="inv-overlay-item hp-item" data-item="elixir" title="Grand Elixir" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                                <i class="fa-solid fa-wine-bottle" style="color: #f1c40f;"></i>
                                <span id="maze_ov_elixir">${currentMaze.inventory.elixir}</span>
                            </div>
                            <div class="inv-overlay-item hp-item" data-item="revivalCharm" title="Phoenix Feather" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                                <i class="fa-solid fa-feather" style="color: #3498db;"></i>
                                <span id="maze_ov_revivalCharm">${currentMaze.inventory.revivalCharm}</span>
                            </div>
                            <div class="inv-overlay-item hp-item" data-item="heartCrystal" title="Heart Crystal" style="${currentMaze.hpEnabled ? '' : 'display:none;'}">
                                <i class="fa-solid fa-gem" style="color: #e91e63;"></i>
                                <span id="maze_ov_heartCrystal">${currentMaze.inventory.heartCrystal}</span>
                            </div>
                            <!-- Visibility Items -->
                            <div class="inv-overlay-item vis-item" data-item="torch" data-usable="true" title="Torch: +2 visibility for 3 moves">
                                <i class="fa-solid fa-fire" style="color: #f39c12;"></i>
                                <span id="maze_ov_torch">${currentMaze.inventory.torch}</span>
                            </div>
                            <div class="inv-overlay-item vis-item" data-item="lantern" title="Lantern: Passive +1 visibility">
                                <i class="fa-solid fa-lightbulb" style="color: #f1c40f;"></i>
                                <span id="maze_ov_lantern">${currentMaze.inventory.lantern}</span>
                            </div>
                            <div class="inv-overlay-item vis-item" data-item="revealScroll" data-usable="true" title="Reveal Scroll: Shows entire floor">
                                <i class="fa-solid fa-scroll" style="color: #9b59b6;"></i>
                                <span id="maze_ov_revealScroll">${currentMaze.inventory.revealScroll}</span>
                            </div>
                            <div class="inv-overlay-item vis-item" data-item="sightPotion" data-usable="true" title="Sight Potion: Permanent +1 visibility">
                                <i class="fa-solid fa-eye" style="color: #3498db;"></i>
                                <span id="maze_ov_sightPotion">${currentMaze.inventory.sightPotion}</span>
                            </div>
                            <div class="inv-overlay-item vis-item" data-item="crystalBall" data-usable="true" title="Crystal Ball: Reveals all minions">
                                <i class="fa-solid fa-crystal-ball" style="color: #8e44ad;"></i>
                                <span id="maze_ov_crystalBall">${currentMaze.inventory.crystalBall}</span>
                            </div>
                        </div>

                        <!-- Action Popup Overlay (for encounter buttons) - OUTSIDE grid container so it persists through re-renders -->
                        <div id="maze_action_popup" class="maze-action-popup" style="display: none;">
                            <div class="maze-action-popup-content">
                                <div id="maze_action_popup_buttons" class="maze-action-popup-buttons">
                                    <!-- Buttons populated dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Circular D-Pad (floating) -->
                <div id="maze_dpad" class="maze-dpad ${extensionSettings.dpadConfig?.floating !== false ? 'floating' : ''}"
                     style="${extensionSettings.dpadConfig?.enabled === false ? 'display: none;' : ''}${extensionSettings.dpadConfig?.position?.x ? `left: ${extensionSettings.dpadConfig.position.x}px; top: ${extensionSettings.dpadConfig.position.y}px;` : ''}">
                    <div class="dpad-ring">
                        <button class="dpad-btn dpad-up" data-dir="up" title="Move Up (Arrow Up)">
                            <i class="fa-solid fa-chevron-up"></i>
                        </button>
                        <button class="dpad-btn dpad-right" data-dir="right" title="Move Right (Arrow Right)">
                            <i class="fa-solid fa-chevron-right"></i>
                        </button>
                        <button class="dpad-btn dpad-down" data-dir="down" title="Move Down (Arrow Down)">
                            <i class="fa-solid fa-chevron-down"></i>
                        </button>
                        <button class="dpad-btn dpad-left" data-dir="left" title="Move Left (Arrow Left)">
                            <i class="fa-solid fa-chevron-left"></i>
                        </button>
                        <!-- Floor navigation buttons (shown when on staircase) -->
                        <button class="dpad-btn dpad-floor-up hidden" data-dir="floor-up" title="Go Up Floor (Shift+Up)">
                            <i class="fa-solid fa-arrow-up"></i><span>UP</span>
                        </button>
                        <button class="dpad-btn dpad-floor-down hidden" data-dir="floor-down" title="Go Down Floor (Shift+Down)">
                            <i class="fa-solid fa-arrow-down"></i><span>DN</span>
                        </button>
                    </div>
                    <div class="dpad-center"></div>
                    <div class="dpad-drag-handle" title="Drag to reposition">
                        <i class="fa-solid fa-grip"></i>
                    </div>
                    <!-- Rest button (HP system) - positioned safely away from directional buttons -->
                    <button id="maze_rest_btn" class="dpad-rest-btn" title="Rest to recover HP" style="display: none;">
                        <i class="fa-solid fa-bed"></i>
                        <span class="rest-cooldown-badge" style="display: none;"></span>
                    </button>
                </div>

                <!-- Close Button (shown on victory) -->
                <button id="maze_close_btn" class="menu_button menu_button_primary maze-close-btn" style="display: none;">
                    <i class="fa-solid fa-check"></i> Close
                </button>
            </div>
        </div>

        <style>
            .mazemaster-maze-overlay {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                height: 100%;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            .mazemaster-maze-container {
                position: relative;
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 15px;
                width: 90vw;
                max-width: 1200px;
                height: 94vh;
                max-height: 960px;
                margin: 10px;
                background: #1a1a2e;
                border-radius: 15px;
                border: 2px solid #333;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                overflow: hidden;
            }

            /* Top Panel - Info & Controls */
            .mazemaster-maze-top {
                display: flex;
                flex-direction: row;
                gap: 16px;
                flex-shrink: 0;
                min-height: 240px;
                height: 280px;
            }

            /* Left Column - Message Box, Stats, Inventory stacked */
            .mazemaster-maze-left-column {
                display: flex;
                flex-direction: column;
                gap: 8px;
                width: 50.1%;
                flex-shrink: 0;
            }

            /* Info Stack - Stats and Inventory */
            .mazemaster-maze-info-stack {
                display: flex;
                flex-direction: column;
                gap: 8px;
                width: 100%;
                position: relative;
            }

            /* ROOM INFO BOX - right side, full height */
            .mazemaster-maze-room-info {
                flex: 1;
                margin-right: 46px; /* Space for power button */
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                padding: 10px 12px;
                border: 1px solid #444;
                display: flex;
                flex-direction: column;
            }

            .room-info-content {
                flex: 1;
                display: flex;
                flex-direction: column;
                color: #aaa;
                font-size: 0.9em;
                gap: 8px;
                overflow-y: auto;
            }

            .room-info-name {
                font-size: 1.1em;
                font-weight: 600;
                color: #ecf0f1;
                margin-bottom: 2px;
            }

            .room-info-desc {
                font-style: italic;
                color: #bdc3c7;
                font-size: 0.9em;
                line-height: 1.3;
                padding-bottom: 8px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            .room-info-section {
                display: flex;
                flex-direction: column;
                gap: 2px;
            }

            .room-info-label {
                font-size: 0.75em;
                color: #7f8c8d;
                text-transform: uppercase;
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .room-info-label i {
                font-size: 0.9em;
                color: #3498db;
            }

            .room-info-section > div:last-child {
                color: #ecf0f1;
                font-size: 0.95em;
            }

            .maze-hero-text {
                display: flex;
                flex-direction: column;
                flex: 1;
                min-width: 0;
            }

            /* Power Button - Top Right Corner */
            .maze-power-btn {
                position: absolute;
                top: 16px;
                right: 10px;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: 2px solid #e94560;
                background: rgba(233, 69, 96, 0.2);
                color: #e94560;
                font-size: 18px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
                z-index: 100;
            }

            .maze-power-btn:hover {
                background: #e94560;
                color: #fff;
                transform: scale(1.1);
            }

            /* Inventory Info Button - Below Power Button */
            .maze-inventory-info-wrapper {
                position: absolute;
                top: 70px;
                right: 10px;
                z-index: 200;
            }

            .maze-inventory-info-wrapper.open {
                z-index: 10100;
            }

            .maze-info-btn {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: 2px solid #f1c40f;
                background: rgba(241, 196, 15, 0.2);
                color: #f1c40f;
                font-size: 18px;
                font-weight: bold;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .maze-info-btn:hover {
                background: #f1c40f;
                color: #1a1a2e;
                transform: scale(1.1);
            }

            .maze-inventory-info-wrapper.open .maze-info-btn {
                background: #f1c40f;
                color: #1a1a2e;
            }

            /* Session Memory Button - Below Inventory Button */
            .maze-memory-wrapper {
                position: absolute;
                top: 124px;
                right: 10px;
                z-index: 200;
            }

            .maze-memory-btn {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: 2px solid #5dade2;
                background: rgba(93, 173, 226, 0.2);
                color: #5dade2;
                font-size: 20px;
                font-weight: bold;
                font-family: 'Georgia', serif;
                font-style: italic;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .maze-memory-btn:hover {
                background: #5dade2;
                color: #1a1a2e;
                transform: scale(1.1);
            }

            .maze-memory-btn.active {
                background: #5dade2;
                color: #1a1a2e;
            }

            /* Session Memory Panel */
            .maze-memory-panel {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 500px;
                max-height: 80vh;
                background: rgba(20, 25, 35, 0.98);
                border: 2px solid #5dade2;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                z-index: 10200;
                display: flex;
                flex-direction: column;
            }

            .maze-memory-panel.hidden {
                display: none;
            }

            .maze-memory-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 16px;
                border-bottom: 1px solid rgba(93, 173, 226, 0.3);
                background: rgba(93, 173, 226, 0.1);
                border-radius: 10px 10px 0 0;
            }

            .maze-memory-header h3 {
                margin: 0;
                color: #5dade2;
                font-size: 16px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .maze-memory-close {
                background: none;
                border: none;
                color: #888;
                font-size: 20px;
                cursor: pointer;
                padding: 4px 8px;
                transition: color 0.2s;
            }

            .maze-memory-close:hover {
                color: #e74c3c;
            }

            .maze-memory-content {
                flex: 1;
                padding: 16px;
                overflow-y: auto;
            }

            .maze-memory-textarea {
                width: 100%;
                height: 300px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(93, 173, 226, 0.3);
                border-radius: 8px;
                color: #e0e0e0;
                font-family: 'Segoe UI', Tahoma, sans-serif;
                font-size: 14px;
                line-height: 1.5;
                padding: 12px;
                resize: vertical;
            }

            .maze-memory-textarea:focus {
                outline: none;
                border-color: #5dade2;
            }

            .maze-memory-textarea::placeholder {
                color: #666;
                font-style: italic;
            }

            .maze-memory-footer {
                padding: 12px 16px;
                border-top: 1px solid rgba(93, 173, 226, 0.2);
                display: flex;
                justify-content: flex-end;
                gap: 10px;
            }

            .maze-memory-save-btn {
                background: linear-gradient(135deg, #5dade2 0%, #3498db 100%);
                border: none;
                color: white;
                padding: 8px 20px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: bold;
                transition: transform 0.2s, box-shadow 0.2s;
            }

            .maze-memory-save-btn:hover {
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(93, 173, 226, 0.4);
            }

            .maze-memory-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.6);
                z-index: 10199;
            }

            .maze-memory-backdrop.hidden {
                display: none;
            }

            /* Inventory Dropdown from Info Button */
            .maze-inventory-dropdown {
                position: absolute;
                top: calc(100% + 8px);
                right: 0;
                min-width: 220px;
                max-height: 70vh;
                overflow-y: auto;
                background: rgba(20, 25, 35, 0.98);
                border: 1px solid rgba(241, 196, 15, 0.3);
                border-radius: 10px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
                backdrop-filter: blur(10px);
                z-index: 10100;
            }

            .maze-inventory-dropdown.hidden {
                display: none;
            }

            .maze-inventory-dropdown .inventory-menu-section {
                padding: 8px 0;
                border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            }

            .maze-inventory-dropdown .inventory-menu-section:last-child {
                border-bottom: none;
            }

            .maze-inventory-dropdown .inventory-menu-header {
                padding: 4px 12px 6px;
                font-size: 0.7em;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                color: #f1c40f;
                font-weight: 600;
            }

            .maze-inventory-dropdown .inventory-menu-item {
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 8px 12px;
                cursor: pointer;
                transition: background 0.15s ease;
            }

            .maze-inventory-dropdown .inventory-menu-item:hover {
                background: rgba(255, 255, 255, 0.08);
            }

            .maze-inventory-dropdown .inventory-menu-item[data-usable="true"]:hover {
                background: rgba(46, 204, 113, 0.15);
            }

            .maze-inventory-dropdown .inventory-menu-item i {
                font-size: 14px;
                width: 18px;
                text-align: center;
            }

            .maze-inventory-dropdown .inventory-menu-item .item-name {
                flex: 1;
                font-size: 0.85em;
                color: #ecf0f1;
            }

            .maze-inventory-dropdown .inventory-menu-item .item-count {
                font-size: 0.85em;
                font-weight: 600;
                color: #f1c40f;
                min-width: 20px;
                text-align: right;
            }

            .maze-inventory-dropdown .inventory-menu-item.execute .item-name {
                color: #e74c3c;
            }

            .maze-inventory-dropdown .inventory-menu-item.execute .item-count {
                color: #e74c3c;
            }

            /* Save Dialog */
            #maze_save_dialog {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 1000;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .maze-save-dialog-backdrop {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
            }

            .maze-save-dialog-content {
                position: relative;
                background: #1a1a2e;
                border: 2px solid #4a90d9;
                border-radius: 12px;
                padding: 24px 32px;
                text-align: center;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            }

            .maze-save-dialog-title {
                color: #fff;
                font-size: 18px;
                font-weight: 600;
                margin-bottom: 20px;
            }

            .maze-save-dialog-buttons {
                display: flex;
                gap: 12px;
                justify-content: center;
            }

            .maze-save-btn {
                padding: 10px 24px;
                border-radius: 6px;
                border: none;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .maze-save-yes {
                background: #27ae60;
                color: #fff;
            }

            .maze-save-yes:hover {
                background: #2ecc71;
            }

            .maze-save-no {
                background: #e74c3c;
                color: #fff;
            }

            .maze-save-no:hover {
                background: #c0392b;
            }

            .maze-save-cancel {
                background: #7f8c8d;
                color: #fff;
            }

            .maze-save-cancel:hover {
                background: #95a5a6;
            }

            /* Bottom Panel - Map Area */
            .mazemaster-maze-bottom {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-end;
                flex: 1;
                min-height: 200px;
                padding-bottom: 15px;
                overflow: auto;
            }

            /* Hero Section - Minion Area (fills remaining height) */
            .mazemaster-maze-hero {
                display: flex;
                flex-direction: column;
                flex: 1;
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                padding: 10px 12px;
                border: 1px solid #444;
                min-height: 80px;
            }

            .maze-minion-name {
                font-weight: bold;
                font-size: 1.2em;
                color: #e94560;
                flex-shrink: 0;
                margin-bottom: 0;
            }

            .maze-minion-role {
                font-size: 0.8em;
                color: #f1c40f;
                flex-shrink: 0;
                margin-bottom: 4px;
            }

            .mazemaster-maze-hero-content {
                display: flex;
                gap: 10px;
                align-items: flex-start;
                flex: 1;
            }

            .mazemaster-maze-hero-avatar {
                width: 72px;
                height: 72px;
                min-width: 72px;
                flex-shrink: 0;
                border-radius: 6px;
                overflow: hidden;
                background: #16213e;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
            }

            .mazemaster-maze-hero-avatar img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                object-position: center top;
                display: block;
            }

            /* LLM Generating Indicator - overlays the entire image */
            .maze-generating-indicator {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(52, 152, 219, 0.7);
                border-radius: 8px;
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 10;
            }

            .maze-generating-indicator.active {
                display: flex;
            }

            .maze-generating-indicator i {
                color: #fff;
                font-size: 32px;
                animation: maze-pulse 1s ease-in-out infinite;
                text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            }

            @keyframes maze-pulse {
                0%, 100% { transform: scale(1); opacity: 1; }
                50% { transform: scale(1.2); opacity: 0.7; }
            }

            .maze-message-log {
                flex: 1;
                color: #eee;
                line-height: 1.4;
                font-size: 0.9em;
                overflow-y: auto;
                max-height: 120px;
                display: flex;
                flex-direction: column;
                gap: 4px;
                padding-right: 4px;
            }

            .maze-message-log::-webkit-scrollbar {
                width: 6px;
            }

            .maze-message-log::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.2);
                border-radius: 3px;
            }

            .maze-message-log::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 3px;
            }

            .maze-message-log::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.5);
            }

            .maze-message-entry {
                padding: 4px 8px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 6px;
                border-left: 3px solid rgba(52, 152, 219, 0.6);
            }

            .maze-message-entry:last-child {
                border-left-color: rgba(46, 204, 113, 0.8);
            }

            .maze-message-speaker {
                font-weight: 600;
                color: #3498db;
                font-size: 0.85em;
                margin-bottom: 2px;
            }

            .maze-message-text {
                font-style: italic;
                color: #ecf0f1;
            }

            /* Stats Bar */
            .mazemaster-maze-stats-bar {
                display: flex;
                justify-content: center;
                flex-wrap: wrap;
                gap: 12px;
                width: 100%;
                padding: 6px 12px;
                background: linear-gradient(135deg, rgba(52, 73, 94, 0.4) 0%, rgba(44, 62, 80, 0.4) 100%);
                border-radius: 8px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .stats-item {
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 0.85em;
                color: #bdc3c7;
            }

            .stats-item i {
                color: #3498db;
                font-size: 0.9em;
            }

            .stats-item span {
                font-weight: 500;
                color: #ecf0f1;
            }

            /* HP Bar Styles (v1.3.0) */
            .stats-hp {
                min-width: 120px;
            }

            .hp-bar-container {
                position: relative;
                width: 80px;
                height: 16px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 8px;
                overflow: hidden;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }

            .hp-bar-fill {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
                background: linear-gradient(90deg, #27ae60, #1e8449);
                transition: width 0.3s ease, background 0.3s ease;
                border-radius: 8px;
            }

            .hp-bar-fill.low {
                background: linear-gradient(90deg, #e74c3c, #c0392b);
                animation: hp-pulse 1s infinite;
            }

            .hp-bar-fill.medium {
                background: linear-gradient(90deg, #f39c12, #d68910);
            }

            .hp-bar-fill.high {
                background: linear-gradient(90deg, #27ae60, #1e8449);
            }

            .hp-bar-text {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.7em;
                font-weight: 600;
                color: #fff;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                white-space: nowrap;
            }

            @keyframes hp-pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.6; }
            }

            /* Damage/Heal Flash Effects */
            .maze-hp-flash {
                position: fixed;
                inset: 0;
                pointer-events: none;
                z-index: 9999;
                animation: hp-flash 0.3s ease-out forwards;
            }

            .maze-hp-flash.damage {
                background: radial-gradient(circle, rgba(231, 76, 60, 0.3) 0%, transparent 70%);
            }

            .maze-hp-flash.heal {
                background: radial-gradient(circle, rgba(46, 204, 113, 0.3) 0%, transparent 70%);
            }

            @keyframes hp-flash {
                from { opacity: 1; }
                to { opacity: 0; }
            }

            /* Low HP Warning Border */
            .mazemaster-maze-container.low-hp {
                animation: low-hp-border 2s infinite;
            }

            @keyframes low-hp-border {
                0%, 100% { box-shadow: inset 0 0 0 2px transparent; }
                50% { box-shadow: inset 0 0 0 2px #e74c3c; }
            }

            /* ============================================= */
            /* HP OVERLAY (upper-right of map) */
            /* ============================================= */
            .maze-hp-overlay {
                position: absolute;
                top: 8px;
                right: 8px;
                z-index: 100;
                pointer-events: none;
            }

            .hp-overlay-bar {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 6px 10px;
                background: rgba(0, 0, 0, 0.6);
                border-radius: 20px;
                backdrop-filter: blur(4px);
                border: 1px solid rgba(255, 255, 255, 0.15);
            }

            .hp-overlay-bar > i {
                color: #e74c3c;
                font-size: 14px;
            }

            .hp-overlay-bar-bg {
                position: relative;
                width: 70px;
                height: 12px;
                background: rgba(0, 0, 0, 0.5);
                border-radius: 6px;
                overflow: hidden;
            }

            .hp-overlay-bar-fill {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
                border-radius: 6px;
                transition: width 0.3s ease, background 0.3s ease;
            }

            .hp-overlay-bar-fill.high {
                background: linear-gradient(90deg, #27ae60, #2ecc71);
            }

            .hp-overlay-bar-fill.medium {
                background: linear-gradient(90deg, #f39c12, #f1c40f);
            }

            .hp-overlay-bar-fill.low {
                background: linear-gradient(90deg, #c0392b, #e74c3c);
                animation: hp-pulse 1s infinite;
            }

            .hp-overlay-text {
                font-size: 11px;
                font-weight: 600;
                color: #fff;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
                white-space: nowrap;
                min-width: 45px;
                text-align: center;
            }

            /* ============================================= */
            /* INVENTORY OVERLAY (upper-left of map) */
            /* ============================================= */
            .maze-inventory-overlay {
                position: absolute;
                top: 8px;
                left: 8px;
                z-index: 100;
                display: flex;
                flex-direction: column;
                gap: 4px;
                pointer-events: none;
            }

            .inv-overlay-item {
                display: flex;
                align-items: center;
                gap: 4px;
                padding: 4px 8px;
                background: rgba(0, 0, 0, 0.6);
                border-radius: 12px;
                backdrop-filter: blur(4px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                font-size: 12px;
            }

            .inv-overlay-item i {
                font-size: 12px;
                width: 14px;
                text-align: center;
            }

            .inv-overlay-item span {
                font-weight: 600;
                color: #fff;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
                min-width: 16px;
                text-align: center;
            }

            .inv-overlay-item.execute {
                border-color: rgba(231, 76, 60, 0.4);
            }

            .inv-overlay-item.execute i {
                animation: star-glow 2s ease-in-out infinite;
            }

            @keyframes star-glow {
                0%, 100% { filter: drop-shadow(0 0 2px #e74c3c); }
                50% { filter: drop-shadow(0 0 6px #e74c3c); }
            }

            /* Hide items with 0 count */
            .inv-overlay-item span:empty,
            .inv-overlay-item[data-count="0"] {
                display: none;
            }

            /* Objectives Section */
            .maze-objectives-section {
                width: 550px;
                max-width: 95vw;
                padding: 8px 12px;
                background: linear-gradient(135deg, rgba(52, 73, 94, 0.4) 0%, rgba(44, 62, 80, 0.4) 100%);
                border-radius: 8px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .maze-objectives-section.hidden {
                display: none;
            }

            .maze-objectives-section .objectives-header {
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 0.8em;
                color: #95a5a6;
                margin-bottom: 6px;
            }

            .maze-objectives-section .objectives-list {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .maze-objectives-section .objective-item {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 0.85em;
                padding: 4px 8px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
            }

            .maze-objectives-section .objective-item i {
                font-size: 0.9em;
            }

            .maze-objectives-section .objective-description {
                flex: 1;
            }

            .maze-objectives-section .objective-progress {
                font-weight: 500;
                font-size: 0.9em;
            }

            .maze-objectives-section .objective-required i {
                color: #e74c3c;
            }

            .maze-objectives-section .objective-optional i {
                color: #95a5a6;
            }

            .maze-objectives-section .objective-complete {
                opacity: 0.7;
            }

            .maze-objectives-section .objective-complete i {
                color: #27ae60 !important;
            }

            .maze-objectives-section.objectives-flash {
                animation: objectives-flash-anim 0.5s ease-out;
            }

            @keyframes objectives-flash-anim {
                0%, 100% {
                    border-color: rgba(255, 255, 255, 0.1);
                }
                50% {
                    border-color: #e74c3c;
                    box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
                }
            }

            /* Player Overlay for Smooth Movement Animation */
            .maze-player-overlay {
                position: absolute;
                top: 2px;
                left: 2px;
                pointer-events: none;
                z-index: 10;
                transition: transform 0.15s ease-out;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .maze-player-marker {
                width: 60%;
                height: 60%;
                background: radial-gradient(circle, #4ecdc4 0%, #2d8f8f 100%);
                border-radius: 50%;
                box-shadow: 0 0 10px rgba(78, 205, 196, 0.6), 0 0 20px rgba(78, 205, 196, 0.3);
                animation: player-pulse 1.5s ease-in-out infinite;
            }

            @keyframes player-pulse {
                0%, 100% { transform: scale(1); opacity: 1; }
                50% { transform: scale(1.1); opacity: 0.9; }
            }

            .maze-player-overlay.teleporting .maze-player-marker {
                animation: teleport-flash 0.2s ease-out;
            }

            @keyframes teleport-flash {
                0% { opacity: 1; transform: scale(1); }
                50% { opacity: 0; transform: scale(0.2); }
                100% { opacity: 1; transform: scale(1); }
            }

            /* Control Bar */
            .maze-action-buttons {
                display: flex;
                gap: 6px;
                justify-content: center;
                flex-wrap: wrap;
            }

            .mazemaster-maze-inventory {
                display: flex;
                flex-wrap: wrap;
                justify-content: space-evenly;
                background: rgba(0, 0, 0, 0.3);
                padding: 8px 12px;
                border-radius: 6px;
            }

            .inventory-item {
                display: flex;
                align-items: center;
                gap: 4px;
                font-size: 0.9em;
            }

            /* Inventory item icon colors */
            .inventory-item i.fa-key { color: #f1c40f; }
            .inventory-item i.fa-user-ninja { color: #9b59b6; }
            .inventory-item i.fa-bolt { color: #e74c3c; }
            .inventory-item.execute i { color: #ffd700; text-shadow: 0 0 4px #ffd700; }
            .inventory-item.floor-key i { color: #3498db; }
            .inventory-item.portal-stone i { color: #9b59b6; }
            .inventory-item.minion-bane i { color: #c0392b; }
            .inventory-item.map-fragment i { color: #27ae60; }
            .inventory-item.time-shard i { color: #f39c12; }
            .inventory-item.void-walk i { color: #7f8c8d; }

            /* Inventory expand icon */
            .inventory-expand-icon {
                margin-left: auto;
                padding-left: 8px;
                color: #888;
                cursor: pointer;
                transition: transform 0.2s;
            }
            .mazemaster-maze-inventory.expanded .inventory-expand-icon {
                transform: rotate(180deg);
            }
            .mazemaster-maze-inventory {
                cursor: pointer;
            }

            /* Inventory Drawer */
            .maze-inventory-drawer {
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: rgba(26, 26, 46, 0.98);
                border: 1px solid #444;
                border-top: none;
                border-radius: 0 0 8px 8px;
                padding: 10px 12px;
                z-index: 200;
                max-height: 300px;
                overflow-y: auto;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            }
            .maze-inventory-drawer.hidden {
                display: none;
            }
            .inventory-drawer-content {
                display: flex;
                flex-direction: column;
                gap: 6px;
            }
            .inventory-drawer-item {
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 6px 8px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 4px;
            }
            .inventory-drawer-item.empty {
                opacity: 0.4;
            }
            .inventory-drawer-item i {
                width: 20px;
                text-align: center;
            }
            .inventory-drawer-item .item-name {
                flex: 1;
                font-size: 0.9em;
            }
            .inventory-drawer-item .item-count {
                font-weight: bold;
                min-width: 24px;
                text-align: right;
            }
            /* Drawer item icon colors - match the bar */
            .inventory-drawer-item i.fa-key { color: #f1c40f; }
            .inventory-drawer-item i.fa-user-ninja { color: #9b59b6; }
            .inventory-drawer-item i.fa-bolt { color: #e74c3c; }
            .inventory-drawer-item.execute i { color: #ffd700; text-shadow: 0 0 4px #ffd700; }
            .inventory-drawer-item.floor-key i { color: #3498db; }
            .inventory-drawer-item.portal-stone i { color: #9b59b6; }
            .inventory-drawer-item.minion-bane i { color: #c0392b; }
            .inventory-drawer-item.map-fragment i { color: #27ae60; }
            .inventory-drawer-item.time-shard i { color: #f39c12; }
            .inventory-drawer-item.void-walk i { color: #7f8c8d; }

            /* Usable items have click cursor and glow */
            .inventory-item[data-usable="true"] {
                cursor: pointer;
                transition: transform 0.2s, box-shadow 0.2s;
            }
            .inventory-item[data-usable="true"]:hover {
                transform: scale(1.1);
                text-shadow: 0 0 8px currentColor;
            }
            .inventory-item.hidden { display: none; }

            .mazemaster-maze-save-exit {
                display: flex;
                gap: 8px;
                justify-content: center;
                margin-top: auto;
                padding-top: 10px;
            }

            /* Maze Area */
            .mazemaster-maze-area {
                position: relative; /* Required for action popup overlay positioning */
                width: 100%;
                height: 100%;
                overflow: hidden;
                cursor: grab;
                user-select: none;
                background: #0a0a1a;
                border-radius: 8px;
            }

            .mazemaster-maze-grid-wrapper {
                position: absolute;
                top: 0;
                left: 0;
                /* Position controlled by JS transforms */
            }

            /* Circular D-Pad */
            .maze-dpad {
                position: absolute;
                bottom: 60px;
                right: 20px;
                width: 140px;
                height: 140px;
                z-index: 100;
            }

            .maze-dpad.floating {
                position: fixed;
                z-index: 10001;
                bottom: 20px;
                right: 20px;
            }

            .dpad-ring {
                position: relative;
                width: 100%;
                height: 100%;
                border-radius: 50%;
                background: radial-gradient(circle, #2c3e50 0%, #1a1a2e 100%);
                border: 3px solid var(--theme-primary, #3498db);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            }

            .dpad-btn {
                position: absolute;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: linear-gradient(to bottom, var(--theme-primary, #3498db), var(--theme-secondary, #2980b9));
                border: 2px solid var(--theme-accent, #5dade2);
                color: white;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.15s;
                font-size: 1em;
            }

            .dpad-btn:hover {
                filter: brightness(1.2);
            }

            .dpad-btn:active {
                filter: brightness(0.9);
            }

            .dpad-up { top: 5px; left: 50%; transform: translateX(-50%); }
            .dpad-up:hover { transform: translateX(-50%) scale(1.1); }
            .dpad-up:active { transform: translateX(-50%) scale(0.95); }

            .dpad-right { right: 5px; top: 50%; transform: translateY(-50%); }
            .dpad-right:hover { transform: translateY(-50%) scale(1.1); }
            .dpad-right:active { transform: translateY(-50%) scale(0.95); }

            .dpad-down { bottom: 5px; left: 50%; transform: translateX(-50%); }
            .dpad-down:hover { transform: translateX(-50%) scale(1.1); }
            .dpad-down:active { transform: translateX(-50%) scale(0.95); }

            .dpad-left { left: 5px; top: 50%; transform: translateY(-50%); }
            .dpad-left:hover { transform: translateY(-50%) scale(1.1); }
            .dpad-left:active { transform: translateY(-50%) scale(0.95); }

            .dpad-center {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 30px;
                height: 30px;
                border-radius: 50%;
                background: #1a1a2e;
                border: 2px solid #34495e;
            }

            /* Floor navigation buttons - appear on LEFT side of D-pad when on stairs */
            .dpad-floor-up, .dpad-floor-down {
                position: absolute;
                width: 36px;
                height: 36px;
                border-radius: 8px;
                font-size: 0.65em;
                background: linear-gradient(to bottom, #27ae60, #1e8449);
                border: 2px solid #2ecc71;
                flex-direction: column;
                gap: 1px;
                z-index: 10;
                box-shadow: 0 2px 8px rgba(46, 204, 113, 0.5);
                left: -50px;
            }

            .dpad-floor-up {
                top: 15px;
            }
            .dpad-floor-up:hover {
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(46, 204, 113, 0.7);
            }
            .dpad-floor-up:active {
                transform: scale(0.95);
            }

            .dpad-floor-down {
                bottom: 15px;
                background: linear-gradient(to bottom, #e67e22, #d35400);
                border-color: #f39c12;
                box-shadow: 0 2px 8px rgba(243, 156, 18, 0.5);
            }
            .dpad-floor-down:hover {
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(243, 156, 18, 0.7);
            }
            .dpad-floor-down:active {
                transform: scale(0.95);
            }

            .dpad-floor-up.hidden, .dpad-floor-down.hidden {
                display: none !important;
            }

            .dpad-floor-up span, .dpad-floor-down span {
                font-size: 0.65em;
                font-weight: bold;
            }

            .dpad-drag-handle {
                position: absolute;
                bottom: -22px;
                left: 50%;
                transform: translateX(-50%);
                padding: 3px 8px;
                background: rgba(0, 0, 0, 0.5);
                border-radius: 4px;
                color: #666;
                font-size: 0.75em;
                cursor: grab;
                display: none;
            }

            .maze-dpad.floating .dpad-drag-handle {
                display: block;
            }

            .maze-dpad:not(.floating) .dpad-drag-handle {
                display: none;
            }

            /* Rest button - positioned top-right corner, away from directional buttons */
            .dpad-rest-btn {
                position: absolute;
                top: -15px;
                right: -15px;
                width: 36px;
                height: 36px;
                border-radius: 50%;
                background: linear-gradient(135deg, #14b8a6, #0d9488);
                border: 2px solid #2dd4bf;
                color: #fff;
                font-size: 14px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 2px 8px rgba(20, 184, 166, 0.4);
                transition: all 0.2s ease;
                z-index: 10;
            }

            .dpad-rest-btn:hover:not(:disabled) {
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(20, 184, 166, 0.6);
            }

            .dpad-rest-btn:active:not(:disabled) {
                transform: scale(0.95);
            }

            .dpad-rest-btn:disabled {
                background: linear-gradient(135deg, #6b7280, #4b5563);
                border-color: #9ca3af;
                cursor: not-allowed;
                opacity: 0.7;
            }

            .dpad-rest-btn .rest-cooldown-badge {
                position: absolute;
                bottom: -4px;
                right: -4px;
                min-width: 16px;
                height: 16px;
                padding: 0 4px;
                background: #ef4444;
                border-radius: 8px;
                font-size: 10px;
                font-weight: bold;
                color: #fff;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* Void Walk active indicator */
            .maze-dpad.void-walk-active .dpad-ring {
                animation: void-walk-pulse 1s infinite;
                border-color: #7f8c8d;
            }
            .maze-dpad.void-walk-active .dpad-btn {
                background: linear-gradient(to bottom, #7f8c8d, #5d6d7e);
                border-color: #95a5a6;
            }
            @keyframes void-walk-pulse {
                0%, 100% { box-shadow: 0 4px 15px rgba(127, 140, 141, 0.5); }
                50% { box-shadow: 0 4px 25px rgba(127, 140, 141, 0.8); }
            }

            .mazemaster-maze-grid {
                display: grid;
                gap: 0;
                background: #333;
                padding: 2px;
                border-radius: 5px;
                border: 2px solid #555;
            }

            .maze-cell {
                width: ${cellSize}px;
                height: ${cellSize}px;
                background: #1a1a2e;
                position: relative;
                box-sizing: border-box;
            }

            .maze-cell.hidden {
                background: #0a0a0a;
            }

            .maze-cell.completely-hidden {
                background: transparent;
                border: none !important;
                visibility: hidden;
            }

            .maze-cell.wall-top { border-top: 2px solid #fff; }
            .maze-cell.wall-right { border-right: 2px solid #fff; }
            .maze-cell.wall-bottom { border-bottom: 2px solid #fff; }
            .maze-cell.wall-left { border-left: 2px solid #fff; }

            /* Player marker now handled by .maze-player-overlay for smooth animation */
            .maze-cell.player {
                /* Player position cell styling - marker is in overlay */
            }

            .maze-cell.exit::before {
                content: '';
                position: absolute;
                top: 50%; left: 50%;
                transform: translate(-50%, -50%);
                width: 70%; height: 70%;
                background: #27ae60;
                border-radius: 3px;
            }

            .maze-cell.visited:not(.hidden) {
                background: #1e2a4a;
            }

            /* Legacy arrow buttons (kept for backwards compatibility) */
            .maze-arrow-btn {
                display: none; /* Hide legacy buttons */
            }

            /* Action buttons */
            .maze-action-btn {
                padding: 8px 14px;
                font-size: 0.85em;
                border-radius: 5px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
            }

            .maze-exit-btn {
                background: linear-gradient(to bottom, #555, #444) !important;
            }

            .maze-close-btn {
                padding: 10px 28px;
                font-size: 1em;
            }

            /* =====================================================
               ACTION POPUP OVERLAY (over map)
               ===================================================== */
            .maze-action-popup {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(0, 0, 0, 0.75);
                z-index: 100;
                backdrop-filter: blur(3px);
                animation: popupFadeIn 0.2s ease-out;
            }

            @keyframes popupFadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }

            .maze-action-popup-content {
                background: linear-gradient(145deg, #2a2a3a, #1a1a2a);
                border: 2px solid #4a4a6a;
                border-radius: 12px;
                padding: 20px 30px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(100, 100, 200, 0.2);
                min-width: 200px;
                max-width: 90%;
            }

            .maze-action-popup-buttons {
                display: flex;
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .maze-action-popup-buttons .menu_button,
            .maze-action-popup-buttons .maze-confirm-btn {
                padding: 12px 24px;
                font-size: 1.1em;
                font-weight: 600;
                border-radius: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                transition: all 0.15s ease;
                min-width: 150px;
            }

            .maze-action-popup-buttons .menu_button:hover,
            .maze-action-popup-buttons .maze-confirm-btn:hover {
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            }

            .maze-action-popup-buttons .maze-accept-btn {
                background: linear-gradient(145deg, #2ecc71, #27ae60) !important;
                border-color: #27ae60 !important;
            }

            .maze-action-popup-buttons .maze-slip-btn {
                background: linear-gradient(145deg, #9b59b6, #8e44ad) !important;
                border-color: #8e44ad !important;
            }

            .maze-cell.victory-glow {
                animation: victoryPulse 1s infinite;
            }

            @keyframes victoryPulse {
                0%, 100% { background: #27ae60; }
                50% { background: #2ecc71; }
            }

            /* =====================================================
               MOBILE / PORTRAIT LAYOUT (v1.2.0)
               ===================================================== */
            .layout-mobile .mazemaster-maze-container,
            #mazemaster_maze_modal.layout-mobile .mazemaster-maze-container {
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
                padding: 8px;
                gap: 6px;
                border-radius: 0;
                margin: 0;
            }

            .layout-mobile .mazemaster-maze-top {
                flex-direction: column;
                max-height: none;
                gap: 8px;
            }

            .layout-mobile .mazemaster-maze-hero {
                width: 100%;
                max-width: 100%;
                min-width: unset;
            }

            .layout-mobile .mazemaster-maze-info-col {
                width: 100%;
            }

            .layout-mobile .mazemaster-maze-buttons-col {
                flex-direction: row;
                width: 100%;
                justify-content: center;
            }

            .layout-mobile .mazemaster-maze-stats-bar {
                flex-wrap: wrap;
                gap: 6px;
                justify-content: center;
            }

            .layout-mobile .mazemaster-maze-inventory {
                flex-wrap: wrap;
                justify-content: center;
            }

            .layout-mobile .maze-action-buttons {
                flex-wrap: wrap;
                justify-content: center;
            }

            .layout-mobile .maze-dpad {
                position: fixed;
                bottom: 10px;
                right: 10px;
                z-index: 10000;
            }

            /* Make grid scrollable on mobile */
            .layout-mobile .maze-grid-area {
                overflow: auto;
                max-height: 50vh;
            }

            /* Larger touch targets on mobile */
            .layout-mobile .dpad-btn {
                min-width: 50px;
                min-height: 50px;
            }

            @media (max-width: 600px) {
                .mazemaster-maze-hero {
                    height: auto;
                    min-height: 80px;
                }

                .maze-message-log {
                    font-size: 0.85em;
                    max-height: 80px;
                }

                .stats-item {
                    font-size: 0.75em;
                    padding: 3px 6px;
                }

                .inventory-item {
                    padding: 4px 6px;
                    font-size: 0.85em;
                }
            }
        </style>
    `;

    document.body.appendChild(modal);

    // Initialize the renderer and insert grid/canvas into container
    const renderer = RendererRegistry.getRenderer();
    const gridContainer = document.getElementById('maze_grid_container');
    if (gridContainer) {
        // Insert renderer-specific grid HTML
        gridContainer.innerHTML = renderer.getGridHTML(currentMaze.size);
        // Add player overlay for CSS grid renderer (canvas renderers draw player on canvas)
        const overlayHTML = renderer.getPlayerOverlayHTML(cellSize);
        if (overlayHTML) {
            gridContainer.insertAdjacentHTML('beforeend', overlayHTML);
        }
        // Initialize renderer (gets canvas context for canvas-based renderers)
        renderer.init(gridContainer, currentMaze);
    }

    // Apply layout mode (responsive)
    applyLayoutMode();

    // Add D-Pad control handlers
    modal.querySelectorAll('.dpad-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const dir = btn.dataset.dir;
            if (dir === 'up') tryMazeMove(0, -1);
            else if (dir === 'down') tryMazeMove(0, 1);
            else if (dir === 'left') tryMazeMove(-1, 0);
            else if (dir === 'right') tryMazeMove(1, 0);
            else if (dir === 'floor-up') tryFloorChange('up');
            else if (dir === 'floor-down') tryFloorChange('down');
        });
        // Touch support for mobile
        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            btn.click();
        });
    });

    // Initialize D-Pad drag functionality
    initDpadDrag();

    // Rest button handler
    const restBtn = document.getElementById('maze_rest_btn');
    if (restBtn) {
        restBtn.addEventListener('click', () => handleRestAction());
        restBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleRestAction();
        });
    }

    // Initialize rest button state
    updateRestButton();

    // Initialize pinch-zoom and pan/drag for the map
    initMapPanZoom();

    // Inventory info button toggle (v1.3.0 redesign)
    const inventoryWrapper = document.getElementById('maze_inventory_wrapper');
    const inventoryBtn = document.getElementById('maze_inventory_btn');
    const inventoryMenu = document.getElementById('maze_inventory_menu');

    if (inventoryBtn && inventoryMenu) {
        inventoryBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isOpen = !inventoryMenu.classList.contains('hidden');
            if (isOpen) {
                inventoryMenu.classList.add('hidden');
                inventoryWrapper?.classList.remove('open');
            } else {
                inventoryMenu.classList.remove('hidden');
                inventoryWrapper?.classList.add('open');
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!inventoryWrapper?.contains(e.target)) {
                inventoryMenu.classList.add('hidden');
                inventoryWrapper?.classList.remove('open');
            }
        });
    }

    // Inventory menu item click handlers
    const menuItems = modal.querySelectorAll('.inventory-menu-item[data-usable="true"]');
    menuItems.forEach(item => {
        item.addEventListener('click', async (e) => {
            e.stopPropagation();
            const itemType = item.dataset.item;
            const hpItem = item.dataset.hpItem;

            if (hpItem) {
                await useHPItem(hpItem);
            } else if (itemType === 'portalStone') {
                await usePortalStone();
            } else if (itemType === 'mapFragment') {
                await useMapFragment();
            } else if (itemType === 'voidWalk') {
                activateVoidWalk();
            } else if (item.dataset.visItem) {
                await useVisibilityItem(item.dataset.visItem);
            }

            // Close menu after use
            inventoryMenu?.classList.add('hidden');
            inventoryWrapper?.classList.remove('open');
        });
    });

    // Apply theme colors
    applyThemeColors(currentMaze.profile);

    // Close button handler
    const closeBtn = document.getElementById('maze_close_btn');
    if (closeBtn) {
        closeBtn.addEventListener('click', closeMaze);
        closeBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            closeMaze();
        });
    }

    // Power button handler - shows custom save dialog with Yes/No/Cancel
    const powerHandler = () => {
        showSaveDialog();
    };
    document.getElementById('maze_power_btn')?.addEventListener('click', powerHandler);

    // Session Memory button handler (v1.4.6)
    const memoryBtn = document.getElementById('maze_memory_btn');
    const memoryPanel = document.getElementById('maze_memory_panel');
    const memoryBackdrop = document.getElementById('maze_memory_backdrop');
    const memoryTextarea = document.getElementById('maze_memory_textarea');
    const memorySaveBtn = document.getElementById('maze_memory_save');
    const memoryCloseBtn = document.getElementById('maze_memory_close');

    const openMemoryPanel = () => {
        if (memoryPanel && memoryBackdrop && memoryTextarea) {
            // Load current notes into textarea
            memoryTextarea.value = currentMaze.sessionNotes || '';
            memoryPanel.style.display = 'flex';
            memoryBackdrop.style.display = 'block';
            memoryBtn?.classList.add('active');
            memoryTextarea.focus();
        }
    };

    const closeMemoryPanel = (save = false) => {
        if (save && memoryTextarea) {
            currentMaze.sessionNotes = memoryTextarea.value;
            // Auto-save on close
            saveMazeProgress();
            console.log('[MazeMaster] Session notes saved');
        }
        if (memoryPanel) memoryPanel.style.display = 'none';
        if (memoryBackdrop) memoryBackdrop.style.display = 'none';
        memoryBtn?.classList.remove('active');
    };

    memoryBtn?.addEventListener('click', openMemoryPanel);
    memoryCloseBtn?.addEventListener('click', () => closeMemoryPanel(true)); // Save on close
    memoryBackdrop?.addEventListener('click', () => closeMemoryPanel(true)); // Save on backdrop click
    memorySaveBtn?.addEventListener('click', () => {
        if (memoryTextarea) {
            currentMaze.sessionNotes = memoryTextarea.value;
            saveMazeProgress();
            console.log('[MazeMaster] Session notes saved');
            // Flash the button to indicate save
            memorySaveBtn.textContent = 'Saved!';
            setTimeout(() => {
                memorySaveBtn.textContent = 'Save Notes';
            }, 1500);
        }
    });
}

/**
 * Show custom save dialog with Yes/No/Cancel buttons
 */
function showSaveDialog() {
    // Remove any existing dialog
    const existingDialog = document.getElementById('maze_save_dialog');
    if (existingDialog) existingDialog.remove();

    const dialog = document.createElement('div');
    dialog.id = 'maze_save_dialog';
    dialog.innerHTML = `
        <div class="maze-save-dialog-backdrop"></div>
        <div class="maze-save-dialog-content">
            <div class="maze-save-dialog-title">Do you wish to save?</div>
            <div class="maze-save-dialog-buttons">
                <button id="maze_save_yes" class="maze-save-btn maze-save-yes">Yes</button>
                <button id="maze_save_no" class="maze-save-btn maze-save-no">No</button>
                <button id="maze_save_cancel" class="maze-save-btn maze-save-cancel">Cancel</button>
            </div>
        </div>
    `;

    const modal = document.getElementById('mazemaster_maze_modal');
    if (modal) {
        modal.appendChild(dialog);
    } else {
        document.body.appendChild(dialog);
    }

    // Button handlers
    document.getElementById('maze_save_yes').addEventListener('click', () => {
        dialog.remove();
        saveMazeProgress();
        closeMaze();
        renderSavedGamesList();
    });

    document.getElementById('maze_save_no').addEventListener('click', () => {
        dialog.remove();
        closeMaze();
    });

    document.getElementById('maze_save_cancel').addEventListener('click', () => {
        dialog.remove();
    });

    // Backdrop click = cancel
    dialog.querySelector('.maze-save-dialog-backdrop').addEventListener('click', () => {
        dialog.remove();
    });
}

function closeMaze() {
    currentMaze.isOpen = false;
    document.removeEventListener('keydown', handleMazeKeydown, { capture: true });

    const modal = document.getElementById('mazemaster_maze_modal');
    if (modal) modal.remove();
}

function renderMazeGrid() {
    // Delegate to the pluggable renderer system
    const renderer = RendererRegistry.getRenderer();
    renderer.render(currentMaze);
}

/**
 * Add an entry to the session notes (auto-populated adventure log)
 * @param {string} entry - The log entry text
 * @param {string} category - Optional category for the entry (encounter, item, story, etc.)
 */
function addSessionNote(entry, category = '') {
    if (!currentMaze || !entry) return;

    // Format timestamp as HH:MM
    const now = new Date();
    const time = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });

    // Format the entry with optional category prefix
    const prefix = category ? `[${category}] ` : '';
    const formattedEntry = `${time} - ${prefix}${entry}`;

    // Append to session notes
    if (currentMaze.sessionNotes) {
        currentMaze.sessionNotes += '\n' + formattedEntry;
    } else {
        currentMaze.sessionNotes = formattedEntry;
    }

    // Update textarea if panel is open
    const textarea = document.getElementById('maze_memory_textarea');
    if (textarea && document.getElementById('maze_memory_panel')?.style.display !== 'none') {
        textarea.value = currentMaze.sessionNotes;
        // Auto-scroll to bottom
        textarea.scrollTop = textarea.scrollHeight;
    }
}

/**
 * Add a message to the maze message log and render it
 * @param {string} speaker - Name of who's speaking
 * @param {string} message - The message text
 * @param {boolean} skipSave - If true, don't save to persistent log (for re-rendering)
 */
function addMazeMessage(speaker, message, skipSave = false) {
    if (!message) return;

    // Add to persistent log (unless we're just re-rendering)
    if (!skipSave) {
        currentMaze.messageLog.push({ speaker, message, timestamp: Date.now() });
    }

    // Render the message log
    renderMessageLog();
}

/**
 * Render the entire message log to the UI
 */
function renderMessageLog() {
    const logEl = document.getElementById('maze_message_log');
    if (!logEl) return;

    logEl.innerHTML = currentMaze.messageLog.map(entry => `
        <div class="maze-message-entry">
            <div class="maze-message-speaker">${escapeHtml(entry.speaker)}</div>
            <div class="maze-message-text">${escapeHtml(entry.message)}</div>
        </div>
    `).join('');

    // Auto-scroll to the latest message
    logEl.scrollTop = logEl.scrollHeight;
}

function updateMazeHero() {
    const { currentMinion, isVictory, profile, messageLog } = currentMaze;

    const imgEl = document.getElementById('maze_minion_img');
    const nameEl = document.getElementById('maze_minion_name');
    const roleEl = document.getElementById('maze_minion_role');

    if (isVictory) {
        // Victory state
        if (profile.winImage && imgEl) {
            imgEl.src = getExtensionImagePath(profile.winImage);
            imgEl.style.display = '';
        }
        if (nameEl) nameEl.textContent = 'Victory!';
        if (roleEl) roleEl.textContent = '';

        // Add victory message to log
        const victoryMessage = profile.winMessage || 'You escaped the maze!';
        const lastEntry = messageLog[messageLog.length - 1];
        if (!lastEntry || lastEntry.message !== victoryMessage) {
            addMazeMessage('Victory!', victoryMessage);
        }
    } else if (currentMinion) {
        // Normal minion display
        if (currentMinion.imagePath && imgEl) {
            imgEl.src = getExtensionImagePath(currentMinion.imagePath);
            imgEl.style.display = 'block';
        } else if (imgEl) {
            imgEl.style.display = 'none';
        }
        if (nameEl) nameEl.textContent = currentMinion.name || '';
        if (roleEl) roleEl.textContent = currentMinion.role || '';

        // Add message to log if it's new (avoid duplicating the same message)
        if (currentMinion.message) {
            const lastEntry = messageLog[messageLog.length - 1];
            if (!lastEntry || lastEntry.message !== currentMinion.message) {
                addMazeMessage(currentMinion.name || 'Unknown', currentMinion.message);
            }
        }
    }

    // Render the message log (in case we're restoring state)
    renderMessageLog();
}

/**
 * Show or hide the LLM generating indicator
 * Also updates the player gem indicator color (orange when generating)
 */
function showGeneratingIndicator(show) {
    const indicator = document.getElementById('maze_generating_indicator');
    if (indicator) {
        indicator.classList.toggle('active', show);
    }

    // v1.4.8: Update global state for player gem indicator
    isLLMGenerating = show;

    // Trigger re-render to update player gem color
    if (currentMaze?.isOpen) {
        renderMazeGrid();
    }
}

/**
 * Update the room info box with current cell information
 */
function updateRoomInfoBox() {
    if (!currentMaze.isOpen) return;

    const { playerX, playerY, grid } = currentMaze;
    const cell = grid[playerY]?.[playerX];
    if (!cell) return;

    // Update name & description
    const nameEl = document.getElementById('room_info_name');
    const descEl = document.getElementById('room_info_desc');
    if (nameEl) nameEl.textContent = cell.roomInfo?.name || 'Unknown Room';

    // v1.4.8: Use enhanced description if available, otherwise fall back to base
    const floor = currentMaze.currentFloor || 0;
    const roomKey = `${floor}:${playerX},${playerY}`;
    const enhancedDesc = currentMaze.enhancedRooms?.[roomKey] || cell.roomInfo?.enhancedDescription;
    let description = enhancedDesc || cell.roomInfo?.description || '...';

    // v1.4.1: Add secret passage hints based on hint level
    if (cell.secretPassage && !cell.secretPassage.revealed) {
        const hintLevel = cell.secretPassage.hintLevel || 0;
        const direction = cell.secretPassage.direction;
        const dirName = direction === 'top' ? 'north' : direction === 'bottom' ? 'south' :
                        direction === 'left' ? 'west' : 'east';

        if (hintLevel >= 3) {
            description += ` <span style="color: #ffcc00;"><i class="fa-solid fa-eye"></i> A hidden passage is clearly visible to the ${dirName}!</span>`;
        } else if (hintLevel >= 2) {
            description += ` <span style="color: #aaaaaa;"><i class="fa-solid fa-question"></i> The ${dirName} wall has suspicious cracks...</span>`;
        } else if (hintLevel >= 1) {
            description += ` <span style="color: #666666;"><i class="fa-solid fa-wind"></i> A faint draft from the ${dirName}...</span>`;
        }
    }

    if (descEl) descEl.innerHTML = description;

    // Update exits based on walls - show direction and room name
    const exitsEl = document.getElementById('room_info_exits');
    if (exitsEl) {
        const exits = [];
        const size = currentMaze.size;

        // North (top wall = y-1)
        if (!cell.walls.top && playerY > 0) {
            const northCell = grid[playerY - 1]?.[playerX];
            const roomName = northCell?.roomInfo?.name || 'Unknown';
            exits.push(`North  ${roomName}`);
        }
        // East (right wall = x+1)
        if (!cell.walls.right && playerX < size - 1) {
            const eastCell = grid[playerY]?.[playerX + 1];
            const roomName = eastCell?.roomInfo?.name || 'Unknown';
            exits.push(`East  ${roomName}`);
        }
        // South (bottom wall = y+1)
        if (!cell.walls.bottom && playerY < size - 1) {
            const southCell = grid[playerY + 1]?.[playerX];
            const roomName = southCell?.roomInfo?.name || 'Unknown';
            exits.push(`South  ${roomName}`);
        }
        // West (left wall = x-1)
        if (!cell.walls.left && playerX > 0) {
            const westCell = grid[playerY]?.[playerX - 1];
            const roomName = westCell?.roomInfo?.name || 'Unknown';
            exits.push(`West  ${roomName}`);
        }

        // Up/Down staircases
        if (cell.staircase) {
            const targetFloor = cell.staircase.targetFloor;
            const targetX = cell.staircase.targetX;
            const targetY = cell.staircase.targetY;
            const targetGrid = currentMaze.floorsData?.[targetFloor]?.grid || currentMaze.floors?.[targetFloor];
            const targetCell = targetGrid?.[targetY]?.[targetX];
            const targetRoomName = targetCell?.roomInfo?.name || `Floor ${targetFloor + 1}`;

            if (cell.staircase.direction === 'up') {
                exits.push(`<i class="fa-solid fa-stairs"></i> Up  ${targetRoomName}`);
            } else if (cell.staircase.direction === 'down') {
                exits.push(`<i class="fa-solid fa-stairs"></i> Down  ${targetRoomName}`);
            }
        }

        exitsEl.innerHTML = exits.length ? exits.join('<br>') : 'None';
    }

    // Update occupants (active minions)
    const occupantsEl = document.getElementById('room_info_occupants');
    if (occupantsEl) {
        const occupants = [];
        if (cell.minion && !cell.minion.defeated && !cell.minion.triggered) {
            const minion = getMinion(cell.minion.minionId);
            occupants.push(minion?.name || 'Unknown Entity');
        }
        if (cell.chest && !cell.chest.opened) {
            occupants.push(cell.chest.type === 'locked' ? 'Locked Chest' : 'Chest');
        }
        if (cell.trap && !cell.trap.triggered) {
            occupants.push('Something feels off...');
        }
        occupantsEl.textContent = occupants.length ? occupants.join(', ') : 'None';
    }

    // Update defeated list
    const defeatedEl = document.getElementById('room_info_defeated');
    if (defeatedEl) {
        const defeated = [];
        if (cell.minion?.defeated || cell.minion?.triggered) {
            const minion = getMinion(cell.minion.minionId);
            defeated.push(minion?.name || 'Unknown');
        }
        if (cell.chest?.opened) {
            defeated.push('Opened Chest');
        }
        if (cell.trap?.triggered) {
            defeated.push('Triggered Trap');
        }
        defeatedEl.textContent = defeated.length ? defeated.join(', ') : 'None';
    }
}

function handleMazeKeydown(e) {
    if (!currentMaze.isOpen || currentMaze.isVictory) return;

    // v1.2.0: SHIFT+Arrow for floor changes
    if (e.shiftKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
        const floorDir = e.key === 'ArrowUp' ? 'up' : 'down';
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        tryFloorChange(floorDir);
        return;
    }

    let dx = 0, dy = 0;
    if (e.key === 'ArrowUp') dy = -1;
    else if (e.key === 'ArrowDown') dy = 1;
    else if (e.key === 'ArrowLeft') dx = -1;
    else if (e.key === 'ArrowRight') dx = 1;
    else return;

    // Block event from reaching ST's swipe handlers
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    tryMazeMove(dx, dy);
}

async function tryMazeMove(dx, dy) {
    if (!currentMaze.isOpen || currentMaze.isVictory) return;

    // Don't allow movement if paused (encounter in progress)
    if (currentMaze.isPaused) return;

    const { playerX, playerY, grid, size } = currentMaze;
    const newX = playerX + dx;
    const newY = playerY + dy;

    // Check bounds
    if (newX < 0 || newX >= size || newY < 0 || newY >= size) return;

    // Check walls (with Void Walk support)
    const currentCell = grid[playerY][playerX];
    let blockedByWall = false;
    if (dx === 1 && currentCell.walls.right) blockedByWall = true;
    if (dx === -1 && currentCell.walls.left) blockedByWall = true;
    if (dy === 1 && currentCell.walls.bottom) blockedByWall = true;
    if (dy === -1 && currentCell.walls.top) blockedByWall = true;

    // v1.2.0: Void Walk allows phasing through one wall
    if (blockedByWall) {
        if (currentMaze.voidWalkActive) {
            // Phase through the wall, consume the Void Walk
            await consumeVoidWalk();
            blockedByWall = false;
        } else {
            // v1.4.0: Try secret discovery when bumping a wall
            const direction = dx === 1 ? 'right' : dx === -1 ? 'left' : dy === 1 ? 'bottom' : 'top';
            const discoveryResult = trySecretDiscovery(currentCell, direction);
            if (discoveryResult.found) {
                // Secret was discovered! Open the passage
                revealSecretPassage(grid, playerX, playerY, direction);
                addMazeMessage('Secret Found!', 'You discovered a hidden passage!');
                await fireHook('onSecretFound', { x: playerX, y: playerY, direction });
                blockedByWall = false;
            } else if (discoveryResult.attempted) {
                addMazeMessage('Wall', discoveryResult.message || 'The wall seems solid...');
                return;
            } else {
                return; // Normal block
            }
        }
    } else if (currentMaze.voidWalkActive) {
        // If Void Walk is active but no wall was encountered, cancel it
        cancelVoidWalk();
    }

    // v1.4.0: Check zone blocking
    const targetCell = grid[newY][newX];
    if (targetCell.zoneId !== undefined && targetCell.zoneId !== null) {
        const floorData = currentMaze.floorsData?.[currentMaze.currentFloor];
        const zone = floorData?.zones?.[targetCell.zoneId];
        if (zone && !zone.isUnlocked) {
            addMazeMessage('Zone Locked', zone.lockedMessage || `${zone.name} is sealed. Clear more rooms to unlock.`);
            return;
        }
    }

    // Determine direction for hook and sprite facing
    const direction = dx === 1 ? 'right' : dx === -1 ? 'left' : dy === 1 ? 'down' : 'up';
    // Convert to compass for sprite facing (right=east, left=west, down=south, up=north)
    const compassDirection = dx === 1 ? 'east' : dx === -1 ? 'west' : dy === 1 ? 'south' : 'north';

    // Move player
    currentMaze.playerX = newX;
    currentMaze.playerY = newY;
    currentMaze.playerDirection = compassDirection;

    // Reveal tiles within visibility radius (with line-of-sight checking)
    const gridSize = currentMaze.grid.length;
    applyVisibilityAtPosition(newX, newY, gridSize);
    currentMaze.moveCount++;

    // Update visibility timers (torch burnout, etc.)
    updateVisibilityOnMove();

    // Track move stat
    await incrementStat('moves', 1);

    // Fire onMove hook
    await fireHook('onMove', { x: newX, y: newY, direction });

    // Decrement rest cooldown
    decrementRestCooldown();

    // Update stats display
    updateStatsDisplay();

    // Update floor buttons based on current tile (staircase check)
    updateDpadFloorButtons();

    // Check for exploration complete
    checkExplorationComplete();

    // Animate player movement
    updatePlayerPosition(true);

    // Update grid (fog of war, etc.)
    renderMazeGrid();

    // Center camera on player (smooth pan)
    if (typeof window.mazeCenterOnPlayer === 'function') {
        window.mazeCenterOnPlayer(true);
    }

    // Check for exit - only on final floor
    if (newX === currentMaze.exitX && newY === currentMaze.exitY &&
        currentMaze.currentFloor === currentMaze.totalFloors - 1) {
        handleExitReached();
        return;
    }

    const cell = grid[newY][newX];

    // Check for chest encounter (before minions)
    if (cell.chest && !cell.chest.opened) {
        triggerChestEncounter(cell.chest, newX, newY);
        return;
    }

    // Check for minion encounter
    if (cell.minion && !cell.minion.triggered) {
        triggerMinionEncounter(cell.minion.minionId, newX, newY);
        return;
    }

    // Check for trap encounter
    if (cell.trap && !cell.trap.triggered) {
        triggerTrapEncounter(cell.trap.trapId, newX, newY);
        return;
    }

    // Check for safe room (HP system - popup with Heal/Ignore)
    if (cell.safeRoom && !cell.safeRoom.exhausted && currentMaze.hpEnabled && currentMaze.hp) {
        triggerSafeRoomEncounter(newX, newY);
        return;
    }

    // Check for portal teleportation
    if (cell.portal) {
        const teleported = await handleTeleport(newX, newY, cell.portal);
        if (teleported) {
            // Re-render grid after teleport
            renderMazeGrid();
            // Center camera on new player position
            if (typeof window.mazeCenterOnPlayer === 'function') {
                window.mazeCenterOnPlayer(true);
            }
            // Check destination cell for encounters
            const destCell = grid[currentMaze.playerY][currentMaze.playerX];
            if (destCell.chest && !destCell.chest.opened) {
                triggerChestEncounter(destCell.chest, currentMaze.playerX, currentMaze.playerY);
                return;
            }
            if (destCell.minion && !destCell.minion.triggered) {
                triggerMinionEncounter(destCell.minion.minionId, currentMaze.playerX, currentMaze.playerY);
                return;
            }
            if (destCell.trap && !destCell.trap.triggered) {
                triggerTrapEncounter(destCell.trap.trapId, currentMaze.playerX, currentMaze.playerY);
                return;
            }
        }
    }

    // Check for main minion random message
    maybeShowMainMinionMessage();

    // Check story milestones
    checkStoryMilestones();

    // v1.4.8: Enhance room description on first entry (async, non-blocking for movement)
    enhanceRoomOnEntry(newX, newY);

    // Process moving minions after player's move
    await processMinionMovement();

    // Re-render grid if minions moved
    if (currentMaze.movingMinions && currentMaze.movingMinions.length > 0) {
        renderMazeGrid();
    }
}

/**
 * Handle reaching the exit tile
 */
async function handleExitReached() {
    const profile = currentMaze.profile;

    // Check if all required objectives are complete
    if (!canWinMaze()) {
        // Show message that objectives need to be completed
        const mainMinion = profile.mainMinion ? getMinion(profile.mainMinion) : null;
        currentMaze.currentMinion = {
            name: mainMinion?.name || 'Exit',
            imagePath: mainMinion?.imagePath || '',
            message: "You haven't completed all required objectives yet! Explore the maze to find what you need.",
        };
        updateMazeHero();

        // Flash the objectives display
        const objectivesSection = document.querySelector('.maze-objectives-section');
        if (objectivesSection) {
            objectivesSection.classList.add('objectives-flash');
            setTimeout(() => objectivesSection.classList.remove('objectives-flash'), 500);
        }
        return;
    }

    // If no main minion or exit encounter already done, just win
    if (!profile.mainMinion || currentMaze.exitEncounterDone) {
        handleMazeWin();
        return;
    }

    const mainMinion = getMinion(profile.mainMinion);
    if (!mainMinion) {
        handleMazeWin();
        return;
    }

    // Pause for exit encounter
    currentMaze.isPaused = true;

    // Show main minion as final boss
    currentMaze.currentMinion = {
        name: mainMinion.name,
        imagePath: mainMinion.imagePath,
        message: "You've reached the exit... but first, face me!",
    };
    updateMazeHero();

    const exitType = profile.mainMinionExitType || 'messenger';
    const exitProfile = profile.mainMinionExitProfile;

    switch (exitType) {
        case 'messenger':
            await delay(2000);
            currentMaze.exitEncounterDone = true;
            currentMaze.isPaused = false;
            handleMazeWin();
            break;

        case 'battlebar':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_battlebar', profile: exitProfile };
                startBattlebar(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'prizewheel':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_wheel', profile: exitProfile };
                loadWheelFromProfile(exitProfile);
                showWheelModal();
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'turnbased':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_turnbased', profile: exitProfile };
                startTurnBased(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'qte':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_qte', profile: exitProfile };
                startQTE(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'dice':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_dice', profile: exitProfile };
                startDice(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'stealth':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_stealth', profile: exitProfile };
                startStealth(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'puzzle':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_puzzle', profile: exitProfile };
                startPuzzle(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        case 'negotiation':
            if (exitProfile) {
                currentMaze.pendingEncounter = { type: 'exit_negotiation', profile: exitProfile };
                startNegotiation(exitProfile);
            } else {
                currentMaze.exitEncounterDone = true;
                currentMaze.isPaused = false;
                handleMazeWin();
            }
            break;

        default:
            handleMazeWin();
    }
}

/**
 * Trigger a minion encounter when stepping on a minion tile
 */
async function triggerMinionEncounter(minionId, x, y) {
    const minion = getMinion(minionId);
    if (!minion) {
        console.warn(`[MazeMaster] Minion "${minionId}" not found`);
        return;
    }

    // Double-check not already triggered (safety check)
    const cell = currentMaze.grid[y][x];
    if (cell.minion?.triggered) {
        console.log(`[MazeMaster] Minion at ${x},${y} already triggered, skipping`);
        return;
    }

    // Mark as triggered FIRST
    cell.minion.triggered = true;
    console.log(`[MazeMaster] Marked minion at ${x},${y} as triggered`);

    // Log encounter to session notes
    const minionType = minion.type || 'messenger';
    addSessionNote(`Encountered ${minion.name} (${minionType})`, 'Encounter');

    // v1.2.0: Check for Minion Bane - auto-defeat non-messenger minions
    if (minionType !== 'messenger' && currentMaze.inventory.minionBane > 0) {
        const baneUsed = await checkMinionBane();
        if (baneUsed) {
            // Auto-defeat the minion
            cell.minion.defeated = true;
            await incrementStat('encountersWon', 1);
            await updateObjectiveProgress('defeat', minionId, 1);
            // v1.4.0: Mark room as cleared for zone progression
            await markRoomCleared(x, y);
            renderMazeGrid();

            // Brief pause then resume
            setTimeout(() => {
                currentMaze.isPaused = false;
                resetMazeHero();
            }, 2000);
            return;
        }
    }

    // Track encounter stat
    await incrementStat('encountersTotal', 1);

    // Update defeat objective (counts when encountered - for battlebar types, this may be premature but we track the encounter)
    await updateObjectiveProgress('defeat', minionId, 1);

    // Pause maze
    currentMaze.isPaused = true;

    // Show minion with placeholder immediately
    currentMaze.currentMinion = {
        name: minion.name,
        imagePath: minion.imagePath,
        message: '...',
    };
    updateMazeHero();
    renderMazeGrid();

    // Get base message
    const baseMessage = getRandomFromArray(minion.messages) || `You encountered ${minion.name}!`;

    // Show generating indicator
    showGeneratingIndicator(true);

    // Generate LLM message if enabled
    let message = baseMessage;
    try {
        message = await generateMinionMessage({
            minionName: minion.name,
            minionDescription: minion.description,
            baseMessage: baseMessage,
            mainStory: getMainStory(),
            currentMilestone: getCurrentMilestone(),
            minionType: minion.type || 'messenger',
        });
    } catch (error) {
        console.error('[MazeMaster] LLM generation error:', error);
    }

    // Hide generating indicator
    showGeneratingIndicator(false);

    // Update with actual message
    currentMaze.currentMinion.message = message;
    updateMazeHero();

    // Execute encounter script if present
    if (minion.encounterScript && minion.encounterScript.trim()) {
        console.log(`[MazeMaster] Executing encounter script for ${minion.name}`);
        await executeWithTimeout(minion.encounterScript);
    }

    // Show confirmation buttons instead of auto-triggering (minionType already defined above)
    showEncounterConfirmation(minionId, x, y, minion.type || 'messenger');
}

/**
 * Trigger a trap encounter when stepping on a trap tile
 */
async function triggerTrapEncounter(trapId, x, y) {
    const trap = getTrap(trapId);
    if (!trap) {
        console.warn(`[MazeMaster] Trap "${trapId}" not found`);
        return;
    }

    // Check for avoidance (future: modified by player stats)
    const avoidChance = trap.avoidChance ?? 0;
    if (avoidChance > 0) {
        const roll = Math.random() * 100;
        if (roll < avoidChance) {
            // Trap avoided!
            console.log(`[MazeMaster] Trap "${trap.name}" avoided (rolled ${roll.toFixed(1)} vs ${avoidChance}%)`);

            // Mark as triggered (used up)
            currentMaze.grid[y][x].trap.triggered = true;
            renderMazeGrid();

            // Track avoided trap stat
            await incrementStat('trapsAvoided', 1);

            // Show avoid message
            const avoidMessage = trap.avoidMessage || `You skillfully avoided the ${trap.name}!`;
            addMazeMessage('Trap Avoided', avoidMessage);

            // Execute avoid script if present
            if (trap.avoidScript && trap.avoidScript.trim()) {
                console.log(`[MazeMaster] Executing avoid script for ${trap.name}`);
                await executeWithTimeout(trap.avoidScript);
            }

            // Don't execute trap script, just continue
            return;
        }
    }

    // Mark as triggered
    currentMaze.grid[y][x].trap.triggered = true;
    renderMazeGrid();

    // Log to session notes
    addSessionNote(`Triggered trap: ${trap.name}`, 'Trap');

    // Track trap stat
    await incrementStat('trapsTriggered', 1);

    // Pause maze
    currentMaze.isPaused = true;

    // Show trap in hero section with placeholder
    currentMaze.currentMinion = {
        name: trap.name,
        imagePath: trap.imagePath,
        message: '...',
    };
    updateMazeHero();

    // Show generating indicator
    showGeneratingIndicator(true);

    // Generate LLM message for trap
    const baseMessage = trap.message || 'You triggered a trap!';
    let message = baseMessage;
    try {
        message = await generateTrapMessage({
            trapName: trap.name,
            baseMessage: baseMessage,
            mainStory: getMainStory(),
        });
    } catch (error) {
        console.error('[MazeMaster] Trap LLM generation error:', error);
    }

    // Hide generating indicator
    showGeneratingIndicator(false);

    // Update with actual message
    currentMaze.currentMinion.message = message;
    updateMazeHero();

    // Execute trap script if present (script can use /mazedamage to deal HP damage)
    if (trap.script && trap.script.trim()) {
        console.log(`[MazeMaster] Executing trap script for ${trap.name}`);
        await executeWithTimeout(trap.script);
    }

    // Show a continue button
    showTrapContinueButton(x, y);
}

/**
 * Show continue button after trap encounter
 */
function showTrapContinueButton(x, y) {
    const buttons = `<button id="maze_trap_continue" class="menu_button maze-confirm-btn">Continue</button>`;
    showActionPopup(buttons);

    document.getElementById('maze_trap_continue')?.addEventListener('click', () => {
        hideActionPopup();
        resumeMaze();
    });
}

/**
 * Resume maze after an encounter completes
 */
function resumeMaze() {
    currentMaze.isPaused = false;
    currentMaze.pendingEncounter = null;

    // Clear action buttons
    const confirmEl = document.getElementById('maze_encounter_confirm');
    if (confirmEl) {
        confirmEl.innerHTML = '';
        confirmEl.style.display = 'none';
    }

    // Restore main minion display if configured
    const profile = currentMaze.profile;
    if (profile.mainMinion) {
        const mainMinion = getMinion(profile.mainMinion);
        if (mainMinion) {
            currentMaze.currentMinion = {
                name: mainMinion.name,
                imagePath: mainMinion.imagePath,
                message: 'Continue onward...',
            };
            updateMazeHero();
            return;
        }
    }

    // Otherwise restore default
    currentMaze.currentMinion = getDefaultMinion();
    updateMazeHero();
}

/**
 * Populate the inventory drawer with themed item names
 */
function populateInventoryDrawer() {
    const drawer = document.querySelector('.inventory-drawer-content');
    if (!drawer) return;

    const profile = currentMaze.profile;
    const inv = currentMaze.inventory;

    const items = [
        { id: 'key', icon: 'fa-key', colorClass: '' },
        { id: 'stealth', icon: 'fa-user-ninja', colorClass: '' },
        { id: 'strike', icon: 'fa-bolt', colorClass: '' },
        { id: 'execute', icon: 'fa-star', colorClass: 'execute' },
        { id: 'floorKey', icon: 'fa-stairs', colorClass: 'floor-key' },
        { id: 'portalStone', icon: 'fa-gem', colorClass: 'portal-stone' },
        { id: 'minionBane', icon: 'fa-skull-crossbones', colorClass: 'minion-bane' },
        { id: 'mapFragment', icon: 'fa-scroll', colorClass: 'map-fragment' },
        { id: 'timeShard', icon: 'fa-hourglass-half', colorClass: 'time-shard' },
        { id: 'voidWalk', icon: 'fa-ghost', colorClass: 'void-walk' },
    ];

    drawer.innerHTML = items.map(item => {
        const count = inv[item.id] || 0;
        const themedName = getThemedItemName(item.id, profile);
        const emptyClass = count === 0 ? 'empty' : '';
        return `
            <div class="inventory-drawer-item ${item.colorClass} ${emptyClass}">
                <i class="fa-solid ${item.icon}"></i>
                <span class="item-name">${themedName}</span>
                <span class="item-count">x${count}</span>
            </div>
        `;
    }).join('');
}

/**
 * Update the inventory display in the maze modal
 */
function updateInventoryDisplay() {
    // Helper to update an element and its parent visibility
    const updateItemElement = (id, value, overlayId = null) => {
        const el = document.getElementById(id);
        if (el) {
            el.textContent = value;
        }
        // Also update overlay element if provided
        if (overlayId) {
            const ovEl = document.getElementById(overlayId);
            if (ovEl) {
                ovEl.textContent = value;
                // Show/hide overlay item based on count
                const parent = ovEl.closest('.inv-overlay-item');
                if (parent) {
                    parent.style.display = value > 0 ? '' : 'none';
                }
            }
        }
    };

    // Core items with overlay equivalents
    updateItemElement('maze_inv_key', currentMaze.inventory.key, 'maze_ov_key');
    updateItemElement('maze_inv_stealth', currentMaze.inventory.stealth, 'maze_ov_stealth');
    updateItemElement('maze_inv_pow', currentMaze.inventory.strike, 'maze_ov_strike');
    updateItemElement('maze_inv_execute', currentMaze.inventory.execute || 0, 'maze_ov_execute');

    // v1.2.0 new items
    const newItems = ['floorKey', 'portalStone', 'minionBane', 'mapFragment', 'timeShard', 'voidWalk'];
    for (const item of newItems) {
        const value = currentMaze.inventory[item] || 0;
        updateItemElement(`maze_inv_${item}`, value, `maze_ov_${item}`);
    }

    // v1.3.0 HP System items
    const hpItems = ['healingPotion', 'greaterHealing', 'elixir', 'revivalCharm', 'heartCrystal'];
    for (const item of hpItems) {
        const value = currentMaze.inventory[item] || 0;
        updateItemElement(`maze_inv_${item}`, value, `maze_ov_${item}`);
    }

    // v1.3.2 Visibility items
    const visItems = ['torch', 'lantern', 'revealScroll', 'sightPotion', 'crystalBall'];
    for (const item of visItems) {
        const value = currentMaze.inventory[item] || 0;
        updateItemElement(`maze_inv_${item}`, value, `maze_ov_${item}`);
    }
}

/**
 * Add items to inventory
 */
async function addToInventory(item, amount = 1) {
    if (currentMaze.inventory[item] !== undefined) {
        currentMaze.inventory[item] += amount;
        updateInventoryDisplay();

        // Track item collection stats
        if (currentMaze.stats?.itemsCollected?.[item] !== undefined) {
            currentMaze.stats.itemsCollected[item] += amount;
        }

        // Fire hook
        await fireHook('onItemAdd', {
            item,
            count: amount,
            total: currentMaze.inventory[item]
        });

        // Update collect objectives
        await updateObjectiveProgress('collect', item, amount);
    }
}

/**
 * Remove items from inventory
 */
async function removeFromInventory(item, amount = 1) {
    if (currentMaze.inventory[item] !== undefined) {
        const prevAmount = currentMaze.inventory[item];
        currentMaze.inventory[item] = Math.max(0, prevAmount - amount);
        updateInventoryDisplay();

        // Fire hook
        await fireHook('onItemRemove', {
            item,
            count: Math.min(prevAmount, amount),
            total: currentMaze.inventory[item]
        });
    }
}

/**
 * Trigger a chest encounter - show Open/Ignore buttons
 */
async function triggerChestEncounter(chestData, x, y) {
    currentMaze.isPaused = true;

    // Store pending chest for button handlers
    currentMaze.pendingChest = { chestData, x, y };

    // v1.4.7: Check for mercy unlock (fairness system)
    let isLocked = chestData.type === 'locked';
    let mercyUnlocked = false;
    if (isLocked && currentMaze.inventory.key === 0 && shouldMercyUnlock(currentMaze.profile)) {
        isLocked = false;
        mercyUnlocked = true;
        chestData.mercyUnlocked = true; // Mark so we give locked chest loot
    }

    const hasKey = currentMaze.inventory.key > 0;

    // Get base message
    let baseMessage;
    if (mercyUnlocked) {
        baseMessage = 'The lock on this chest is broken! Lucky you!';
    } else if (isLocked) {
        baseMessage = hasKey ? 'A locked chest! Use a key to open it?' : 'A locked chest! You need a Key to open it.';
    } else {
        baseMessage = 'You found a chest!';
    }

    // Set initial display with base message
    currentMaze.currentMinion = {
        name: isLocked ? 'Locked Chest' : 'Chest',
        imagePath: '',
        message: baseMessage,
    };
    updateMazeHero();

    // Generate LLM message
    const mainStory = currentMaze.profile?.storyConfig?.mainStory || '';
    showGeneratingIndicator(true);

    try {
        const generatedMessage = await generateChestMessage({
            chestType: isLocked ? 'locked' : 'normal',
            baseMessage,
            mainStory,
            hasKey,
        });

        currentMaze.currentMinion.message = generatedMessage;
        updateMazeHero();
    } catch (error) {
        console.error('[MazeMaster] Chest message generation failed:', error);
    } finally {
        showGeneratingIndicator(false);
    }

    // Show buttons
    showChestConfirmation(isLocked, hasKey);
}

/**
 * Show chest confirmation buttons
 */
function showChestConfirmation(isLocked, hasKey) {
    let buttons = '';
    if (isLocked) {
        if (hasKey) {
            buttons = `
                <button id="maze_chest_unlock" class="menu_button maze-confirm-btn">Unlock</button>
                <button id="maze_chest_ignore" class="menu_button maze-confirm-btn">Ignore</button>
            `;
        } else {
            buttons = `
                <button id="maze_chest_ignore" class="menu_button maze-confirm-btn">Continue</button>
            `;
        }
    } else {
        buttons = `
            <button id="maze_chest_open" class="menu_button maze-confirm-btn">Open</button>
            <button id="maze_chest_ignore" class="menu_button maze-confirm-btn">Ignore</button>
        `;
    }

    // Show buttons in popup overlay
    showActionPopup(buttons);

    // Attach handlers
    document.getElementById('maze_chest_open')?.addEventListener('click', handleChestOpen);
    document.getElementById('maze_chest_unlock')?.addEventListener('click', handleChestUnlock);
    document.getElementById('maze_chest_ignore')?.addEventListener('click', handleChestIgnore);
}

/**
 * Handle opening a normal chest
 */
function handleChestOpen() {
    hideActionPopup();

    const { chestData, x, y } = currentMaze.pendingChest || {};
    if (!chestData) return;

    // Mark as opened
    currentMaze.grid[y][x].chest.opened = true;
    renderMazeGrid();

    // Check for mimic
    if (chestData.type === 'mimic') {
        triggerMimicEncounter(x, y);
        return;
    }

    // v1.4.7: If mercy unlocked, give locked chest loot (better rewards)
    if (chestData.mercyUnlocked) {
        openLockedChest(x, y);
        return;
    }

    // Normal chest - give loot
    openNormalChest(x, y);
}

/**
 * Handle unlocking a locked chest
 */
function handleChestUnlock() {
    hideActionPopup();

    const { chestData, x, y } = currentMaze.pendingChest || {};
    if (!chestData) return;

    // Use key
    removeFromInventory('key');

    // Mark as opened
    currentMaze.grid[y][x].chest.opened = true;
    renderMazeGrid();

    // Check for mimic (locked chests can be mimics too)
    if (chestData.type === 'mimic') {
        triggerMimicEncounter(x, y);
        return;
    }

    // Give locked chest loot
    openLockedChest(x, y);
}

/**
 * Handle ignoring a chest
 */
function handleChestIgnore() {
    hideActionPopup();

    // v1.4.7: Track locked chests skipped (for fairness system)
    if (currentMaze?.pendingChest?.chestData?.type === 'locked' && currentMaze.inventory.key === 0) {
        if (currentMaze.fairness) {
            currentMaze.fairness.lockedChestsSkipped++;
            console.log(`[MazeMaster] Fairness: Locked chest skipped (total: ${currentMaze.fairness.lockedChestsSkipped})`);
        }
    }

    currentMaze.pendingChest = null;
    resumeMaze();
}

// =============================================================================
// SAFE ROOM ENCOUNTERS
// =============================================================================

/**
 * Trigger a safe room encounter with Heal/Ignore popup
 */
async function triggerSafeRoomEncounter(x, y) {
    currentMaze.isPaused = true;

    // Store pending safe room for handlers
    currentMaze.pendingSafeRoom = { x, y };

    const profile = currentMaze.profile || {};
    const healPercent = profile.safeRoomHealPercent ?? 100;
    const useLLM = profile.safeRoomUseLLM && profile.enableLLM;
    const maxTotal = currentMaze.hp.max + currentMaze.hp.maxBonus;
    const currentHP = currentMaze.hp.current;
    const needsHealing = currentHP < maxTotal;

    // Base message
    let baseMessage = needsHealing
        ? `A sanctuary of peace and healing. Rest here to restore ${healPercent}% of your health.`
        : 'A sanctuary of peace. You are already at full health.';

    // Set initial display
    currentMaze.currentMinion = {
        name: 'Safe Room',
        imagePath: '',
        message: baseMessage,
    };
    updateMazeHero();

    // Generate LLM message if enabled
    if (useLLM) {
        const mainStory = profile.storyConfig?.mainStory || '';
        showGeneratingIndicator(true);

        try {
            const generatedMessage = await generateSafeRoomMessage({
                baseMessage,
                mainStory,
                needsHealing,
                healPercent,
                currentHP,
                maxHP: maxTotal,
                theme: profile.theme || 'fantasy',
            });

            currentMaze.currentMinion.message = generatedMessage;
            updateMazeHero();
        } catch (error) {
            console.error('[MazeMaster] Safe room message generation failed:', error);
        } finally {
            showGeneratingIndicator(false);
        }
    }

    // Show action buttons
    showSafeRoomConfirmation(needsHealing, healPercent);
}

/**
 * Generate LLM-powered safe room message
 */
async function generateSafeRoomMessage({ baseMessage, mainStory, needsHealing, healPercent, currentHP, maxHP, theme }) {
    const prompt = `You are narrating a dungeon crawler game. The player has found a safe room (a healing sanctuary).
Theme: ${theme}
Story context: ${mainStory || 'A dangerous dungeon adventure'}
Player HP: ${currentHP}/${maxHP}
Needs healing: ${needsHealing ? 'Yes' : 'No (already at full health)'}
Heal amount: ${healPercent}%

Write a brief atmospheric description (2-3 sentences) of this safe haven. Make it match the theme. If they need healing, hint at the restorative nature of the room. Keep it immersive but concise.`;

    try {
        const response = await fetch('/api/openai/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                prompt,
                max_tokens: 150,
                temperature: 0.8,
            }),
        });

        if (response.ok) {
            const data = await response.json();
            return data.choices?.[0]?.text?.trim() || baseMessage;
        }
    } catch (error) {
        console.error('[MazeMaster] LLM safe room message failed:', error);
    }

    return baseMessage;
}

/**
 * Show safe room action buttons
 */
function showSafeRoomConfirmation(needsHealing, healPercent) {
    let buttons = '';

    if (needsHealing) {
        buttons = `
            <button id="maze_saferoom_heal" class="menu_button maze-confirm-btn" style="background: linear-gradient(135deg, #14b8a6, #2dd4bf);">
                <i class="fa-solid fa-heart"></i> Heal (${healPercent}%)
            </button>
            <button id="maze_saferoom_ignore" class="menu_button maze-confirm-btn">Ignore</button>
        `;
    } else {
        buttons = `
            <button id="maze_saferoom_ignore" class="menu_button maze-confirm-btn">Continue</button>
        `;
    }

    showActionPopup(buttons);

    // Attach handlers
    document.getElementById('maze_saferoom_heal')?.addEventListener('click', handleSafeRoomHeal);
    document.getElementById('maze_saferoom_ignore')?.addEventListener('click', handleSafeRoomIgnore);
}

/**
 * Handle using the safe room to heal
 */
async function handleSafeRoomHeal() {
    hideActionPopup();

    const { x, y } = currentMaze.pendingSafeRoom || {};
    if (x === undefined || y === undefined) return;

    const profile = currentMaze.profile || {};
    const healPercent = profile.safeRoomHealPercent ?? 100;

    // Apply healing
    await healPlayer(healPercent, true, 'safeRoom');

    // Mark safe room as exhausted
    if (currentMaze.grid[y]?.[x]?.safeRoom) {
        currentMaze.grid[y][x].safeRoom.exhausted = true;
    }

    // Re-render to remove safe room indicator
    renderMazeGrid();

    addMazeMessage('Safe Room', `You rest and recover ${healPercent}% of your health.`);

    currentMaze.pendingSafeRoom = null;
    resumeMaze();
}

/**
 * Handle ignoring the safe room (can return later)
 */
function handleSafeRoomIgnore() {
    hideActionPopup();

    addMazeMessage('Safe Room', 'You leave the sanctuary undisturbed. You can return later.');

    currentMaze.pendingSafeRoom = null;
    resumeMaze();
}

/**
 * Open a normal chest
 */
async function openNormalChest(x, y) {
    currentMaze.pendingChest = null;
    const profile = currentMaze.profile;
    const chestData = currentMaze.grid[y][x].chest;
    const loot = generateChestLoot(profile, false);

    // v1.3.2: Add guaranteed items from Find Early
    if (chestData.guaranteedItems && chestData.guaranteedItems.length > 0) {
        for (const item of chestData.guaranteedItems) {
            if (loot[item] !== undefined) {
                loot[item]++;
            } else {
                loot[item] = 1;  // Handle new item types
            }
        }
    }

    // v1.4.1: Add guaranteed floor key for multi-floor progression
    if (chestData.guaranteedFloorKey) {
        loot.floorKey = (loot.floorKey || 0) + 1;
        console.log(`[MazeMaster] Chest at (${x}, ${y}) gave guaranteed floor key`);
    }

    awardLoot(loot);
    showChestLootMessage(loot, "Chest");

    // v1.4.7: Update fairness counters
    updateFairnessCounters(loot);

    // Log to session notes
    const lootItems = Object.entries(loot).filter(([k, v]) => v > 0).map(([k, v]) => `${k}x${v}`);
    addSessionNote(`Opened chest: ${lootItems.length > 0 ? lootItems.join(', ') : 'empty'}`, 'Loot');

    // Track stats and fire hook
    await incrementStat('chestsOpened', 1);
    await fireHook('onChestOpen', {
        type: 'normal',
        loot: JSON.stringify(loot),
        x, y
    });
}

/**
 * Open a locked chest
 */
async function openLockedChest(x, y) {
    currentMaze.pendingChest = null;
    const profile = currentMaze.profile;
    const chestData = currentMaze.grid[y][x].chest;
    const loot = generateChestLoot(profile, true);

    // v1.3.2: Add guaranteed items from Find Early
    if (chestData.guaranteedItems && chestData.guaranteedItems.length > 0) {
        for (const item of chestData.guaranteedItems) {
            if (loot[item] !== undefined) {
                loot[item]++;
            } else {
                loot[item] = 1;  // Handle new item types
            }
        }
    }

    // v1.4.1: Add guaranteed floor key for multi-floor progression
    if (chestData.guaranteedFloorKey) {
        loot.floorKey = (loot.floorKey || 0) + 1;
        console.log(`[MazeMaster] Locked chest at (${x}, ${y}) gave guaranteed floor key`);
    }

    awardLoot(loot);
    showChestLootMessage(loot, "Locked Chest");

    // v1.4.7: Update fairness counters
    updateFairnessCounters(loot);

    // Log to session notes
    const lootItems = Object.entries(loot).filter(([k, v]) => v > 0).map(([k, v]) => `${k}x${v}`);
    addSessionNote(`Opened locked chest: ${lootItems.length > 0 ? lootItems.join(', ') : 'empty'}`, 'Loot');

    // Track stats and fire hook
    await incrementStat('chestsOpened', 1);
    await fireHook('onChestOpen', {
        type: 'locked',
        loot: JSON.stringify(loot),
        x, y
    });
}

/**
 * v1.4.7: Update fairness counters based on loot received
 */
function updateFairnessCounters(loot) {
    if (!currentMaze?.fairness) return;

    const f = currentMaze.fairness;

    // Track key drops
    if (loot.key > 0) {
        f.chestsWithoutKey = 0; // Reset counter
    } else {
        f.chestsWithoutKey++;
    }

    // Track healing drops
    const hasHealing = loot.healingPotion > 0 || loot.greaterHealing > 0 || loot.elixir > 0;
    if (hasHealing) {
        f.chestsWithoutHealing = 0;
        f.lastHealingFoundFloor = currentMaze.currentFloor;
    } else {
        f.chestsWithoutHealing++;
    }
}

/**
 * v1.4.7: Check if a locked chest should be mercy-unlocked
 * Returns true if the chest should be treated as unlocked
 */
function shouldMercyUnlock(profile) {
    if (!currentMaze?.fairness) return false;

    const fairnessConfig = profile?.fairness || {};
    if (fairnessConfig.enabled === false) return false;
    if (fairnessConfig.mercyUnlock === false) return false;

    const f = currentMaze.fairness;
    const mercyThreshold = fairnessConfig.mercyUnlockThreshold || 2;

    // Mercy unlock if player has no keys AND has skipped multiple locked chests
    if (currentMaze.inventory.key === 0 && f.lockedChestsSkipped >= mercyThreshold) {
        console.log(`[MazeMaster] Fairness: Mercy unlock triggered (${f.lockedChestsSkipped} locked chests skipped)`);
        f.lockedChestsSkipped = 0; // Reset counter
        addSessionNote('Lucky break: Found the chest already unlocked!', 'Fairness');
        return true;
    }

    return false;
}

/**
 * Generate loot for a chest
 * Applies difficulty scaling to loot chances
 */
function generateChestLoot(profile, isLocked) {
    const loot = {
        key: 0, strike: 0, stealth: 0, execute: 0,
        // v1.2.0 new items
        floorKey: 0, portalStone: 0, minionBane: 0, mapFragment: 0, timeShard: 0, voidWalk: 0,
        // v1.3.0 HP System items
        healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, heartCrystal: 0,
        // v1.3.2 Vision items
        torch: 0, lantern: 0, revealScroll: 0, sightPotion: 0, crystalBall: 0
    };
    const min = profile.chestLootMin || 1;
    const max = profile.chestLootMax || 2;
    const itemCount = min + Math.floor(Math.random() * (max - min + 1));

    // Get difficulty scaling for loot
    const difficulty = getDifficultySettings(profile);
    const lootMult = difficulty.chestLootMult || 1.0;

    // Base chances for original items
    const chances = isLocked ? {
        key: (profile.lockedChestKeyChance || 40) * lootMult,
        strike: (profile.lockedChestStrikeChance || 60) * lootMult,
        stealth: (profile.lockedChestStealthChance || 30) * lootMult,
        execute: (profile.lockedChestExecuteChance || 5) * lootMult,
    } : {
        key: (profile.chestKeyChance || 30) * lootMult,
        strike: (profile.chestStrikeChance || 50) * lootMult,
        stealth: (profile.chestStealthChance || 0) * lootMult,
        execute: (profile.chestExecuteChance || 0) * lootMult,
    };

    // v1.2.0 new item chances (rarer, locked chests give better odds)
    const newItemChances = {
        floorKey: (isLocked ? 20 : 10) * lootMult,      // Floor key for multi-floor maps
        portalStone: (isLocked ? 15 : 8) * lootMult,    // Teleport to revealed portals
        minionBane: (isLocked ? 12 : 5) * lootMult,     // Auto-defeat next minion
        mapFragment: (isLocked ? 25 : 15) * lootMult,   // Reveal 3x3 area
        timeShard: (isLocked ? 10 : 5) * lootMult,      // Slow battlebar by 50%
        voidWalk: (isLocked ? 8 : 3) * lootMult,        // Phase through one wall
    };

    // v1.3.0 HP System item chances (only if HP enabled)
    const hpItemChances = (profile.hpEnabled !== false) ? {
        healingPotion: (isLocked ? 35 : 20) * lootMult,   // 25% HP heal
        greaterHealing: (isLocked ? 15 : 8) * lootMult,   // 50% HP heal
        elixir: (isLocked ? 5 : 2) * lootMult,            // Full HP heal
        revivalCharm: (isLocked ? 3 : 1) * lootMult,      // Auto-resurrect on death
        heartCrystal: (isLocked ? 2 : 0.5) * lootMult,    // +10 max HP permanent
    } : null;

    // v1.3.2 Vision item chances
    const visionItemChances = {
        torch: (isLocked ? 18 : 10) * lootMult,           // +2 visibility for 3 moves
        lantern: (isLocked ? 8 : 4) * lootMult,           // +1 passive visibility
        revealScroll: (isLocked ? 6 : 3) * lootMult,      // Reveal entire floor
        sightPotion: (isLocked ? 4 : 2) * lootMult,       // Permanent +1 visibility
        crystalBall: (isLocked ? 5 : 2) * lootMult,       // Reveal all minions
    };

    // Apply locked bonus multiplier
    if (isLocked) {
        const bonus = 1 + (profile.chestLockedBonusPercent || 50) / 100;
        chances.key = Math.min(100, chances.key * bonus);
        chances.strike = Math.min(100, chances.strike * bonus);
        chances.stealth = Math.min(100, chances.stealth * bonus);
        chances.execute = Math.min(100, chances.execute * bonus);
        // Apply bonus to new items too
        for (const item of Object.keys(newItemChances)) {
            newItemChances[item] = Math.min(100, newItemChances[item] * bonus);
        }
        // Apply bonus to HP items (v1.3.0)
        if (hpItemChances) {
            for (const item of Object.keys(hpItemChances)) {
                hpItemChances[item] = Math.min(100, hpItemChances[item] * bonus);
            }
        }
        // Apply bonus to vision items (v1.3.2)
        for (const item of Object.keys(visionItemChances)) {
            visionItemChances[item] = Math.min(100, visionItemChances[item] * bonus);
        }
    }

    // v1.4.7: Apply fairness modifiers (pity system)
    const fairnessConfig = profile.fairness || {};
    if (fairnessConfig.enabled !== false && currentMaze?.fairness) {
        const f = currentMaze.fairness;

        // Key pity: Boost key chance after multiple chests without one
        if (f.chestsWithoutKey >= (fairnessConfig.keyPityThreshold || 3)) {
            const keyBoost = Math.min(50, f.chestsWithoutKey * 15); // +15% per chest, max +50%
            chances.key = Math.min(100, chances.key + keyBoost);
            console.log(`[MazeMaster] Fairness: Key pity active (+${keyBoost}% key chance)`);
        }

        // Healing pity: Boost healing when HP is low or haven't found healing recently
        if (hpItemChances && currentMaze.hpEnabled && currentMaze.hp) {
            const hpPercent = currentMaze.hp.current / (currentMaze.hp.max + currentMaze.hp.maxBonus);
            const lowHpThreshold = fairnessConfig.lowHpThreshold || 0.4;

            if (hpPercent <= lowHpThreshold) {
                const healBoost = Math.round((1 - hpPercent) * 40); // Up to +40% when near death
                hpItemChances.healingPotion = Math.min(100, hpItemChances.healingPotion + healBoost);
                hpItemChances.greaterHealing = Math.min(100, hpItemChances.greaterHealing + healBoost / 2);
                console.log(`[MazeMaster] Fairness: Low HP pity (+${healBoost}% healing chance)`);
            }

            // Extra boost if many chests without healing
            if (f.chestsWithoutHealing >= (fairnessConfig.healingPityThreshold || 4)) {
                const healStreakBoost = Math.min(30, f.chestsWithoutHealing * 8);
                hpItemChances.healingPotion = Math.min(100, hpItemChances.healingPotion + healStreakBoost);
                console.log(`[MazeMaster] Fairness: Healing drought pity (+${healStreakBoost}%)`);
            }
        }
    }

    for (let i = 0; i < itemCount; i++) {
        // Roll for each item type
        if (Math.random() * 100 < chances.key) loot.key++;
        if (Math.random() * 100 < chances.strike) loot.strike++;
        if (Math.random() * 100 < chances.stealth) loot.stealth++;
        if (Math.random() * 100 < chances.execute) loot.execute++;
        // Roll for new items
        if (Math.random() * 100 < newItemChances.floorKey) loot.floorKey++;
        if (Math.random() * 100 < newItemChances.portalStone) loot.portalStone++;
        if (Math.random() * 100 < newItemChances.minionBane) loot.minionBane++;
        if (Math.random() * 100 < newItemChances.mapFragment) loot.mapFragment++;
        if (Math.random() * 100 < newItemChances.timeShard) loot.timeShard++;
        if (Math.random() * 100 < newItemChances.voidWalk) loot.voidWalk++;
        // Roll for HP items (v1.3.0)
        if (hpItemChances) {
            if (Math.random() * 100 < hpItemChances.healingPotion) loot.healingPotion++;
            if (Math.random() * 100 < hpItemChances.greaterHealing) loot.greaterHealing++;
            if (Math.random() * 100 < hpItemChances.elixir) loot.elixir++;
            if (Math.random() * 100 < hpItemChances.revivalCharm) loot.revivalCharm++;
            if (Math.random() * 100 < hpItemChances.heartCrystal) loot.heartCrystal++;
        }
        // Roll for vision items (v1.3.2)
        if (Math.random() * 100 < visionItemChances.torch) loot.torch++;
        if (Math.random() * 100 < visionItemChances.lantern) loot.lantern++;
        if (Math.random() * 100 < visionItemChances.revealScroll) loot.revealScroll++;
        if (Math.random() * 100 < visionItemChances.sightPotion) loot.sightPotion++;
        if (Math.random() * 100 < visionItemChances.crystalBall) loot.crystalBall++;
    }

    return loot;
}

/**
 * Award loot to player
 */
function awardLoot(loot) {
    if (loot.key > 0) addToInventory('key', loot.key);
    if (loot.strike > 0) addToInventory('strike', loot.strike);
    if (loot.stealth > 0) addToInventory('stealth', loot.stealth);
    if (loot.execute > 0) addToInventory('execute', loot.execute);
    // v1.2.0 new items
    if (loot.floorKey > 0) addToInventory('floorKey', loot.floorKey);
    if (loot.portalStone > 0) addToInventory('portalStone', loot.portalStone);
    if (loot.minionBane > 0) addToInventory('minionBane', loot.minionBane);
    if (loot.mapFragment > 0) addToInventory('mapFragment', loot.mapFragment);
    if (loot.timeShard > 0) addToInventory('timeShard', loot.timeShard);
    if (loot.voidWalk > 0) addToInventory('voidWalk', loot.voidWalk);
    // v1.3.0 HP System items
    if (loot.healingPotion > 0) addToInventory('healingPotion', loot.healingPotion);
    if (loot.greaterHealing > 0) addToInventory('greaterHealing', loot.greaterHealing);
    if (loot.elixir > 0) addToInventory('elixir', loot.elixir);
    if (loot.revivalCharm > 0) addToInventory('revivalCharm', loot.revivalCharm);
    if (loot.heartCrystal > 0) addToInventory('heartCrystal', loot.heartCrystal);
    // v1.3.2 Vision items
    if (loot.torch > 0) addToInventory('torch', loot.torch);
    if (loot.lantern > 0) addToInventory('lantern', loot.lantern);
    if (loot.revealScroll > 0) addToInventory('revealScroll', loot.revealScroll);
    if (loot.sightPotion > 0) addToInventory('sightPotion', loot.sightPotion);
    if (loot.crystalBall > 0) addToInventory('crystalBall', loot.crystalBall);
}

/**
 * Show a chest message in the hero section
 */
function showChestMessage(message, chestType) {
    currentMaze.currentMinion = {
        name: chestType,
        imagePath: '',
        message: message,
    };
    updateMazeHero();
}

/**
 * Show loot message from a chest
 */
function showChestLootMessage(loot, chestType) {
    const items = [];
    // Original items
    if (loot.key > 0) items.push(`${loot.key} Key${loot.key > 1 ? 's' : ''}`);
    if (loot.strike > 0) items.push(`${loot.strike} Strike${loot.strike > 1 ? 's' : ''}`);
    if (loot.stealth > 0) items.push(`${loot.stealth} Stealth${loot.stealth > 1 ? 's' : ''}`);
    if (loot.execute > 0) items.push(`${loot.execute} GRANDSTRIKE!`);
    // v1.2.0 new items
    if (loot.floorKey > 0) items.push(`${loot.floorKey} Floor Key${loot.floorKey > 1 ? 's' : ''}`);
    if (loot.portalStone > 0) items.push(`${loot.portalStone} Portal Stone${loot.portalStone > 1 ? 's' : ''}`);
    if (loot.minionBane > 0) items.push(`${loot.minionBane} Minion Bane${loot.minionBane > 1 ? 's' : ''}`);
    if (loot.mapFragment > 0) items.push(`${loot.mapFragment} Map Fragment${loot.mapFragment > 1 ? 's' : ''}`);
    if (loot.timeShard > 0) items.push(`${loot.timeShard} Time Shard${loot.timeShard > 1 ? 's' : ''}`);
    if (loot.voidWalk > 0) items.push(`${loot.voidWalk} Void Walk${loot.voidWalk > 1 ? 's' : ''}`);
    // v1.3.0 HP items
    if (loot.healingPotion > 0) items.push(`${loot.healingPotion} Healing Potion${loot.healingPotion > 1 ? 's' : ''}`);
    if (loot.greaterHealing > 0) items.push(`${loot.greaterHealing} Greater Healing${loot.greaterHealing > 1 ? 's' : ''}`);
    if (loot.elixir > 0) items.push(`${loot.elixir} Elixir${loot.elixir > 1 ? 's' : ''}`);
    if (loot.revivalCharm > 0) items.push(`${loot.revivalCharm} Revival Charm${loot.revivalCharm > 1 ? 's' : ''}`);
    if (loot.heartCrystal > 0) items.push(`${loot.heartCrystal} Heart Crystal${loot.heartCrystal > 1 ? 's' : ''}`);
    // v1.3.2 Vision items
    if (loot.torch > 0) items.push(`${loot.torch} Torch${loot.torch > 1 ? 'es' : ''}`);
    if (loot.lantern > 0) items.push(`${loot.lantern} Lantern${loot.lantern > 1 ? 's' : ''}`);
    if (loot.revealScroll > 0) items.push(`${loot.revealScroll} Reveal Scroll${loot.revealScroll > 1 ? 's' : ''}`);
    if (loot.sightPotion > 0) items.push(`${loot.sightPotion} Sight Potion${loot.sightPotion > 1 ? 's' : ''}`);
    if (loot.crystalBall > 0) items.push(`${loot.crystalBall} Crystal Ball${loot.crystalBall > 1 ? 's' : ''}`);

    const message = items.length > 0
        ? `You found: ${items.join(', ')}!`
        : 'The chest was empty!';

    showChestMessage(message, chestType);
    setTimeout(() => resumeMaze(), 2000);
}

/**
 * Trigger a mimic encounter (random battlebar)
 */
function triggerMimicEncounter(x, y) {
    // Clear pending chest since we've opened it
    currentMaze.pendingChest = null;

    const bbProfiles = getBattlebarProfileNames();
    if (bbProfiles.length > 0) {
        const randomProfile = bbProfiles[Math.floor(Math.random() * bbProfiles.length)];
        currentMaze.pendingEncounter = { type: 'mimic_battlebar', profile: randomProfile };

        // Show mimic message first
        currentMaze.currentMinion = {
            name: 'Mimic!',
            imagePath: '',
            message: 'The chest was a mimic! Prepare to fight!',
        };
        updateMazeHero();

        setTimeout(() => {
            startBattlebar(randomProfile);
        }, 1000);
    } else {
        // No battlebar profiles - just resume
        showChestMessage("The chest was empty... and creepy.", "Mimic");
        setTimeout(() => resumeMaze(), 1500);
    }
}

/**
 * Show action popup overlay with buttons
 * @param {string} buttonsHTML - HTML string of buttons to display
 */
function showActionPopup(buttonsHTML) {
    const popup = document.getElementById('maze_action_popup');
    const buttonsContainer = document.getElementById('maze_action_popup_buttons');

    if (!popup || !buttonsContainer) return;

    buttonsContainer.innerHTML = buttonsHTML;
    popup.style.display = 'flex';

    // Also hide the old confirm area if it exists
    const oldConfirm = document.getElementById('maze_encounter_confirm');
    if (oldConfirm) {
        oldConfirm.style.display = 'none';
        oldConfirm.innerHTML = '';
    }
}

/**
 * Hide action popup overlay
 */
function hideActionPopup() {
    const popup = document.getElementById('maze_action_popup');
    const buttonsContainer = document.getElementById('maze_action_popup_buttons');

    if (popup) {
        popup.style.display = 'none';
    }
    if (buttonsContainer) {
        buttonsContainer.innerHTML = '';
    }

    // Also hide the old confirm area if it exists
    const oldConfirm = document.getElementById('maze_encounter_confirm');
    if (oldConfirm) {
        oldConfirm.style.display = 'none';
        oldConfirm.innerHTML = '';
    }
}

/**
 * Show encounter confirmation buttons
 */
function showEncounterConfirmation(minionId, x, y, encounterType) {
    console.log('[MazeMaster] showEncounterConfirmation called:', { minionId, x, y, encounterType });
    const minion = getMinion(minionId);
    console.log('[MazeMaster] Minion data:', minion);
    const canSlipAway = encounterType !== 'messenger' && encounterType !== 'merchant' && currentMaze.inventory.stealth > 0;

    currentMaze.pendingConfirmation = { type: encounterType, minionId, x, y, canSlipAway };
    console.log('[MazeMaster] Set pendingConfirmation:', currentMaze.pendingConfirmation);

    let buttons = '';
    if (encounterType === 'messenger') {
        buttons = `<button id="maze_confirm_ok" class="menu_button maze-confirm-btn">OK</button>`;
    } else if (encounterType === 'merchant') {
        // Calculate random item count for this merchant
        const merchantConfig = minion.merchantItemCount || { min: 2, max: 4 };
        const itemCount = merchantConfig.min + Math.floor(Math.random() * (merchantConfig.max - merchantConfig.min + 1));

        // Get item pool and select random items
        const poolName = minion.merchantItemPool || 'Common Goods';
        const offeredItems = selectRandomMerchantItems(poolName, itemCount);
        currentMaze.pendingConfirmation.offeredItems = offeredItems;

        // Update message with browse prompt
        currentMaze.currentMinion.message = `Take a look at my wares! I have ${itemCount} items that might interest you...`;
        updateMazeHero();

        buttons = `
            <button id="maze_confirm_browse" class="menu_button maze-confirm-btn maze-accept-btn">Browse Wares</button>
            <button id="maze_confirm_decline" class="menu_button maze-confirm-btn">No Thanks</button>
        `;
    } else {
        // Get appropriate action text based on encounter type
        const actionTexts = {
            'battlebar': 'Fight!',
            'prizewheel': 'Spin!',
            'turnbased': 'Battle!',
            'qte': 'React!',
            'dice': 'Roll!',
            'stealth': 'Sneak!',
            'puzzle': 'Solve!',
            'negotiation': 'Negotiate!',
        };
        const actionText = actionTexts[encounterType] || 'Engage!';
        buttons = `<button id="maze_confirm_action" class="menu_button maze-confirm-btn">${actionText}</button>`;
        if (canSlipAway) {
            buttons += `<button id="maze_confirm_slip" class="menu_button maze-confirm-btn maze-slip-btn">Slip Away</button>`;
        }
    }

    // Show buttons in popup overlay
    showActionPopup(buttons);

    // Attach handlers
    document.getElementById('maze_confirm_ok')?.addEventListener('click', handleConfirmOk);
    document.getElementById('maze_confirm_action')?.addEventListener('click', handleConfirmAction);
    document.getElementById('maze_confirm_slip')?.addEventListener('click', handleConfirmSlipAway);
    document.getElementById('maze_confirm_browse')?.addEventListener('click', handleMerchantBrowse);
    document.getElementById('maze_confirm_decline')?.addEventListener('click', handleMerchantDecline);
}

/**
 * Handle OK confirmation (messenger encounters)
 */
function handleConfirmOk() {
    hideActionPopup();
    currentMaze.pendingConfirmation = null;
    resumeMaze();
}

/**
 * Handle action confirmation (all combat encounter types)
 */
function handleConfirmAction() {
    console.log('[MazeMaster] handleConfirmAction called');
    hideActionPopup();
    const conf = currentMaze.pendingConfirmation;
    console.log('[MazeMaster] pendingConfirmation:', conf);
    if (!conf) {
        console.warn('[MazeMaster] No pending confirmation, returning');
        return;
    }

    const minion = getMinion(conf.minionId);
    console.log('[MazeMaster] Minion for encounter:', conf.minionId, minion);
    console.log('[MazeMaster] Encounter type:', conf.type);
    currentMaze.pendingConfirmation = null;

    // Trigger the actual encounter based on type
    switch (conf.type) {
        case 'battlebar': {
            const bbProfile = getRandomFromArray(minion.battlebarProfiles);
            console.log('[MazeMaster] Battlebar profiles:', minion.battlebarProfiles, '-> selected:', bbProfile);
            if (bbProfile) {
                currentMaze.pendingEncounter = { type: 'battlebar', profile: bbProfile, minionName: minion.name };
                startBattlebar(bbProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No battlebar profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'prizewheel': {
            const wheelProfile = getRandomFromArray(minion.wheelProfiles);
            console.log('[MazeMaster] Wheel profiles:', minion.wheelProfiles, '-> selected:', wheelProfile);
            if (wheelProfile) {
                currentMaze.pendingEncounter = { type: 'wheel', profile: wheelProfile };
                loadWheelFromProfile(wheelProfile);
                showWheelModal();
            } else {
                console.warn('[MazeMaster] No wheel profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'turnbased': {
            const tbProfile = getRandomFromArray(minion.turnbasedProfiles);
            console.log('[MazeMaster] Turnbased profiles:', minion.turnbasedProfiles, '-> selected:', tbProfile);
            if (tbProfile) {
                currentMaze.pendingEncounter = { type: 'turnbased', profile: tbProfile, minionName: minion.name };
                console.log('[MazeMaster] Calling startTurnBased with profile:', tbProfile);
                startTurnBased(tbProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No turnbased profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'qte': {
            const qteProfile = getRandomFromArray(minion.qteProfiles);
            console.log('[MazeMaster] QTE profiles:', minion.qteProfiles, '-> selected:', qteProfile);
            if (qteProfile) {
                currentMaze.pendingEncounter = { type: 'qte', profile: qteProfile, minionName: minion.name };
                console.log('[MazeMaster] Calling startQTE with profile:', qteProfile);
                startQTE(qteProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No QTE profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'dice': {
            const diceProfile = getRandomFromArray(minion.diceProfiles);
            console.log('[MazeMaster] Dice profiles:', minion.diceProfiles, '-> selected:', diceProfile);
            if (diceProfile) {
                currentMaze.pendingEncounter = { type: 'dice', profile: diceProfile, minionName: minion.name };
                console.log('[MazeMaster] Calling startDice with profile:', diceProfile);
                startDice(diceProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No dice profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'stealth': {
            const stealthProfile = getRandomFromArray(minion.stealthProfiles);
            console.log('[MazeMaster] Stealth profiles:', minion.stealthProfiles, '-> selected:', stealthProfile);
            if (stealthProfile) {
                currentMaze.pendingEncounter = { type: 'stealth', profile: stealthProfile, minionName: minion.name };
                console.log('[MazeMaster] Calling startStealth with profile:', stealthProfile);
                startStealth(stealthProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No stealth profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'puzzle': {
            const puzzleProfile = getRandomFromArray(minion.puzzleProfiles);
            console.log('[MazeMaster] Puzzle profiles:', minion.puzzleProfiles, '-> selected:', puzzleProfile);
            if (puzzleProfile) {
                currentMaze.pendingEncounter = { type: 'puzzle', profile: puzzleProfile, minionName: minion.name };
                console.log('[MazeMaster] Calling startPuzzle with profile:', puzzleProfile);
                startPuzzle(puzzleProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No puzzle profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        case 'negotiation': {
            const negoProfile = getRandomFromArray(minion.negotiationProfiles);
            console.log('[MazeMaster] Negotiation profiles:', minion.negotiationProfiles, '-> selected:', negoProfile);
            if (negoProfile) {
                currentMaze.pendingEncounter = { type: 'negotiation', profile: negoProfile, minionName: minion.name };
                console.log('[MazeMaster] Calling startNegotiation with profile:', negoProfile);
                startNegotiation(negoProfile, minion.name);
            } else {
                console.warn('[MazeMaster] No negotiation profile found, resuming maze');
                resumeMaze();
            }
            break;
        }
        default:
            console.warn(`[MazeMaster] Unknown encounter type: ${conf.type}`);
            resumeMaze();
    }
}

/**
 * Handle slip away (uses stealth to skip encounter)
 */
function handleConfirmSlipAway() {
    hideActionPopup();
    if (currentMaze.inventory.stealth > 0) {
        removeFromInventory('stealth');
        currentMaze.pendingConfirmation = null;
        resumeMaze();
    }
}

/**
 * Handle merchant browse - open merchant modal to select items
 */
function handleMerchantBrowse() {
    const conf = currentMaze.pendingConfirmation;
    if (!conf || conf.type !== 'merchant') return;

    hideActionPopup();

    // Open merchant modal with the offered items
    showMerchantModal(conf.minionId, conf.offeredItems || []);
}

/**
 * Handle merchant decline - skip trade
 */
function handleMerchantDecline() {
    hideActionPopup();
    currentMaze.pendingConfirmation = null;
    resumeMaze();
}

/**
 * Maybe show a random message from the main minion
 */
async function maybeShowMainMinionMessage() {
    const profile = currentMaze.profile;
    if (!profile.mainMinion) return;
    if (!profile.mainMinionRandomChance) return;
    if (!profile.mainMinionRandomMessages || profile.mainMinionRandomMessages.length === 0) return;

    // Roll random chance (0-100)
    if (Math.random() * 100 > profile.mainMinionRandomChance) return;

    const mainMinion = getMinion(profile.mainMinion);
    if (!mainMinion) return;

    const baseMessage = getRandomFromArray(profile.mainMinionRandomMessages);
    if (!baseMessage) return;

    // Show placeholder immediately
    currentMaze.currentMinion = {
        name: mainMinion.name,
        imagePath: mainMinion.imagePath,
        message: '...',
    };
    updateMazeHero();

    // Show generating indicator
    showGeneratingIndicator(true);

    // Generate LLM message
    let message = baseMessage;
    try {
        message = await generateMinionMessage({
            minionName: mainMinion.name,
            minionDescription: mainMinion.description,
            baseMessage: baseMessage,
            mainStory: getMainStory(),
            currentMilestone: getCurrentMilestone(),
            minionType: mainMinion.type || 'messenger',
        });
    } catch (error) {
        console.error('[MazeMaster] Random message LLM generation error:', error);
    }

    // Hide generating indicator
    showGeneratingIndicator(false);

    // Update with actual message
    currentMaze.currentMinion.message = message;
    updateMazeHero();
}

/**
 * Check and trigger story milestones based on maze progress
 */
function checkStoryMilestones() {
    const profile = currentMaze.profile;
    if (!profile.storyConfig || !profile.storyConfig.milestones || profile.storyConfig.milestones.length === 0) return;

    // Calculate progress percentage
    const totalCells = currentMaze.size * currentMaze.size;
    const visitedCount = currentMaze.visited.size;
    const percentComplete = Math.floor((visitedCount / totalCells) * 100);

    // Check each milestone
    for (const milestone of profile.storyConfig.milestones) {
        if (percentComplete >= milestone.percent && !currentMaze.shownMilestones.has(milestone.percent)) {
            // Mark as shown
            currentMaze.shownMilestones.add(milestone.percent);

            // Log to session notes
            addSessionNote(`Milestone ${milestone.percent}%: ${milestone.storyUpdate?.substring(0, 50)}...`, 'Story');

            // Show milestone message
            const mainMinion = profile.mainMinion ? getMinion(profile.mainMinion) : null;
            currentMaze.currentMinion = {
                name: mainMinion?.name || 'Story',
                imagePath: mainMinion?.imagePath || '',
                message: milestone.storyUpdate,
            };
            updateMazeHero();

            // Only show one milestone at a time
            return;
        }
    }
}

/**
 * Handle maze loss (from battlebar defeat)
 */
function handleMazeLoss() {
    currentMaze.isVictory = false;
    currentMaze.isPaused = true;

    // Log to session notes
    addSessionNote(`DEFEAT! Adventure ended.`, 'End');

    // Stop stats timer
    stopStatsTimer();

    // Save persistent stats
    savePersistentStats('lose');

    // Record result
    lastResults.maze[currentMaze.profileName] = {
        result: 'lose',
        timestamp: Date.now(),
    };

    // Show loss screen in hero section
    document.getElementById('maze_minion_name').textContent = 'Defeat!';
    addMazeMessage('Defeat!', 'You have been defeated...');

    // Hide minion image on loss
    const minionImg = document.getElementById('maze_minion_img');
    if (minionImg) minionImg.style.display = 'none';

    // Show close button
    const closeBtn = document.getElementById('maze_close_btn');
    if (closeBtn) closeBtn.style.display = '';

    // Execute loss command if exists
    if (currentMaze.profile.loseCommand) {
        executeWithTimeout(currentMaze.profile.loseCommand);
    }

    document.removeEventListener('keydown', handleMazeKeydown, { capture: true });
}

/**
 * Respawn player at start position
 */
function respawnPlayer() {
    currentMaze.playerX = 0;
    currentMaze.playerY = 0;
    currentMaze.isPaused = false;
    currentMaze.pendingEncounter = null;
    renderMazeGrid();
    updateDpadFloorButtons();

    // Show respawn message from main minion
    const profile = currentMaze.profile;
    if (profile.mainMinion) {
        const mainMinion = getMinion(profile.mainMinion);
        if (mainMinion) {
            currentMaze.currentMinion = {
                name: mainMinion.name,
                imagePath: mainMinion.imagePath,
                message: 'Back to the beginning with you!',
            };
            updateMazeHero();
            return;
        }
    }

    // Otherwise show default
    currentMaze.currentMinion = getDefaultMinion();
    updateMazeHero();
}

async function handleMazeWin() {
    currentMaze.isVictory = true;

    // Log to session notes
    addSessionNote(`VICTORY! Maze completed.`, 'End');

    // Stop stats timer
    stopStatsTimer();

    // Save persistent stats
    savePersistentStats('win');

    // Record result
    lastResults.maze[currentMaze.profileName] = {
        result: 'win',
        timestamp: Date.now(),
    };

    // Update UI
    updateMazeHero();
    renderMazeGrid();

    // Show close button
    const closeBtn = document.getElementById('maze_close_btn');
    if (closeBtn) closeBtn.style.display = '';

    // Hide mobile controls
    const controls = document.querySelector('.mazemaster-maze-controls');
    if (controls) controls.style.display = 'none';

    // Remove keyboard listener
    document.removeEventListener('keydown', handleMazeKeydown, { capture: true });

    // Execute win command
    if (currentMaze.profile.winCommand) {
        await executeWithTimeout(currentMaze.profile.winCommand);
    }

    console.log(`[MazeMaster] Maze "${currentMaze.profileName}" completed!`);

    // Auto-close after delay so player can see victory state
    await delay(2500);
    closeMaze();

    // Switch to Game tab in extension panel
    const gameTab = document.querySelector('.mazemaster-tab[data-tab="game"]');
    if (gameTab) gameTab.click();
}

// =============================================================================
// CONFIG PANEL UI
// =============================================================================

function getPanelHtml() {
    const wheelProfiles = getProfileNames();
    const currentWheelProfile = extensionSettings.currentProfile || 'default';
    const bbProfiles = getBattlebarProfileNames();
    const currentBbProfile = extensionSettings.currentBattlebarProfile || 'default';
    const currentBb = getBattlebarProfile(currentBbProfile) || {};
    const mazeProfiles = getMazeProfileNames();
    const currentMazeProfileName = extensionSettings.currentMazeProfile || 'default';
    const currentMazeData = getMazeProfile(currentMazeProfileName) || {};
    const minionsList = getMinionNames();
    const activeGame = extensionSettings.activeGameConfig || 'maze';

    return `
        <div class="mazemaster-panel">
            <div class="mazemaster-panel-header">
                <h2><i class="fa-solid fa-gamepad"></i> MazeMaster</h2>
            </div>
            <div class="mazemaster-tabs">
                <button class="mazemaster-tab active" data-tab="game">Game</button>
                <button class="mazemaster-tab" data-tab="config">Config</button>
                <button class="mazemaster-tab" data-tab="help">Help</button>
            </div>
            <div class="mazemaster-panel-content">
                <!-- GAME TAB -->
                <div class="mazemaster-tab-content active" id="mazemaster-tab-game">
                    <div class="mazemaster-game-launch">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Maze Profile</label>
                            <select id="mazemaster_play_profile" class="mazemaster-select">
                                ${mazeProfiles.length === 0 ? '<option value="">No profiles</option>' : ''}
                                ${mazeProfiles.map(p => `<option value="${escapeHtml(p)}" ${p === currentMazeProfileName ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                            </select>
                        </div>
                        <button id="mazemaster_play_maze" class="menu_button menu_button_primary mazemaster-play-btn">
                            <i class="fa-solid fa-play"></i> Play Maze
                        </button>
                    </div>

                    <!-- LLM Generation Settings -->
                    <div class="mazemaster-section">
                        <label class="mazemaster-label"><i class="fa-solid fa-brain"></i> LLM Message Generation</label>
                        <div class="mazemaster-form-group">
                            <label>Generation Preset</label>
                            <select id="mazemaster_llm_preset" class="mazemaster-select">
                                <option value="">(Use Current)</option>
                                <!-- Presets populated dynamically -->
                            </select>
                        </div>
                        <label class="mazemaster-checkbox-label">
                            <input type="checkbox" id="mazemaster_llm_enabled" ${extensionSettings.llmEnabled !== false ? 'checked' : ''}>
                            Enable LLM message generation
                        </label>
                        <label class="mazemaster-checkbox-label">
                            <input type="checkbox" id="mazemaster_close_chat" ${extensionSettings.closeChatOnStart !== false ? 'checked' : ''}>
                            Close current chat before starting (prevents context bleed)
                        </label>
                    </div>

                    <!-- D-Pad Settings -->
                    <div class="mazemaster-section">
                        <label class="mazemaster-label"><i class="fa-solid fa-gamepad"></i> D-Pad Controls</label>
                        <label class="mazemaster-checkbox-label">
                            <input type="checkbox" id="mazemaster_dpad_enabled" ${extensionSettings.dpadConfig?.enabled !== false ? 'checked' : ''}>
                            Enable D-Pad controls
                        </label>
                        <label class="mazemaster-checkbox-label">
                            <input type="checkbox" id="mazemaster_dpad_floating" ${extensionSettings.dpadConfig?.floating !== false ? 'checked' : ''}>
                            Floating D-Pad (draggable position)
                        </label>
                        <button id="mazemaster_dpad_reset" class="menu_button" style="margin-top: 6px;">
                            <i class="fa-solid fa-rotate-left"></i> Reset D-Pad Position
                        </button>
                    </div>

                    <!-- Renderer Settings -->
                    <div class="mazemaster-section">
                        <label class="mazemaster-label"><i class="fa-solid fa-cube"></i> Renderer</label>
                        <select id="mazemaster_renderer_type" class="mazemaster-select">
                            <option value="css-grid" ${extensionSettings.rendererType === 'css-grid' ? 'selected' : ''}>Classic (CSS Grid)</option>
                            <option value="isometric" ${(extensionSettings.rendererType || 'isometric') === 'isometric' ? 'selected' : ''}>Isometric 2.5D</option>
                            <option value="canvas" ${extensionSettings.rendererType === 'canvas' ? 'selected' : ''}>Canvas (Experimental)</option>
                        </select>
                        <div class="mazemaster-help-small"><small>Isometric gives a 3D-like view. Requires restart of active maze.</small></div>
                    </div>

                    <!-- Layout Mode -->
                    <div class="mazemaster-section">
                        <label class="mazemaster-label"><i class="fa-solid fa-mobile-screen"></i> Layout Mode</label>
                        <select id="mazemaster_layout_mode" class="mazemaster-select">
                            <option value="auto" ${extensionSettings.layoutMode === 'auto' ? 'selected' : ''} disabled>Auto-detect (disabled)</option>
                            <option value="desktop" ${(extensionSettings.layoutMode || 'desktop') === 'desktop' ? 'selected' : ''}>Desktop (Horizontal)</option>
                            <option value="mobile" ${extensionSettings.layoutMode === 'mobile' ? 'selected' : ''} disabled>Mobile (Vertical) (disabled)</option>
                        </select>
                        <div class="mazemaster-help-small"><small>Mobile layout stacks UI vertically for portrait screens.</small></div>
                    </div>

                    <!-- Saved Games in Game Tab -->
                    <div class="mazemaster-section">
                        <label class="mazemaster-label"><i class="fa-solid fa-floppy-disk"></i> Saved Games</label>
                        <div id="mazemaster_game_tab_saves" class="mazemaster-saved-games-list">
                            <!-- Saved games rendered here -->
                        </div>
                    </div>
                </div>

                <!-- CONFIG TAB -->
                <div class="mazemaster-tab-content" id="mazemaster-tab-config">
                    <!-- Game Selector -->
                    <div class="mazemaster-game-selector">
                        <button id="mazemaster_show_maze" class="menu_button mazemaster-game-btn ${activeGame === 'maze' ? 'active' : ''}">
                            <i class="fa-solid fa-border-all"></i> Maze
                        </button>
                        <button id="mazemaster_show_wheel" class="menu_button mazemaster-game-btn ${activeGame === 'wheel' ? 'active' : ''}">
                            <i class="fa-solid fa-dharmachakra"></i> Wheel
                        </button>
                        <button id="mazemaster_show_combat" class="menu_button mazemaster-game-btn ${activeGame === 'combat' ? 'active' : ''}">
                            <i class="fa-solid fa-khanda"></i> Combat
                        </button>
                        <button id="mazemaster_show_minions" class="menu_button mazemaster-game-btn ${activeGame === 'minions' ? 'active' : ''}">
                            <i class="fa-solid fa-ghost"></i> Minions
                        </button>
                        <button id="mazemaster_show_traps" class="menu_button mazemaster-game-btn ${activeGame === 'traps' ? 'active' : ''}">
                            <i class="fa-solid fa-dungeon"></i> Traps
                        </button>
                    </div>

                    <!-- WHEEL CONFIG -->
                    <div id="mazemaster_wheel_config" class="mazemaster-game-config" style="${activeGame === 'wheel' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Wheel Profile</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_profile_select" class="mazemaster-select">
                                    ${wheelProfiles.length === 0 ? '<option value="">No profiles</option>' : ''}
                                    ${wheelProfiles.map(p => `<option value="${escapeHtml(p)}" ${p === currentWheelProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                </select>
                                <button id="mazemaster_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                                <button id="mazemaster_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                                <button id="mazemaster_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                    <i class="fa-solid fa-pen"></i>
                                </button>
                                <button id="mazemaster_export_btn" class="menu_button menu_button_icon" title="Export Profile">
                                    <i class="fa-solid fa-download"></i>
                                </button>
                                <button id="mazemaster_import_btn" class="menu_button menu_button_icon" title="Import Profile">
                                    <i class="fa-solid fa-upload"></i>
                                </button>
                                <input type="file" id="mazemaster_import_file" accept=".json" style="display: none;">
                                <button id="mazemaster_preview_wheel_btn" class="menu_button menu_button_icon" title="Preview Wheel">
                                    <i class="fa-solid fa-eye"></i>
                                </button>
                            </div>
                        </div>

                        <div class="mazemaster-section mazemaster-profile-settings">
                            <div class="mazemaster-profile-options">
                                <label class="mazemaster-checkbox-label">
                                    <input type="checkbox" id="mazemaster_randomize" ${getProfile(currentWheelProfile)?.randomize ? 'checked' : ''}>
                                    Randomize segment positions
                                </label>
                                <div class="mazemaster-difficulty-row">
                                    <label>Difficulty:</label>
                                    <select id="mazemaster_difficulty" class="mazemaster-select-small">
                                        ${[1,2,3,4,5].map(n => `<option value="${n}" ${(getProfile(currentWheelProfile)?.difficulty || 1) === n ? 'selected' : ''}>${n}</option>`).join('')}
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Segments</label>
                            <div id="mazemaster_segments_list" class="mazemaster-segments-list">
                                <!-- Segments rendered here -->
                            </div>
                            <button id="mazemaster_add_segment_btn" class="menu_button mazemaster-add-btn">
                                <i class="fa-solid fa-plus"></i> Add Segment
                            </button>
                        </div>

                        <div class="mazemaster-section">
                            <button id="mazemaster_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                <i class="fa-solid fa-save"></i> Save Profile
                            </button>
                        </div>

                        <div class="mazemaster-section">
                            <div class="mazemaster-help">
                                <div class="mazemaster-help-title">Usage:</div>
                                <code>/wheel profile="profileName"</code>
                                <div class="mazemaster-help-title">Sizes:</div>
                                <ul>
                                    <li><code>fraction</code> - Normal (1x)</li>
                                    <li><code>halfseg</code> - Half (0.5x)</li>
                                    <li><code>doubleseg</code> - Double (2x)</li>
                                </ul>
                                <small>halfseg count must equal doubleseg count</small>
                            </div>
                        </div>
                    </div>

                    <!-- COMBAT CONFIG (with sub-tabs) -->
                    <div id="mazemaster_combat_config" class="mazemaster-game-config" style="${activeGame === 'combat' ? '' : 'display: none;'}">
                        <!-- Combat Sub-tabs -->
                        <div class="mazemaster-combat-subtabs">
                            <button class="combat-subtab active" data-combat="battlebar">Battlebar</button>
                            <button class="combat-subtab" data-combat="turnbased">Turn-Based</button>
                            <button class="combat-subtab" data-combat="qte">QTE</button>
                            <button class="combat-subtab" data-combat="dice">Dice</button>
                            <button class="combat-subtab" data-combat="stealth">Stealth</button>
                            <button class="combat-subtab" data-combat="puzzle">Puzzle</button>
                            <button class="combat-subtab" data-combat="negotiation">Negotiation</button>
                        </div>

                        <!-- BATTLEBAR SUB-TAB -->
                        <div id="combat_battlebar_content" class="combat-content active">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Battlebar Profile</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_bb_profile_select" class="mazemaster-select">
                                    ${bbProfiles.length === 0 ? '<option value="">No profiles</option>' : ''}
                                    ${bbProfiles.map(p => `<option value="${escapeHtml(p)}" ${p === currentBbProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                </select>
                                <button id="mazemaster_bb_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                                <button id="mazemaster_bb_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                                <button id="mazemaster_bb_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                    <i class="fa-solid fa-pen"></i>
                                </button>
                                <button id="mazemaster_bb_export_btn" class="menu_button menu_button_icon" title="Export Profile">
                                    <i class="fa-solid fa-download"></i>
                                </button>
                                <button id="mazemaster_bb_import_btn" class="menu_button menu_button_icon" title="Import Profile">
                                    <i class="fa-solid fa-upload"></i>
                                </button>
                                <input type="file" id="mazemaster_bb_import_file" accept=".json" style="display: none;">
                                <button id="mazemaster_preview_battlebar_btn" class="menu_button menu_button_icon" title="Preview Battlebar">
                                    <i class="fa-solid fa-eye"></i>
                                </button>
                            </div>
                        </div>

                        <div class="mazemaster-section mazemaster-profile-settings">
                            <div class="mazemaster-bb-settings">
                                <div class="mazemaster-bb-row">
                                    <div class="mazemaster-bb-field" style="flex: 2;">
                                        <label>Difficulty <span id="mazemaster_bb_diff_val" style="opacity: 0.7;">(${currentBb.difficulty || 5})</span></label>
                                        <input type="range" id="mazemaster_bb_difficulty" min="1" max="10" value="${currentBb.difficulty || 5}" style="width: 100%;">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Damage</label>
                                        <input type="number" id="mazemaster_bb_damage" min="0" max="100" value="${currentBb.damage || 25}" title="HP damage on loss">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Hits to Win</label>
                                        <input type="number" id="mazemaster_bb_hits" min="1" max="20" value="${currentBb.hitsToWin || 5}">
                                    </div>
                                    <div class="mazemaster-bb-field">
                                        <label>Misses to Lose</label>
                                        <input type="number" id="mazemaster_bb_misses" min="1" max="20" value="${currentBb.missesToLose || 3}">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Main Title</label>
                            <input type="text" id="mazemaster_bb_main_title" class="mazemaster-input" placeholder="e.g. Boss Battle!" value="${escapeHtml(currentBb.mainTitle || '')}">
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Commands</label>
                            <div class="mazemaster-bb-commands">
                                <div class="mazemaster-bb-command">
                                    <label>On Hit:</label>
                                    <textarea id="mazemaster_bb_hit_cmd" placeholder="/echo Hit!">${escapeHtml(currentBb.hitCommand || '')}</textarea>
                                </div>
                                <div class="mazemaster-bb-command">
                                    <label>On Miss:</label>
                                    <textarea id="mazemaster_bb_miss_cmd" placeholder="/echo Miss!">${escapeHtml(currentBb.missCommand || '')}</textarea>
                                </div>
                                <div class="mazemaster-bb-command">
                                    <label>On Win:</label>
                                    <textarea id="mazemaster_bb_win_cmd" placeholder="/echo Victory!">${escapeHtml(currentBb.winCommand || '')}</textarea>
                                </div>
                                <div class="mazemaster-bb-command">
                                    <label>On Lose:</label>
                                    <textarea id="mazemaster_bb_lose_cmd" placeholder="/echo Defeat!">${escapeHtml(currentBb.loseCommand || '')}</textarea>
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Stages (click image to edit message)</label>
                            <div id="mazemaster_bb_images_list" class="mazemaster-bb-images-list">
                                <!-- Images rendered here -->
                            </div>
                            <button id="mazemaster_bb_add_image_btn" class="menu_button mazemaster-add-btn">
                                <i class="fa-solid fa-plus"></i> Add Image
                            </button>
                            <input type="file" id="mazemaster_bb_image_file" accept="image/*" style="display: none;">
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Item Drops on Win (Maze Only)</label>
                            <div class="mazemaster-row">
                                <label>Key %</label>
                                <input type="number" id="mazemaster_bb_key_drop" class="mazemaster-input-small" min="0" max="100" value="${currentBb.keyDropChance ?? 40}">
                            </div>
                            <div class="mazemaster-row">
                                <label>Strike %</label>
                                <input type="number" id="mazemaster_bb_pow_drop" class="mazemaster-input-small" min="0" max="100" value="${currentBb.strikeDropChance ?? 20}">
                            </div>
                            <div class="mazemaster-row">
                                <label>Stealth %</label>
                                <input type="number" id="mazemaster_bb_stealth_drop" class="mazemaster-input-small" min="0" max="100" value="${currentBb.stealthDropChance ?? 10}">
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <button id="mazemaster_bb_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                <i class="fa-solid fa-save"></i> Save Profile
                            </button>
                        </div>

                        <div class="mazemaster-section">
                            <div class="mazemaster-help">
                                <div class="mazemaster-help-title">Usage:</div>
                                <code>/battlebar profile="profileName"</code>
                                <div class="mazemaster-help-title">Difficulty:</div>
                                <ul>
                                    <li><code>1</code> - Easy (large zone, slow)</li>
                                    <li><code>5</code> - Medium</li>
                                    <li><code>10</code> - Hard (small zone, fast)</li>
                                </ul>
                            </div>
                        </div>
                        </div><!-- End combat_battlebar_content -->

                        <!-- TURN-BASED SUB-TAB -->
                        <div id="combat_turnbased_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Turn-Based Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_tb_profile_select" class="mazemaster-select">
                                        ${getTurnbasedProfileNames().length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${getTurnbasedProfileNames().map(p => `<option value="${escapeHtml(p)}" ${p === extensionSettings.currentTurnbasedProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_tb_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_tb_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_tb_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                    <button id="mazemaster_preview_turnbased_btn" class="menu_button menu_button_icon" title="Preview Turn-Based">
                                        <i class="fa-solid fa-eye"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Display</label>
                                <div class="mazemaster-row">
                                    <label>Title</label>
                                    <input type="text" id="mazemaster_tb_main_title" class="mazemaster-input" placeholder="Combat!" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Enemy Name</label>
                                    <input type="text" id="mazemaster_tb_enemy_name" class="mazemaster-input" placeholder="Enemy" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Description</label>
                                    <textarea id="mazemaster_tb_description" class="mazemaster-input" rows="2" placeholder="A fierce battle awaits..."></textarea>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Combat Stats</label>
                                <div class="mazemaster-combat-grid">
                                    <div class="mazemaster-combat-col">
                                        <strong style="color: #2ecc71;">Player</strong>
                                        <div class="mazemaster-row">
                                            <label>HP</label>
                                            <input type="number" id="mazemaster_tb_player_hp" class="mazemaster-input-small" min="1" max="999" value="100">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Attack</label>
                                            <input type="number" id="mazemaster_tb_player_attack" class="mazemaster-input-small" min="1" max="99" value="15">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Defense</label>
                                            <input type="number" id="mazemaster_tb_player_defense" class="mazemaster-input-small" min="0" max="99" value="5">
                                        </div>
                                    </div>
                                    <div class="mazemaster-combat-col">
                                        <strong style="color: #e74c3c;">Enemy</strong>
                                        <div class="mazemaster-row">
                                            <label>HP</label>
                                            <input type="number" id="mazemaster_tb_enemy_hp" class="mazemaster-input-small" min="1" max="999" value="50">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Attack</label>
                                            <input type="number" id="mazemaster_tb_enemy_attack" class="mazemaster-input-small" min="1" max="99" value="8">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Defense</label>
                                            <input type="number" id="mazemaster_tb_enemy_defense" class="mazemaster-input-small" min="0" max="99" value="2">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Mechanics</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Turn Order</label>
                                            <select id="mazemaster_tb_turn_order" class="mazemaster-select">
                                                <option value="player_first">Player First</option>
                                                <option value="enemy_first">Enemy First</option>
                                                <option value="random">Random</option>
                                            </select>
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Flee Chance %</label>
                                            <input type="number" id="mazemaster_tb_flee_chance" class="mazemaster-input-small" min="0" max="100" value="50">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Crit Chance %</label>
                                            <input type="number" id="mazemaster_tb_crit_chance" class="mazemaster-input-small" min="0" max="100" value="15">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Crit Multiplier</label>
                                            <input type="number" id="mazemaster_tb_crit_mult" class="mazemaster-input-small" min="1" max="5" step="0.1" value="1.5">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="flex: 2;">
                                            <label>Difficulty <span id="mazemaster_tb_diff_val" style="opacity: 0.7;">(5)</span></label>
                                            <input type="range" id="mazemaster_tb_difficulty" min="1" max="10" value="5" style="width: 100%;">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Damage on Loss</label>
                                            <input type="number" id="mazemaster_tb_damage" class="mazemaster-input-small" min="0" max="100" value="15">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Win:</label>
                                        <textarea id="mazemaster_tb_on_win" placeholder="/echo Victory!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Lose:</label>
                                        <textarea id="mazemaster_tb_on_lose" placeholder="/echo Defeat..."></textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Item Drops on Win</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Key %</label>
                                            <input type="number" id="mazemaster_tb_key_drop" class="mazemaster-input-small" min="0" max="100" value="30">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Strike %</label>
                                            <input type="number" id="mazemaster_tb_strike_drop" class="mazemaster-input-small" min="0" max="100" value="15">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Stealth %</label>
                                            <input type="number" id="mazemaster_tb_stealth_drop" class="mazemaster-input-small" min="0" max="100" value="10">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Potion %</label>
                                            <input type="number" id="mazemaster_tb_potion_drop" class="mazemaster-input-small" min="0" max="100" value="25">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_tb_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_turnbased_content -->

                        <!-- QTE SUB-TAB -->
                        <div id="combat_qte_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">QTE Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_qte_profile_select" class="mazemaster-select">
                                        ${getQteProfileNames().length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${getQteProfileNames().map(p => `<option value="${escapeHtml(p)}" ${p === extensionSettings.currentQteProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_qte_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_qte_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_qte_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                    <button id="mazemaster_preview_qte_btn" class="menu_button menu_button_icon" title="Preview QTE">
                                        <i class="fa-solid fa-eye"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Display</label>
                                <div class="mazemaster-row">
                                    <label>Title</label>
                                    <input type="text" id="mazemaster_qte_main_title" class="mazemaster-input" placeholder="Reaction Test" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Description</label>
                                    <textarea id="mazemaster_qte_description" class="mazemaster-input" rows="2" placeholder="Press the keys as they appear!"></textarea>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Sequence Settings</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Min Length</label>
                                            <input type="number" id="mazemaster_qte_seq_min" class="mazemaster-input-small" min="1" max="20" value="3">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Max Length</label>
                                            <input type="number" id="mazemaster_qte_seq_max" class="mazemaster-input-small" min="1" max="20" value="5">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Time Window (ms)</label>
                                            <input type="number" id="mazemaster_qte_time_base" class="mazemaster-input-small" min="500" max="5000" step="100" value="1500">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Min Time (ms)</label>
                                            <input type="number" id="mazemaster_qte_time_min" class="mazemaster-input-small" min="200" max="2000" step="100" value="800">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="flex: 2;">
                                            <label>Difficulty <span id="mazemaster_qte_diff_val" style="opacity: 0.7;">(5)</span></label>
                                            <input type="range" id="mazemaster_qte_difficulty" min="1" max="10" value="5" style="width: 100%;">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Damage on Fail</label>
                                            <input type="number" id="mazemaster_qte_damage" class="mazemaster-input-small" min="0" max="100" value="10">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Perfect Window %</label>
                                            <input type="number" id="mazemaster_qte_perfect" class="mazemaster-input-small" min="10" max="50" value="30">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Allowed Keys</label>
                                <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                                    <label style="display: flex; align-items: center; gap: 4px;"><input type="checkbox" id="mazemaster_qte_key_w" checked> W</label>
                                    <label style="display: flex; align-items: center; gap: 4px;"><input type="checkbox" id="mazemaster_qte_key_a" checked> A</label>
                                    <label style="display: flex; align-items: center; gap: 4px;"><input type="checkbox" id="mazemaster_qte_key_s" checked> S</label>
                                    <label style="display: flex; align-items: center; gap: 4px;"><input type="checkbox" id="mazemaster_qte_key_d" checked> D</label>
                                    <label style="display: flex; align-items: center; gap: 4px;"><input type="checkbox" id="mazemaster_qte_key_space" checked> SPACE</label>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Complete:</label>
                                        <textarea id="mazemaster_qte_on_complete" placeholder="/echo Quick reflexes!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Fail:</label>
                                        <textarea id="mazemaster_qte_on_fail" placeholder="/echo Too slow..."></textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_qte_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_qte_content -->

                        <!-- DICE SUB-TAB -->
                        <div id="combat_dice_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Dice Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_dice_profile_select" class="mazemaster-select">
                                        ${getDiceProfileNames().length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${getDiceProfileNames().map(p => `<option value="${escapeHtml(p)}" ${p === extensionSettings.currentDiceProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_dice_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_dice_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_dice_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                    <button id="mazemaster_preview_dice_btn" class="menu_button menu_button_icon" title="Preview Dice">
                                        <i class="fa-solid fa-eye"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Display</label>
                                <div class="mazemaster-row">
                                    <label>Title</label>
                                    <input type="text" id="mazemaster_dice_main_title" class="mazemaster-input" placeholder="Skill Check" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Description</label>
                                    <textarea id="mazemaster_dice_description" class="mazemaster-input" rows="2" placeholder="Roll to beat the target!"></textarea>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Dice Settings</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Dice Count</label>
                                            <input type="number" id="mazemaster_dice_count" class="mazemaster-input-small" min="1" max="10" value="2">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Dice Type</label>
                                            <select id="mazemaster_dice_type" class="mazemaster-select">
                                                <option value="4">d4</option>
                                                <option value="6" selected>d6</option>
                                                <option value="8">d8</option>
                                                <option value="10">d10</option>
                                                <option value="12">d12</option>
                                                <option value="20">d20</option>
                                                <option value="100">d100</option>
                                            </select>
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Target Number</label>
                                            <input type="number" id="mazemaster_dice_target" class="mazemaster-input-small" min="1" max="100" value="7">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Modifier</label>
                                            <input type="number" id="mazemaster_dice_modifier" class="mazemaster-input-small" min="-20" max="20" value="0">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="flex: 2;">
                                            <label>Difficulty <span id="mazemaster_dice_diff_val" style="opacity: 0.7;">(5)</span></label>
                                            <input type="range" id="mazemaster_dice_difficulty" min="1" max="10" value="5" style="width: 100%;">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Damage on Fail</label>
                                            <input type="number" id="mazemaster_dice_damage" class="mazemaster-input-small" min="0" max="100" value="15">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Rerolls</label>
                                            <input type="number" id="mazemaster_dice_rerolls" class="mazemaster-input-small" min="0" max="5" value="1">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Success:</label>
                                        <textarea id="mazemaster_dice_on_success" placeholder="/echo Success!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Fail:</label>
                                        <textarea id="mazemaster_dice_on_fail" placeholder="/echo Failed the check..."></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Critical:</label>
                                        <textarea id="mazemaster_dice_on_crit" placeholder="/echo Critical success!"></textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_dice_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_dice_content -->

                        <!-- STEALTH SUB-TAB -->
                        <div id="combat_stealth_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Stealth Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_stealth_profile_select" class="mazemaster-select">
                                        ${getStealthProfileNames().length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${getStealthProfileNames().map(p => `<option value="${escapeHtml(p)}" ${p === extensionSettings.currentStealthProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_stealth_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_stealth_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_stealth_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                    <button id="mazemaster_preview_stealth_btn" class="menu_button menu_button_icon" title="Preview Stealth">
                                        <i class="fa-solid fa-eye"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Display</label>
                                <div class="mazemaster-row">
                                    <label>Title</label>
                                    <input type="text" id="mazemaster_stealth_main_title" class="mazemaster-input" placeholder="Sneak Past" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Guard Name</label>
                                    <input type="text" id="mazemaster_stealth_guard_name" class="mazemaster-input" placeholder="Guard" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Description</label>
                                    <textarea id="mazemaster_stealth_description" class="mazemaster-input" rows="2" placeholder="Sneak past without being detected!"></textarea>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Stealth Settings</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Sections</label>
                                            <input type="number" id="mazemaster_stealth_sections" class="mazemaster-input-small" min="1" max="10" value="3" title="Areas to pass through">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Detection Limit</label>
                                            <input type="number" id="mazemaster_stealth_detection_limit" class="mazemaster-input-small" min="50" max="200" value="100" title="Max detection before caught">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Base Detection</label>
                                            <input type="number" id="mazemaster_stealth_base_detection" class="mazemaster-input-small" min="5" max="50" value="15" title="Detection gain when advancing">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Damage on Fail</label>
                                            <input type="number" id="mazemaster_stealth_damage" class="mazemaster-input-small" min="0" max="100" value="20">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="flex: 2;">
                                            <label>Difficulty <span id="mazemaster_stealth_diff_val" style="opacity: 0.7;">(5)</span></label>
                                            <input type="range" id="mazemaster_stealth_difficulty" min="1" max="10" value="5" style="width: 100%;">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Hide Reduction</label>
                                            <input type="number" id="mazemaster_stealth_hide_reduce" class="mazemaster-input-small" min="5" max="30" value="10" title="Detection reduced by Hide">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Distract Max</label>
                                            <input type="number" id="mazemaster_stealth_distract_max" class="mazemaster-input-small" min="10" max="50" value="25" title="Max detection reduced by Distract">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Success:</label>
                                        <textarea id="mazemaster_stealth_on_success" placeholder="/echo You made it past!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Caught:</label>
                                        <textarea id="mazemaster_stealth_on_caught" placeholder="/echo You've been spotted!"></textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_stealth_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_stealth_content -->

                        <!-- PUZZLE SUB-TAB -->
                        <div id="combat_puzzle_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Puzzle Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_puzzle_profile_select" class="mazemaster-select">
                                        ${getPuzzleProfileNames().length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${getPuzzleProfileNames().map(p => `<option value="${escapeHtml(p)}" ${p === extensionSettings.currentPuzzleProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_puzzle_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_puzzle_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_puzzle_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                    <button id="mazemaster_preview_puzzle_btn" class="menu_button menu_button_icon" title="Preview Puzzle">
                                        <i class="fa-solid fa-eye"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Display</label>
                                <div class="mazemaster-row">
                                    <label>Title</label>
                                    <input type="text" id="mazemaster_puzzle_main_title" class="mazemaster-input" placeholder="Memory Puzzle" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Description</label>
                                    <textarea id="mazemaster_puzzle_description" class="mazemaster-input" rows="2" placeholder="Watch the sequence and repeat it!"></textarea>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Puzzle Settings</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Grid Size</label>
                                            <select id="mazemaster_puzzle_grid_size" class="mazemaster-select">
                                                <option value="2">2x2</option>
                                                <option value="3" selected>3x3</option>
                                                <option value="4">4x4</option>
                                                <option value="5">5x5</option>
                                            </select>
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Sequence Length</label>
                                            <input type="number" id="mazemaster_puzzle_seq_length" class="mazemaster-input-small" min="2" max="12" value="4">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Max Mistakes</label>
                                            <input type="number" id="mazemaster_puzzle_max_mistakes" class="mazemaster-input-small" min="1" max="10" value="5">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Hints</label>
                                            <input type="number" id="mazemaster_puzzle_hints" class="mazemaster-input-small" min="0" max="5" value="3">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="flex: 2;">
                                            <label>Difficulty <span id="mazemaster_puzzle_diff_val" style="opacity: 0.7;">(5)</span></label>
                                            <input type="range" id="mazemaster_puzzle_difficulty" min="1" max="10" value="5" style="width: 100%;">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Damage on Fail</label>
                                            <input type="number" id="mazemaster_puzzle_damage" class="mazemaster-input-small" min="0" max="100" value="15">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Time Limit (sec)</label>
                                            <input type="number" id="mazemaster_puzzle_time_limit" class="mazemaster-input-small" min="0" max="300" value="60" title="0 = no limit">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Solve:</label>
                                        <textarea id="mazemaster_puzzle_on_solve" placeholder="/echo Puzzle solved!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Fail:</label>
                                        <textarea id="mazemaster_puzzle_on_fail" placeholder="/echo Too many mistakes..."></textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_puzzle_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_puzzle_content -->

                        <!-- NEGOTIATION SUB-TAB -->
                        <div id="combat_negotiation_content" class="combat-content">
                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Negotiation Profile</label>
                                <div class="mazemaster-profile-row">
                                    <select id="mazemaster_negotiation_profile_select" class="mazemaster-select">
                                        ${getNegotiationProfileNames().length === 0 ? '<option value="">No profiles</option>' : ''}
                                        ${getNegotiationProfileNames().map(p => `<option value="${escapeHtml(p)}" ${p === extensionSettings.currentNegotiationProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                    </select>
                                    <button id="mazemaster_negotiation_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                        <i class="fa-solid fa-plus"></i>
                                    </button>
                                    <button id="mazemaster_negotiation_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                    <button id="mazemaster_negotiation_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                        <i class="fa-solid fa-pen"></i>
                                    </button>
                                    <button id="mazemaster_preview_negotiation_btn" class="menu_button menu_button_icon" title="Preview Negotiation">
                                        <i class="fa-solid fa-eye"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Display</label>
                                <div class="mazemaster-row">
                                    <label>Title</label>
                                    <input type="text" id="mazemaster_negotiate_main_title" class="mazemaster-input" placeholder="Negotiation" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>NPC Name</label>
                                    <input type="text" id="mazemaster_negotiate_npc_name" class="mazemaster-input" placeholder="Merchant" value="">
                                </div>
                                <div class="mazemaster-row">
                                    <label>Description</label>
                                    <textarea id="mazemaster_negotiate_description" class="mazemaster-input" rows="2" placeholder="Convince them to help you..."></textarea>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">Negotiation Settings</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Favor Target</label>
                                            <input type="number" id="mazemaster_negotiate_favor_target" class="mazemaster-input-small" min="25" max="100" value="75" title="Favor needed to win">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Starting Favor</label>
                                            <input type="number" id="mazemaster_negotiate_starting_favor" class="mazemaster-input-small" min="0" max="75" value="25">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Max Turns</label>
                                            <input type="number" id="mazemaster_negotiate_max_turns" class="mazemaster-input-small" min="3" max="20" value="6">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Damage on Fail</label>
                                            <input type="number" id="mazemaster_negotiate_damage" class="mazemaster-input-small" min="0" max="100" value="10">
                                        </div>
                                    </div>
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field" style="flex: 2;">
                                            <label>Difficulty <span id="mazemaster_negotiate_diff_val" style="opacity: 0.7;">(5)</span></label>
                                            <input type="range" id="mazemaster_negotiate_difficulty" min="1" max="10" value="5" style="width: 100%;">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Persuade Avg</label>
                                            <input type="number" id="mazemaster_negotiate_persuade" class="mazemaster-input-small" min="5" max="30" value="12" title="Average favor from Persuade">
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Flatter Avg</label>
                                            <input type="number" id="mazemaster_negotiate_flatter" class="mazemaster-input-small" min="5" max="25" value="10" title="Average favor from Flatter">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">NPC Personality</label>
                                <div class="mazemaster-bb-settings">
                                    <div class="mazemaster-bb-row">
                                        <div class="mazemaster-bb-field">
                                            <label>Starting Mood</label>
                                            <select id="mazemaster_negotiate_mood" class="mazemaster-select">
                                                <option value="hostile">Hostile (-favor)</option>
                                                <option value="unfriendly" selected>Unfriendly</option>
                                                <option value="neutral">Neutral</option>
                                                <option value="friendly">Friendly (+favor)</option>
                                            </select>
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Intimidate Risk</label>
                                            <select id="mazemaster_negotiate_intimidate" class="mazemaster-select">
                                                <option value="low">Low (safe)</option>
                                                <option value="medium" selected>Medium</option>
                                                <option value="high">High (risky)</option>
                                            </select>
                                        </div>
                                        <div class="mazemaster-bb-field">
                                            <label>Bribe Cost</label>
                                            <select id="mazemaster_negotiate_bribe_cost" class="mazemaster-select">
                                                <option value="key">Key</option>
                                                <option value="gold" selected>Gold (10)</option>
                                                <option value="potion">Potion</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <label class="mazemaster-label">STScript Hooks</label>
                                <div class="mazemaster-bb-commands">
                                    <div class="mazemaster-bb-command">
                                        <label>On Success:</label>
                                        <textarea id="mazemaster_negotiate_on_success" placeholder="/echo They agreed to help!"></textarea>
                                    </div>
                                    <div class="mazemaster-bb-command">
                                        <label>On Fail:</label>
                                        <textarea id="mazemaster_negotiate_on_fail" placeholder="/echo Negotiations broke down..."></textarea>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-section">
                                <button id="mazemaster_negotiate_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                    <i class="fa-solid fa-save"></i> Save Profile
                                </button>
                            </div>
                        </div><!-- End combat_negotiation_content -->

                    </div><!-- End mazemaster_combat_config -->

                    <!-- MAZE CONFIG -->
                    <div id="mazemaster_maze_config" class="mazemaster-game-config" style="${activeGame === 'maze' ? '' : 'display: none;'}">
                        <!-- Profile Selection -->
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Maze Profile</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_maze_profile_select" class="mazemaster-select">
                                    ${mazeProfiles.length === 0 ? '<option value="">No profiles</option>' : ''}
                                    ${mazeProfiles.map(p => `<option value="${escapeHtml(p)}" ${p === currentMazeProfileName ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('')}
                                </select>
                                <button id="mazemaster_maze_new_profile_btn" class="menu_button menu_button_icon" title="New Profile">
                                    <i class="fa-solid fa-plus"></i>
                                </button>
                                <button id="mazemaster_maze_delete_profile_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                                <button id="mazemaster_maze_rename_profile_btn" class="menu_button menu_button_icon" title="Rename Profile">
                                    <i class="fa-solid fa-pen"></i>
                                </button>
                            </div>
                        </div>

                        <!-- Grid Size and Difficulty -->
                        <div class="mazemaster-inline-row">
                            <div class="mazemaster-section mazemaster-flex-1">
                                <label class="mazemaster-label">Grid Size</label>
                                <select id="mazemaster_maze_size" class="mazemaster-select">
                                    <option value="5" ${(currentMazeData.gridSize || 10) === 5 ? 'selected' : ''}>5x5</option>
                                    <option value="6" ${(currentMazeData.gridSize || 10) === 6 ? 'selected' : ''}>6x6</option>
                                    <option value="7" ${(currentMazeData.gridSize || 10) === 7 ? 'selected' : ''}>7x7</option>
                                    <option value="8" ${(currentMazeData.gridSize || 10) === 8 ? 'selected' : ''}>8x8</option>
                                    <option value="9" ${(currentMazeData.gridSize || 10) === 9 ? 'selected' : ''}>9x9</option>
                                    <option value="10" ${(currentMazeData.gridSize || 10) === 10 ? 'selected' : ''}>10x10</option>
                                    <option value="11" ${(currentMazeData.gridSize || 10) === 11 ? 'selected' : ''}>11x11</option>
                                    <option value="12" ${(currentMazeData.gridSize || 10) === 12 ? 'selected' : ''}>12x12</option>
                                    <option value="13" ${(currentMazeData.gridSize || 10) === 13 ? 'selected' : ''}>13x13</option>
                                    <option value="14" ${(currentMazeData.gridSize || 10) === 14 ? 'selected' : ''}>14x14</option>
                                    <option value="15" ${(currentMazeData.gridSize || 10) === 15 ? 'selected' : ''}>15x15</option>
                                    <option value="16" ${(currentMazeData.gridSize || 10) === 16 ? 'selected' : ''}>16x16</option>
                                    <option value="17" ${(currentMazeData.gridSize || 10) === 17 ? 'selected' : ''}>17x17</option>
                                    <option value="18" ${(currentMazeData.gridSize || 10) === 18 ? 'selected' : ''}>18x18</option>
                                    <option value="19" ${(currentMazeData.gridSize || 10) === 19 ? 'selected' : ''}>19x19</option>
                                    <option value="20" ${(currentMazeData.gridSize || 10) === 20 ? 'selected' : ''}>20x20</option>
                                </select>
                            </div>
                            <div class="mazemaster-section mazemaster-flex-1">
                                <label class="mazemaster-label">Difficulty</label>
                                <select id="mazemaster_maze_difficulty" class="mazemaster-select">
                                    <option value="easy" ${(currentMazeData.difficulty || 'normal') === 'easy' ? 'selected' : ''}>Easy</option>
                                    <option value="normal" ${(currentMazeData.difficulty || 'normal') === 'normal' ? 'selected' : ''}>Normal</option>
                                    <option value="hard" ${(currentMazeData.difficulty || 'normal') === 'hard' ? 'selected' : ''}>Hard</option>
                                    <option value="nightmare" ${(currentMazeData.difficulty || 'normal') === 'nightmare' ? 'selected' : ''}>Nightmare</option>
                                </select>
                            </div>
                        </div>
                        <div class="mazemaster-help-small"><small>Difficulty affects encounter density, trap frequency, loot, and starting inventory</small></div>

                        <div class="mazemaster-flex-row">
                            <div class="mazemaster-section mazemaster-flex-1">
                                <label class="mazemaster-label">Theme</label>
                                <select id="mazemaster_maze_theme" class="mazemaster-select">
                                    <option value="fantasy" ${(currentMazeData.theme || 'fantasy') === 'fantasy' ? 'selected' : ''}>Fantasy</option>
                                    <option value="horror" ${(currentMazeData.theme || 'fantasy') === 'horror' ? 'selected' : ''}>Horror</option>
                                    <option value="scifi" ${(currentMazeData.theme || 'fantasy') === 'scifi' ? 'selected' : ''}>Sci-Fi</option>
                                    <option value="action" ${(currentMazeData.theme || 'fantasy') === 'action' ? 'selected' : ''}>Action</option>
                                    <option value="cyberpunk" ${(currentMazeData.theme || 'fantasy') === 'cyberpunk' ? 'selected' : ''}>Cyberpunk</option>
                                    <option value="noir" ${(currentMazeData.theme || 'fantasy') === 'noir' ? 'selected' : ''}>Noir</option>
                                    <option value="postapoc" ${(currentMazeData.theme || 'fantasy') === 'postapoc' ? 'selected' : ''}>Post-Apocalyptic</option>
                                    <option value="comedy" ${(currentMazeData.theme || 'fantasy') === 'comedy' ? 'selected' : ''}>Comedy</option>
                                    <option value="western" ${(currentMazeData.theme || 'fantasy') === 'western' ? 'selected' : ''}>Western</option>
                                </select>
                            </div>
                            <div class="mazemaster-section mazemaster-flex-1">
                                <label class="mazemaster-label">Map Style</label>
                                <select id="mazemaster_maze_mapstyle" class="mazemaster-select">
                                    <option value="maze" ${(currentMazeData.mapStyle || 'maze') === 'maze' ? 'selected' : ''}>Classic Maze</option>
                                    <option value="dungeon" ${(currentMazeData.mapStyle || 'maze') === 'dungeon' ? 'selected' : ''}>Dungeon</option>
                                    <option value="city" ${(currentMazeData.mapStyle || 'maze') === 'city' ? 'selected' : ''}>City Streets</option>
                                    <option value="forest" ${(currentMazeData.mapStyle || 'maze') === 'forest' ? 'selected' : ''}>Forest</option>
                                    <option value="outpost" ${(currentMazeData.mapStyle || 'maze') === 'outpost' ? 'selected' : ''}>Outpost</option>
                                    <option value="spacestation" ${(currentMazeData.mapStyle || 'maze') === 'spacestation' ? 'selected' : ''}>Space Station</option>
                                    <option value="college" ${(currentMazeData.mapStyle || 'maze') === 'college' ? 'selected' : ''}>College Campus</option>
                                    <option value="apartment" ${(currentMazeData.mapStyle || 'maze') === 'apartment' ? 'selected' : ''}>Apartment Complex</option>
                                    <option value="neotokyo" ${(currentMazeData.mapStyle || 'maze') === 'neotokyo' ? 'selected' : ''}>Neo Tokyo</option>
                                    <option value="arena" ${(currentMazeData.mapStyle || 'maze') === 'arena' ? 'selected' : ''}>Battle Arena</option>
                                    <option value="hospital" ${(currentMazeData.mapStyle || 'maze') === 'hospital' ? 'selected' : ''}>Hospital</option>
                                    <option value="highrise" ${(currentMazeData.mapStyle || 'maze') === 'highrise' ? 'selected' : ''}>Abandoned Highrise</option>
                                </select>
                            </div>
                            <div class="mazemaster-section mazemaster-flex-1">
                                <label class="mazemaster-label">Floors</label>
                                <select id="mazemaster_maze_floors" class="mazemaster-select">
                                    <option value="1" ${(currentMazeData.floors || 1) === 1 ? 'selected' : ''}>1 Floor</option>
                                    <option value="2" ${(currentMazeData.floors || 1) === 2 ? 'selected' : ''}>2 Floors</option>
                                    <option value="3" ${(currentMazeData.floors || 1) === 3 ? 'selected' : ''}>3 Floors</option>
                                    <option value="4" ${(currentMazeData.floors || 1) === 4 ? 'selected' : ''}>4 Floors</option>
                                    <option value="5" ${(currentMazeData.floors || 1) === 5 ? 'selected' : ''}>5 Floors</option>
                                </select>
                            </div>
                        </div>
                        <div class="mazemaster-help-small"><small>Theme affects flavor text and item names. Map style changes the generation algorithm. Floors adds vertical navigation with staircases.</small></div>

                        <div class="mazemaster-row" style="margin-top: 8px;">
                            <label style="font-size: 0.85em; color: var(--SmartThemeBodyColor); margin-bottom: 4px; display: block;">Map Visibility</label>
                            <div class="mazemaster-radio-group" style="display: flex; gap: 12px; flex-wrap: wrap;">
                                <label class="mazemaster-radio-label" style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                    <input type="radio" name="mazemaster_map_visibility" value="showAll" ${currentMazeData.mapVisibility === 'showAll' || (!currentMazeData.mapVisibility && currentMazeData.fogOfWar === false) ? 'checked' : ''}>
                                    <span>Show Full</span>
                                </label>
                                <label class="mazemaster-radio-label" style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                    <input type="radio" name="mazemaster_map_visibility" value="fogOfWar" ${currentMazeData.mapVisibility === 'fogOfWar' || (!currentMazeData.mapVisibility && currentMazeData.fogOfWar !== false) ? 'checked' : ''}>
                                    <span>Fog of War</span>
                                </label>
                                <label class="mazemaster-radio-label" style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                    <input type="radio" name="mazemaster_map_visibility" value="hideUnexplored" ${currentMazeData.mapVisibility === 'hideUnexplored' ? 'checked' : ''}>
                                    <span>Hide Unexplored</span>
                                </label>
                            </div>
                        </div>

                        <!-- v1.4.0 BSP Configuration -->
                        <div class="mazemaster-collapsible ${currentMazeData.bspConfig?.zoneCount > 1 || currentMazeData.bspConfig?.secretDensity > 0 ? 'expanded' : ''}">
                            <button class="mazemaster-collapsible-header" data-target="bsp_config_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Zone & Secret Settings</span>
                                <span class="mazemaster-collapse-hint">(BSP dungeon generation)</span>
                            </button>
                            <div id="bsp_config_section" class="mazemaster-collapsible-content" style="display: ${currentMazeData.bspConfig?.zoneCount > 1 || currentMazeData.bspConfig?.secretDensity > 0 ? 'block' : 'none'};">
                                <div class="mazemaster-flex-row" style="gap: 10px;">
                                    <div class="mazemaster-section mazemaster-flex-1">
                                        <label class="mazemaster-label">Zone Count</label>
                                        <select id="mazemaster_bsp_zone_count" class="mazemaster-select">
                                            <option value="1" ${(currentMazeData.bspConfig?.zoneCount || 1) === 1 ? 'selected' : ''}>1 (No zones)</option>
                                            <option value="2" ${(currentMazeData.bspConfig?.zoneCount || 1) === 2 ? 'selected' : ''}>2 Zones</option>
                                            <option value="3" ${(currentMazeData.bspConfig?.zoneCount || 1) === 3 ? 'selected' : ''}>3 Zones</option>
                                            <option value="4" ${(currentMazeData.bspConfig?.zoneCount || 1) === 4 ? 'selected' : ''}>4 Zones</option>
                                            <option value="5" ${(currentMazeData.bspConfig?.zoneCount || 1) === 5 ? 'selected' : ''}>5 Zones</option>
                                        </select>
                                    </div>
                                    <div class="mazemaster-section mazemaster-flex-1">
                                        <label class="mazemaster-label">Secret Passages</label>
                                        <select id="mazemaster_bsp_secret_density" class="mazemaster-select">
                                            <option value="0" ${(currentMazeData.bspConfig?.secretDensity || 0) === 0 ? 'selected' : ''}>None</option>
                                            <option value="0.02" ${(currentMazeData.bspConfig?.secretDensity || 0) == 0.02 ? 'selected' : ''}>Low (2%)</option>
                                            <option value="0.05" ${(currentMazeData.bspConfig?.secretDensity || 0) == 0.05 ? 'selected' : ''}>Medium (5%)</option>
                                            <option value="0.08" ${(currentMazeData.bspConfig?.secretDensity || 0) == 0.08 ? 'selected' : ''}>High (8%)</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="mazemaster-flex-row" style="gap: 10px; margin-top: 8px;">
                                    <div class="mazemaster-section mazemaster-flex-1">
                                        <label class="mazemaster-checkbox-label">
                                            <input type="checkbox" id="mazemaster_bsp_zones_require_clear" ${currentMazeData.bspConfig?.zonesRequireClear !== false ? 'checked' : ''}>
                                            <span>Zones require room clearing</span>
                                        </label>
                                    </div>
                                    <div class="mazemaster-section mazemaster-flex-1">
                                        <label class="mazemaster-checkbox-label">
                                            <input type="checkbox" id="mazemaster_bsp_secret_hints" ${currentMazeData.bspConfig?.secretHints !== false ? 'checked' : ''}>
                                            <span>Show secret hints</span>
                                        </label>
                                    </div>
                                </div>
                                <div class="mazemaster-flex-row" style="gap: 10px; margin-top: 8px;">
                                    <div class="mazemaster-section mazemaster-flex-1">
                                        <label class="mazemaster-checkbox-label">
                                            <input type="checkbox" id="mazemaster_bsp_floor_scaling" ${currentMazeData.bspConfig?.floorComplexityScaling !== false ? 'checked' : ''}>
                                            <span>Scale complexity per floor</span>
                                        </label>
                                    </div>
                                </div>
                                <div class="mazemaster-help-small" style="margin-top: 6px;"><small>Zones create Metroidvania-style progression. Clear rooms to unlock the next zone. Secrets are hidden passages found by bumping walls.</small></div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Teleport Portals -->
                        <div class="mazemaster-collapsible ${(currentMazeData.portals && currentMazeData.portals.length > 0) ? 'expanded' : ''}">
                            <button class="mazemaster-collapsible-header" data-target="portals_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Teleport Portals</span>
                                <span class="mazemaster-collapse-hint">(${(currentMazeData.portals || []).length} portal pairs)</span>
                            </button>
                            <div id="portals_section" class="mazemaster-collapsible-content" style="display: ${(currentMazeData.portals && currentMazeData.portals.length > 0) ? 'block' : 'none'};">
                                <div class="mazemaster-section">
                                    <div class="mazemaster-help-small"><small>Add portals that teleport the player between two points. Leave coordinates blank for random placement.</small></div>
                                    <div id="mazemaster_portals_list" class="mazemaster-portals-list">
                                        ${(currentMazeData.portals || []).map((portal, idx) => `
                                            <div class="mazemaster-portal-item" data-portal-index="${idx}">
                                                <div class="portal-header">
                                                    <span class="portal-color" style="background: ${portal.color || '#9b59b6'}"></span>
                                                    <span class="portal-name">${escapeHtml(portal.id || 'Portal ' + (idx + 1))}</span>
                                                    <button class="menu_button remove-portal-btn" data-index="${idx}" title="Remove Portal">
                                                        <i class="fa-solid fa-trash"></i>
                                                    </button>
                                                </div>
                                                <div class="portal-details">
                                                    <div class="portal-row">
                                                        <label>ID:</label>
                                                        <input type="text" class="portal-id mazemaster-input" value="${escapeHtml(portal.id || '')}" placeholder="portal1">
                                                    </div>
                                                    <div class="portal-row">
                                                        <label>Color:</label>
                                                        <input type="color" class="portal-color-input" value="${portal.color || '#9b59b6'}">
                                                    </div>
                                                    <div class="portal-row">
                                                        <label>Bidirectional:</label>
                                                        <input type="checkbox" class="portal-bidirectional" ${portal.bidirectional !== false ? 'checked' : ''}>
                                                    </div>
                                                    <div class="portal-row coords-row">
                                                        <span>Start: X</span>
                                                        <input type="number" class="portal-start-x mazemaster-input" value="${portal.startX ?? ''}" placeholder="auto" min="0">
                                                        <span>Y</span>
                                                        <input type="number" class="portal-start-y mazemaster-input" value="${portal.startY ?? ''}" placeholder="auto" min="0">
                                                    </div>
                                                    <div class="portal-row coords-row">
                                                        <span>End: X</span>
                                                        <input type="number" class="portal-end-x mazemaster-input" value="${portal.endX ?? ''}" placeholder="auto" min="0">
                                                        <span>Y</span>
                                                        <input type="number" class="portal-end-y mazemaster-input" value="${portal.endY ?? ''}" placeholder="auto" min="0">
                                                    </div>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                    <button id="mazemaster_add_portal_btn" class="menu_button">
                                        <i class="fa-solid fa-plus"></i> Add Portal Pair
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Objectives -->
                        <div class="mazemaster-collapsible ${(currentMazeData.objectives && currentMazeData.objectives.length > 0) ? 'expanded' : ''}">
                            <button class="mazemaster-collapsible-header" data-target="objectives_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Objectives</span>
                                <span class="mazemaster-collapse-hint">(${(currentMazeData.objectives || []).length} objectives)</span>
                            </button>
                            <div id="objectives_section" class="mazemaster-collapsible-content" style="display: ${(currentMazeData.objectives && currentMazeData.objectives.length > 0) ? 'block' : 'none'};">
                                <div class="mazemaster-section">
                                    <div class="mazemaster-help-small"><small>Define objectives the player must complete. Required objectives must be done before exiting.</small></div>
                                    <div id="mazemaster_objectives_list" class="mazemaster-objectives-list">
                                        ${(currentMazeData.objectives || []).map((obj, idx) => `
                                            <div class="mazemaster-objective-item" data-objective-index="${idx}">
                                                <div class="objective-config-header">
                                                    <span class="objective-name">${escapeHtml(obj.description || obj.id || 'Objective ' + (idx + 1))}</span>
                                                    <button class="menu_button remove-objective-btn" data-index="${idx}" title="Remove Objective">
                                                        <i class="fa-solid fa-trash"></i>
                                                    </button>
                                                </div>
                                                <div class="objective-config-details">
                                                    <div class="objective-config-row">
                                                        <label>ID:</label>
                                                        <input type="text" class="objective-id mazemaster-input" value="${escapeHtml(obj.id || '')}" placeholder="obj1">
                                                    </div>
                                                    <div class="objective-config-row">
                                                        <label>Type:</label>
                                                        <select class="objective-type mazemaster-select">
                                                            <option value="collect" ${obj.type === 'collect' ? 'selected' : ''}>Collect Item</option>
                                                            <option value="defeat" ${obj.type === 'defeat' ? 'selected' : ''}>Defeat Minion</option>
                                                            <option value="explore" ${obj.type === 'explore' ? 'selected' : ''}>Explore %</option>
                                                        </select>
                                                    </div>
                                                    <div class="objective-config-row objective-target-row" style="display: ${obj.type !== 'explore' ? 'flex' : 'none'};">
                                                        <label>Target:</label>
                                                        <input type="text" class="objective-target mazemaster-input" value="${escapeHtml(obj.target || '')}" placeholder="${obj.type === 'collect' ? 'key, strike, stealth...' : 'minion ID'}">
                                                    </div>
                                                    <div class="objective-config-row">
                                                        <label>Count:</label>
                                                        <input type="number" class="objective-count mazemaster-input" value="${obj.count || 1}" min="1" placeholder="${obj.type === 'explore' ? '% to explore' : 'amount'}">
                                                    </div>
                                                    <div class="objective-config-row">
                                                        <label>Description:</label>
                                                        <input type="text" class="objective-description mazemaster-input" value="${escapeHtml(obj.description || '')}" placeholder="Find 3 Keys">
                                                    </div>
                                                    <div class="objective-config-row">
                                                        <label>Required:</label>
                                                        <input type="checkbox" class="objective-required" ${obj.required ? 'checked' : ''}>
                                                    </div>
                                                    <div class="objective-config-row">
                                                        <label>Reward Script:</label>
                                                        <input type="text" class="objective-reward mazemaster-input" value="${escapeHtml(obj.reward || '')}" placeholder="/echo Objective complete!">
                                                    </div>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                    <button id="mazemaster_add_objective_btn" class="menu_button">
                                        <i class="fa-solid fa-plus"></i> Add Objective
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Main Minion -->
                        <div class="mazemaster-collapsible ${currentMazeData.mainMinion ? 'expanded' : ''}">
                            <button class="mazemaster-collapsible-header" data-target="main_minion_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Main Minion</span>
                                <span class="mazemaster-collapse-hint">(narrator/boss)</span>
                            </button>
                            <div id="main_minion_section" class="mazemaster-collapsible-content" style="display: ${currentMazeData.mainMinion ? 'block' : 'none'};">
                                <div class="mazemaster-section">
                                    <select id="mazemaster_maze_main_minion" class="mazemaster-select">
                                        <option value="">None</option>
                                        ${minionsList.map(id => {
                                            const m = getMinion(id);
                                            return `<option value="${escapeHtml(id)}" ${currentMazeData.mainMinion === id ? 'selected' : ''}>${escapeHtml(m?.name || id)}</option>`;
                                        }).join('')}
                                    </select>
                                    <div class="mazemaster-help-small"><small>The main minion narrates the maze and guards the exit</small></div>
                                </div>

                                <div id="mazemaster_main_minion_settings" class="mazemaster-subsection" style="display: ${currentMazeData.mainMinion ? 'block' : 'none'};">
                                    <div class="mazemaster-section">
                                        <label class="mazemaster-label">Intro Message</label>
                                        <input type="text" id="mazemaster_maze_intro_message" class="mazemaster-input" placeholder="Welcome to my maze..." value="${escapeHtml(currentMazeData.mainMinionIntroMessage || '')}">
                                    </div>

                                    <div class="mazemaster-inline-row">
                                        <div class="mazemaster-section mazemaster-flex-1">
                                            <label class="mazemaster-label">Random Msg %</label>
                                            <input type="number" id="mazemaster_maze_random_chance" class="mazemaster-input" min="0" max="100" value="${currentMazeData.mainMinionRandomChance || 15}">
                                        </div>
                                    </div>

                                    <div class="mazemaster-section">
                                        <label class="mazemaster-label">Random Messages (one per line)</label>
                                        <textarea id="mazemaster_maze_random_messages" class="mazemaster-textarea" rows="2" placeholder="You're still here?&#10;Getting lost yet?">${escapeHtml((currentMazeData.mainMinionRandomMessages || []).join('\n'))}</textarea>
                                    </div>

                                    <div class="mazemaster-section">
                                        <label class="mazemaster-label">Exit Encounter</label>
                                        <div class="mazemaster-help-small"><small>What happens when the player reaches the exit</small></div>
                                        <select id="mazemaster_maze_exit_type" class="mazemaster-select">
                                            <option value="messenger" ${(currentMazeData.mainMinionExitType || 'messenger') === 'messenger' ? 'selected' : ''}>Message Only (no challenge)</option>
                                            <option value="battlebar" ${currentMazeData.mainMinionExitType === 'battlebar' ? 'selected' : ''}>Battlebar Fight</option>
                                            <option value="prizewheel" ${currentMazeData.mainMinionExitType === 'prizewheel' ? 'selected' : ''}>Prize Wheel</option>
                                            <option value="turnbased" ${currentMazeData.mainMinionExitType === 'turnbased' ? 'selected' : ''}>Turn-Based Combat</option>
                                            <option value="qte" ${currentMazeData.mainMinionExitType === 'qte' ? 'selected' : ''}>QTE Combat</option>
                                            <option value="dice" ${currentMazeData.mainMinionExitType === 'dice' ? 'selected' : ''}>Dice Combat</option>
                                            <option value="stealth" ${currentMazeData.mainMinionExitType === 'stealth' ? 'selected' : ''}>Stealth</option>
                                            <option value="puzzle" ${currentMazeData.mainMinionExitType === 'puzzle' ? 'selected' : ''}>Puzzle</option>
                                            <option value="negotiation" ${currentMazeData.mainMinionExitType === 'negotiation' ? 'selected' : ''}>Negotiation</option>
                                        </select>
                                    </div>

                                    <div id="mazemaster_exit_profile_section" class="mazemaster-section" style="display: ${currentMazeData.mainMinionExitType && currentMazeData.mainMinionExitType !== 'messenger' ? 'block' : 'none'};">
                                        <label class="mazemaster-label">Exit Game Profile</label>
                                        <div class="mazemaster-help-small"><small>Which Battlebar/Wheel profile to use for the exit boss</small></div>
                                        <select id="mazemaster_maze_exit_profile" class="mazemaster-select">
                                            <option value="">Select...</option>
                                        </select>
                                    </div>

                                    <div class="mazemaster-section">
                                        <button id="mazemaster_maze_story_btn" class="menu_button">
                                            <i class="fa-solid fa-book"></i> Story Milestones
                                        </button>
                                        <div class="mazemaster-help-small"><small>Configure story text shown as player progresses</small></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Encounters -->
                        <div class="mazemaster-collapsible expanded">
                            <button class="mazemaster-collapsible-header" data-target="encounters_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Encounters</span>
                                <span class="mazemaster-collapse-hint">(minions & traps)</span>
                            </button>
                            <div id="encounters_section" class="mazemaster-collapsible-content" style="display: block;">
                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Minion Encounters</label>
                                    <div id="mazemaster_maze_encounters_list" class="mazemaster-encounters-list">
                                        <!-- Encounter rows rendered here -->
                                    </div>
                                    <button id="mazemaster_add_encounter_btn" class="menu_button mazemaster-add-btn">
                                        <i class="fa-solid fa-plus"></i> Add Minion
                                    </button>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Trap Tiles</label>
                                    <div id="mazemaster_maze_traps_list" class="mazemaster-encounters-list">
                                        <!-- Trap encounter rows rendered here -->
                                    </div>
                                    <button id="mazemaster_add_trap_encounter_btn" class="menu_button mazemaster-add-btn">
                                        <i class="fa-solid fa-plus"></i> Add Trap
                                    </button>
                                </div>

                                <div class="mazemaster-section">
                                    <button id="mazemaster_intelligent_distribute" class="menu_button mazemaster-distribute-btn">
                                        <i class="fa-solid fa-wand-magic-sparkles"></i> Intelligent Distribute
                                    </button>
                                    <div class="mazemaster-help-small">
                                        <small>Auto-sets tile percentages based on minion types</small>
                                    </div>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">On Battlebar Loss</label>
                                    <select id="mazemaster_maze_loss_action" class="mazemaster-select">
                                        <option value="continue" ${(currentMazeData.onBattlebarLoss || 'continue') === 'continue' ? 'selected' : ''}>Continue (skip encounter)</option>
                                        <option value="respawn" ${currentMazeData.onBattlebarLoss === 'respawn' ? 'selected' : ''}>Respawn at Start</option>
                                        <option value="gameover" ${currentMazeData.onBattlebarLoss === 'gameover' ? 'selected' : ''}>Game Over</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Chests & Loot -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="chests_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Chests & Loot</span>
                            </button>
                            <div id="chests_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Chest Image</label>
                                    <div class="mazemaster-row" style="gap: 10px; align-items: center;">
                                        <div class="mazemaster-chest-preview" style="width: 50px; height: 50px; border-radius: 5px; overflow: hidden; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;">
                                            ${currentMazeData.chestImage ? `<img id="mazemaster_chest_preview_img" src="${getExtensionImagePath(currentMazeData.chestImage)}" style="width: 100%; height: 100%; object-fit: cover;">` : '<i id="mazemaster_chest_preview_icon" class="fa-solid fa-box" style="color: #888;"></i>'}
                                        </div>
                                        <button id="mazemaster_chest_image_btn" class="menu_button menu_button_icon" title="Upload Chest Image">
                                            <i class="fa-solid fa-upload"></i>
                                        </button>
                                        <input type="file" id="mazemaster_chest_image_file" accept="image/*" style="display: none;">
                                        <small style="color: #888;">Custom chest appearance</small>
                                    </div>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Chest Distribution</label>
                                    <div class="mazemaster-grid-2col">
                                        <div class="mazemaster-row">
                                            <label>Chest Tiles %</label>
                                            <input type="number" id="mazemaster_maze_chest_percent" class="mazemaster-input-small" min="0" max="50" value="${currentMazeData.chestTilePercent || 10}">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Locked %</label>
                                            <input type="number" id="mazemaster_maze_locked_percent" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.chestLockedPercent || 30}">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Locked Bonus %</label>
                                            <input type="number" id="mazemaster_maze_locked_bonus" class="mazemaster-input-small" min="0" max="200" value="${currentMazeData.chestLockedBonusPercent || 50}">
                                        </div>
                                        <div class="mazemaster-row">
                                            <label>Mimic %</label>
                                            <input type="number" id="mazemaster_maze_mimic_percent" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.chestMimicPercent || 15}">
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Loot per Chest</label>
                                    <div class="mazemaster-row">
                                        <input type="number" id="mazemaster_maze_loot_min" class="mazemaster-input-small" min="1" max="10" value="${currentMazeData.chestLootMin || 1}" style="width:50px">
                                        <span>to</span>
                                        <input type="number" id="mazemaster_maze_loot_max" class="mazemaster-input-small" min="1" max="10" value="${currentMazeData.chestLootMax || 2}" style="width:50px">
                                        <span>items</span>
                                    </div>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Regular Chest Loot %</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label>Key</label><input type="number" id="mazemaster_maze_chest_key" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.chestKeyChance || 30}"></div>
                                        <div class="mazemaster-row"><label>Strike</label><input type="number" id="mazemaster_maze_chest_pow" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.chestStrikeChance || 50}"></div>
                                        <div class="mazemaster-row"><label>Stealth</label><input type="number" id="mazemaster_maze_chest_stealth" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.chestStealthChance || 0}"></div>
                                        <div class="mazemaster-row"><label>Execute</label><input type="number" id="mazemaster_maze_chest_execute" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.chestExecuteChance || 0}"></div>
                                    </div>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Locked Chest Loot %</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label>Key</label><input type="number" id="mazemaster_maze_locked_key" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.lockedChestKeyChance || 40}"></div>
                                        <div class="mazemaster-row"><label>Strike</label><input type="number" id="mazemaster_maze_locked_pow" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.lockedChestStrikeChance || 60}"></div>
                                        <div class="mazemaster-row"><label>Stealth</label><input type="number" id="mazemaster_maze_locked_stealth" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.lockedChestStealthChance || 30}"></div>
                                        <div class="mazemaster-row"><label>Execute</label><input type="number" id="mazemaster_maze_locked_execute" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.lockedChestExecuteChance || 5}"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Victory & Loss -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="victory_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Victory & Loss</span>
                            </button>
                            <div id="victory_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Victory Message</label>
                                    <input type="text" id="mazemaster_maze_win_message" class="mazemaster-input" placeholder="You escaped the maze!" value="${escapeHtml(currentMazeData.winMessage || '')}">
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Victory Image</label>
                                    <div class="mazemaster-maze-win-image-row">
                                        <div class="mazemaster-maze-win-image-preview">
                                            ${currentMazeData.winImage ? `<img id="maze_win_image_preview" src="${escapeHtml(currentMazeData.winImage)}" alt="Victory">` : '<div id="maze_win_image_preview" class="no-image">No image</div>'}
                                        </div>
                                        <button id="mazemaster_maze_win_image_btn" class="menu_button">
                                            <i class="fa-solid fa-upload"></i> Upload
                                        </button>
                                    </div>
                                    <input type="file" id="mazemaster_maze_win_image_file" accept="image/*" style="display: none;">
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Win Command</label>
                                    <textarea id="mazemaster_maze_win_cmd" class="mazemaster-textarea" rows="2" placeholder="/echo Victory!">${escapeHtml(currentMazeData.winCommand || '')}</textarea>
                                </div>

                                <div class="mazemaster-section">
                                    <label class="mazemaster-label">Lose Command</label>
                                    <textarea id="mazemaster_maze_lose_cmd" class="mazemaster-textarea" rows="2" placeholder="/echo Defeated...">${escapeHtml(currentMazeData.loseCommand || '')}</textarea>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Starting Inventory -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="starting_inv_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Starting Inventory</span>
                            </button>
                            <div id="starting_inv_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-section">
                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor);">Combat Items</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-key"></i> Keys</label><input type="number" id="mazemaster_start_key" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.key || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-bolt"></i> Strike</label><input type="number" id="mazemaster_start_pow" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.strike || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-user-ninja"></i> Stealth</label><input type="number" id="mazemaster_start_stealth" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.stealth || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-star"></i> Execute</label><input type="number" id="mazemaster_start_execute" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.execute || 0}"></div>
                                    </div>
                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 8px;">HP Items</label>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-flask" style="color:#e74c3c;"></i> Potion</label><input type="number" id="mazemaster_start_healingPotion" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.healingPotion || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-flask" style="color:#9b59b6;"></i> Greater</label><input type="number" id="mazemaster_start_greaterHealing" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.greaterHealing || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-vial" style="color:#f1c40f;"></i> Elixir</label><input type="number" id="mazemaster_start_elixir" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.elixir || 0}"></div>
                                        <div class="mazemaster-row"><label><i class="fa-solid fa-heart" style="color:#e91e63;"></i> Revival</label><input type="number" id="mazemaster_start_revivalCharm" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.startingInventory?.revivalCharm || 0}"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: Find Early Items -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="find_early_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Find Early Items</span>
                            </button>
                            <div id="find_early_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-help-small"><small>Guarantee items in chests near the starting position. Great for ensuring vision or healing items are available early.</small></div>
                                <div class="mazemaster-section">
                                    <div class="mazemaster-grid-3col" style="margin-bottom: 8px;">
                                        <div class="mazemaster-row"><label>Search Radius</label><input type="number" id="mazemaster_findearly_radius" class="mazemaster-input-small" min="1" max="10" value="${currentMazeData.findEarly?.radius || 4}" title="Manhattan distance from start to search for chests"></div>
                                        <div class="mazemaster-row"><label>Items/Chest</label><input type="number" id="mazemaster_findearly_perchest" class="mazemaster-input-small" min="1" max="5" value="${currentMazeData.findEarly?.itemsPerChest || 1}" title="Max guaranteed items per chest"></div>
                                        <div></div>
                                    </div>
                                    <label class="mazemaster-label">Items to Place Near Start</label>
                                    <div class="mazemaster-grid-5col" style="gap: 4px;">
                                        <label class="mazemaster-checkbox-label"><input type="checkbox" id="mazemaster_findearly_torch" ${currentMazeData.findEarly?.items?.includes('torch') ? 'checked' : ''}><i class="fa-solid fa-fire" style="color:#f39c12;"></i> Torch</label>
                                        <label class="mazemaster-checkbox-label"><input type="checkbox" id="mazemaster_findearly_lantern" ${currentMazeData.findEarly?.items?.includes('lantern') ? 'checked' : ''}><i class="fa-solid fa-lightbulb" style="color:#f1c40f;"></i> Lantern</label>
                                        <label class="mazemaster-checkbox-label"><input type="checkbox" id="mazemaster_findearly_mapFragment" ${currentMazeData.findEarly?.items?.includes('mapFragment') ? 'checked' : ''}><i class="fa-solid fa-map" style="color:#3498db;"></i> Map</label>
                                        <label class="mazemaster-checkbox-label"><input type="checkbox" id="mazemaster_findearly_healingPotion" ${currentMazeData.findEarly?.items?.includes('healingPotion') ? 'checked' : ''}><i class="fa-solid fa-flask" style="color:#e74c3c;"></i> Potion</label>
                                        <label class="mazemaster-checkbox-label"><input type="checkbox" id="mazemaster_findearly_greaterHealing" ${currentMazeData.findEarly?.items?.includes('greaterHealing') ? 'checked' : ''}><i class="fa-solid fa-flask" style="color:#9b59b6;"></i> Greater</label>
                                        <label class="mazemaster-checkbox-label"><input type="checkbox" id="mazemaster_findearly_revealScroll" ${currentMazeData.findEarly?.items?.includes('revealScroll') ? 'checked' : ''}><i class="fa-solid fa-scroll" style="color:#9b59b6;"></i> Reveal</label>
                                        <label class="mazemaster-checkbox-label"><input type="checkbox" id="mazemaster_findearly_sightPotion" ${currentMazeData.findEarly?.items?.includes('sightPotion') ? 'checked' : ''}><i class="fa-solid fa-eye" style="color:#1abc9c;"></i> Sight</label>
                                        <label class="mazemaster-checkbox-label"><input type="checkbox" id="mazemaster_findearly_key" ${currentMazeData.findEarly?.items?.includes('key') ? 'checked' : ''}><i class="fa-solid fa-key" style="color:#f1c40f;"></i> Key</label>
                                        <label class="mazemaster-checkbox-label"><input type="checkbox" id="mazemaster_findearly_strike" ${currentMazeData.findEarly?.items?.includes('strike') ? 'checked' : ''}><i class="fa-solid fa-bolt" style="color:#e67e22;"></i> Strike</label>
                                        <label class="mazemaster-checkbox-label"><input type="checkbox" id="mazemaster_findearly_stealth" ${currentMazeData.findEarly?.items?.includes('stealth') ? 'checked' : ''}><i class="fa-solid fa-user-ninja" style="color:#2ecc71;"></i> Stealth</label>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: HP System Settings -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="hp_settings_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>HP System Settings</span>
                            </button>
                            <div id="hp_settings_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-section">
                                    <div class="mazemaster-row" style="margin-bottom: 8px;">
                                        <label style="display: flex; align-items: center; gap: 8px;">
                                            <input type="checkbox" id="mazemaster_hp_enabled" ${currentMazeData.hpEnabled !== false ? 'checked' : ''}>
                                            <span>Enable HP System</span>
                                        </label>
                                    </div>
                                    <div class="mazemaster-grid-4col">
                                        <div class="mazemaster-row"><label>Max HP</label><input type="number" id="mazemaster_hp_max" class="mazemaster-input-small" min="1" max="999" value="${currentMazeData.maxHP || 100}"></div>
                                        <div class="mazemaster-row"><label>Dmg Mult</label><input type="number" id="mazemaster_hp_battlebar_mult" class="mazemaster-input-small" min="0" max="10" step="0.1" value="${currentMazeData.battlebarDamageMultiplier ?? 1.0}" title="Multiplier for battlebar damage"></div>
                                        <div class="mazemaster-row"><label>Diff Mult</label><input type="number" id="mazemaster_hp_battlebar_diff" class="mazemaster-input-small" min="0.1" max="3" step="0.1" value="${currentMazeData.battlebarDifficultyMultiplier ?? 1.0}" title="Multiplier for battlebar difficulty (speed/zone size)"></div>
                                        <div class="mazemaster-row"><label>Respawn HP%</label><input type="number" id="mazemaster_hp_respawn" class="mazemaster-input-small" min="1" max="100" value="${currentMazeData.respawnHPPercent || 50}"></div>
                                    </div>
                                    <div class="mazemaster-row" style="margin-top: 8px;">
                                        <label>On Death</label>
                                        <select id="mazemaster_hp_ondeath" class="mazemaster-select" style="width: auto;">
                                            <option value="respawn" ${(currentMazeData.onDeath || 'respawn') === 'respawn' ? 'selected' : ''}>Respawn at Start (100% HP)</option>
                                            <option value="respawnPenalty" ${(currentMazeData.onDeath || 'respawn') === 'respawnPenalty' ? 'selected' : ''}>Respawn at Start (Penalty HP%)</option>
                                            <option value="gameover" ${(currentMazeData.onDeath || 'respawn') === 'gameover' ? 'selected' : ''}>Game Over</option>
                                        </select>
                                    </div>

                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 12px;">Safe Rooms</label>
                                    <div class="mazemaster-grid-3col">
                                        <div class="mazemaster-row"><label>Count/Floor</label><input type="number" id="mazemaster_saferoom_count" class="mazemaster-input-small" min="0" max="20" value="${currentMazeData.safeRoomCount ?? 3}"></div>
                                        <div class="mazemaster-row"><label>Heal %</label><input type="number" id="mazemaster_saferoom_heal" class="mazemaster-input-small" min="1" max="100" value="${currentMazeData.safeRoomHealPercent ?? 100}"></div>
                                        <div class="mazemaster-row">
                                            <label style="display: flex; align-items: center; gap: 4px;">
                                                <input type="checkbox" id="mazemaster_saferoom_llm" ${currentMazeData.safeRoomUseLLM ? 'checked' : ''}>
                                                <span>LLM Messages</span>
                                            </label>
                                        </div>
                                    </div>

                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 12px;">LLM Enhancement</label>
                                    <div class="mazemaster-row" style="margin-bottom: 4px;">
                                        <label style="display: flex; align-items: center; gap: 8px;">
                                            <input type="checkbox" id="mazemaster_llm_enhance_rooms" ${currentMazeData.llmEnhanceRooms !== false ? 'checked' : ''}>
                                            <span>Enhance Room Descriptions</span>
                                        </label>
                                        <small style="color: var(--SmartThemeEmColor); margin-left: 24px;">LLM generates unique descriptions on first entry</small>
                                    </div>

                                    <label style="font-size: 0.8em; color: var(--SmartThemeEmColor); margin-top: 12px;">Rest Mechanic</label>
                                    <div class="mazemaster-row" style="margin-bottom: 4px;">
                                        <label style="display: flex; align-items: center; gap: 8px;">
                                            <input type="checkbox" id="mazemaster_rest_enabled" ${currentMazeData.restEnabled !== false ? 'checked' : ''}>
                                            <span>Enable Rest Button</span>
                                        </label>
                                    </div>
                                    <div class="mazemaster-grid-3col">
                                        <div class="mazemaster-row"><label>Heal %</label><input type="number" id="mazemaster_rest_heal" class="mazemaster-input-small" min="1" max="100" value="${currentMazeData.restHealPercent ?? 20}"></div>
                                        <div class="mazemaster-row"><label>Cooldown (turns)</label><input type="number" id="mazemaster_rest_cooldown" class="mazemaster-input-small" min="0" max="99" value="${currentMazeData.restCooldown ?? 3}"></div>
                                        <div class="mazemaster-row"><label>Interrupt %</label><input type="number" id="mazemaster_rest_interrupt" class="mazemaster-input-small" min="0" max="100" value="${currentMazeData.restInterruptChance ?? 0}"></div>
                                    </div>
                                    <div class="mazemaster-row" style="margin-top: 4px;">
                                        <label>Interrupt Script <small>(empty = random encounter)</small></label>
                                        <input type="text" id="mazemaster_rest_interrupt_script" class="mazemaster-input" value="${escapeHtml(currentMazeData.restInterruptScript || '')}" placeholder="/echo You were ambushed!">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- COLLAPSIBLE: STScript Hooks -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="hooks_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>STScript Hooks</span>
                                <span class="mazemaster-collapse-hint">(advanced)</span>
                            </button>
                            <div id="hooks_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div class="mazemaster-help-small"><small>Run STScript commands when events occur. Use {{variable}} placeholders for event data.</small></div>

                                <div class="mazemaster-hooks-group">
                                    <label class="mazemaster-hooks-label">Movement</label>
                                    <div class="mazemaster-hooks-items">
                                        <div class="hook-item">
                                            <label>On Move</label>
                                            <input type="text" id="mazemaster_hook_onMove" class="mazemaster-input" value="${escapeHtml(currentMazeData.onMove || '')}" placeholder="{{x}}, {{y}}, {{direction}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Milestone</label>
                                            <input type="text" id="mazemaster_hook_onMilestone" class="mazemaster-input" value="${escapeHtml(currentMazeData.onMilestone || '')}" placeholder="{{percentage}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Explore Complete</label>
                                            <input type="text" id="mazemaster_hook_onExploreComplete" class="mazemaster-input" value="${escapeHtml(currentMazeData.onExploreComplete || '')}" placeholder="Fires at 100%">
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-hooks-group">
                                    <label class="mazemaster-hooks-label">Items</label>
                                    <div class="mazemaster-hooks-items">
                                        <div class="hook-item">
                                            <label>On Item Add</label>
                                            <input type="text" id="mazemaster_hook_onItemAdd" class="mazemaster-input" value="${escapeHtml(currentMazeData.onItemAdd || '')}" placeholder="{{item}}, {{count}}, {{total}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Item Remove</label>
                                            <input type="text" id="mazemaster_hook_onItemRemove" class="mazemaster-input" value="${escapeHtml(currentMazeData.onItemRemove || '')}" placeholder="{{item}}, {{count}}, {{remaining}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Chest Open</label>
                                            <input type="text" id="mazemaster_hook_onChestOpen" class="mazemaster-input" value="${escapeHtml(currentMazeData.onChestOpen || '')}" placeholder="{{type}}, {{loot}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Trade</label>
                                            <input type="text" id="mazemaster_hook_onTrade" class="mazemaster-input" value="${escapeHtml(currentMazeData.onTrade || '')}" placeholder="{{given}}, {{received}}">
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-hooks-group">
                                    <label class="mazemaster-hooks-label">Special Tiles</label>
                                    <div class="mazemaster-hooks-items">
                                        <div class="hook-item">
                                            <label>On Enemy Move</label>
                                            <input type="text" id="mazemaster_hook_onEnemyMove" class="mazemaster-input" value="${escapeHtml(currentMazeData.onEnemyMove || '')}" placeholder="{{minionId}}, {{fromX}}, {{fromY}}, {{toX}}, {{toY}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Teleport</label>
                                            <input type="text" id="mazemaster_hook_onTeleport" class="mazemaster-input" value="${escapeHtml(currentMazeData.onTeleport || '')}" placeholder="{{portalId}}, {{fromX}}, {{fromY}}, {{toX}}, {{toY}}">
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-hooks-group">
                                    <label class="mazemaster-hooks-label">Objectives</label>
                                    <div class="mazemaster-hooks-items">
                                        <div class="hook-item">
                                            <label>On Progress</label>
                                            <input type="text" id="mazemaster_hook_onObjectiveProgress" class="mazemaster-input" value="${escapeHtml(currentMazeData.onObjectiveProgress || '')}" placeholder="{{objectiveId}}, {{current}}, {{target}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On Complete</label>
                                            <input type="text" id="mazemaster_hook_onObjectiveComplete" class="mazemaster-input" value="${escapeHtml(currentMazeData.onObjectiveComplete || '')}" placeholder="{{objectiveId}}">
                                        </div>
                                        <div class="hook-item">
                                            <label>On All Complete</label>
                                            <input type="text" id="mazemaster_hook_onAllObjectivesComplete" class="mazemaster-input" value="${escapeHtml(currentMazeData.onAllObjectivesComplete || '')}" placeholder="All required done">
                                        </div>
                                    </div>
                                </div>

                                <div class="mazemaster-hooks-group">
                                    <label class="mazemaster-hooks-label">Stats</label>
                                    <div class="mazemaster-hooks-items">
                                        <div class="hook-item">
                                            <label>On Stat Update</label>
                                            <input type="text" id="mazemaster_hook_onStatUpdate" class="mazemaster-input" value="${escapeHtml(currentMazeData.onStatUpdate || '')}" placeholder="{{statName}}, {{value}}">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Save Button -->
                        <div class="mazemaster-section">
                            <button id="mazemaster_maze_save_btn" class="menu_button menu_button_primary mazemaster-save-btn">
                                <i class="fa-solid fa-save"></i> Save Profile
                            </button>
                        </div>

                        <!-- Saved Games -->
                        <div class="mazemaster-collapsible">
                            <button class="mazemaster-collapsible-header" data-target="saved_games_section">
                                <i class="fa-solid fa-chevron-right mazemaster-collapse-icon"></i>
                                <span>Saved Games</span>
                            </button>
                            <div id="saved_games_section" class="mazemaster-collapsible-content" style="display: none;">
                                <div id="mazemaster_saved_games_list" class="mazemaster-saved-games-list">
                                    <!-- Saved games rendered here -->
                                </div>
                            </div>
                        </div>

                        <!-- Usage Help -->
                        <div class="mazemaster-section">
                            <div class="mazemaster-help">
                                <div class="mazemaster-help-title">Usage:</div>
                                <code>/maze profile="profileName"</code>
                            </div>
                        </div>
                    </div>

                    <!-- MINIONS CONFIG -->
                    <div id="mazemaster_minions_config" class="mazemaster-game-config" style="${activeGame === 'minions' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Minion Profile</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_minion_profile_select" class="mazemaster-select">
                                    <option value="">-- Show All Minions --</option>
                                    ${Object.keys(extensionSettings.minionProfiles || {}).map(p => `<option value="${escapeHtml(p)}">${escapeHtml(p)}</option>`).join('')}
                                </select>
                                <button id="mazemaster_minion_profile_save_btn" class="menu_button menu_button_icon" title="Save Current as Profile">
                                    <i class="fa-solid fa-floppy-disk"></i>
                                </button>
                                <button id="mazemaster_minion_profile_load_btn" class="menu_button menu_button_icon" title="Load Profile">
                                    <i class="fa-solid fa-folder-open"></i>
                                </button>
                                <button id="mazemaster_minion_profile_delete_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                            </div>
                            <div class="mazemaster-help-small"><small>Save/load sets of minions as profiles</small></div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Minions</label>
                            <div id="mazemaster_minions_list" class="mazemaster-minions-list">
                                <!-- Minions rendered here -->
                            </div>
                            <button id="mazemaster_add_minion_btn" class="menu_button mazemaster-add-btn">
                                <i class="fa-solid fa-plus"></i> Add Minion
                            </button>
                            <input type="file" id="mazemaster_minion_image_file" accept="image/*" style="display: none;">
                        </div>

                        <div class="mazemaster-section">
                            <div class="mazemaster-help">
                                <div class="mazemaster-help-title">Usage:</div>
                                <code>/mazeminion name="MinionName" message="Hello!"</code>
                                <p><small>Sets the minion display in an active maze game.</small></p>
                            </div>
                        </div>
                    </div>

                    <!-- TRAPS CONFIG -->
                    <div id="mazemaster_traps_config" class="mazemaster-game-config" style="${activeGame === 'traps' ? '' : 'display: none;'}">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Trap Profile</label>
                            <div class="mazemaster-profile-row">
                                <select id="mazemaster_trap_profile_select" class="mazemaster-select">
                                    <option value="">(Current Traps)</option>
                                    ${Object.keys(extensionSettings.trapProfiles || {}).map(p => `<option value="${escapeHtml(p)}">${escapeHtml(p)}</option>`).join('')}
                                </select>
                                <button id="mazemaster_trap_profile_save_btn" class="menu_button menu_button_icon" title="Save Current as Profile">
                                    <i class="fa-solid fa-floppy-disk"></i>
                                </button>
                                <button id="mazemaster_trap_profile_load_btn" class="menu_button menu_button_icon" title="Load Profile">
                                    <i class="fa-solid fa-folder-open"></i>
                                </button>
                                <button id="mazemaster_trap_profile_delete_btn" class="menu_button menu_button_icon" title="Delete Profile">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                            </div>
                            <div class="mazemaster-help-small"><small>Save/load sets of traps as profiles</small></div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label">Traps</label>
                            <div id="mazemaster_traps_list" class="mazemaster-traps-list">
                                <!-- Traps rendered here -->
                            </div>
                            <button id="mazemaster_add_trap_btn" class="menu_button mazemaster-add-btn">
                                <i class="fa-solid fa-plus"></i> Add Trap
                            </button>
                            <input type="file" id="mazemaster_trap_image_file" accept="image/*" style="display: none;">
                        </div>

                        <div class="mazemaster-section">
                            <div class="mazemaster-help">
                                <div class="mazemaster-help-title">Traps:</div>
                                <p><small>Traps can be placed on maze tiles. When a player steps on a trap, it shows the image/message and runs the script.</small></p>
                                <p><small>Add traps to maze profiles in the Maze tab under "Trap Tiles".</small></p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- HELP TAB -->
                <div class="mazemaster-tab-content" id="mazemaster-tab-help">
                    <div class="mazemaster-help-reference">
                        <div class="mazemaster-section">
                            <label class="mazemaster-label"><i class="fa-solid fa-terminal"></i> Slash Commands Reference</label>

                            <div class="mazemaster-help-category">
                                <div class="mazemaster-help-title">Wheel Commands</div>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-command">
                                        <code>/wheel [profile="name"]</code>
                                        <span>Open the wheel using specified or current profile</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/spin [profile]</code>
                                        <span>Spin the wheel using the specified or current profile</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/spinresult</code>
                                        <span>Returns the last wheel spin result</span>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-help-category">
                                <div class="mazemaster-help-title">Battlebar Commands</div>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-command">
                                        <code>/battlebar [profile="name"]</code>
                                        <span>Start a battlebar challenge (difficulty 1-10)</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/battlebarresult</code>
                                        <span>Returns the last battlebar result (win/lose)</span>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-help-category">
                                <div class="mazemaster-help-title">Maze Commands</div>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-command">
                                        <code>/maze [profile="name"]</code>
                                        <span>Start a maze using the specified or current profile</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazeclose</code>
                                        <span>Close the current maze</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazepos</code>
                                        <span>Returns current position as JSON (x, y, floor)</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazestats</code>
                                        <span>Returns maze statistics (moves, encounters, chests, etc.)</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazeexplore</code>
                                        <span>Returns exploration percentage (0-100)</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazeobjective [id="name"]</code>
                                        <span>Get objective progress (all or specific by ID)</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazemove &lt;direction&gt;</code>
                                        <span>Move the player (up/down/left/right)</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazeminion [name="x"] [message="x"]</code>
                                        <span>Set minion display in active maze</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazefloor</code>
                                        <span>Returns current/total floor info as JSON</span>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-help-category">
                                <div class="mazemaster-help-title">Maze Settings Commands</div>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-command">
                                        <code>/mazedifficulty [tier="x"]</code>
                                        <span>Get/set difficulty (easy/normal/hard/nightmare)</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazetheme [theme="x"]</code>
                                        <span>Get/set theme (fantasy/horror/scifi/action)</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazemapstyle [style="x"]</code>
                                        <span>Get/set map style (maze/dungeon/city/forest/spaceship)</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazepersonastats [persona="x"]</code>
                                        <span>Get maze stats for a persona (current if omitted)</span>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-help-category">
                                <div class="mazemaster-help-title">HP System Commands</div>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-command">
                                        <code>/mazehp [set=N]</code>
                                        <span>Get HP status as JSON, or set HP to value</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazeheal [amount=N] [percent=true]</code>
                                        <span>Heal player (absolute or % of max)</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazedamage [amount=N] [source="x"]</code>
                                        <span>Deal damage with optional source for hooks</span>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-help-category">
                                <div class="mazemaster-help-title">Inventory Commands</div>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-command">
                                        <code>/mazeitem action="add" item="x" [amount=N]</code>
                                        <span>Add item(s) to inventory by name or number</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazeitem action="remove" item="x" [amount=N]</code>
                                        <span>Remove item(s) from inventory</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mazeitem action="list"</code>
                                        <span>List all available items with IDs</span>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-help-category">
                                <div class="mazemaster-help-title">Item Reference</div>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-item-ref"><span class="item-num">1-4</span> <strong>Core:</strong> key, stealth, strike, execute</div>
                                    <div class="mazemaster-item-ref"><span class="item-num">5-10</span> <strong>Special:</strong> floorKey, portalStone, minionBane, mapFragment, timeShard, voidWalk</div>
                                    <div class="mazemaster-item-ref"><span class="item-num">11-15</span> <strong>HP:</strong> healingPotion (25%), greaterHealing (50%), elixir (100%), revivalCharm, heartCrystal (+10 max)</div>
                                    <div class="mazemaster-item-ref"><span class="item-num">16-20</span> <strong>Vision:</strong> torch (+2 for 3 moves), lantern (+1 passive), revealScroll (full floor), sightPotion (+1 perm), crystalBall (show minions)</div>
                                </div>
                            </div>

                            <div class="mazemaster-help-category">
                                <div class="mazemaster-help-title">Combat Mode Commands</div>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-command">
                                        <code>/turnbased [profile="name"]</code>
                                        <span>Start turn-based combat encounter</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/qte [profile="name"]</code>
                                        <span>Start Quick-Time Event challenge</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/dice [profile="name"]</code>
                                        <span>Start dice roll challenge</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/stealth [profile="name"]</code>
                                        <span>Start stealth encounter</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/puzzle [profile="name"]</code>
                                        <span>Start puzzle/sequence challenge</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/negotiate [profile="name"]</code>
                                        <span>Start negotiation encounter</span>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-help-category">
                                <div class="mazemaster-help-title">Encounter Commands</div>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-command">
                                        <code>/encounter [profile]</code>
                                        <span>Trigger a random minion encounter from pool</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/encounterresult</code>
                                        <span>Returns the last encounter result</span>
                                    </div>
                                </div>
                            </div>

                            <div class="mazemaster-help-category">
                                <div class="mazemaster-help-title">Utility Commands</div>
                                <div class="mazemaster-command-list">
                                    <div class="mazemaster-command">
                                        <code>/mmexport &lt;type&gt; [name]</code>
                                        <span>Export profile (wheel/maze/battlebar/minion/turnbased/qte/dice/stealth/puzzle/negotiate)</span>
                                    </div>
                                    <div class="mazemaster-command">
                                        <code>/mmimport &lt;type&gt; &lt;json&gt;</code>
                                        <span>Import profile from JSON</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label"><i class="fa-solid fa-book"></i> STScript Hooks</label>
                            <div class="mazemaster-help">
                                <p><small>Maze profiles support STScript hooks that fire on events:</small></p>
                                <ul class="mazemaster-hooks-list">
                                    <li><code>onEnter</code> - When entering the maze</li>
                                    <li><code>onExit</code> - When completing the maze</li>
                                    <li><code>onMove</code> - Each time player moves</li>
                                    <li><code>onFloorChange</code> - When changing floors</li>
                                    <li><code>onEncounter</code> - When encountering a minion</li>
                                    <li><code>onChest</code> - When opening a chest</li>
                                    <li><code>onTrap</code> - When triggering a trap</li>
                                    <li><code>onDamage</code> - When taking damage (HP system)</li>
                                    <li><code>onHeal</code> - When healing (HP system)</li>
                                    <li><code>onPlayerDeath</code> - When HP reaches 0</li>
                                </ul>
                                <p><small>Configure hooks in maze profile settings.</small></p>
                            </div>
                        </div>

                        <div class="mazemaster-section">
                            <label class="mazemaster-label"><i class="fa-solid fa-circle-info"></i> Version Info</label>
                            <div class="mazemaster-help">
                                <p><strong>MazeMaster v1.3.0</strong></p>
                                <p><small>HP System, Combat Modes (Turn-based, QTE, Dice, Stealth, Puzzle, Negotiation), Multi-floor Dungeons, Isometric Renderer, Fog of War</small></p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <style>
            .mazemaster-panel {
                display: flex;
                flex-direction: column;
                height: 100%;
            }

            .mazemaster-panel-header {
                padding: 10px 15px;
                border-bottom: 1px solid var(--SmartThemeBorderColor, #555);
            }

            .mazemaster-panel-header h2 {
                margin: 0;
                font-size: 1.2em;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .mazemaster-tabs {
                display: flex;
                border-bottom: 1px solid var(--SmartThemeBorderColor, #555);
                padding: 0 10px;
            }

            .mazemaster-tab {
                padding: 8px 16px;
                background: transparent;
                border: none;
                border-bottom: 2px solid transparent;
                cursor: pointer;
                color: var(--SmartThemeBodyColor);
                font-size: 0.9em;
            }

            .mazemaster-tab:hover {
                background: rgba(255, 255, 255, 0.05);
            }

            .mazemaster-tab.active {
                border-bottom-color: var(--SmartThemeQuoteColor, #4a7c59);
                color: var(--SmartThemeQuoteColor, #4a7c59);
            }

            .mazemaster-panel-content {
                flex: 1;
                overflow-y: auto;
                padding: 15px;
            }

            .mazemaster-tab-content {
                display: none;
            }

            .mazemaster-tab-content.active {
                display: block;
            }

            /* Combat sub-tabs */
            .mazemaster-combat-subtabs {
                display: flex;
                gap: 4px;
                margin-bottom: 12px;
                flex-wrap: wrap;
                padding-bottom: 10px;
                border-bottom: 1px solid var(--SmartThemeBorderColor, #444);
            }

            .combat-subtab {
                padding: 6px 12px;
                background: var(--SmartThemeBlurTintColor, rgba(0,0,0,0.3));
                border: 1px solid var(--SmartThemeBorderColor, #555);
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor);
                transition: all 0.15s ease;
            }

            .combat-subtab:hover {
                background: rgba(255, 255, 255, 0.1);
            }

            .combat-subtab.active {
                background: var(--SmartThemeQuoteColor, #4a7c59);
                color: var(--SmartThemeBodyColor);
                border-color: var(--SmartThemeQuoteColor, #4a7c59);
            }

            .combat-content {
                display: none;
            }

            .combat-content.active {
                display: block;
            }

            .mazemaster-section {
                margin-bottom: 15px;
            }

            .mazemaster-label {
                display: block;
                font-weight: bold;
                margin-bottom: 5px;
                font-size: 0.9em;
            }

            .mazemaster-profile-row {
                display: flex;
                gap: 5px;
            }

            .mazemaster-profile-row select {
                flex: 1;
            }

            .mazemaster-select {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-segments-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
                margin-bottom: 10px;
                max-height: 300px;
                overflow-y: auto;
            }

            .mazemaster-segment-item {
                background: rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                padding: 10px;
            }

            .mazemaster-segment-row {
                display: flex;
                gap: 8px;
                margin-bottom: 8px;
                align-items: center;
            }

            .mazemaster-segment-row:last-child {
                margin-bottom: 0;
            }

            .mazemaster-segment-field {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 2px;
            }

            .mazemaster-segment-field label {
                font-size: 0.7em;
                opacity: 0.7;
            }

            .mazemaster-segment-field input:not([type="checkbox"]),
            .mazemaster-segment-field select,
            .mazemaster-segment-field textarea {
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 5px 8px;
                color: var(--SmartThemeBodyColor);
                font-size: 0.85em;
            }

            .mazemaster-segment-field textarea {
                min-height: 40px;
                resize: vertical;
                font-family: monospace;
            }

            .mazemaster-segment-field.small {
                flex: 0 0 80px;
            }

            .mazemaster-segment-field.tiny {
                flex: 0 0 100px;
                overflow: visible;
            }

            .mazemaster-segment-checkbox {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 0.85em;
                cursor: pointer;
                white-space: nowrap;
                padding: 5px;
                margin: 0;
            }

            .mazemaster-segment-checkbox input[type="checkbox"] {
                width: 18px;
                height: 18px;
                min-width: 18px;
                min-height: 18px;
                cursor: pointer;
                pointer-events: auto;
                margin: 0;
                flex-shrink: 0;
            }

            .mazemaster-profile-settings {
                background: rgba(0, 0, 0, 0.15);
                padding: 10px;
                border-radius: 5px;
            }

            .mazemaster-profile-options {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .mazemaster-checkbox-label {
                display: flex;
                align-items: center;
                gap: 8px;
                cursor: pointer;
                font-size: 0.9em;
            }

            .mazemaster-checkbox-label input[type="checkbox"] {
                width: 16px;
                height: 16px;
                cursor: pointer;
            }

            .mazemaster-difficulty-row {
                display: flex;
                align-items: center;
                gap: 10px;
                font-size: 0.9em;
            }

            .mazemaster-select-small {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 4px 8px;
                color: var(--SmartThemeBodyColor);
                width: 60px;
            }

            .mazemaster-segment-delete {
                padding: 5px 8px;
            }

            .mazemaster-add-btn,
            .mazemaster-save-btn {
                width: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 5px;
            }

            .mazemaster-distribute-btn {
                width: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                background: linear-gradient(135deg, #9b59b6, #8e44ad) !important;
                color: #fff !important;
            }

            .mazemaster-distribute-btn:hover {
                background: linear-gradient(135deg, #8e44ad, #7d3c98) !important;
            }

            .mazemaster-help-small {
                margin-top: 5px;
                color: #888;
                text-align: center;
            }

            /* Help Tab Styles */
            .mazemaster-help-reference {
                padding: 5px;
            }

            .mazemaster-help-category {
                margin-bottom: 16px;
                padding: 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 6px;
            }

            .mazemaster-help-category .mazemaster-help-title {
                font-weight: 600;
                margin-bottom: 8px;
                color: var(--SmartThemeQuoteColor, #4a7c59);
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                padding-bottom: 5px;
            }

            .mazemaster-command-list {
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .mazemaster-command {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: baseline;
                padding: 4px 0;
            }

            .mazemaster-command code {
                background: rgba(0, 0, 0, 0.3);
                padding: 3px 8px;
                border-radius: 4px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 0.85em;
                color: #e8c170;
                white-space: nowrap;
            }

            .mazemaster-command span {
                color: #aaa;
                font-size: 0.85em;
            }

            .mazemaster-item-ref {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 3px 0;
                font-size: 0.85em;
            }

            .mazemaster-item-ref .item-num {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 20px;
                height: 20px;
                background: var(--SmartThemeQuoteColor, #4a7c59);
                border-radius: 4px;
                font-weight: bold;
                font-size: 0.8em;
            }

            .mazemaster-item-ref code {
                background: rgba(0, 0, 0, 0.3);
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Consolas', 'Monaco', monospace;
                color: #e8c170;
            }

            .mazemaster-hooks-list {
                margin: 8px 0;
                padding-left: 20px;
            }

            .mazemaster-hooks-list li {
                margin: 4px 0;
                font-size: 0.85em;
            }

            .mazemaster-hooks-list code {
                background: rgba(0, 0, 0, 0.3);
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Consolas', 'Monaco', monospace;
                color: #e8c170;
            }

            .menu_button_primary {
                background: var(--SmartThemeQuoteColor, #4a7c59) !important;
            }

            .mazemaster-help {
                background: rgba(0, 0, 0, 0.2);
                padding: 10px;
                border-radius: 5px;
                font-size: 0.85em;
            }

            .mazemaster-help-title {
                font-weight: bold;
                margin-bottom: 5px;
                margin-top: 10px;
            }

            .mazemaster-help-title:first-child {
                margin-top: 0;
            }

            .mazemaster-help code {
                background: rgba(0, 0, 0, 0.3);
                padding: 2px 6px;
                border-radius: 3px;
                font-family: monospace;
                font-size: 0.9em;
            }

            .mazemaster-help ul {
                margin: 5px 0;
                padding-left: 20px;
            }

            .mazemaster-help li {
                margin: 3px 0;
            }

            .mazemaster-help small {
                opacity: 0.7;
                display: block;
                margin-top: 5px;
            }

            .mazemaster-empty-state {
                text-align: center;
                padding: 15px;
                opacity: 0.6;
            }

            /* Game Selector */
            .mazemaster-game-selector {
                display: flex;
                gap: 10px;
                margin-bottom: 15px;
            }

            .mazemaster-game-btn {
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                padding: 10px;
                border-radius: 5px;
                transition: all 0.2s;
            }

            .mazemaster-game-btn.active {
                background: var(--SmartThemeQuoteColor, #4a7c59) !important;
                color: white;
            }

            .mazemaster-game-config {
                animation: fadeIn 0.2s ease;
            }

            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }

            /* Battlebar Styles */
            .mazemaster-bb-settings {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .mazemaster-bb-row {
                display: flex;
                gap: 10px;
            }

            .mazemaster-bb-field {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .mazemaster-bb-field label {
                font-size: 0.8em;
                opacity: 0.8;
            }

            .mazemaster-bb-field input,
            .mazemaster-bb-field select {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-bb-commands {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .mazemaster-bb-command {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .mazemaster-bb-command label {
                font-size: 0.85em;
                font-weight: bold;
            }

            .mazemaster-bb-command textarea {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 8px;
                color: var(--SmartThemeBodyColor);
                font-family: monospace;
                font-size: 0.85em;
                min-height: 40px;
                resize: vertical;
            }

            .mazemaster-bb-images-list {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 10px;
            }

            .mazemaster-input {
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 8px 10px;
                color: var(--SmartThemeBodyColor, #fff);
                font-size: 1em;
            }

            .mazemaster-input::placeholder {
                color: var(--SmartThemeBodyColor, #888);
                opacity: 0.6;
            }

            .mazemaster-bb-image-item {
                position: relative;
                width: 120px;
                display: flex;
                flex-direction: column;
                border-radius: 5px;
                overflow: hidden;
                border: 2px solid var(--SmartThemeBorderColor, #444);
                cursor: pointer;
                background: rgba(0, 0, 0, 0.2);
            }

            .mazemaster-bb-image-item:hover {
                border-color: var(--SmartThemeQuoteColor, #888);
            }

            .mazemaster-bb-image-item img {
                width: 100%;
                height: 80px;
                object-fit: cover;
            }

            .mazemaster-bb-image-item .bb-image-index {
                position: absolute;
                top: 2px;
                left: 2px;
                background: rgba(0, 0, 0, 0.7);
                color: white;
                font-size: 0.7em;
                padding: 2px 5px;
                border-radius: 3px;
            }

            .mazemaster-bb-image-item .bb-image-message {
                padding: 4px 6px;
                font-size: 0.7em;
                color: var(--SmartThemeBodyColor, #aaa);
                text-align: center;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                max-height: 20px;
            }

            .mazemaster-bb-image-item .bb-image-delete {
                position: absolute;
                top: 2px;
                right: 2px;
                background: rgba(231, 76, 60, 0.9);
                color: white;
                border: none;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0.7em;
            }

            .mazemaster-bb-image-item .bb-image-delete:hover {
                background: #c0392b;
            }

            /* Game Tab Styles */
            .mazemaster-game-launch {
                display: flex;
                flex-direction: column;
                gap: 15px;
                padding: 10px 0;
            }

            .mazemaster-play-btn {
                width: 100%;
                padding: 15px 20px;
                font-size: 1.2em;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
            }

            /* Maze Config Styles */
            .mazemaster-textarea {
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 8px 10px;
                color: var(--SmartThemeBodyColor, #fff);
                font-family: monospace;
                font-size: 0.9em;
                min-height: 60px;
                resize: vertical;
            }

            .mazemaster-maze-win-image-row {
                display: flex;
                gap: 10px;
                align-items: flex-start;
            }

            .mazemaster-maze-win-image-preview {
                width: 80px;
                height: 80px;
                border-radius: 5px;
                border: 2px solid var(--SmartThemeBorderColor, #444);
                overflow: hidden;
                background: rgba(0, 0, 0, 0.2);
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .mazemaster-maze-win-image-preview img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .mazemaster-maze-win-image-preview .no-image {
                font-size: 0.7em;
                opacity: 0.5;
                text-align: center;
            }

            /* Maze Subsection Styles */
            .mazemaster-subsection {
                background: rgba(0, 0, 0, 0.15);
                border-left: 3px solid var(--SmartThemeQuoteColor, #666);
                padding: 10px;
                margin: 10px 0;
                border-radius: 0 5px 5px 0;
            }

            /* Encounters List Styles */
            .mazemaster-encounters-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
                margin-bottom: 10px;
            }

            .mazemaster-encounter-row {
                display: flex;
                gap: 8px;
                align-items: center;
            }

            .mazemaster-encounter-row select {
                flex: 1;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-encounter-row input[type="number"] {
                width: 60px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
                text-align: center;
            }

            .mazemaster-encounter-row .encounter-remove-btn {
                padding: 5px 8px;
            }

            /* Maze Cell Minion Indicators */
            .maze-cell.has-minion:not(.hidden)::before {
                content: '?';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.7em;
                color: #f39c12;
                font-weight: bold;
                z-index: 1;
            }

            .maze-cell.minion-triggered:not(.hidden)::before {
                content: '\\2713';
                color: #27ae60;
            }

            /* Moving Minion Indicators */
            .maze-cell.minion-moving:not(.hidden):not(.minion-triggered)::before {
                animation: minion-move-pulse 0.8s ease-in-out infinite;
            }

            .maze-cell.minion-chase:not(.hidden):not(.minion-triggered)::before {
                content: '\\f06d';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                color: #e74c3c;
            }

            .maze-cell.minion-patrol:not(.hidden):not(.minion-triggered)::before {
                content: '\\f554';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                color: #9b59b6;
            }

            @keyframes minion-move-pulse {
                0%, 100% {
                    transform: translate(-50%, -50%) scale(1);
                    opacity: 1;
                }
                50% {
                    transform: translate(-50%, -50%) scale(1.15);
                    opacity: 0.8;
                }
            }

            /* Maze Cell Chest Indicators */
            .maze-cell.has-chest:not(.hidden)::before {
                content: '\\f187';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.6em;
                color: #f39c12;
                z-index: 1;
            }

            .maze-cell.chest-locked:not(.hidden)::before {
                color: #95a5a6;
            }

            .maze-cell.chest-opened:not(.hidden)::before {
                color: #666;
                opacity: 0.5;
            }

            /* Hide default icon when custom chest image is used */
            .maze-cell.has-custom-chest::before {
                display: none !important;
            }

            /* Maze Cell Trap Indicators */
            .maze-cell.has-trap:not(.hidden)::before {
                content: '\\f6e2';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.6em;
                color: #e74c3c;
                z-index: 1;
            }

            .maze-cell.trap-triggered:not(.hidden)::before {
                color: #666;
                opacity: 0.5;
            }

            /* Safe Room Indicators */
            .maze-cell.safe-room:not(.hidden) {
                background: radial-gradient(circle, rgba(45, 212, 191, 0.4), transparent 70%);
            }

            .maze-cell.safe-room:not(.hidden)::before {
                content: '\\f004';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.6em;
                color: #2dd4bf;
                z-index: 1;
                animation: saferoom-pulse 2s ease-in-out infinite;
                text-shadow: 0 0 8px rgba(45, 212, 191, 0.8);
            }

            @keyframes saferoom-pulse {
                0%, 100% { opacity: 0.7; transform: translate(-50%, -50%) scale(1); }
                50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            }

            /* Portal Indicators */
            .maze-cell.has-portal:not(.hidden)::before {
                content: '\\f111';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.7em;
                color: var(--portal-color, #9b59b6);
                z-index: 1;
                animation: portal-pulse 1.2s ease-in-out infinite;
                text-shadow: 0 0 8px var(--portal-color, #9b59b6);
            }

            .maze-cell.portal-exit-only:not(.hidden)::before {
                opacity: 0.5;
                animation: none;
            }

            .maze-cell.portal-flash {
                animation: teleport-flash 0.3s ease-out;
            }

            @keyframes portal-pulse {
                0%, 100% {
                    opacity: 0.7;
                    transform: translate(-50%, -50%) scale(1);
                }
                50% {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(1.2);
                }
            }

            @keyframes teleport-flash {
                0% {
                    background: rgba(155, 89, 182, 0.8);
                    box-shadow: 0 0 20px rgba(155, 89, 182, 0.8);
                }
                100% {
                    background: rgba(0, 0, 0, 0.4);
                    box-shadow: none;
                }
            }

            /* Staircase Indicators (v1.2.0) */
            .maze-cell.has-staircase:not(.hidden)::before {
                content: '\\f54b';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.8em;
                color: #3498db;
                z-index: 1;
                text-shadow: 0 0 4px rgba(52, 152, 219, 0.6);
            }

            .maze-cell.staircase-up:not(.hidden)::before {
                content: '\\f148';
                color: #27ae60;
                text-shadow: 0 0 4px rgba(39, 174, 96, 0.6);
            }

            .maze-cell.staircase-down:not(.hidden)::before {
                content: '\\f149';
                color: #e67e22;
                text-shadow: 0 0 4px rgba(230, 126, 34, 0.6);
            }

            .maze-cell.staircase-locked:not(.hidden)::after {
                content: '\\f023';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                top: 2px;
                right: 2px;
                font-size: 0.45em;
                color: #e74c3c;
                z-index: 2;
            }

            /* Inventory Display */
            .mazemaster-maze-inventory {
                display: flex;
                justify-content: center;
                gap: 12px;
                padding: 6px 12px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 6px;
                margin-bottom: 8px;
            }

            .inventory-item {
                display: flex;
                align-items: center;
                gap: 4px;
                font-size: 0.85em;
                color: #fff;
            }

            .inventory-item i { font-size: 0.9em; }
            .inventory-item i.fa-key { color: #f1c40f; }
            .inventory-item i.fa-user-ninja { color: #9b59b6; }
            .inventory-item i.fa-bolt { color: #e74c3c; }
            .inventory-item.execute i.fa-star { color: #ffd700; text-shadow: 0 0 5px #ffd700; }
            .inventory-item.execute { font-weight: bold; }

            /* Encounter Confirmation Buttons */
            .maze-confirm-buttons {
                margin-top: 8px;
                display: flex;
                gap: 8px;
                justify-content: center;
            }

            .maze-confirm-btn {
                padding: 8px 16px;
                font-size: 0.9em;
                font-weight: bold;
                border-radius: 6px;
                background: linear-gradient(to bottom, #3498db, #2980b9);
                color: #fff;
                border: 2px solid #5dade2;
                box-shadow: 0 2px 8px rgba(52, 152, 219, 0.4);
                transition: all 0.2s;
            }

            .maze-confirm-btn:hover {
                background: linear-gradient(to bottom, #5dade2, #3498db);
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(52, 152, 219, 0.6);
            }

            .maze-slip-btn {
                background: linear-gradient(to bottom, #9b59b6, #8e44ad);
                border-color: #bb8fce;
                box-shadow: 0 2px 8px rgba(155, 89, 182, 0.4);
            }

            .maze-slip-btn:hover {
                background: linear-gradient(to bottom, #bb8fce, #9b59b6);
                box-shadow: 0 4px 12px rgba(155, 89, 182, 0.6);
            }

            .maze-accept-btn {
                background: linear-gradient(to bottom, #27ae60, #1e8449);
                border-color: #58d68d;
                box-shadow: 0 2px 8px rgba(39, 174, 96, 0.4);
            }

            .maze-accept-btn:hover {
                background: linear-gradient(to bottom, #58d68d, #27ae60);
                box-shadow: 0 4px 12px rgba(39, 174, 96, 0.6);
            }

            /* Battlebar Action Buttons */
            .mazemaster-bb-action-buttons {
                display: flex;
                gap: 10px;
                justify-content: center;
                flex-wrap: wrap;
                width: 100%;
                max-width: 400px;
            }

            .mazemaster-bb-strike-btn,
            .mazemaster-bb-execute-btn {
                flex: 1;
                min-width: 120px;
                max-width: 180px;
                padding: 12px 15px;
                font-size: 1em;
                border-radius: 10px;
                cursor: pointer;
                font-weight: bold;
                border: none;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                transition: transform 0.1s, box-shadow 0.1s;
            }

            .mazemaster-bb-strike-btn {
                background: linear-gradient(to bottom, #e74c3c, #c0392b);
                color: #fff;
                box-shadow: 0 4px 10px rgba(231, 76, 60, 0.3);
            }

            .mazemaster-bb-strike-btn:hover {
                background: linear-gradient(to bottom, #c0392b, #a93226);
                transform: scale(1.02);
            }

            .mazemaster-bb-execute-btn {
                background: linear-gradient(135deg, #ffd700, #ffaa00);
                color: #000;
                text-shadow: 0 1px 0 rgba(255,255,255,0.5);
                box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            }

            .mazemaster-bb-execute-btn:hover {
                background: linear-gradient(135deg, #ffea00, #ffc400);
                box-shadow: 0 4px 20px rgba(255, 215, 0, 0.6);
                transform: scale(1.02);
            }

            /* Encounter Percent Label */
            .encounter-percent-label {
                font-size: 0.9em;
                color: #888;
            }

            .encounter-percent-input {
                width: 50px;
            }

            /* Small input for config rows */
            .mazemaster-input-small {
                width: 60px;
                padding: 4px 8px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                color: var(--SmartThemeBodyColor);
            }

            /* Grid layout for config rows */
            .mazemaster-row {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 6px;
            }

            .mazemaster-row label {
                min-width: 90px;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor);
                opacity: 0.9;
            }

            /* Two-column grid for percentage fields */
            .mazemaster-grid-2col {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px 16px;
            }

            .mazemaster-grid-2col .mazemaster-row {
                margin-bottom: 0;
            }

            .mazemaster-grid-2col .mazemaster-row label {
                min-width: 80px;
            }

            /* Three-column grid for loot percentages */
            .mazemaster-grid-3col {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }

            .mazemaster-grid-3col .mazemaster-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 4px;
                margin-bottom: 0;
            }

            .mazemaster-grid-3col .mazemaster-row label {
                min-width: auto;
                font-size: 0.8em;
                opacity: 0.8;
            }

            .mazemaster-grid-3col .mazemaster-input-small {
                width: 100%;
            }

            /* 4-column grid */
            .mazemaster-grid-4col {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 8px;
            }

            .mazemaster-grid-4col .mazemaster-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 2px;
                margin-bottom: 0;
            }

            .mazemaster-grid-4col .mazemaster-row label {
                min-width: auto;
                font-size: 0.75em;
                opacity: 0.8;
            }

            .mazemaster-grid-4col .mazemaster-input-small {
                width: 100%;
            }

            /* 5-column grid (for Find Early checkboxes) */
            .mazemaster-grid-5col {
                display: grid;
                grid-template-columns: repeat(5, 1fr);
                gap: 6px;
            }

            .mazemaster-checkbox-label {
                display: flex;
                align-items: center;
                gap: 4px;
                font-size: 0.8em;
                padding: 4px 6px;
                background: rgba(0, 0, 0, 0.15);
                border-radius: 4px;
                cursor: pointer;
                transition: background 0.2s;
            }

            .mazemaster-checkbox-label:hover {
                background: rgba(0, 0, 0, 0.25);
            }

            .mazemaster-checkbox-label input[type="checkbox"] {
                margin: 0;
            }

            /* Collapsible Sections */
            .mazemaster-collapsible {
                margin-bottom: 8px;
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 6px;
                overflow: hidden;
            }

            .mazemaster-collapsible-header {
                width: 100%;
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 10px 12px;
                background: rgba(0, 0, 0, 0.2);
                border: none;
                cursor: pointer;
                text-align: left;
                font-size: 0.95em;
                font-weight: 500;
                color: inherit;
                transition: background 0.2s;
            }

            .mazemaster-collapsible-header:hover {
                background: rgba(0, 0, 0, 0.3);
            }

            .mazemaster-collapse-icon {
                font-size: 0.8em;
                transition: transform 0.2s;
            }

            .mazemaster-collapsible.expanded .mazemaster-collapse-icon {
                transform: rotate(90deg);
            }

            .mazemaster-collapse-hint {
                font-size: 0.8em;
                opacity: 0.6;
                margin-left: auto;
            }

            .mazemaster-collapsible-content {
                padding: 12px;
                border-top: 1px solid var(--SmartThemeBorderColor, #444);
                background: rgba(0, 0, 0, 0.1);
            }

            .mazemaster-collapsible-content .mazemaster-section:last-child {
                margin-bottom: 0;
            }

            /* Portal Config List */
            .mazemaster-portals-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
                margin-bottom: 10px;
            }

            .mazemaster-portal-item {
                background: rgba(0, 0, 0, 0.2);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 6px;
                overflow: hidden;
            }

            .mazemaster-portal-item .portal-header {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 10px;
                background: rgba(0, 0, 0, 0.2);
                border-bottom: 1px solid var(--SmartThemeBorderColor, #444);
            }

            .mazemaster-portal-item .portal-color {
                width: 16px;
                height: 16px;
                border-radius: 50%;
                flex-shrink: 0;
            }

            .mazemaster-portal-item .portal-name {
                flex: 1;
                font-weight: 500;
            }

            .mazemaster-portal-item .portal-details {
                padding: 10px;
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .mazemaster-portal-item .portal-row {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .mazemaster-portal-item .portal-row label {
                width: 90px;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor, #ccc);
            }

            .mazemaster-portal-item .portal-row input[type="text"],
            .mazemaster-portal-item .portal-row input[type="number"] {
                flex: 1;
                max-width: 80px;
            }

            .mazemaster-portal-item .coords-row {
                gap: 4px;
            }

            .mazemaster-portal-item .coords-row span {
                font-size: 0.8em;
                color: var(--SmartThemeBodyColor, #999);
            }

            .mazemaster-portal-item .coords-row input {
                width: 50px !important;
                max-width: 50px !important;
            }

            .mazemaster-portal-item .portal-color-input {
                width: 32px;
                height: 24px;
                padding: 0;
                border: 1px solid var(--SmartThemeBorderColor, #444);
                cursor: pointer;
            }

            .mazemaster-portal-item .remove-portal-btn {
                padding: 4px 8px;
                font-size: 0.8em;
            }

            /* Objectives Config List */
            .mazemaster-objectives-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
                margin-bottom: 10px;
            }

            .mazemaster-objective-item {
                background: rgba(0, 0, 0, 0.2);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 6px;
                overflow: hidden;
            }

            .mazemaster-objective-item .objective-config-header {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 10px;
                background: rgba(0, 0, 0, 0.2);
                border-bottom: 1px solid var(--SmartThemeBorderColor, #444);
            }

            .mazemaster-objective-item .objective-name {
                flex: 1;
                font-weight: 500;
            }

            .mazemaster-objective-item .objective-config-details {
                padding: 10px;
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .mazemaster-objective-item .objective-config-row {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .mazemaster-objective-item .objective-config-row label {
                width: 100px;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor, #ccc);
            }

            .mazemaster-objective-item .objective-config-row input[type="text"],
            .mazemaster-objective-item .objective-config-row input[type="number"],
            .mazemaster-objective-item .objective-config-row select {
                flex: 1;
            }

            .mazemaster-objective-item .remove-objective-btn {
                padding: 4px 8px;
                font-size: 0.8em;
            }

            /* STScript Hooks Config */
            .mazemaster-hooks-group {
                margin-top: 12px;
            }

            .mazemaster-hooks-group:first-of-type {
                margin-top: 8px;
            }

            .mazemaster-hooks-label {
                display: block;
                font-size: 0.85em;
                font-weight: 500;
                color: #3498db;
                margin-bottom: 6px;
                padding-bottom: 4px;
                border-bottom: 1px solid rgba(52, 152, 219, 0.3);
            }

            .mazemaster-hooks-items {
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .mazemaster-hooks-items .hook-item {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .mazemaster-hooks-items .hook-item > label {
                width: 120px;
                flex-shrink: 0;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor, #ccc);
            }

            .mazemaster-hooks-items .hook-item input {
                flex: 1;
            }

            /* Inline row */
            .mazemaster-inline-row {
                display: flex;
                gap: 12px;
            }

            .mazemaster-flex-1 {
                flex: 1;
            }

            /* Saved Games */
            .mazemaster-saved-games-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .mazemaster-saved-game {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
            }

            .mazemaster-saved-game-info {
                display: flex;
                flex-direction: column;
                gap: 2px;
            }

            .mazemaster-saved-game-name {
                font-weight: 500;
            }

            .mazemaster-saved-game-details {
                font-size: 0.8em;
                opacity: 0.7;
            }

            .mazemaster-saved-game-actions {
                display: flex;
                gap: 6px;
            }

            .mazemaster-no-saves {
                text-align: center;
                opacity: 0.6;
                padding: 12px;
                font-style: italic;
            }

            /* Side-by-side sections */
            .mazemaster-section-row {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 16px;
            }

            .mazemaster-section-row .mazemaster-section {
                margin-bottom: 0;
            }

            /* Minions Config Styles */
            .mazemaster-minions-list {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-bottom: 10px;
            }

            .mazemaster-minion-card {
                display: flex;
                gap: 10px;
                align-items: center;
                padding: 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                border: 1px solid var(--SmartThemeBorderColor, #444);
            }

            .mazemaster-minion-card .minion-image {
                width: 50px;
                height: 50px;
                border-radius: 5px;
                overflow: hidden;
                background: rgba(0, 0, 0, 0.3);
                flex-shrink: 0;
                position: relative;
                cursor: pointer;
            }

            .mazemaster-minion-card .minion-image img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .mazemaster-minion-card .minion-image:hover {
                outline: 2px solid var(--SmartThemeQuoteColor, #e74c3c);
                outline-offset: 2px;
            }

            .mazemaster-minion-card .minion-image::after {
                content: '\\f030';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                bottom: 2px;
                right: 2px;
                font-size: 10px;
                color: white;
                background: rgba(0, 0, 0, 0.6);
                padding: 2px 4px;
                border-radius: 3px;
                opacity: 0;
                transition: opacity 0.2s;
            }

            .mazemaster-minion-card .minion-image:hover::after {
                opacity: 1;
            }

            .mazemaster-minion-card .minion-info {
                flex: 1;
            }

            .mazemaster-minion-card .minion-row {
                display: flex;
                gap: 8px;
                margin-bottom: 8px;
            }

            .mazemaster-minion-card .minion-name-input {
                flex: 1;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-minion-card .minion-type-select {
                width: 110px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-minion-card .minion-profiles {
                margin-top: 8px;
            }

            .mazemaster-minion-card .minion-profiles label {
                display: block;
                font-size: 0.85em;
                color: var(--SmartThemeQuoteColor);
                margin-bottom: 4px;
            }

            .mazemaster-minion-card .minion-profiles select {
                width: 100%;
                min-height: 60px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 4px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-minion-card .minion-profiles textarea {
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
                resize: vertical;
            }

            .mazemaster-minion-card .merchant-range-row {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .mazemaster-minion-card .merchant-range-row span {
                color: var(--SmartThemeBodyColor);
                opacity: 0.8;
            }

            .mazemaster-minion-card .minion-encounter-script {
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid var(--SmartThemeBorderColor, #333);
            }

            .mazemaster-minion-card .minion-encounter-script label {
                display: block;
                font-size: 0.85em;
                color: var(--SmartThemeQuoteColor);
                margin-bottom: 4px;
            }

            .mazemaster-minion-card .minion-encounter-script textarea {
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
                resize: vertical;
                font-family: monospace;
            }

            .mazemaster-minion-card .minion-delete-btn {
                padding: 5px 8px;
                flex-shrink: 0;
                align-self: flex-start;
            }

            /* Minion Movement Settings */
            .mazemaster-minion-card .minion-movement-settings {
                margin-top: 8px;
                padding-top: 8px;
                border-top: 1px solid var(--SmartThemeBorderColor, #444);
            }

            .mazemaster-minion-card .minion-movement-settings > label {
                display: block;
                font-size: 0.85em;
                color: var(--SmartThemeBodyColor, #999);
                margin-bottom: 4px;
            }

            .mazemaster-minion-card .movement-row {
                display: flex;
                gap: 8px;
                margin-bottom: 6px;
            }

            .mazemaster-minion-card .minion-movement-type {
                flex: 1;
            }

            .mazemaster-minion-card .movement-params {
                display: flex;
                gap: 12px;
                flex-wrap: wrap;
            }

            .mazemaster-minion-card .movement-param {
                display: flex;
                align-items: center;
                gap: 4px;
                font-size: 0.85em;
            }

            .mazemaster-minion-card .movement-param span {
                color: var(--SmartThemeBodyColor, #999);
            }

            .mazemaster-minion-card .movement-param input {
                width: 50px;
            }

            /* TRAP CARD STYLES */
            .mazemaster-traps-list {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-bottom: 10px;
                max-height: 400px;
                overflow-y: auto;
            }

            .mazemaster-trap-card {
                display: flex;
                gap: 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 8px;
                padding: 10px;
                align-items: flex-start;
            }

            .mazemaster-trap-card .trap-image {
                width: 80px;
                height: 80px;
                flex-shrink: 0;
                border-radius: 6px;
                overflow: hidden;
                background: rgba(0, 0, 0, 0.3);
                position: relative;
                cursor: pointer;
            }

            .mazemaster-trap-card .trap-image img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .mazemaster-trap-card .trap-image:hover {
                outline: 2px solid var(--SmartThemeQuoteColor, #e74c3c);
                outline-offset: 2px;
            }

            .mazemaster-trap-card .trap-image::after {
                content: '\\f030';
                font-family: 'Font Awesome 6 Free';
                font-weight: 900;
                position: absolute;
                bottom: 4px;
                right: 4px;
                font-size: 12px;
                color: white;
                background: rgba(0, 0, 0, 0.6);
                padding: 3px 5px;
                border-radius: 3px;
                opacity: 0;
                transition: opacity 0.2s;
            }

            .mazemaster-trap-card .trap-image:hover::after {
                opacity: 1;
            }

            .mazemaster-trap-card .trap-no-image {
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                color: var(--SmartThemeBodyColor);
                opacity: 0.5;
                font-size: 24px;
            }

            .mazemaster-trap-card .trap-info {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .mazemaster-trap-card .trap-row {
                display: flex;
                gap: 8px;
            }

            .mazemaster-trap-card .trap-name-input {
                flex: 1;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
            }

            .mazemaster-trap-card .trap-message-row,
            .mazemaster-trap-card .trap-script-row {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .mazemaster-trap-card .trap-message-row label,
            .mazemaster-trap-card .trap-script-row label {
                font-size: 0.75em;
                opacity: 0.7;
            }

            .mazemaster-trap-card .trap-message-input,
            .mazemaster-trap-card .trap-script-input {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--SmartThemeBodyColor);
                resize: vertical;
                font-family: inherit;
            }

            .mazemaster-trap-card .trap-delete-btn {
                padding: 5px 8px;
                flex-shrink: 0;
                align-self: flex-start;
            }

            /* Story Milestones Modal */
            .mazemaster-story-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            }

            .mazemaster-story-modal-content {
                background: var(--SmartThemeBlurTintColor, #1a1a1a);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 10px;
                padding: 20px;
                width: 90%;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
            }

            .mazemaster-story-modal-content h3 {
                margin: 0 0 15px 0;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .mazemaster-story-textarea {
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 8px;
                color: var(--SmartThemeBodyColor);
                resize: vertical;
                font-family: inherit;
            }

            .mazemaster-milestones-list {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-bottom: 10px;
                max-height: 200px;
                overflow-y: auto;
            }

            .mazemaster-milestone-row {
                display: flex;
                gap: 10px;
                align-items: flex-start;
                background: rgba(0, 0, 0, 0.2);
                padding: 10px;
                border-radius: 6px;
            }

            .milestone-percent {
                display: flex;
                align-items: center;
                gap: 4px;
                flex-shrink: 0;
            }

            .milestone-percent-input {
                width: 50px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px;
                color: var(--SmartThemeBodyColor);
                text-align: center;
            }

            .milestone-text-input {
                flex: 1;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--SmartThemeBorderColor, #444);
                border-radius: 4px;
                padding: 6px;
                color: var(--SmartThemeBodyColor);
                resize: vertical;
                font-family: inherit;
            }

            .mazemaster-story-modal-buttons {
                display: flex;
                gap: 10px;
                justify-content: flex-end;
                margin-top: 15px;
            }
        </style>
    `;
}

function updateProfileSettings() {
    const profileName = document.getElementById('mazemaster_profile_select')?.value;
    const profile = getProfile(profileName);

    const randomizeCheckbox = document.getElementById('mazemaster_randomize');
    if (randomizeCheckbox) {
        randomizeCheckbox.checked = profile?.randomize || false;
    }

    const difficultySelect = document.getElementById('mazemaster_difficulty');
    if (difficultySelect) {
        difficultySelect.value = profile?.difficulty || 1;
    }
}

function renderSegmentsList() {
    const list = document.getElementById('mazemaster_segments_list');
    if (!list) return;

    const profileName = document.getElementById('mazemaster_profile_select')?.value;
    const profile = getProfile(profileName);
    const segments = profile?.segments || [];

    if (segments.length === 0) {
        list.innerHTML = '<div class="mazemaster-empty-state">No segments. Click "Add Segment" to create one.</div>';
        return;
    }

    list.innerHTML = segments.map((seg, index) => `
        <div class="mazemaster-segment-item" data-index="${index}">
            <div class="mazemaster-segment-row">
                <div class="mazemaster-segment-field small">
                    <label>Trigger</label>
                    <input type="text" class="seg-trigger" value="${escapeHtml(seg.trigger || '')}" placeholder="com1">
                </div>
                <div class="mazemaster-segment-field">
                    <label>Display Text</label>
                    <input type="text" class="seg-text" value="${escapeHtml(seg.text || '')}" placeholder="Prize name">
                </div>
                <div class="mazemaster-segment-field small">
                    <label>Size</label>
                    <select class="seg-size">
                        ${SIZE_OPTIONS.map(s => `<option value="${s}" ${seg.size === s ? 'selected' : ''}>${s}</option>`).join('')}
                    </select>
                </div>
                <button class="menu_button menu_button_icon mazemaster-segment-delete" title="Delete">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
            <div class="mazemaster-segment-row">
                <div class="mazemaster-segment-field">
                    <label>STScript Command</label>
                    <textarea class="seg-command" placeholder="/echo You won!">${escapeHtml(seg.command || '')}</textarea>
                </div>
                <div class="mazemaster-segment-field tiny">
                    <label>&nbsp;</label>
                    <label class="mazemaster-segment-checkbox">
                        <input type="checkbox" class="seg-respin" ${seg.respin ? 'checked' : ''}>
                        Respin
                    </label>
                </div>
            </div>
        </div>
    `).join('');

    // Add delete handlers
    list.querySelectorAll('.mazemaster-segment-delete').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.target.closest('.mazemaster-segment-item').remove();
        });
    });
}

function collectSegmentsFromUI() {
    const items = document.querySelectorAll('.mazemaster-segment-item');
    const segments = [];

    items.forEach(item => {
        const trigger = item.querySelector('.seg-trigger').value.trim();
        const text = item.querySelector('.seg-text').value.trim();
        const command = item.querySelector('.seg-command').value.trim();
        const size = item.querySelector('.seg-size').value;
        const respin = item.querySelector('.seg-respin').checked;

        if (trigger || text) {
            segments.push({ trigger, text, command, size, respin });
        }
    });

    return segments;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text || '';
    return div.innerHTML;
}

function exportProfile(profileName) {
    const profile = getProfile(profileName);
    if (!profile) {
        alert(`Profile "${profileName}" not found`);
        return;
    }

    const exportData = {
        name: profileName,
        profile: profile,
        exportedAt: new Date().toISOString(),
        version: '1.0',
    };

    const jsonStr = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `mazemaster-${profileName}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    console.log(`[MazeMaster] Exported profile "${profileName}"`);
}

function importProfile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);

                if (!data.profile || !data.name) {
                    reject(new Error('Invalid profile format: missing name or profile data'));
                    return;
                }

                let profileName = data.name;

                // If profile already exists, ask for new name
                if (extensionSettings.profiles[profileName]) {
                    const newName = prompt(`Profile "${profileName}" already exists. Enter a new name:`, `${profileName}_imported`);
                    if (!newName || !newName.trim()) {
                        reject(new Error('Import cancelled'));
                        return;
                    }
                    profileName = newName.trim();
                }

                // Validate profile structure
                const profile = data.profile;
                if (!profile.segments || !Array.isArray(profile.segments)) {
                    profile.segments = [];
                }
                if (typeof profile.randomize !== 'boolean') {
                    profile.randomize = false;
                }
                if (typeof profile.difficulty !== 'number' || profile.difficulty < 1 || profile.difficulty > 5) {
                    profile.difficulty = 1;
                }

                // Save the imported profile
                extensionSettings.profiles[profileName] = profile;
                extensionSettings.currentProfile = profileName;
                saveSettingsDebounced();

                console.log(`[MazeMaster] Imported profile "${profileName}":`, profile);
                resolve(profileName);
            } catch (err) {
                reject(new Error(`Failed to parse JSON: ${err.message}`));
            }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsText(file);
    });
}

// =============================================================================
// BATTLEBAR UI HELPERS
// =============================================================================

function updateBattlebarSettings() {
    const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
    const profile = getBattlebarProfile(profileName) || {};

    const difficultySlider = document.getElementById('mazemaster_bb_difficulty');
    const difficultyVal = document.getElementById('mazemaster_bb_diff_val');
    if (difficultySlider) {
        // Convert legacy 1-5 to new 1-10 scale
        let diff = profile.difficulty || 5;
        if (diff <= 5 && BATTLEBAR_DIFFICULTY_LEGACY[diff]) {
            diff = BATTLEBAR_DIFFICULTY_LEGACY[diff];
        }
        difficultySlider.value = diff;
        if (difficultyVal) difficultyVal.textContent = `(${diff})`;
    }

    const damageInput = document.getElementById('mazemaster_bb_damage');
    if (damageInput) damageInput.value = profile.damage || 25;

    const hitsInput = document.getElementById('mazemaster_bb_hits');
    if (hitsInput) hitsInput.value = profile.hitsToWin || 5;

    const missesInput = document.getElementById('mazemaster_bb_misses');
    if (missesInput) missesInput.value = profile.missesToLose || 3;

    const hitCmd = document.getElementById('mazemaster_bb_hit_cmd');
    if (hitCmd) hitCmd.value = profile.hitCommand || '';

    const missCmd = document.getElementById('mazemaster_bb_miss_cmd');
    if (missCmd) missCmd.value = profile.missCommand || '';

    const winCmd = document.getElementById('mazemaster_bb_win_cmd');
    if (winCmd) winCmd.value = profile.winCommand || '';

    const loseCmd = document.getElementById('mazemaster_bb_lose_cmd');
    if (loseCmd) loseCmd.value = profile.loseCommand || '';

    const mainTitle = document.getElementById('mazemaster_bb_main_title');
    if (mainTitle) mainTitle.value = profile.mainTitle || '';
}

function renderBattlebarImages() {
    const list = document.getElementById('mazemaster_bb_images_list');
    if (!list) return;

    const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
    if (!profileName) {
        list.innerHTML = '<div class="mazemaster-empty-state">Select or create a profile first.</div>';
        return;
    }

    const profile = getBattlebarProfile(profileName) || {};
    const images = profile.images || [];

    if (images.length === 0) {
        list.innerHTML = '<div class="mazemaster-empty-state">No stages. Add images to create stages.</div>';
        return;
    }

    list.innerHTML = images.map((img, index) => `
        <div class="mazemaster-bb-image-item" data-index="${index}" title="Click to edit stage message">
            <img src="/${img.path}" alt="${escapeHtml(img.stageMessage || '')}">
            <span class="bb-image-index">${index}</span>
            <div class="bb-image-message">${escapeHtml(img.stageMessage || '(no message)')}</div>
            <button class="bb-image-delete" title="Delete">
                <i class="fa-solid fa-times"></i>
            </button>
        </div>
    `).join('');

    // Add click handler to edit stage message
    list.querySelectorAll('.mazemaster-bb-image-item').forEach(item => {
        item.addEventListener('click', async (e) => {
            // Don't trigger if clicking delete button
            if (e.target.closest('.bb-image-delete')) return;

            const index = parseInt(item.dataset.index);
            const profile = getBattlebarProfile(profileName) || {};
            const images = profile.images || [];
            const currentMessage = images[index]?.stageMessage || '';

            const newMessage = await callGenericPopup(
                `Stage ${index} Message:`,
                POPUP_TYPE.INPUT,
                currentMessage
            );

            if (newMessage !== null && newMessage !== undefined) {
                images[index].stageMessage = newMessage;
                saveBattlebarProfile(profileName, profile);
                renderBattlebarImages();
            }
        });
    });

    // Add delete handlers
    list.querySelectorAll('.bb-image-delete').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const item = e.target.closest('.mazemaster-bb-image-item');
            const index = parseInt(item.dataset.index);

            const confirmed = await callGenericPopup(`Delete stage ${index}?`, POPUP_TYPE.CONFIRM);
            if (!confirmed) return;

            const profile = getBattlebarProfile(profileName) || {};
            profile.images = (profile.images || []).filter((_, i) => i !== index);
            saveBattlebarProfile(profileName, profile);
            renderBattlebarImages();
        });
    });
}

function collectBattlebarDataFromUI() {
    const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
    const existingProfile = getBattlebarProfile(profileName) || {};

    return {
        difficulty: parseInt(document.getElementById('mazemaster_bb_difficulty')?.value) || 5,
        damage: parseInt(document.getElementById('mazemaster_bb_damage')?.value) || 25,
        hitsToWin: parseInt(document.getElementById('mazemaster_bb_hits')?.value) || 5,
        missesToLose: parseInt(document.getElementById('mazemaster_bb_misses')?.value) || 3,
        mainTitle: document.getElementById('mazemaster_bb_main_title')?.value || '',
        hitCommand: document.getElementById('mazemaster_bb_hit_cmd')?.value || '',
        missCommand: document.getElementById('mazemaster_bb_miss_cmd')?.value || '',
        winCommand: document.getElementById('mazemaster_bb_win_cmd')?.value || '',
        loseCommand: document.getElementById('mazemaster_bb_lose_cmd')?.value || '',
        // Preserve images with their stageMessages (edited via click)
        images: existingProfile.images || [],
        // Item drops (maze only)
        keyDropChance: parseInt(document.getElementById('mazemaster_bb_key_drop')?.value) ?? 40,
        strikeDropChance: parseInt(document.getElementById('mazemaster_bb_pow_drop')?.value) ?? 20,
        stealthDropChance: parseInt(document.getElementById('mazemaster_bb_stealth_drop')?.value) ?? 10,
    };
}

function exportBattlebarProfile(profileName) {
    const profile = getBattlebarProfile(profileName);
    if (!profile) {
        alert(`Battlebar profile "${profileName}" not found`);
        return;
    }

    const exportData = {
        name: profileName,
        type: 'battlebar',
        profile: profile,
        exportedAt: new Date().toISOString(),
        version: '1.0',
    };

    const jsonStr = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `mazemaster-battlebar-${profileName}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    console.log(`[MazeMaster] Exported battlebar profile "${profileName}"`);
}

function importBattlebarProfile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);

                if (!data.profile || !data.name) {
                    reject(new Error('Invalid profile format: missing name or profile data'));
                    return;
                }

                let profileName = data.name;

                if (extensionSettings.battlebarProfiles[profileName]) {
                    const newName = prompt(`Battlebar profile "${profileName}" already exists. Enter a new name:`, `${profileName}_imported`);
                    if (!newName || !newName.trim()) {
                        reject(new Error('Import cancelled'));
                        return;
                    }
                    profileName = newName.trim();
                }

                saveBattlebarProfile(profileName, data.profile);
                extensionSettings.currentBattlebarProfile = profileName;
                saveSettingsDebounced();

                console.log(`[MazeMaster] Imported battlebar profile "${profileName}":`, data.profile);
                resolve(profileName);
            } catch (err) {
                reject(new Error(`Failed to parse JSON: ${err.message}`));
            }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsText(file);
    });
}

async function uploadBattlebarImage(file, profileName) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const base64 = e.target.result.split(',')[1];
                const ext = file.name.split('.').pop().toLowerCase();
                const timestamp = Date.now();
                const filename = `battlebar_${profileName}_${timestamp}`;

                const response = await fetch('/api/images/upload', {
                    method: 'POST',
                    headers: getRequestHeaders(),
                    body: JSON.stringify({
                        image: base64,
                        ch_name: 'MazeMaster',
                        filename: filename,
                        format: ext,
                    }),
                });

                if (response.ok) {
                    resolve(`user/images/MazeMaster/${filename}.${ext}`);
                } else {
                    const error = await response.json().catch(() => ({}));
                    reject(new Error(error.error || 'Upload failed'));
                }
            } catch (err) {
                reject(err);
            }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(file);
    });
}

// =============================================================================
// MAZE UI HELPERS
// =============================================================================

function updateMazeSettings() {
    const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
    const profile = getMazeProfile(profileName) || {};

    const sizeSelect = document.getElementById('mazemaster_maze_size');
    if (sizeSelect) sizeSelect.value = profile.gridSize || 10;

    // Set floors dropdown
    const floorsSelect = document.getElementById('mazemaster_maze_floors');
    if (floorsSelect) floorsSelect.value = profile.floors || 1;

    // Set difficulty dropdown
    const difficultySelect = document.getElementById('mazemaster_maze_difficulty');
    if (difficultySelect) difficultySelect.value = profile.difficulty || 'normal';

    // Set theme dropdown
    const themeSelect = document.getElementById('mazemaster_maze_theme');
    if (themeSelect) themeSelect.value = profile.theme || 'fantasy';

    // Set map style dropdown
    const mapStyleSelect = document.getElementById('mazemaster_maze_mapstyle');
    if (mapStyleSelect) mapStyleSelect.value = profile.mapStyle || 'maze';

    const winCmd = document.getElementById('mazemaster_maze_win_cmd');
    if (winCmd) winCmd.value = profile.winCommand || '';

    const loseCmd = document.getElementById('mazemaster_maze_lose_cmd');
    if (loseCmd) loseCmd.value = profile.loseCommand || '';

    const winMessage = document.getElementById('mazemaster_maze_win_message');
    if (winMessage) winMessage.value = profile.winMessage || '';

    // Main minion settings - repopulate options first
    const mainMinionSelect = document.getElementById('mazemaster_maze_main_minion');
    if (mainMinionSelect) {
        const minionNames = getMinionNames();
        mainMinionSelect.innerHTML = '<option value="">None</option>' +
            minionNames.map(id => {
                const m = getMinion(id);
                return `<option value="${escapeHtml(id)}" ${profile.mainMinion === id ? 'selected' : ''}>${escapeHtml(m?.name || id)}</option>`;
            }).join('');
    }

    const mainMinionSettings = document.getElementById('mazemaster_main_minion_settings');
    if (mainMinionSettings) mainMinionSettings.style.display = profile.mainMinion ? 'block' : 'none';

    const introMessage = document.getElementById('mazemaster_maze_intro_message');
    if (introMessage) introMessage.value = profile.mainMinionIntroMessage || '';

    const randomChance = document.getElementById('mazemaster_maze_random_chance');
    if (randomChance) randomChance.value = profile.mainMinionRandomChance || 15;

    const randomMessages = document.getElementById('mazemaster_maze_random_messages');
    if (randomMessages) randomMessages.value = (profile.mainMinionRandomMessages || []).join('\n');

    const exitType = document.getElementById('mazemaster_maze_exit_type');
    if (exitType) exitType.value = profile.mainMinionExitType || 'messenger';

    // Update exit profile dropdown
    updateExitProfileDropdown(profile.mainMinionExitType || 'messenger', profile.mainMinionExitProfile);

    // Loss action
    const lossAction = document.getElementById('mazemaster_maze_loss_action');
    if (lossAction) lossAction.value = profile.onBattlebarLoss || 'continue';

    // Update win image preview
    const previewContainer = document.querySelector('.mazemaster-maze-win-image-preview');
    if (previewContainer) {
        if (profile.winImage) {
            previewContainer.innerHTML = `<img id="maze_win_image_preview" src="${profile.winImage}" alt="Victory">`;
        } else {
            previewContainer.innerHTML = '<div id="maze_win_image_preview" class="no-image">No image</div>';
        }
    }

    // Chest distribution settings
    const chestPercent = document.getElementById('mazemaster_maze_chest_percent');
    if (chestPercent) chestPercent.value = profile.chestTilePercent || 10;

    const lockedPercent = document.getElementById('mazemaster_maze_locked_percent');
    if (lockedPercent) lockedPercent.value = profile.chestLockedPercent || 30;

    const lockedBonus = document.getElementById('mazemaster_maze_locked_bonus');
    if (lockedBonus) lockedBonus.value = profile.chestLockedBonusPercent || 50;

    const mimicPercent = document.getElementById('mazemaster_maze_mimic_percent');
    if (mimicPercent) mimicPercent.value = profile.chestMimicPercent || 15;

    // Loot per chest
    const lootMin = document.getElementById('mazemaster_maze_loot_min');
    if (lootMin) lootMin.value = profile.chestLootMin || 1;

    const lootMax = document.getElementById('mazemaster_maze_loot_max');
    if (lootMax) lootMax.value = profile.chestLootMax || 2;

    // Regular chest loot chances
    const chestKey = document.getElementById('mazemaster_maze_chest_key');
    if (chestKey) chestKey.value = profile.chestKeyChance || 30;

    const chestPow = document.getElementById('mazemaster_maze_chest_pow');
    if (chestPow) chestPow.value = profile.chestStrikeChance || 50;

    const chestStealth = document.getElementById('mazemaster_maze_chest_stealth');
    if (chestStealth) chestStealth.value = profile.chestStealthChance || 0;

    const chestExecute = document.getElementById('mazemaster_maze_chest_execute');
    if (chestExecute) chestExecute.value = profile.chestExecuteChance || 0;

    // Locked chest loot chances
    const lockedKey = document.getElementById('mazemaster_maze_locked_key');
    if (lockedKey) lockedKey.value = profile.lockedChestKeyChance || 40;

    const lockedPow = document.getElementById('mazemaster_maze_locked_pow');
    if (lockedPow) lockedPow.value = profile.lockedChestStrikeChance || 60;

    const lockedStealth = document.getElementById('mazemaster_maze_locked_stealth');
    if (lockedStealth) lockedStealth.value = profile.lockedChestStealthChance || 30;

    const lockedExecute = document.getElementById('mazemaster_maze_locked_execute');
    if (lockedExecute) lockedExecute.value = profile.lockedChestExecuteChance || 5;

    // Starting inventory - use defaults if empty/zero
    let startInv = profile.startingInventory || {};

    // If startingInventory is empty/zero and we have defaults, use them
    const isEmptyInventory = !startInv.key && !startInv.stealth && !startInv.strike && !startInv.execute;
    if (isEmptyInventory && DEFAULT_MAZE_PROFILE[profileName]?.startingInventory) {
        startInv = DEFAULT_MAZE_PROFILE[profileName].startingInventory;
        profile.startingInventory = JSON.parse(JSON.stringify(startInv));
        saveSettingsDebounced();
    }

    const startKey = document.getElementById('mazemaster_start_key');
    if (startKey) startKey.value = startInv.key || 0;

    const startStealth = document.getElementById('mazemaster_start_stealth');
    if (startStealth) startStealth.value = startInv.stealth || 0;

    const startPow = document.getElementById('mazemaster_start_pow');
    if (startPow) startPow.value = startInv.strike || 0;

    const startExecute = document.getElementById('mazemaster_start_execute');
    if (startExecute) startExecute.value = startInv.execute || 0;

    // HP System settings
    const hpEnabled = document.getElementById('mazemaster_hp_enabled');
    if (hpEnabled) hpEnabled.checked = profile.hpEnabled !== false;

    const maxHP = document.getElementById('mazemaster_hp_max');
    if (maxHP) maxHP.value = profile.maxHP || 100;

    const bbDamageMult = document.getElementById('mazemaster_hp_battlebar_mult');
    if (bbDamageMult) bbDamageMult.value = profile.battlebarDamageMultiplier ?? 1.0;

    const bbDiffMult = document.getElementById('mazemaster_hp_battlebar_diff');
    if (bbDiffMult) bbDiffMult.value = profile.battlebarDifficultyMultiplier ?? 1.0;

    const respawnHP = document.getElementById('mazemaster_hp_respawn');
    if (respawnHP) respawnHP.value = profile.respawnHPPercent || 50;

    const onDeath = document.getElementById('mazemaster_hp_ondeath');
    if (onDeath) onDeath.value = profile.onDeath || 'respawn';

    // Safe room settings
    const safeRoomCount = document.getElementById('mazemaster_safe_room_count');
    if (safeRoomCount) safeRoomCount.value = profile.safeRoomCount ?? 3;

    const safeRoomHeal = document.getElementById('mazemaster_safe_room_heal');
    if (safeRoomHeal) safeRoomHeal.value = profile.safeRoomHealPercent ?? 100;

    const safeRoomLLM = document.getElementById('mazemaster_safe_room_llm');
    if (safeRoomLLM) safeRoomLLM.checked = profile.safeRoomUseLLM || false;

    // LLM Enhancement settings
    const llmEnhanceRooms = document.getElementById('mazemaster_llm_enhance_rooms');
    if (llmEnhanceRooms) llmEnhanceRooms.checked = profile.llmEnhanceRooms !== false;

    // Rest settings
    const restEnabled = document.getElementById('mazemaster_rest_enabled');
    if (restEnabled) restEnabled.checked = profile.restEnabled !== false;

    const restHeal = document.getElementById('mazemaster_rest_heal');
    if (restHeal) restHeal.value = profile.restHealPercent || 20;

    const restCooldown = document.getElementById('mazemaster_rest_cooldown');
    if (restCooldown) restCooldown.value = profile.restCooldown ?? 3;

    const restInterrupt = document.getElementById('mazemaster_rest_interrupt');
    if (restInterrupt) restInterrupt.value = profile.restInterruptChance ?? 15;

    // Map visibility radio buttons
    const mapVis = profile.mapVisibility || 'fogOfWar';
    const visRadio = document.querySelector(`input[name="mazemaster_map_visibility"][value="${mapVis}"]`);
    if (visRadio) visRadio.checked = true;

    // Render encounters list - use defaults from DEFAULT_MAZE_PROFILE if empty
    let minionEncounters = profile.minionEncounters || [];
    let trapEncounters = profile.trapEncounters || [];

    // If encounters are empty and we have defaults for this profile, use them
    if (minionEncounters.length === 0 && DEFAULT_MAZE_PROFILE[profileName]?.minionEncounters) {
        minionEncounters = DEFAULT_MAZE_PROFILE[profileName].minionEncounters;
        // Also update the profile so it persists
        profile.minionEncounters = JSON.parse(JSON.stringify(minionEncounters));
        saveSettingsDebounced();
    }
    if (trapEncounters.length === 0 && DEFAULT_MAZE_PROFILE[profileName]?.trapEncounters) {
        trapEncounters = DEFAULT_MAZE_PROFILE[profileName].trapEncounters;
        // Also update the profile so it persists
        profile.trapEncounters = JSON.parse(JSON.stringify(trapEncounters));
        saveSettingsDebounced();
    }

    renderMazeEncountersList(minionEncounters);
    renderMazeTrapEncountersList(trapEncounters);

    // Find Early settings (v1.3.2)
    const findEarly = profile.findEarly || {};
    const findEarlyRadius = document.getElementById('mazemaster_findearly_radius');
    if (findEarlyRadius) findEarlyRadius.value = findEarly.radius || 4;

    const findEarlyPerChest = document.getElementById('mazemaster_findearly_perchest');
    if (findEarlyPerChest) findEarlyPerChest.value = findEarly.itemsPerChest || 1;

    // Set checkboxes for Find Early items
    const findEarlyItems = findEarly.items || [];
    const itemTypes = ['torch', 'lantern', 'mapFragment', 'healingPotion', 'greaterHealing',
                       'revealScroll', 'sightPotion', 'key', 'strike', 'stealth'];
    for (const item of itemTypes) {
        const checkbox = document.getElementById(`mazemaster_findearly_${item}`);
        if (checkbox) checkbox.checked = findEarlyItems.includes(item);
    }
}

function updateExitProfileDropdown(exitType, selectedProfile) {
    const profileSection = document.getElementById('mazemaster_exit_profile_section');
    const profileSelect = document.getElementById('mazemaster_maze_exit_profile');

    if (!profileSection || !profileSelect) return;

    if (exitType === 'messenger') {
        profileSection.style.display = 'none';
        return;
    }

    profileSection.style.display = 'block';

    // Populate with appropriate profiles based on exit type
    let profiles = [];
    switch (exitType) {
        case 'battlebar':
            profiles = getBattlebarProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_BATTLEBAR_PROFILES);
            break;
        case 'prizewheel':
            profiles = getProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_WHEEL_PROFILES);
            break;
        case 'turnbased':
            profiles = getTurnbasedProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_TURNBASED_PROFILES);
            break;
        case 'qte':
            profiles = getQteProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_QTE_PROFILES);
            break;
        case 'dice':
            profiles = getDiceProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_DICE_PROFILES);
            break;
        case 'stealth':
            profiles = getStealthProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_STEALTH_PROFILES);
            break;
        case 'puzzle':
            profiles = getPuzzleProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_PUZZLE_PROFILES);
            break;
        case 'negotiation':
            profiles = getNegotiationProfileNames();
            if (profiles.length === 0) profiles = Object.keys(DEFAULT_NEGOTIATION_PROFILES);
            break;
    }

    profileSelect.innerHTML = '<option value="">Select...</option>' +
        profiles.map(p => `<option value="${escapeHtml(p)}" ${p === selectedProfile ? 'selected' : ''}>${escapeHtml(p)}</option>`).join('');
}

function renderMazeEncountersList(encounters) {
    const list = document.getElementById('mazemaster_maze_encounters_list');
    if (!list) return;

    const minionNames = getMinionNames();

    if (encounters.length === 0) {
        list.innerHTML = '<div class="mazemaster-empty-state" style="font-size: 0.85em;">No encounters. Minions will be randomly placed in the maze.</div>';
        return;
    }

    list.innerHTML = encounters.map((enc, index) => {
        const minion = getMinion(enc.minionId);
        return `
            <div class="mazemaster-encounter-row" data-index="${index}">
                <select class="encounter-minion-select">
                    ${minionNames.map(id => {
                        const m = getMinion(id);
                        return `<option value="${escapeHtml(id)}" ${enc.minionId === id ? 'selected' : ''}>${escapeHtml(m?.name || id)}</option>`;
                    }).join('')}
                </select>
                <input type="number" class="encounter-percent-input" min="1" max="100" value="${enc.percent || 5}" placeholder="%">
                <span class="encounter-percent-label">%</span>
                <button class="menu_button menu_button_icon encounter-remove-btn" title="Remove">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
        `;
    }).join('');

    // Add event handlers
    list.querySelectorAll('.mazemaster-encounter-row').forEach(row => {
        const index = parseInt(row.dataset.index);

        row.querySelector('.encounter-minion-select')?.addEventListener('change', () => {
            // Will be saved when Save Profile is clicked
        });

        row.querySelector('.encounter-percent-input')?.addEventListener('change', () => {
            // Will be saved when Save Profile is clicked
        });

        row.querySelector('.encounter-remove-btn')?.addEventListener('click', () => {
            row.remove();
        });
    });
}

function renderMazeTrapEncountersList(trapEncounters) {
    const list = document.getElementById('mazemaster_maze_traps_list');
    if (!list) return;

    const trapNames = getTrapNames();

    if (trapEncounters.length === 0) {
        list.innerHTML = '<div class="mazemaster-empty-state" style="font-size: 0.85em;">No traps. Add traps to place trap tiles in the maze.</div>';
        return;
    }

    list.innerHTML = trapEncounters.map((enc, index) => {
        const trap = getTrap(enc.trapId);
        return `
            <div class="mazemaster-encounter-row mazemaster-trap-encounter-row" data-index="${index}">
                <select class="trap-encounter-select">
                    ${trapNames.map(id => {
                        const t = getTrap(id);
                        return `<option value="${escapeHtml(id)}" ${enc.trapId === id ? 'selected' : ''}>${escapeHtml(t?.name || id)}</option>`;
                    }).join('')}
                </select>
                <input type="number" class="trap-encounter-percent-input" min="1" max="100" value="${enc.percent || 5}" placeholder="%">
                <span class="encounter-percent-label">%</span>
                <button class="menu_button menu_button_icon trap-encounter-remove-btn" title="Remove">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
        `;
    }).join('');

    // Add event handlers
    list.querySelectorAll('.mazemaster-trap-encounter-row').forEach(row => {
        row.querySelector('.trap-encounter-remove-btn')?.addEventListener('click', () => {
            row.remove();
        });
    });
}

function collectMazeDataFromUI() {
    const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
    const existingProfile = getMazeProfile(profileName) || {};

    // Collect encounters from the list (now using percent)
    const encounterRows = document.querySelectorAll('#mazemaster_maze_encounters_list .mazemaster-encounter-row');
    const minionEncounters = [];
    encounterRows.forEach(row => {
        const minionId = row.querySelector('.encounter-minion-select')?.value;
        const percent = parseInt(row.querySelector('.encounter-percent-input')?.value) || 5;
        if (minionId) {
            minionEncounters.push({ minionId, percent });
        }
    });

    // Collect trap encounters from the list
    const trapEncounterRows = document.querySelectorAll('#mazemaster_maze_traps_list .mazemaster-trap-encounter-row');
    const trapEncounters = [];
    trapEncounterRows.forEach(row => {
        const trapId = row.querySelector('.trap-encounter-select')?.value;
        const percent = parseInt(row.querySelector('.trap-encounter-percent-input')?.value) || 5;
        if (trapId) {
            trapEncounters.push({ trapId, percent });
        }
    });

    // Collect random messages
    const randomMessagesText = document.getElementById('mazemaster_maze_random_messages')?.value || '';
    const mainMinionRandomMessages = randomMessagesText.split('\n').filter(m => m.trim());

    return {
        gridSize: parseInt(document.getElementById('mazemaster_maze_size')?.value) || 10,
        difficulty: document.getElementById('mazemaster_maze_difficulty')?.value || 'normal',
        theme: document.getElementById('mazemaster_maze_theme')?.value || 'fantasy',
        mapStyle: document.getElementById('mazemaster_maze_mapstyle')?.value || 'maze',
        floors: parseInt(document.getElementById('mazemaster_maze_floors')?.value) || 1,
        mapVisibility: document.querySelector('input[name="mazemaster_map_visibility"]:checked')?.value || 'fogOfWar',
        winCommand: document.getElementById('mazemaster_maze_win_cmd')?.value || '',
        loseCommand: document.getElementById('mazemaster_maze_lose_cmd')?.value || '',
        winMessage: document.getElementById('mazemaster_maze_win_message')?.value || '',
        winImage: existingProfile.winImage || '',
        chestImage: existingProfile.chestImage || '',
        // Main minion settings
        mainMinion: document.getElementById('mazemaster_maze_main_minion')?.value || '',
        mainMinionIntroMessage: document.getElementById('mazemaster_maze_intro_message')?.value || '',
        mainMinionRandomChance: parseInt(document.getElementById('mazemaster_maze_random_chance')?.value) || 15,
        mainMinionRandomMessages: mainMinionRandomMessages,
        mainMinionExitType: document.getElementById('mazemaster_maze_exit_type')?.value || 'messenger',
        mainMinionExitProfile: document.getElementById('mazemaster_maze_exit_profile')?.value || '',
        // Encounters (percent-based)
        minionEncounters: minionEncounters,
        trapEncounters: trapEncounters,
        // Loss behavior
        onBattlebarLoss: document.getElementById('mazemaster_maze_loss_action')?.value || 'continue',
        // Chest settings
        chestTilePercent: parseInt(document.getElementById('mazemaster_maze_chest_percent')?.value) || 10,
        chestLockedPercent: parseInt(document.getElementById('mazemaster_maze_locked_percent')?.value) || 30,
        chestLockedBonusPercent: parseInt(document.getElementById('mazemaster_maze_locked_bonus')?.value) || 50,
        chestMimicPercent: parseInt(document.getElementById('mazemaster_maze_mimic_percent')?.value) || 15,
        chestLootMin: parseInt(document.getElementById('mazemaster_maze_loot_min')?.value) || 1,
        chestLootMax: parseInt(document.getElementById('mazemaster_maze_loot_max')?.value) || 2,
        chestKeyChance: parseInt(document.getElementById('mazemaster_maze_chest_key')?.value) || 30,
        chestStrikeChance: parseInt(document.getElementById('mazemaster_maze_chest_pow')?.value) || 50,
        chestStealthChance: parseInt(document.getElementById('mazemaster_maze_chest_stealth')?.value) || 0,
        chestExecuteChance: parseInt(document.getElementById('mazemaster_maze_chest_execute')?.value) || 0,
        lockedChestKeyChance: parseInt(document.getElementById('mazemaster_maze_locked_key')?.value) || 40,
        lockedChestStrikeChance: parseInt(document.getElementById('mazemaster_maze_locked_pow')?.value) || 60,
        lockedChestStealthChance: parseInt(document.getElementById('mazemaster_maze_locked_stealth')?.value) || 30,
        lockedChestExecuteChance: parseInt(document.getElementById('mazemaster_maze_locked_execute')?.value) || 5,
        // Starting inventory
        startingInventory: {
            key: parseInt(document.getElementById('mazemaster_start_key')?.value) || 0,
            strike: parseInt(document.getElementById('mazemaster_start_pow')?.value) || 0,
            stealth: parseInt(document.getElementById('mazemaster_start_stealth')?.value) || 0,
            execute: parseInt(document.getElementById('mazemaster_start_execute')?.value) || 0,
            // HP items
            healingPotion: parseInt(document.getElementById('mazemaster_start_healingPotion')?.value) || 0,
            greaterHealing: parseInt(document.getElementById('mazemaster_start_greaterHealing')?.value) || 0,
            elixir: parseInt(document.getElementById('mazemaster_start_elixir')?.value) || 0,
            revivalCharm: parseInt(document.getElementById('mazemaster_start_revivalCharm')?.value) || 0,
        },
        // HP System settings
        hpEnabled: document.getElementById('mazemaster_hp_enabled')?.checked !== false,
        maxHP: parseInt(document.getElementById('mazemaster_hp_max')?.value) || 100,
        battlebarDamageMultiplier: parseFloat(document.getElementById('mazemaster_hp_battlebar_mult')?.value) || 1.0,
        battlebarDifficultyMultiplier: parseFloat(document.getElementById('mazemaster_hp_battlebar_diff')?.value) || 1.0,
        respawnHPPercent: parseInt(document.getElementById('mazemaster_hp_respawn')?.value) || 50,
        onDeath: document.getElementById('mazemaster_hp_ondeath')?.value || 'respawn',
        // Safe room settings
        safeRoomCount: parseInt(document.getElementById('mazemaster_saferoom_count')?.value) ?? 3,
        safeRoomHealPercent: parseInt(document.getElementById('mazemaster_saferoom_heal')?.value) ?? 100,
        safeRoomUseLLM: document.getElementById('mazemaster_saferoom_llm')?.checked || false,
        // LLM Enhancement settings
        llmEnhanceRooms: document.getElementById('mazemaster_llm_enhance_rooms')?.checked !== false,
        // Rest mechanic settings
        restEnabled: document.getElementById('mazemaster_rest_enabled')?.checked !== false,
        restHealPercent: parseInt(document.getElementById('mazemaster_rest_heal')?.value) ?? 20,
        restCooldown: parseInt(document.getElementById('mazemaster_rest_cooldown')?.value) ?? 3,
        restInterruptChance: parseInt(document.getElementById('mazemaster_rest_interrupt')?.value) ?? 0,
        restInterruptScript: document.getElementById('mazemaster_rest_interrupt_script')?.value || '',
        // Portals
        portals: collectPortalsFromUI(),
        // v1.4.0 BSP Configuration
        bspConfig: {
            zoneCount: parseInt(document.getElementById('mazemaster_bsp_zone_count')?.value) || 1,
            secretDensity: parseFloat(document.getElementById('mazemaster_bsp_secret_density')?.value) || 0,
            zonesRequireClear: document.getElementById('mazemaster_bsp_zones_require_clear')?.checked !== false,
            secretHints: document.getElementById('mazemaster_bsp_secret_hints')?.checked !== false,
            floorComplexityScaling: document.getElementById('mazemaster_bsp_floor_scaling')?.checked !== false,
        },
        // Objectives
        objectives: collectObjectivesFromUI(),
        // STScript Hooks
        onMove: document.getElementById('mazemaster_hook_onMove')?.value || '',
        onMilestone: document.getElementById('mazemaster_hook_onMilestone')?.value || '',
        onExploreComplete: document.getElementById('mazemaster_hook_onExploreComplete')?.value || '',
        onItemAdd: document.getElementById('mazemaster_hook_onItemAdd')?.value || '',
        onItemRemove: document.getElementById('mazemaster_hook_onItemRemove')?.value || '',
        onChestOpen: document.getElementById('mazemaster_hook_onChestOpen')?.value || '',
        onTrade: document.getElementById('mazemaster_hook_onTrade')?.value || '',
        onEnemyMove: document.getElementById('mazemaster_hook_onEnemyMove')?.value || '',
        onTeleport: document.getElementById('mazemaster_hook_onTeleport')?.value || '',
        onObjectiveProgress: document.getElementById('mazemaster_hook_onObjectiveProgress')?.value || '',
        onObjectiveComplete: document.getElementById('mazemaster_hook_onObjectiveComplete')?.value || '',
        onAllObjectivesComplete: document.getElementById('mazemaster_hook_onAllObjectivesComplete')?.value || '',
        onStatUpdate: document.getElementById('mazemaster_hook_onStatUpdate')?.value || '',
        // Preserve story config
        storyConfig: existingProfile.storyConfig || { mainStory: '', milestones: [] },
        // Find Early items (v1.3.2)
        findEarly: collectFindEarlyFromUI(),
    };
}

/**
 * Collect Find Early configuration from UI checkboxes
 */
function collectFindEarlyFromUI() {
    const radius = parseInt(document.getElementById('mazemaster_findearly_radius')?.value) || 4;
    const itemsPerChest = parseInt(document.getElementById('mazemaster_findearly_perchest')?.value) || 1;

    // Collect checked items
    const items = [];
    const itemTypes = ['torch', 'lantern', 'mapFragment', 'healingPotion', 'greaterHealing',
                       'revealScroll', 'sightPotion', 'key', 'strike', 'stealth'];

    for (const item of itemTypes) {
        const checkbox = document.getElementById(`mazemaster_findearly_${item}`);
        if (checkbox?.checked) {
            items.push(item);
        }
    }

    // Only return findEarly config if items are selected
    if (items.length === 0) {
        return null;
    }

    return { radius, items, itemsPerChest };
}

/**
 * Collect portal configuration from the UI
 */
function collectPortalsFromUI() {
    const portals = [];
    const portalItems = document.querySelectorAll('#mazemaster_portals_list .mazemaster-portal-item');

    portalItems.forEach((item) => {
        const id = item.querySelector('.portal-id')?.value?.trim() || '';
        const color = item.querySelector('.portal-color-input')?.value || '#9b59b6';
        const bidirectional = item.querySelector('.portal-bidirectional')?.checked ?? true;

        const startXInput = item.querySelector('.portal-start-x')?.value;
        const startYInput = item.querySelector('.portal-start-y')?.value;
        const endXInput = item.querySelector('.portal-end-x')?.value;
        const endYInput = item.querySelector('.portal-end-y')?.value;

        portals.push({
            id: id || `portal_${portals.length + 1}`,
            color: color,
            bidirectional: bidirectional,
            startX: startXInput !== '' ? parseInt(startXInput) : null,
            startY: startYInput !== '' ? parseInt(startYInput) : null,
            endX: endXInput !== '' ? parseInt(endXInput) : null,
            endY: endYInput !== '' ? parseInt(endYInput) : null,
        });
    });

    return portals;
}

/**
 * Collect objectives configuration from the UI
 */
function collectObjectivesFromUI() {
    const objectives = [];
    const objectiveItems = document.querySelectorAll('#mazemaster_objectives_list .mazemaster-objective-item');

    objectiveItems.forEach((item, idx) => {
        const id = item.querySelector('.objective-id')?.value?.trim() || `obj_${idx + 1}`;
        const type = item.querySelector('.objective-type')?.value || 'collect';
        const target = item.querySelector('.objective-target')?.value?.trim() || '';
        const count = parseInt(item.querySelector('.objective-count')?.value) || 1;
        const description = item.querySelector('.objective-description')?.value?.trim() || '';
        const required = item.querySelector('.objective-required')?.checked ?? true;
        const reward = item.querySelector('.objective-reward')?.value?.trim() || '';

        objectives.push({
            id,
            type,
            target: type === 'explore' ? null : target,
            count,
            description: description || `${type === 'collect' ? 'Collect' : type === 'defeat' ? 'Defeat' : 'Explore'} ${count}${type === 'explore' ? '%' : ' ' + target}`,
            required,
            reward,
        });
    });

    return objectives;
}

/**
 * Crop an image file to a square (center crop)
 * @param {File} file - The image file to crop
 * @returns {Promise<Blob>} - The cropped image as a Blob
 */
async function cropToSquare(file) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);

        img.onload = () => {
            URL.revokeObjectURL(url);

            const size = Math.min(img.width, img.height);
            const offsetX = (img.width - size) / 2;
            const offsetY = (img.height - size) / 2;

            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;

            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, offsetX, offsetY, size, size, 0, 0, size, size);

            canvas.toBlob((blob) => {
                if (blob) {
                    resolve(blob);
                } else {
                    reject(new Error('Failed to create cropped image'));
                }
            }, file.type || 'image/png');
        };

        img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error('Failed to load image'));
        };

        img.src = url;
    });
}

async function uploadImage(file, filenamePrefix) {
    // First crop the image to square
    let imageBlob;
    try {
        imageBlob = await cropToSquare(file);
    } catch (err) {
        console.warn('[MazeMaster] Could not crop image, using original:', err);
        imageBlob = file;
    }

    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const base64 = e.target.result.split(',')[1];
                const ext = file.name.split('.').pop().toLowerCase();
                const timestamp = Date.now();
                const filename = `${filenamePrefix}_${timestamp}`;

                const response = await fetch('/api/images/upload', {
                    method: 'POST',
                    headers: getRequestHeaders(),
                    body: JSON.stringify({
                        image: base64,
                        ch_name: 'MazeMaster',
                        filename: filename,
                        format: ext,
                    }),
                });

                if (response.ok) {
                    resolve(`user/images/MazeMaster/${filename}.${ext}`);
                } else {
                    const error = await response.json().catch(() => ({}));
                    reject(new Error(error.error || 'Upload failed'));
                }
            } catch (err) {
                reject(err);
            }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(imageBlob);
    });
}

// =============================================================================
// MINIONS UI HELPERS
// =============================================================================

function renderMinionsList() {
    const list = document.getElementById('mazemaster_minions_list');
    if (!list) return;

    // Get selected minion profile to filter the list
    const profileSelect = document.getElementById('mazemaster_minion_profile_select');
    const selectedProfile = profileSelect?.value || '';

    let minionIds = getMinionNames();

    // Filter by selected profile if one is selected
    if (selectedProfile && extensionSettings.minionProfiles?.[selectedProfile]) {
        const profile = extensionSettings.minionProfiles[selectedProfile];
        // Check if it's the new format (array of minion IDs) or old format (full minion objects)
        if (Array.isArray(profile.minions)) {
            // New format: { minions: ['id1', 'id2'] }
            minionIds = minionIds.filter(id => profile.minions.includes(id));
        } else if (typeof profile === 'object' && !profile.minions) {
            // Old format: { 'fantasy_herald': {...}, 'fantasy_guardian': {...} }
            const profileMinions = Object.keys(profile);
            minionIds = minionIds.filter(id => profileMinions.includes(id));
        }
    }

    if (minionIds.length === 0) {
        const message = selectedProfile
            ? `No minions in profile "${selectedProfile}". Select a different profile or add minions.`
            : 'No minions. Add minions for use in the maze game.';
        list.innerHTML = `<div class="mazemaster-empty-state">${message}</div>`;
        return;
    }

    // Get available profiles for dropdowns
    const battlebarProfileNames = getBattlebarProfileNames();
    const wheelProfileNames = getProfileNames();
    const turnbasedProfileNames = getTurnbasedProfileNames();
    const qteProfileNames = getQteProfileNames();
    const diceProfileNames = getDiceProfileNames();
    const stealthProfileNames = getStealthProfileNames();
    const puzzleProfileNames = getPuzzleProfileNames();
    const negotiationProfileNames = getNegotiationProfileNames();

    list.innerHTML = minionIds.map(id => {
        const minion = getMinion(id);
        if (!minion) {
            console.warn(`[MazeMaster] Minion "${id}" not found, skipping`);
            return '';
        }
        const minionType = minion.type || 'messenger';
        const battlebarProfiles = minion.battlebarProfiles || [];
        const wheelProfiles = minion.wheelProfiles || [];
        const turnbasedProfiles = minion.turnbasedProfiles || [];
        const qteProfiles = minion.qteProfiles || [];
        const diceProfiles = minion.diceProfiles || [];
        const stealthProfiles = minion.stealthProfiles || [];
        const puzzleProfiles = minion.puzzleProfiles || [];
        const negotiationProfiles = minion.negotiationProfiles || [];
        const messages = minion.messages || [];
        const encounterScript = minion.encounterScript || '';
        const merchantItemCount = minion.merchantItemCount || { min: 1, max: 3 };
        const merchantItemPool = minion.merchantItemPool || 'Common Goods';
        const merchantPoolNames = Object.keys(extensionSettings.merchantItemPools || DEFAULT_MERCHANT_ITEM_POOLS);
        const movement = minion.movement || { type: 'stationary', patrolRadius: 3, chaseRange: 5, speed: 1 };

        return `
            <div class="mazemaster-minion-card" data-id="${escapeHtml(id)}">
                <div class="minion-image">
                    ${minion.imagePath ? `<img src="${escapeHtml(getExtensionImagePath(minion.imagePath))}" alt="${escapeHtml(minion.name)}">` : ''}
                </div>
                <div class="minion-info">
                    <div class="minion-row">
                        <input type="text" class="minion-name-input" value="${escapeHtml(minion.name)}" placeholder="Minion name">
                        <select class="minion-type-select">
                            <option value="messenger" ${minionType === 'messenger' ? 'selected' : ''}>Messenger</option>
                            <option value="battlebar" ${minionType === 'battlebar' ? 'selected' : ''}>Battlebar</option>
                            <option value="prizewheel" ${minionType === 'prizewheel' ? 'selected' : ''}>PrizeWheel</option>
                            <option value="merchant" ${minionType === 'merchant' ? 'selected' : ''}>Merchant</option>
                            <option value="turnbased" ${minionType === 'turnbased' ? 'selected' : ''}>Turn-Based Combat</option>
                            <option value="qte" ${minionType === 'qte' ? 'selected' : ''}>QTE Combat</option>
                            <option value="dice" ${minionType === 'dice' ? 'selected' : ''}>Dice Combat</option>
                            <option value="stealth" ${minionType === 'stealth' ? 'selected' : ''}>Stealth</option>
                            <option value="puzzle" ${minionType === 'puzzle' ? 'selected' : ''}>Puzzle</option>
                            <option value="negotiation" ${minionType === 'negotiation' ? 'selected' : ''}>Negotiation</option>
                        </select>
                    </div>
                    <div class="minion-profiles battlebar-profiles" style="display: ${minionType === 'battlebar' ? 'block' : 'none'};">
                        <label>Battlebar Profiles:</label>
                        <select multiple class="minion-battlebar-select">
                            ${battlebarProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${battlebarProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles wheel-profiles" style="display: ${minionType === 'prizewheel' ? 'block' : 'none'};">
                        <label>Wheel Profiles:</label>
                        <select multiple class="minion-wheel-select">
                            ${wheelProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${wheelProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles messenger-messages" style="display: ${minionType === 'messenger' ? 'block' : 'none'};">
                        <label>Messages (one per line):</label>
                        <textarea class="minion-messages-input" rows="2" placeholder="Hello traveler!&#10;Beware the maze...">${escapeHtml(messages.join('\n'))}</textarea>
                    </div>
                    <div class="minion-profiles merchant-settings" style="display: ${minionType === 'merchant' ? 'block' : 'none'};">
                        <label>Item Pool:</label>
                        <select class="merchant-pool-select">
                            ${merchantPoolNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${merchantItemPool === name ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                        <label>Items Offered (random range):</label>
                        <div class="merchant-range-row">
                            <input type="number" class="merchant-min-input mazemaster-input-small" min="1" max="10" value="${merchantItemCount.min}">
                            <span>to</span>
                            <input type="number" class="merchant-max-input mazemaster-input-small" min="1" max="10" value="${merchantItemCount.max}">
                            <span>items</span>
                        </div>
                    </div>
                    <div class="minion-profiles turnbased-profiles" style="display: ${minionType === 'turnbased' ? 'block' : 'none'};">
                        <label>Turn-Based Profiles:</label>
                        <select multiple class="minion-turnbased-select">
                            ${turnbasedProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${turnbasedProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles qte-profiles" style="display: ${minionType === 'qte' ? 'block' : 'none'};">
                        <label>QTE Profiles:</label>
                        <select multiple class="minion-qte-select">
                            ${qteProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${qteProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles dice-profiles" style="display: ${minionType === 'dice' ? 'block' : 'none'};">
                        <label>Dice Profiles:</label>
                        <select multiple class="minion-dice-select">
                            ${diceProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${diceProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles stealth-profiles" style="display: ${minionType === 'stealth' ? 'block' : 'none'};">
                        <label>Stealth Profiles:</label>
                        <select multiple class="minion-stealth-select">
                            ${stealthProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${stealthProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles puzzle-profiles" style="display: ${minionType === 'puzzle' ? 'block' : 'none'};">
                        <label>Puzzle Profiles:</label>
                        <select multiple class="minion-puzzle-select">
                            ${puzzleProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${puzzleProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-profiles negotiation-profiles" style="display: ${minionType === 'negotiation' ? 'block' : 'none'};">
                        <label>Negotiation Profiles:</label>
                        <select multiple class="minion-negotiation-select">
                            ${negotiationProfileNames.map(name =>
                                `<option value="${escapeHtml(name)}" ${negotiationProfiles.includes(name) ? 'selected' : ''}>${escapeHtml(name)}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="minion-encounter-script">
                        <label>Encounter Script (STScript):</label>
                        <textarea class="minion-script-input" rows="2" placeholder="/echo Custom action on encounter...">${escapeHtml(encounterScript)}</textarea>
                    </div>
                    <div class="minion-movement-settings">
                        <label>Maze Movement:</label>
                        <div class="movement-row">
                            <select class="minion-movement-type">
                                <option value="stationary" ${movement.type === 'stationary' ? 'selected' : ''}>Stationary</option>
                                <option value="patrol" ${movement.type === 'patrol' ? 'selected' : ''}>Patrol</option>
                                <option value="chase" ${movement.type === 'chase' ? 'selected' : ''}>Chase Player</option>
                            </select>
                        </div>
                        <div class="movement-params" style="display: ${movement.type !== 'stationary' ? 'flex' : 'none'};">
                            <div class="movement-param patrol-param" style="display: ${movement.type === 'patrol' ? 'flex' : 'none'};">
                                <span>Radius:</span>
                                <input type="number" class="minion-patrol-radius mazemaster-input-small" min="1" max="10" value="${movement.patrolRadius || 3}">
                            </div>
                            <div class="movement-param chase-param" style="display: ${movement.type === 'chase' ? 'flex' : 'none'};">
                                <span>Range:</span>
                                <input type="number" class="minion-chase-range mazemaster-input-small" min="1" max="20" value="${movement.chaseRange || 5}">
                            </div>
                            <div class="movement-param">
                                <span>Speed:</span>
                                <input type="number" class="minion-movement-speed mazemaster-input-small" min="1" max="5" value="${movement.speed || 1}" title="Moves every N player moves">
                            </div>
                        </div>
                    </div>
                </div>
                <button class="menu_button menu_button_icon minion-delete-btn" title="Delete Minion">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
        `;
    }).join('');

    // Add event handlers
    list.querySelectorAll('.mazemaster-minion-card').forEach(card => {
        const minionId = card.dataset.id;

        // Name input change
        const nameInput = card.querySelector('.minion-name-input');
        if (nameInput) {
            nameInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.name = nameInput.value.trim() || 'Unknown';
                    saveMinion(minionId, minion);
                }
            });
        }

        // Type select change
        const typeSelect = card.querySelector('.minion-type-select');
        if (typeSelect) {
            typeSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.type = typeSelect.value;
                    saveMinion(minionId, minion);

                    // Toggle visibility of profile sections based on type
                    const sections = {
                        battlebar: card.querySelector('.battlebar-profiles'),
                        prizewheel: card.querySelector('.wheel-profiles'),
                        messenger: card.querySelector('.messenger-messages'),
                        merchant: card.querySelector('.merchant-settings'),
                        turnbased: card.querySelector('.turnbased-profiles'),
                        qte: card.querySelector('.qte-profiles'),
                        dice: card.querySelector('.dice-profiles'),
                        stealth: card.querySelector('.stealth-profiles'),
                        puzzle: card.querySelector('.puzzle-profiles'),
                        negotiation: card.querySelector('.negotiation-profiles'),
                    };

                    for (const [type, section] of Object.entries(sections)) {
                        if (section) section.style.display = minion.type === type ? 'block' : 'none';
                    }
                }
            });
        }

        // Battlebar profiles select
        const battlebarSelect = card.querySelector('.minion-battlebar-select');
        if (battlebarSelect) {
            battlebarSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.battlebarProfiles = Array.from(battlebarSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Wheel profiles select
        const wheelSelect = card.querySelector('.minion-wheel-select');
        if (wheelSelect) {
            wheelSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.wheelProfiles = Array.from(wheelSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Turn-based profiles select
        const turnbasedSelect = card.querySelector('.minion-turnbased-select');
        if (turnbasedSelect) {
            turnbasedSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.turnbasedProfiles = Array.from(turnbasedSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // QTE profiles select
        const qteSelect = card.querySelector('.minion-qte-select');
        if (qteSelect) {
            qteSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.qteProfiles = Array.from(qteSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Dice profiles select
        const diceSelect = card.querySelector('.minion-dice-select');
        if (diceSelect) {
            diceSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.diceProfiles = Array.from(diceSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Stealth profiles select
        const stealthSelect = card.querySelector('.minion-stealth-select');
        if (stealthSelect) {
            stealthSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.stealthProfiles = Array.from(stealthSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Puzzle profiles select
        const puzzleSelect = card.querySelector('.minion-puzzle-select');
        if (puzzleSelect) {
            puzzleSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.puzzleProfiles = Array.from(puzzleSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Negotiation profiles select
        const negotiationSelect = card.querySelector('.minion-negotiation-select');
        if (negotiationSelect) {
            negotiationSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.negotiationProfiles = Array.from(negotiationSelect.selectedOptions).map(opt => opt.value);
                    saveMinion(minionId, minion);
                }
            });
        }

        // Messenger messages textarea
        const messagesInput = card.querySelector('.minion-messages-input');
        if (messagesInput) {
            messagesInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.messages = messagesInput.value.split('\n').filter(m => m.trim());
                    saveMinion(minionId, minion);
                }
            });
        }

        // Merchant settings
        const merchantPoolSelect = card.querySelector('.merchant-pool-select');
        const merchantMinInput = card.querySelector('.merchant-min-input');
        const merchantMaxInput = card.querySelector('.merchant-max-input');
        if (merchantPoolSelect) {
            merchantPoolSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.merchantItemPool = merchantPoolSelect.value;
                    saveMinion(minionId, minion);
                }
            });
        }
        if (merchantMinInput) {
            merchantMinInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.merchantItemCount = minion.merchantItemCount || { min: 1, max: 3 };
                    minion.merchantItemCount.min = parseInt(merchantMinInput.value) || 1;
                    saveMinion(minionId, minion);
                }
            });
        }
        if (merchantMaxInput) {
            merchantMaxInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.merchantItemCount = minion.merchantItemCount || { min: 1, max: 3 };
                    minion.merchantItemCount.max = parseInt(merchantMaxInput.value) || 3;
                    saveMinion(minionId, minion);
                }
            });
        }

        // Encounter script textarea
        const scriptInput = card.querySelector('.minion-script-input');
        if (scriptInput) {
            scriptInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.encounterScript = scriptInput.value;
                    saveMinion(minionId, minion);
                }
            });
        }

        // Movement settings
        const movementTypeSelect = card.querySelector('.minion-movement-type');
        const movementParams = card.querySelector('.movement-params');
        const patrolParams = card.querySelector('.patrol-param');
        const chaseParams = card.querySelector('.chase-param');
        const patrolRadiusInput = card.querySelector('.minion-patrol-radius');
        const chaseRangeInput = card.querySelector('.minion-chase-range');
        const movementSpeedInput = card.querySelector('.minion-movement-speed');

        if (movementTypeSelect) {
            movementTypeSelect.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || { type: 'stationary', patrolRadius: 3, chaseRange: 5, speed: 1 };
                    minion.movement.type = movementTypeSelect.value;
                    saveMinion(minionId, minion);

                    // Show/hide params based on type
                    if (movementParams) {
                        movementParams.style.display = movementTypeSelect.value !== 'stationary' ? 'flex' : 'none';
                    }
                    if (patrolParams) {
                        patrolParams.style.display = movementTypeSelect.value === 'patrol' ? 'flex' : 'none';
                    }
                    if (chaseParams) {
                        chaseParams.style.display = movementTypeSelect.value === 'chase' ? 'flex' : 'none';
                    }
                }
            });
        }

        if (patrolRadiusInput) {
            patrolRadiusInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || { type: 'patrol', patrolRadius: 3, chaseRange: 5, speed: 1 };
                    minion.movement.patrolRadius = parseInt(patrolRadiusInput.value) || 3;
                    saveMinion(minionId, minion);
                }
            });
        }

        if (chaseRangeInput) {
            chaseRangeInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || { type: 'chase', patrolRadius: 3, chaseRange: 5, speed: 1 };
                    minion.movement.chaseRange = parseInt(chaseRangeInput.value) || 5;
                    saveMinion(minionId, minion);
                }
            });
        }

        if (movementSpeedInput) {
            movementSpeedInput.addEventListener('change', () => {
                const minion = getMinion(minionId);
                if (minion) {
                    minion.movement = minion.movement || { type: 'stationary', patrolRadius: 3, chaseRange: 5, speed: 1 };
                    minion.movement.speed = parseInt(movementSpeedInput.value) || 1;
                    saveMinion(minionId, minion);
                }
            });
        }

        // Minion image click-to-edit
        const minionImageDiv = card.querySelector('.minion-image');
        if (minionImageDiv) {
            minionImageDiv.style.cursor = 'pointer';
            minionImageDiv.title = 'Click to change image';
            minionImageDiv.addEventListener('click', () => {
                // Create a temporary file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.style.display = 'none';
                document.body.appendChild(fileInput);

                fileInput.addEventListener('change', async (e) => {
                    const file = e.target.files?.[0];
                    if (!file) {
                        document.body.removeChild(fileInput);
                        return;
                    }

                    try {
                        const imagePath = await uploadImage(file, minionId);
                        const minion = getMinion(minionId);
                        if (minion) {
                            minion.imagePath = imagePath;
                            saveMinion(minionId, minion);
                            renderMinionsList();
                        }
                    } catch (err) {
                        console.error('[MazeMaster] Image upload failed:', err);
                        alert(`Image upload failed: ${err.message}`);
                    }

                    document.body.removeChild(fileInput);
                });

                fileInput.click();
            });
        }

        // Delete button
        const deleteBtn = card.querySelector('.minion-delete-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', async () => {
                const minion = getMinion(minionId);
                const confirmed = await callGenericPopup(`Delete minion "${minion?.name || minionId}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteMinion(minionId);
                    renderMinionsList();
                }
            });
        }
    });
}

function renderTrapsList() {
    const list = document.getElementById('mazemaster_traps_list');
    if (!list) return;

    const trapIds = getTrapNames();

    if (trapIds.length === 0) {
        list.innerHTML = '<div class="mazemaster-empty-state">No traps. Add traps for use in maze profiles.</div>';
        return;
    }

    list.innerHTML = trapIds.map(id => {
        const trap = getTrap(id);
        const avoidChance = trap.avoidChance ?? 0;
        return `
            <div class="mazemaster-trap-card" data-id="${escapeHtml(id)}">
                <div class="trap-image">
                    ${trap.imagePath ? `<img src="${escapeHtml(getExtensionImagePath(trap.imagePath))}" alt="${escapeHtml(trap.name)}">` : '<div class="trap-no-image"><i class="fa-solid fa-dungeon"></i></div>'}
                </div>
                <div class="trap-info">
                    <div class="trap-row">
                        <input type="text" class="trap-name-input mazemaster-input" value="${escapeHtml(trap.name)}" placeholder="Trap name">
                    </div>
                    <div class="trap-message-row">
                        <label>Message:</label>
                        <textarea class="trap-message-input" rows="2" placeholder="You triggered a trap!">${escapeHtml(trap.message || '')}</textarea>
                    </div>
                    <div class="trap-script-row">
                        <label>Script (STScript):</label>
                        <textarea class="trap-script-input" rows="2" placeholder="/echo Trap triggered! | /mazedamage 25">${escapeHtml(trap.script || '')}</textarea>
                    </div>
                    <div class="trap-avoid-row" style="display: flex; gap: 8px; align-items: center; margin-top: 4px;">
                        <label style="white-space: nowrap;">Avoid %:</label>
                        <input type="number" class="trap-avoid-input mazemaster-input" value="${avoidChance}" min="0" max="100" style="width: 60px;">
                        <input type="text" class="trap-avoid-message-input mazemaster-input" value="${escapeHtml(trap.avoidMessage || '')}" placeholder="Message when avoided" style="flex: 1;">
                    </div>
                    <div class="trap-avoid-script-row" style="margin-top: 4px;">
                        <label>Avoid Script (STScript):</label>
                        <textarea class="trap-avoid-script-input" rows="1" placeholder="/echo {{user}} dodged the trap!">${escapeHtml(trap.avoidScript || '')}</textarea>
                    </div>
                </div>
                <button class="menu_button menu_button_icon trap-delete-btn" title="Delete Trap">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
        `;
    }).join('');

    // Add event handlers
    list.querySelectorAll('.mazemaster-trap-card').forEach(card => {
        const trapId = card.dataset.id;

        // Name input change
        const nameInput = card.querySelector('.trap-name-input');
        if (nameInput) {
            nameInput.addEventListener('change', () => {
                const trap = getTrap(trapId);
                if (trap) {
                    trap.name = nameInput.value.trim() || 'Unknown Trap';
                    saveTrap(trapId, trap);
                }
            });
        }

        // Message textarea change
        const messageInput = card.querySelector('.trap-message-input');
        if (messageInput) {
            messageInput.addEventListener('change', () => {
                const trap = getTrap(trapId);
                if (trap) {
                    trap.message = messageInput.value;
                    saveTrap(trapId, trap);
                }
            });
        }

        // Script textarea change
        const scriptInput = card.querySelector('.trap-script-input');
        if (scriptInput) {
            scriptInput.addEventListener('change', () => {
                const trap = getTrap(trapId);
                if (trap) {
                    trap.script = scriptInput.value;
                    saveTrap(trapId, trap);
                }
            });
        }

        // Avoid chance input change
        const avoidInput = card.querySelector('.trap-avoid-input');
        if (avoidInput) {
            avoidInput.addEventListener('change', () => {
                const trap = getTrap(trapId);
                if (trap) {
                    trap.avoidChance = Math.max(0, Math.min(100, parseInt(avoidInput.value) || 0));
                    saveTrap(trapId, trap);
                }
            });
        }

        // Avoid message input change
        const avoidMessageInput = card.querySelector('.trap-avoid-message-input');
        if (avoidMessageInput) {
            avoidMessageInput.addEventListener('change', () => {
                const trap = getTrap(trapId);
                if (trap) {
                    trap.avoidMessage = avoidMessageInput.value;
                    saveTrap(trapId, trap);
                }
            });
        }

        // Avoid script input change
        const avoidScriptInput = card.querySelector('.trap-avoid-script-input');
        if (avoidScriptInput) {
            avoidScriptInput.addEventListener('change', () => {
                const trap = getTrap(trapId);
                if (trap) {
                    trap.avoidScript = avoidScriptInput.value;
                    saveTrap(trapId, trap);
                }
            });
        }

        // Trap image click-to-edit
        const trapImageDiv = card.querySelector('.trap-image');
        if (trapImageDiv) {
            trapImageDiv.style.cursor = 'pointer';
            trapImageDiv.title = 'Click to change image';
            trapImageDiv.addEventListener('click', () => {
                // Create a temporary file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.style.display = 'none';
                document.body.appendChild(fileInput);

                fileInput.addEventListener('change', async (e) => {
                    const file = e.target.files?.[0];
                    if (!file) {
                        document.body.removeChild(fileInput);
                        return;
                    }

                    try {
                        const imagePath = await uploadImage(file, trapId);
                        const trap = getTrap(trapId);
                        if (trap) {
                            trap.imagePath = imagePath;
                            saveTrap(trapId, trap);
                            renderTrapsList();
                        }
                    } catch (err) {
                        console.error('[MazeMaster] Image upload failed:', err);
                        alert(`Image upload failed: ${err.message}`);
                    }

                    document.body.removeChild(fileInput);
                });

                fileInput.click();
            });
        }

        // Delete button
        const deleteBtn = card.querySelector('.trap-delete-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', async () => {
                const trap = getTrap(trapId);
                const confirmed = await callGenericPopup(`Delete trap "${trap?.name || trapId}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteTrap(trapId);
                    renderTrapsList();
                }
            });
        }
    });
}

function initUI(retryCount = 0) {
    console.log('[MazeMaster] initUI called (attempt ' + (retryCount + 1) + ')');

    // Check if drawer already exists (prevent duplicates)
    const existingDrawer = document.getElementById('mazemaster-button');
    if (existingDrawer) {
        console.log('[MazeMaster] Drawer already exists, skipping insertion');
        setupEventHandlers();
        renderSegmentsList();
        renderMinionsList();
        renderTrapsList();
        updateMazeSettings();
        if (extensionSettings.activeGameConfig === 'battlebar') {
            renderBattlebarImages();
        }
        return;
    }

    // Check if extensions button exists yet
    const extensionsButton = document.getElementById('extensions-settings-button');
    if (!extensionsButton) {
        if (retryCount < 10) {
            console.log('[MazeMaster] extensions-settings-button not found, retrying in 500ms...');
            setTimeout(() => initUI(retryCount + 1), 500);
            return;
        } else {
            console.error('[MazeMaster] extensions-settings-button NOT FOUND after 10 retries!');
            return;
        }
    }

    let panelHtml;
    try {
        panelHtml = getPanelHtml();
        console.log('[MazeMaster] getPanelHtml succeeded');
    } catch (e) {
        console.error('[MazeMaster] getPanelHtml FAILED:', e);
        panelHtml = '<div>Error loading panel</div>';
    }

    const drawerWrapper = document.createElement('div');
    drawerWrapper.id = 'mazemaster-button';
    drawerWrapper.className = 'drawer';
    drawerWrapper.innerHTML = `
        <div class="drawer-toggle drawer-header">
            <div class="drawer-icon fa-solid fa-dharmachakra fa-fw closedIcon" title="MazeMaster"></div>
        </div>
        <div id="mazemaster_drawer" class="drawer-content closedDrawer">
            ${panelHtml}
        </div>
    `;

    extensionsButton.after(drawerWrapper);
    console.log('[MazeMaster] Drawer inserted after extensions button');

    // Set up drawer toggle click handler directly (more reliable than copying from another drawer)
    const drawerToggle = drawerWrapper.querySelector('.drawer-toggle');
    if (drawerToggle && window.jQuery) {
        const $ = window.jQuery;
        $(drawerToggle).on('click', async function() {
            const icon = $(this).find('.drawer-icon');
            const drawer = $(this).parent().find('.drawer-content');
            const drawerWasOpenAlready = drawer.hasClass('openDrawer');

            if (!drawerWasOpenAlready) {
                // Close other open drawers (except pinned ones)
                $('.openDrawer:not(.pinnedOpen)').removeClass('openDrawer').addClass('closedDrawer');
                $('.openIcon:not(.drawerPinnedOpen)').removeClass('openIcon').addClass('closedIcon');
            }

            // Toggle this drawer
            icon.toggleClass('openIcon closedIcon');
            drawer.toggleClass('openDrawer closedDrawer');
        });
    }

    setupEventHandlers();
    renderSegmentsList();
    renderMinionsList();
    renderTrapsList();
    updateMazeSettings();

    // If battlebar config is active, render images
    if (extensionSettings.activeGameConfig === 'battlebar') {
        renderBattlebarImages();
    }
}

/**
 * Handle Intelligent Distribute button - auto-set tile percentages
 * Defaults: Trap 5%, Chest 15%, Minions distributed (messenger high, merchant low)
 */
function handleIntelligentDistribute() {
    // Set chest tiles to 15%
    const chestPercentInput = document.getElementById('mazemaster_maze_chest_percent');
    if (chestPercentInput) chestPercentInput.value = '15';

    // Get current minion encounters
    const encountersList = document.getElementById('mazemaster_maze_encounters_list');
    const encounterRows = encountersList?.querySelectorAll('.mazemaster-encounter-row') || [];

    // Calculate minion percentages based on type
    // Remaining after chests (15%) and traps (5%) = 80%
    // Reserve ~15% for empty/movement space
    // Available for minions: ~65% (but we'll use what's configured)

    // Type priority weights (higher = more tiles)
    const typeWeights = {
        'messenger': 10,    // Highest priority - most common
        'prizewheel': 6,    // Medium-high
        'battlebar': 4,     // Medium
        'merchant': 1,      // Lowest - rarest
    };

    // Calculate total weight and assign percentages
    let totalWeight = 0;
    const minionTypes = [];

    encounterRows.forEach(row => {
        const minionId = row.getAttribute('data-minion-id');
        if (!minionId) return;

        const minion = getMinion(minionId);
        const type = minion?.type || 'battlebar';
        const weight = typeWeights[type] || 4;
        totalWeight += weight;
        minionTypes.push({ row, type, weight });
    });

    // Distribute remaining percentage (after traps 5%, chests 15% = 20% used)
    // Available: 80%, but leave some empty space
    const minionTotalPercent = 60; // 60% for minions, 20% empty

    if (totalWeight > 0) {
        minionTypes.forEach(({ row, weight }) => {
            const percent = Math.round((weight / totalWeight) * minionTotalPercent);
            const percentInput = row.querySelector('.encounter-percent-input');
            if (percentInput) {
                percentInput.value = percent;
            }
        });
    }

    // Set trap tiles to 5%
    const trapsList = document.getElementById('mazemaster_maze_traps_list');
    const trapRows = trapsList?.querySelectorAll('.mazemaster-encounter-row') || [];

    if (trapRows.length > 0) {
        // Distribute 5% across trap types
        const trapPercent = Math.floor(5 / trapRows.length);
        trapRows.forEach(row => {
            const percentInput = row.querySelector('.encounter-percent-input');
            if (percentInput) {
                percentInput.value = trapPercent || 1;
            }
        });
    }

    // Save the profile with new values and refresh UI
    const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
    if (profileName) {
        const profileData = collectMazeDataFromUI();
        saveMazeProfile(profileName, profileData);
        loadMazeProfileSettings(); // Refresh the UI to show saved values
    }

    console.log('[MazeMaster] Intelligent Distribute applied: Chests 15%, Traps 5%, Minions distributed');
}

/**
 * Save current maze progress
 */
function saveMazeProgress() {
    if (!currentMaze.isOpen || !currentMaze.profileName) {
        console.warn('[MazeMaster] No active maze to save');
        return false;
    }

    // Create serializable state (avoiding circular references)
    const saveState = {
        profileName: currentMaze.profileName,
        size: currentMaze.size,
        playerX: currentMaze.playerX,
        playerY: currentMaze.playerY,
        exitX: currentMaze.exitX,
        exitY: currentMaze.exitY,
        visited: Array.from(currentMaze.visited),
        inventory: { ...currentMaze.inventory },
        exitEncounterDone: currentMaze.exitEncounterDone,
        shownMilestones: Array.from(currentMaze.shownMilestones || []),
        // v1.2.0: Multi-floor support
        currentFloor: currentMaze.currentFloor || 0,
        totalFloors: currentMaze.totalFloors || 1,
        floors: (currentMaze.floors || [currentMaze.grid]).map(floor =>
            floor.map(row => row.map(cell => ({
                walls: cell.walls,
                visited: cell.visited,
                minion: cell.minion,
                trap: cell.trap,
                chest: cell.chest,
                staircase: cell.staircase,
                roomInfo: cell.roomInfo,  // v1.2.1: Room name/description
                safeRoom: cell.safeRoom,  // v1.3.0: Safe room state
            })))
        ),
        // Serialize grid with only essential data (for backwards compat, same as floors[currentFloor])
        grid: currentMaze.grid.map(row => row.map(cell => ({
            walls: cell.walls,
            visited: cell.visited,
            minion: cell.minion,
            trap: cell.trap,
            chest: cell.chest,
            staircase: cell.staircase,
            roomInfo: cell.roomInfo,  // v1.2.1: Room name/description
            safeRoom: cell.safeRoom,  // v1.3.0: Safe room state
        }))),
        // v1.2.1: Persistent message log
        messageLog: currentMaze.messageLog || [],
        // v1.3.0: HP System
        hpEnabled: currentMaze.hpEnabled,
        hp: currentMaze.hp ? { ...currentMaze.hp } : null,
        restCooldown: currentMaze.restCooldown || 0,
        // v1.4.6: Session Notes
        sessionNotes: currentMaze.sessionNotes || '',
        // v1.4.7: Fairness System
        fairness: currentMaze.fairness || {},
        // v1.4.8: LLM Enhanced Room Descriptions
        enhancedRooms: currentMaze.enhancedRooms || {},
        timestamp: Date.now(),
    };

    extensionSettings.savedMazes[currentMaze.profileName] = saveState;
    saveSettingsDebounced();

    console.log(`[MazeMaster] Maze progress saved for "${currentMaze.profileName}"`);
    return true;
}

/**
 * Load saved maze progress
 */
function loadMazeProgress(profileName) {
    const saveState = extensionSettings.savedMazes?.[profileName];
    if (!saveState) {
        console.warn(`[MazeMaster] No saved game for "${profileName}"`);
        return false;
    }

    const profile = getMazeProfile(profileName);
    if (!profile) {
        console.error(`[MazeMaster] Profile "${profileName}" no longer exists`);
        return false;
    }

    // v1.2.0: Restore multi-floor state
    const totalFloors = saveState.totalFloors || 1;
    const currentFloor = saveState.currentFloor || 0;

    // Restore all floors (backwards compatible with single-floor saves)
    let floors;
    if (saveState.floors && saveState.floors.length > 0) {
        floors = saveState.floors.map(floor =>
            floor.map(row => row.map(cell => ({
                walls: cell.walls,
                visited: cell.visited,
                minion: cell.minion,
                trap: cell.trap,
                chest: cell.chest,
                staircase: cell.staircase,
                roomInfo: cell.roomInfo,  // v1.2.1: Room name/description
                safeRoom: cell.safeRoom,  // v1.3.0: Safe room state
            })))
        );
    } else {
        // Old save format - single floor
        floors = [saveState.grid.map(row => row.map(cell => ({
            walls: cell.walls,
            visited: cell.visited,
            minion: cell.minion,
            trap: cell.trap,
            chest: cell.chest,
            staircase: cell.staircase,
            roomInfo: cell.roomInfo,  // v1.2.1: Room name/description
            safeRoom: cell.safeRoom,  // v1.3.0: Safe room state
        })))];
    }

    // Current grid is the current floor
    const grid = floors[currentFloor];

    // Determine initial minion display
    let initialMinion = getDefaultMinion();
    const mainMinion = profile.mainMinion ? getMinion(profile.mainMinion) : null;
    if (mainMinion) {
        initialMinion = {
            name: mainMinion.name,
            imagePath: mainMinion.imagePath,
            message: 'Continuing your journey...',
        };
    }

    // Restore state
    currentMaze = {
        isOpen: true,
        profile: profile,
        profileName: profileName,
        grid: grid,
        size: saveState.size,
        playerX: saveState.playerX,
        playerY: saveState.playerY,
        exitX: saveState.exitX,
        exitY: saveState.exitY,
        visited: new Set(saveState.visited),
        isVictory: false,
        currentMinion: initialMinion,
        isPaused: false,
        pendingEncounter: null,
        exitEncounterDone: saveState.exitEncounterDone,
        pendingConfirmation: null,
        pendingChest: null,
        inventory: {
            key: 0, stealth: 0, strike: 0, execute: 0,
            floorKey: 0, portalStone: 0, minionBane: 0, mapFragment: 0, timeShard: 0, voidWalk: 0,
            // v1.3.0 HP items
            healingPotion: 0, greaterHealing: 0, elixir: 0, revivalCharm: 0, heartCrystal: 0,
            ...saveState.inventory  // Overlay saved values
        },
        shownMilestones: new Set(saveState.shownMilestones || []),
        // v1.2.0: Multi-floor state
        currentFloor: currentFloor,
        totalFloors: totalFloors,
        floors: floors,
        voidWalkActive: false,
        // v1.2.1: Persistent message log
        messageLog: saveState.messageLog || [],
        // v1.3.0: HP System
        hpEnabled: saveState.hpEnabled ?? (profile.hpEnabled !== false),
        hp: saveState.hp ? {
            current: saveState.hp.current ?? initHP(profile).current,
            max: saveState.hp.max ?? initHP(profile).max,
            maxBonus: saveState.hp.maxBonus ?? 0,
            reviveCharges: saveState.hp.reviveCharges ?? 0,
        } : initHP(profile),
        restCooldown: saveState.restCooldown || 0,
        // v1.4.6: Session Notes
        sessionNotes: saveState.sessionNotes || '',
        // v1.4.7: Fairness System
        fairness: saveState.fairness || {
            chestsWithoutKey: 0,
            combatLossStreak: 0,
            chestsWithoutHealing: 0,
            lockedChestsSkipped: 0,
            lastHealingFoundFloor: 0,
        },
        // v1.4.8: LLM Enhanced Room Descriptions
        enhancedRooms: saveState.enhancedRooms || {},
    };

    // Sanity check: ensure current HP doesn't exceed max
    if (currentMaze.hp) {
        const maxTotal = currentMaze.hp.max + (currentMaze.hp.maxBonus || 0);
        if (currentMaze.hp.current > maxTotal) {
            console.log(`[MazeMaster] Clamping HP from ${currentMaze.hp.current} to ${maxTotal}`);
            currentMaze.hp.current = maxTotal;
        }
    }

    showMazeModal();
    renderMazeGrid();
    updatePlayerPosition(false); // Set initial position without animation
    renderMessageLog();  // Render saved messages first
    updateMazeHero();
    updateInventoryDisplay();
    updateHPDisplay();  // v1.3.0: Restore HP display
    updateRestButton(); // v1.3.0: Restore rest button state

    // v1.2.0: Update floor UI
    updateFloorIndicator();
    updateDpadFloorButtons();

    document.addEventListener('keydown', handleMazeKeydown, { capture: true });

    console.log(`[MazeMaster] Loaded saved maze "${profileName}" (floor ${currentFloor + 1}/${totalFloors})`);
    return true;
}

/**
 * Delete saved maze
 */
function deleteSavedMaze(profileName) {
    if (extensionSettings.savedMazes?.[profileName]) {
        delete extensionSettings.savedMazes[profileName];
        saveSettingsDebounced();
        console.log(`[MazeMaster] Deleted saved maze "${profileName}"`);
        return true;
    }
    return false;
}

/**
 * Get list of saved maze profile names
 */
function getSavedMazeNames() {
    return Object.keys(extensionSettings.savedMazes || {});
}

/**
 * Render the saved games list in the config panel and game tab
 */
function renderSavedGamesList() {
    // Render to both config panel and game tab
    const listIds = ['mazemaster_saved_games_list', 'mazemaster_game_tab_saves'];

    const savedNames = getSavedMazeNames();

    for (const listId of listIds) {
        const list = document.getElementById(listId);
        if (!list) continue;

        if (savedNames.length === 0) {
            list.innerHTML = '<div class="mazemaster-no-saves">No saved games</div>';
            continue;
        }

        list.innerHTML = savedNames.map(name => {
            const save = extensionSettings.savedMazes[name];
            const date = new Date(save.timestamp);
            const progress = save.visited ? Math.round((save.visited.length / (save.size * save.size)) * 100) : 0;

            return `
                <div class="mazemaster-saved-game" data-profile="${escapeHtml(name)}">
                    <div class="mazemaster-saved-game-info">
                        <div class="mazemaster-saved-game-name">${escapeHtml(name)}</div>
                        <div class="mazemaster-saved-game-details">${progress}% explored - ${date.toLocaleDateString()}</div>
                    </div>
                    <div class="mazemaster-saved-game-actions">
                        <button class="menu_button menu_button_icon saved-game-load" title="Resume">
                            <i class="fa-solid fa-play"></i>
                        </button>
                        <button class="menu_button menu_button_icon saved-game-delete" title="Delete">
                            <i class="fa-solid fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        }).join('');

        // Attach handlers
        list.querySelectorAll('.mazemaster-saved-game').forEach(item => {
            const profileName = item.dataset.profile;

            item.querySelector('.saved-game-load')?.addEventListener('click', () => {
                loadMazeProgress(profileName);
            });

            item.querySelector('.saved-game-delete')?.addEventListener('click', async () => {
                const confirmed = await callGenericPopup(`Delete saved game "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteSavedMaze(profileName);
                    renderSavedGamesList();
                }
            });
        });
    }
}

/**
 * Populate the LLM preset dropdown with available presets
 */
function populateLLMPresetDropdown() {
    const dropdown = document.getElementById('mazemaster_llm_preset');
    if (!dropdown) return;

    // Clear existing options except the first "(Use Current)" option
    dropdown.innerHTML = '<option value="">(Use Current)</option>';

    // Try to get presets from the preset manager
    try {
        if (typeof getPresetManager === 'function') {
            const presetManager = getPresetManager();
            if (presetManager && typeof presetManager.getAllPresets === 'function') {
                const presets = presetManager.getAllPresets();
                presets.forEach(preset => {
                    const option = document.createElement('option');
                    option.value = preset;
                    option.textContent = preset;
                    if (preset === extensionSettings.llmPreset) {
                        option.selected = true;
                    }
                    dropdown.appendChild(option);
                });
                console.log(`[MazeMaster] Populated LLM preset dropdown with ${presets.length} presets`);
            }
        }
    } catch (error) {
        console.warn('[MazeMaster] Could not populate LLM presets:', error);
    }
}

/**
 * Show Story Milestones modal for configuring maze story
 */
async function showStoryMilestonesModal() {
    const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
    if (!profileName) {
        alert('Please create a maze profile first');
        return;
    }

    const profile = getMazeProfile(profileName) || {};
    const storyConfig = profile.storyConfig || { mainStory: '', milestones: [] };

    // Create modal HTML
    const modalHtml = `
        <div id="mazemaster_story_modal" class="mazemaster-story-modal">
            <div class="mazemaster-story-modal-content">
                <h3><i class="fa-solid fa-book"></i> Story Milestones</h3>

                <div class="mazemaster-section">
                    <label class="mazemaster-label">Main Story</label>
                    <textarea id="story_main_text" class="mazemaster-story-textarea" rows="4"
                        placeholder="The maze stretches before you, filled with danger and mystery...">${escapeHtml(storyConfig.mainStory || '')}</textarea>
                </div>

                <div class="mazemaster-section">
                    <label class="mazemaster-label">Milestones</label>
                    <div id="story_milestones_list" class="mazemaster-milestones-list">
                        <!-- Milestones rendered here -->
                    </div>
                    <button id="story_add_milestone_btn" class="menu_button mazemaster-add-btn">
                        <i class="fa-solid fa-plus"></i> Add Milestone
                    </button>
                </div>

                <div class="mazemaster-story-modal-buttons">
                    <button id="story_save_btn" class="menu_button menu_button_primary">
                        <i class="fa-solid fa-save"></i> Save
                    </button>
                    <button id="story_cancel_btn" class="menu_button">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;

    // Add modal to body
    const modalWrapper = document.createElement('div');
    modalWrapper.innerHTML = modalHtml;
    document.body.appendChild(modalWrapper.firstElementChild);

    const modal = document.getElementById('mazemaster_story_modal');
    const milestonesList = document.getElementById('story_milestones_list');

    // Render milestones
    function renderMilestones() {
        if (storyConfig.milestones.length === 0) {
            milestonesList.innerHTML = '<div class="mazemaster-empty-state">No milestones. Add milestones to show story updates at specific progress points.</div>';
            return;
        }

        milestonesList.innerHTML = storyConfig.milestones.map((m, index) => `
            <div class="mazemaster-milestone-row" data-index="${index}">
                <div class="milestone-percent">
                    <input type="number" class="milestone-percent-input" min="1" max="99" value="${m.percent || 25}" placeholder="%">
                    <span>%</span>
                </div>
                <textarea class="milestone-text-input" rows="2" placeholder="Story update at this point...">${escapeHtml(m.storyUpdate || '')}</textarea>
                <button class="menu_button menu_button_icon milestone-remove-btn" title="Remove">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
        `).join('');

        // Add remove handlers
        milestonesList.querySelectorAll('.milestone-remove-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const row = e.target.closest('.mazemaster-milestone-row');
                const index = parseInt(row.dataset.index);
                storyConfig.milestones.splice(index, 1);
                renderMilestones();
            });
        });
    }

    renderMilestones();

    // Add milestone button
    document.getElementById('story_add_milestone_btn')?.addEventListener('click', () => {
        storyConfig.milestones.push({ percent: 50, storyUpdate: '' });
        renderMilestones();
    });

    // Save button
    document.getElementById('story_save_btn')?.addEventListener('click', () => {
        // Collect data from modal
        storyConfig.mainStory = document.getElementById('story_main_text')?.value || '';

        // Collect milestones from inputs
        const milestoneRows = milestonesList.querySelectorAll('.mazemaster-milestone-row');
        storyConfig.milestones = [];
        milestoneRows.forEach(row => {
            const percent = parseInt(row.querySelector('.milestone-percent-input')?.value) || 25;
            const storyUpdate = row.querySelector('.milestone-text-input')?.value || '';
            if (storyUpdate.trim()) {
                storyConfig.milestones.push({ percent, storyUpdate });
            }
        });

        // Sort by percent
        storyConfig.milestones.sort((a, b) => a.percent - b.percent);

        // Save to profile
        profile.storyConfig = storyConfig;
        saveMazeProfile(profileName, profile);

        // Close modal
        modal.remove();
        alert('Story milestones saved!');
    });

    // Cancel button
    document.getElementById('story_cancel_btn')?.addEventListener('click', () => {
        modal.remove();
    });

    // Close on background click
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });
}

function setupEventHandlers() {
    // Profile select change
    const profileSelect = document.getElementById('mazemaster_profile_select');
    if (profileSelect) {
        profileSelect.addEventListener('change', (e) => {
            extensionSettings.currentProfile = e.target.value;
            saveSettingsDebounced();
            updateProfileSettings();
            renderSegmentsList();
        });
    }

    // New profile button
    const newProfileBtn = document.getElementById('mazemaster_new_profile_btn');
    if (newProfileBtn) {
        newProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new wheel profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.profiles[trimmed]) {
                    extensionSettings.profiles[trimmed] = { segments: [], randomize: false, difficulty: 1 };
                    extensionSettings.currentProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                } else {
                    await callGenericPopup(`Profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Delete profile button
    const deleteProfileBtn = document.getElementById('mazemaster_delete_profile_btn');
    if (deleteProfileBtn) {
        deleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete wheel profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteProfile(profileName);
                    refreshPanel();
                }
            }
        });
    }

    // Rename profile button
    const renameProfileBtn = document.getElementById('mazemaster_rename_profile_btn');
    if (renameProfileBtn) {
        renameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.profiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.profiles[trimmed] = extensionSettings.profiles[oldName];
                delete extensionSettings.profiles[oldName];
                extensionSettings.currentProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
            }
        });
    }

    // Export profile button
    const exportBtn = document.getElementById('mazemaster_export_btn');
    if (exportBtn) {
        exportBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_profile_select')?.value;
            if (!profileName) {
                alert('No profile selected to export');
                return;
            }
            exportProfile(profileName);
        });
    }

    // Import profile button
    const importBtn = document.getElementById('mazemaster_import_btn');
    const importFile = document.getElementById('mazemaster_import_file');
    if (importBtn && importFile) {
        importBtn.addEventListener('click', () => {
            importFile.click();
        });

        importFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            try {
                const profileName = await importProfile(file);
                alert(`Profile "${profileName}" imported successfully!`);
                refreshPanel();
            } catch (err) {
                alert(`Import failed: ${err.message}`);
            }

            // Reset file input
            importFile.value = '';
        });
    }

    // Add segment button
    const addSegmentBtn = document.getElementById('mazemaster_add_segment_btn');
    if (addSegmentBtn) {
        addSegmentBtn.addEventListener('click', () => {
            const list = document.getElementById('mazemaster_segments_list');
            if (!list) return;

            const emptyState = list.querySelector('.mazemaster-empty-state');
            if (emptyState) emptyState.remove();

            const index = list.querySelectorAll('.mazemaster-segment-item').length;
            const newItem = document.createElement('div');
            newItem.className = 'mazemaster-segment-item';
            newItem.dataset.index = index;
            newItem.innerHTML = `
                <div class="mazemaster-segment-row">
                    <div class="mazemaster-segment-field small">
                        <label>Trigger</label>
                        <input type="text" class="seg-trigger" value="com${index + 1}" placeholder="com1">
                    </div>
                    <div class="mazemaster-segment-field">
                        <label>Display Text</label>
                        <input type="text" class="seg-text" value="" placeholder="Prize name">
                    </div>
                    <div class="mazemaster-segment-field small">
                        <label>Size</label>
                        <select class="seg-size">
                            ${SIZE_OPTIONS.map(s => `<option value="${s}" ${s === 'fraction' ? 'selected' : ''}>${s}</option>`).join('')}
                        </select>
                    </div>
                    <button class="menu_button menu_button_icon mazemaster-segment-delete" title="Delete">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
                <div class="mazemaster-segment-row">
                    <div class="mazemaster-segment-field">
                        <label>STScript Command</label>
                        <textarea class="seg-command" placeholder="/echo You won!"></textarea>
                    </div>
                    <div class="mazemaster-segment-field tiny">
                        <label>&nbsp;</label>
                        <label class="mazemaster-segment-checkbox">
                            <input type="checkbox" class="seg-respin">
                            Respin
                        </label>
                    </div>
                </div>
            `;

            newItem.querySelector('.mazemaster-segment-delete').addEventListener('click', () => {
                newItem.remove();
            });

            list.appendChild(newItem);
        });
    }

    // Save button
    const saveBtn = document.getElementById('mazemaster_save_btn');
    if (saveBtn) {
        saveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_profile_select')?.value;
            if (!profileName) {
                alert('Please create a profile first');
                return;
            }

            const segments = collectSegmentsFromUI();
            const randomize = document.getElementById('mazemaster_randomize')?.checked || false;
            const difficulty = parseInt(document.getElementById('mazemaster_difficulty')?.value) || 1;

            // Validate wheel balance
            if (segments.length === 0) {
                alert('Error: Wheel must have at least one segment');
                return;
            }

            const halfCount = segments.filter(s => s.size === 'halfseg').length;
            const doubleCount = segments.filter(s => s.size === 'doubleseg').length;
            if (halfCount !== doubleCount) {
                alert(`Error: Wheel unbalanced!\n\n${halfCount} halfseg(s)  ${doubleCount} doubleseg(s)\n\nFor every halfseg, you need a doubleseg to balance the wheel.`);
                return;
            }

            saveProfile(profileName, segments, randomize, difficulty);
            console.log(`[MazeMaster] Saved profile "${profileName}":`, { segments, randomize, difficulty });
            alert(`Profile "${profileName}" saved!`);
        });
    }

    // Preview Wheel button
    const previewWheelBtn = document.getElementById('mazemaster_preview_wheel_btn');
    if (previewWheelBtn) {
        previewWheelBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_profile_select')?.value;
            if (!profileName) {
                alert('Please select or create a wheel profile first');
                return;
            }

            // Load the profile and show the wheel
            const result = loadWheelFromProfile(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
                return;
            }

            const validation = validateWheelBalance();
            if (!validation.valid) {
                alert(`Error: ${validation.error}`);
                return;
            }

            showWheelModal();
        });
    }

    // Preview Battlebar button
    const previewBattlebarBtn = document.getElementById('mazemaster_preview_battlebar_btn');
    if (previewBattlebarBtn) {
        previewBattlebarBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
            if (!profileName) {
                alert('Please select or create a battlebar profile first');
                return;
            }

            const result = startBattlebar(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
                return;
            }
        });
    }

    // =========================================================================
    // GAME SELECTOR HANDLERS
    // =========================================================================

    const showWheelBtn = document.getElementById('mazemaster_show_wheel');
    const showCombatBtn = document.getElementById('mazemaster_show_combat');
    const showMazeBtn = document.getElementById('mazemaster_show_maze');
    const showMinionsBtn = document.getElementById('mazemaster_show_minions');
    const showTrapsBtn = document.getElementById('mazemaster_show_traps');
    const wheelConfig = document.getElementById('mazemaster_wheel_config');
    const combatConfig = document.getElementById('mazemaster_combat_config');
    const mazeConfig = document.getElementById('mazemaster_maze_config');
    const minionsConfig = document.getElementById('mazemaster_minions_config');
    const trapsConfig = document.getElementById('mazemaster_traps_config');

    function setActiveGameConfig(configType) {
        // Map 'battlebar' to 'combat' for backward compatibility
        if (configType === 'battlebar') configType = 'combat';

        extensionSettings.activeGameConfig = configType;
        saveSettingsDebounced();

        // Update button states
        showWheelBtn?.classList.toggle('active', configType === 'wheel');
        showCombatBtn?.classList.toggle('active', configType === 'combat');
        showMazeBtn?.classList.toggle('active', configType === 'maze');
        showMinionsBtn?.classList.toggle('active', configType === 'minions');
        showTrapsBtn?.classList.toggle('active', configType === 'traps');

        // Update config visibility
        if (wheelConfig) wheelConfig.style.display = configType === 'wheel' ? 'block' : 'none';
        if (combatConfig) combatConfig.style.display = configType === 'combat' ? 'block' : 'none';
        if (mazeConfig) mazeConfig.style.display = configType === 'maze' ? 'block' : 'none';
        if (minionsConfig) minionsConfig.style.display = configType === 'minions' ? 'block' : 'none';
        if (trapsConfig) trapsConfig.style.display = configType === 'traps' ? 'block' : 'none';

        // Render content if needed
        if (configType === 'combat') renderBattlebarImages();
        if (configType === 'minions') renderMinionsList();
        if (configType === 'traps') renderTrapsList();
    }

    if (showWheelBtn) showWheelBtn.addEventListener('click', () => setActiveGameConfig('wheel'));
    if (showCombatBtn) showCombatBtn.addEventListener('click', () => setActiveGameConfig('combat'));
    if (showMazeBtn) showMazeBtn.addEventListener('click', () => setActiveGameConfig('maze'));
    if (showMinionsBtn) showMinionsBtn.addEventListener('click', () => setActiveGameConfig('minions'));
    if (showTrapsBtn) showTrapsBtn.addEventListener('click', () => setActiveGameConfig('traps'));

    // Combat sub-tab switching
    document.querySelectorAll('.combat-subtab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.combat-subtab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.combat-content').forEach(c => c.classList.remove('active'));
            tab.classList.add('active');
            const target = tab.dataset.combat;
            document.getElementById(`combat_${target}_content`)?.classList.add('active');

            // Render content if switching to battlebar
            if (target === 'battlebar') {
                renderBattlebarImages();
            }
        });
    });

    // TAB HANDLERS
    // =========================================================================
    const tabs = document.querySelectorAll('.mazemaster-tab');
    const tabContents = document.querySelectorAll('.mazemaster-tab-content');

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const targetTab = tab.dataset.tab;

            // Update tab buttons
            tabs.forEach(t => t.classList.toggle('active', t === tab));

            // Update tab content
            tabContents.forEach(content => {
                const isTarget = content.id === `mazemaster-tab-${targetTab}`;
                content.classList.toggle('active', isTarget);
            });
        });
    });

    // PLAY MAZE BUTTON
    // =========================================================================
    const playMazeBtn = document.getElementById('mazemaster_play_maze');
    if (playMazeBtn) {
        playMazeBtn.addEventListener('click', async () => {
            const profileSelect = document.getElementById('mazemaster_play_profile');
            const profileName = profileSelect?.value || extensionSettings.currentMazeProfile || 'default';

            // Close current chat to prevent LLM from absorbing chat context
            try {
                await executeSlashCommandsWithOptions('/closechat');
            } catch (e) {
                // Chat may already be closed or not exist
                console.log('[MazeMaster] No active chat to close');
            }

            startMaze(profileName);
        });
    }

    // LLM PRESET DROPDOWN
    // =========================================================================
    populateLLMPresetDropdown();

    const llmPresetSelect = document.getElementById('mazemaster_llm_preset');
    if (llmPresetSelect) {
        llmPresetSelect.addEventListener('change', (e) => {
            extensionSettings.llmPreset = e.target.value;
            saveSettingsDebounced();
        });
    }

    const llmEnabledCheckbox = document.getElementById('mazemaster_llm_enabled');
    if (llmEnabledCheckbox) {
        llmEnabledCheckbox.addEventListener('change', (e) => {
            extensionSettings.llmEnabled = e.target.checked;
            saveSettingsDebounced();
        });
    }

    const closeChatCheckbox = document.getElementById('mazemaster_close_chat');
    if (closeChatCheckbox) {
        closeChatCheckbox.addEventListener('change', (e) => {
            extensionSettings.closeChatOnStart = e.target.checked;
            saveSettingsDebounced();
        });
    }

    // D-PAD SETTINGS
    // =========================================================================
    const dpadEnabledCheckbox = document.getElementById('mazemaster_dpad_enabled');
    if (dpadEnabledCheckbox) {
        dpadEnabledCheckbox.addEventListener('change', (e) => {
            if (!extensionSettings.dpadConfig) {
                extensionSettings.dpadConfig = { enabled: true, floating: true, position: { x: null, y: null } };
            }
            extensionSettings.dpadConfig.enabled = e.target.checked;
            // Update visibility if D-pad exists
            const dpad = document.getElementById('maze_dpad');
            if (dpad) {
                dpad.style.display = e.target.checked ? '' : 'none';
            }
            saveSettingsDebounced();
        });
    }

    const dpadFloatingCheckbox = document.getElementById('mazemaster_dpad_floating');
    if (dpadFloatingCheckbox) {
        dpadFloatingCheckbox.addEventListener('change', (e) => {
            if (!extensionSettings.dpadConfig) {
                extensionSettings.dpadConfig = { enabled: true, floating: true, position: { x: null, y: null } };
            }
            extensionSettings.dpadConfig.floating = e.target.checked;
            // Update floating class if D-pad exists
            const dpad = document.getElementById('maze_dpad');
            if (dpad) {
                dpad.classList.toggle('floating', e.target.checked);
                if (e.target.checked) {
                    initDpadDrag();
                }
            }
            saveSettingsDebounced();
        });
    }

    const dpadResetBtn = document.getElementById('mazemaster_dpad_reset');
    if (dpadResetBtn) {
        dpadResetBtn.addEventListener('click', () => {
            if (!extensionSettings.dpadConfig) {
                extensionSettings.dpadConfig = { enabled: true, floating: true, position: { x: null, y: null } };
            }
            extensionSettings.dpadConfig.position = { x: null, y: null };
            saveSettingsDebounced();
            // Also reset if D-Pad is currently visible
            const dpad = document.getElementById('maze_dpad');
            if (dpad) {
                dpad.style.left = '';
                dpad.style.top = '';
                dpad.style.right = '20px';
                dpad.style.bottom = '20px';
            }
        });
    }

    // RENDERER SETTINGS
    // =========================================================================
    const rendererSelect = document.getElementById('mazemaster_renderer_type');
    if (rendererSelect) {
        rendererSelect.addEventListener('change', (e) => {
            extensionSettings.rendererType = e.target.value;
            RendererRegistry.getRenderer(e.target.value);  // Switch renderer
            saveSettingsDebounced();
        });
    }

    // LAYOUT MODE SETTINGS
    // =========================================================================
    const layoutSelect = document.getElementById('mazemaster_layout_mode');
    if (layoutSelect) {
        layoutSelect.addEventListener('change', (e) => {
            extensionSettings.layoutMode = e.target.value;
            saveSettingsDebounced();
            applyLayoutMode();  // Apply immediately
        });
    }

    // =========================================================================
    // BATTLEBAR HANDLERS
    // =========================================================================

    // Battlebar profile select
    const bbProfileSelect = document.getElementById('mazemaster_bb_profile_select');
    if (bbProfileSelect) {
        bbProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentBattlebarProfile = e.target.value;
            saveSettingsDebounced();
            updateBattlebarSettings();
            renderBattlebarImages();
        });
    }

    // Battlebar new profile
    const bbNewProfileBtn = document.getElementById('mazemaster_bb_new_profile_btn');
    if (bbNewProfileBtn) {
        bbNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new battlebar profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.battlebarProfiles[trimmed]) {
                    saveBattlebarProfile(trimmed, {});
                    extensionSettings.currentBattlebarProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    // Switch to battlebar view
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                    }, 100);
                } else {
                    await callGenericPopup(`Battlebar profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Battlebar delete profile
    const bbDeleteProfileBtn = document.getElementById('mazemaster_bb_delete_profile_btn');
    if (bbDeleteProfileBtn) {
        bbDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete battlebar profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteBattlebarProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                    }, 100);
                }
            }
        });
    }

    // Battlebar rename profile
    const bbRenameProfileBtn = document.getElementById('mazemaster_bb_rename_profile_btn');
    if (bbRenameProfileBtn) {
        bbRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_bb_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.battlebarProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.battlebarProfiles[trimmed] = extensionSettings.battlebarProfiles[oldName];
                delete extensionSettings.battlebarProfiles[oldName];
                extensionSettings.currentBattlebarProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                }, 100);
            }
        });
    }

    // Battlebar export
    const bbExportBtn = document.getElementById('mazemaster_bb_export_btn');
    if (bbExportBtn) {
        bbExportBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
            if (!profileName) {
                alert('No profile selected to export');
                return;
            }
            exportBattlebarProfile(profileName);
        });
    }

    // Battlebar import
    const bbImportBtn = document.getElementById('mazemaster_bb_import_btn');
    const bbImportFile = document.getElementById('mazemaster_bb_import_file');
    if (bbImportBtn && bbImportFile) {
        bbImportBtn.addEventListener('click', () => {
            bbImportFile.click();
        });

        bbImportFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            try {
                const profileName = await importBattlebarProfile(file);
                alert(`Battlebar profile "${profileName}" imported successfully!`);
                refreshPanel();
                document.getElementById('mazemaster_show_combat')?.click();
            } catch (err) {
                alert(`Import failed: ${err.message}`);
            }

            bbImportFile.value = '';
        });
    }

    // Battlebar save button
    const bbSaveBtn = document.getElementById('mazemaster_bb_save_btn');
    if (bbSaveBtn) {
        bbSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
            if (!profileName) {
                alert('Please create a battlebar profile first');
                return;
            }

            const profileData = collectBattlebarDataFromUI();

            // Validate required fields
            const errors = [];
            if (!profileData.hitsToWin || profileData.hitsToWin < 1) {
                errors.push('Hits to Win must be at least 1');
            }
            if (!profileData.missesToLose || profileData.missesToLose < 1) {
                errors.push('Misses to Lose must be at least 1');
            }
            if (!profileData.difficulty || profileData.difficulty < 1 || profileData.difficulty > 10) {
                errors.push('Difficulty must be between 1 and 10');
            }

            if (errors.length > 0) {
                alert('Validation Error:\n\n' + errors.join('\n'));
                return;
            }

            saveBattlebarProfile(profileName, profileData);
            alert(`Battlebar profile "${profileName}" saved!`);
        });
    }

    // Battlebar difficulty slider - update display value
    const bbDifficultySlider = document.getElementById('mazemaster_bb_difficulty');
    const bbDifficultyVal = document.getElementById('mazemaster_bb_diff_val');
    if (bbDifficultySlider && bbDifficultyVal) {
        bbDifficultySlider.addEventListener('input', (e) => {
            bbDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // Battlebar add image button
    const bbAddImageBtn = document.getElementById('mazemaster_bb_add_image_btn');
    const bbImageFile = document.getElementById('mazemaster_bb_image_file');
    if (bbAddImageBtn && bbImageFile) {
        bbAddImageBtn.addEventListener('click', () => {
            bbImageFile.click();
        });

        bbImageFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            const profileName = document.getElementById('mazemaster_bb_profile_select')?.value;
            if (!profileName) {
                alert('Please create a profile first');
                bbImageFile.value = '';
                return;
            }

            try {
                const imagePath = await uploadBattlebarImage(file, profileName);
                const profile = getBattlebarProfile(profileName) || {};
                const images = profile.images || [];
                images.push({ path: imagePath, name: file.name });
                profile.images = images;
                saveBattlebarProfile(profileName, profile);
                renderBattlebarImages();
            } catch (err) {
                alert(`Image upload failed: ${err.message}`);
            }

            bbImageFile.value = '';
        });
    }

    // =========================================================================
    // TURN-BASED HANDLERS
    // =========================================================================

    // Turn-based profile select
    const tbProfileSelect = document.getElementById('mazemaster_tb_profile_select');
    if (tbProfileSelect) {
        tbProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentTurnbasedProfile = e.target.value;
            saveSettingsDebounced();
            loadTurnbasedProfileIntoUI(e.target.value);
        });
    }

    // Turn-based new profile
    const tbNewProfileBtn = document.getElementById('mazemaster_tb_new_profile_btn');
    if (tbNewProfileBtn) {
        tbNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new Turn-Based profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.turnbasedProfiles[trimmed]) {
                    const template = getTurnbasedProfile('Training Bout') || {};
                    saveTurnbasedProfile(trimmed, { ...template, mainTitle: trimmed });
                    extensionSettings.currentTurnbasedProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="turnbased"]')?.click();
                        }, 50);
                    }, 100);
                } else {
                    await callGenericPopup(`Turn-Based profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Turn-based delete profile
    const tbDeleteProfileBtn = document.getElementById('mazemaster_tb_delete_profile_btn');
    if (tbDeleteProfileBtn) {
        tbDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_tb_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete Turn-Based profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteTurnbasedProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="turnbased"]')?.click();
                        }, 50);
                    }, 100);
                }
            }
        });
    }

    // Turn-based rename profile
    const tbRenameProfileBtn = document.getElementById('mazemaster_tb_rename_profile_btn');
    if (tbRenameProfileBtn) {
        tbRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_tb_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.turnbasedProfiles[trimmed]) {
                    await callGenericPopup(`Profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                    return;
                }
                extensionSettings.turnbasedProfiles[trimmed] = extensionSettings.turnbasedProfiles[oldName];
                delete extensionSettings.turnbasedProfiles[oldName];
                extensionSettings.currentTurnbasedProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                    setTimeout(() => {
                        document.querySelector('[data-combat="turnbased"]')?.click();
                    }, 50);
                }, 100);
            }
        });
    }

    // Turn-based difficulty slider
    const tbDifficultySlider = document.getElementById('mazemaster_tb_difficulty');
    const tbDifficultyVal = document.getElementById('mazemaster_tb_diff_val');
    if (tbDifficultySlider && tbDifficultyVal) {
        tbDifficultySlider.addEventListener('input', (e) => {
            tbDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // Turn-based save button
    const tbSaveBtn = document.getElementById('mazemaster_tb_save_btn');
    if (tbSaveBtn) {
        tbSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_tb_profile_select')?.value;
            if (!profileName) {
                alert('Please create a Turn-Based profile first');
                return;
            }

            const profileData = {
                mainTitle: document.getElementById('mazemaster_tb_main_title')?.value || '',
                enemyName: document.getElementById('mazemaster_tb_enemy_name')?.value || 'Enemy',
                description: document.getElementById('mazemaster_tb_description')?.value || '',
                playerHP: parseInt(document.getElementById('mazemaster_tb_player_hp')?.value) || 100,
                playerAttack: parseInt(document.getElementById('mazemaster_tb_player_attack')?.value) || 15,
                playerDefense: parseInt(document.getElementById('mazemaster_tb_player_defense')?.value) || 5,
                enemyHP: parseInt(document.getElementById('mazemaster_tb_enemy_hp')?.value) || 50,
                enemyAttack: parseInt(document.getElementById('mazemaster_tb_enemy_attack')?.value) || 8,
                enemyDefense: parseInt(document.getElementById('mazemaster_tb_enemy_defense')?.value) || 2,
                turnOrder: document.getElementById('mazemaster_tb_turn_order')?.value || 'player_first',
                fleeChance: parseInt(document.getElementById('mazemaster_tb_flee_chance')?.value) || 50,
                critChance: parseInt(document.getElementById('mazemaster_tb_crit_chance')?.value) || 15,
                critMultiplier: parseFloat(document.getElementById('mazemaster_tb_crit_mult')?.value) || 1.5,
                difficulty: parseInt(document.getElementById('mazemaster_tb_difficulty')?.value) || 5,
                damage: parseInt(document.getElementById('mazemaster_tb_damage')?.value) || 15,
                onWin: document.getElementById('mazemaster_tb_on_win')?.value || '',
                onLose: document.getElementById('mazemaster_tb_on_lose')?.value || '',
                keyDropChance: parseInt(document.getElementById('mazemaster_tb_key_drop')?.value) || 30,
                strikeDropChance: parseInt(document.getElementById('mazemaster_tb_strike_drop')?.value) || 15,
                stealthDropChance: parseInt(document.getElementById('mazemaster_tb_stealth_drop')?.value) || 10,
                healingPotionDropChance: parseInt(document.getElementById('mazemaster_tb_potion_drop')?.value) || 25,
            };

            saveTurnbasedProfile(profileName, profileData);
            alert(`Turn-Based profile "${profileName}" saved!`);
        });
    }

    // Helper to load turn-based profile data into UI
    function loadTurnbasedProfileIntoUI(profileName) {
        const profile = getTurnbasedProfile(profileName) || {};
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        setVal('mazemaster_tb_main_title', profile.mainTitle);
        setVal('mazemaster_tb_enemy_name', profile.enemyName);
        setVal('mazemaster_tb_description', profile.description);
        setVal('mazemaster_tb_player_hp', profile.playerHP || 100);
        setVal('mazemaster_tb_player_attack', profile.playerAttack || 15);
        setVal('mazemaster_tb_player_defense', profile.playerDefense || 5);
        setVal('mazemaster_tb_enemy_hp', profile.enemyHP || 50);
        setVal('mazemaster_tb_enemy_attack', profile.enemyAttack || 8);
        setVal('mazemaster_tb_enemy_defense', profile.enemyDefense || 2);
        setVal('mazemaster_tb_turn_order', profile.turnOrder || 'player_first');
        setVal('mazemaster_tb_flee_chance', profile.fleeChance || 50);
        setVal('mazemaster_tb_crit_chance', profile.critChance || 15);
        setVal('mazemaster_tb_crit_mult', profile.critMultiplier || 1.5);
        setVal('mazemaster_tb_difficulty', profile.difficulty || 5);
        setVal('mazemaster_tb_damage', profile.damage || 15);
        setVal('mazemaster_tb_on_win', profile.onWin);
        setVal('mazemaster_tb_on_lose', profile.onLose);
        setVal('mazemaster_tb_key_drop', profile.keyDropChance || 30);
        setVal('mazemaster_tb_strike_drop', profile.strikeDropChance || 15);
        setVal('mazemaster_tb_stealth_drop', profile.stealthDropChance || 10);
        setVal('mazemaster_tb_potion_drop', profile.healingPotionDropChance || 25);
        // Update difficulty display
        const diffVal = document.getElementById('mazemaster_tb_diff_val');
        if (diffVal) diffVal.textContent = `(${profile.difficulty || 5})`;
    }

    // Load initial turn-based profile
    if (extensionSettings.currentTurnbasedProfile) {
        loadTurnbasedProfileIntoUI(extensionSettings.currentTurnbasedProfile);
    }

    // =========================================================================
    // QTE HANDLERS
    // =========================================================================

    // QTE profile select
    const qteProfileSelect = document.getElementById('mazemaster_qte_profile_select');
    if (qteProfileSelect) {
        qteProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentQteProfile = e.target.value;
            saveSettingsDebounced();
            loadQteProfileIntoUI(e.target.value);
        });
    }

    // QTE new profile
    const qteNewProfileBtn = document.getElementById('mazemaster_qte_new_profile_btn');
    if (qteNewProfileBtn) {
        qteNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new QTE profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.qteProfiles[trimmed]) {
                    // Create with defaults from 'Reaction Test'
                    const template = getQteProfile('Reaction Test') || {};
                    saveQteProfile(trimmed, { ...template, mainTitle: trimmed });
                    extensionSettings.currentQteProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="qte"]')?.click();
                        }, 50);
                    }, 100);
                } else {
                    await callGenericPopup(`QTE profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // QTE delete profile
    const qteDeleteProfileBtn = document.getElementById('mazemaster_qte_delete_profile_btn');
    if (qteDeleteProfileBtn) {
        qteDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_qte_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete QTE profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteQteProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="qte"]')?.click();
                        }, 50);
                    }, 100);
                }
            }
        });
    }

    // QTE rename profile
    const qteRenameProfileBtn = document.getElementById('mazemaster_qte_rename_profile_btn');
    if (qteRenameProfileBtn) {
        qteRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_qte_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.qteProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.qteProfiles[trimmed] = extensionSettings.qteProfiles[oldName];
                extensionSettings.qteProfiles[trimmed].mainTitle = trimmed;
                delete extensionSettings.qteProfiles[oldName];
                extensionSettings.currentQteProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                    setTimeout(() => {
                        document.querySelector('[data-combat="qte"]')?.click();
                    }, 50);
                }, 100);
            }
        });
    }

    // QTE preview button
    const qtePreviewBtn = document.getElementById('mazemaster_preview_qte_btn');
    if (qtePreviewBtn) {
        qtePreviewBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_qte_profile_select')?.value;
            if (!profileName) {
                alert('Please select a QTE profile first');
                return;
            }
            const result = startQTE(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
            }
        });
    }

    // QTE difficulty slider
    const qteDifficultySlider = document.getElementById('mazemaster_qte_difficulty');
    const qteDifficultyVal = document.getElementById('mazemaster_qte_diff_val');
    if (qteDifficultySlider && qteDifficultyVal) {
        qteDifficultySlider.addEventListener('input', (e) => {
            qteDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // QTE save button
    const qteSaveBtn = document.getElementById('mazemaster_qte_save_btn');
    if (qteSaveBtn) {
        qteSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_qte_profile_select')?.value;
            if (!profileName) {
                alert('Please create a QTE profile first');
                return;
            }

            const allowedKeys = [];
            if (document.getElementById('mazemaster_qte_key_w')?.checked) allowedKeys.push('W');
            if (document.getElementById('mazemaster_qte_key_a')?.checked) allowedKeys.push('A');
            if (document.getElementById('mazemaster_qte_key_s')?.checked) allowedKeys.push('S');
            if (document.getElementById('mazemaster_qte_key_d')?.checked) allowedKeys.push('D');
            if (document.getElementById('mazemaster_qte_key_space')?.checked) allowedKeys.push('SPACE');

            const profileData = {
                mainTitle: document.getElementById('mazemaster_qte_main_title')?.value || '',
                description: document.getElementById('mazemaster_qte_description')?.value || '',
                sequenceLengthMin: parseInt(document.getElementById('mazemaster_qte_seq_min')?.value) || 3,
                sequenceLengthMax: parseInt(document.getElementById('mazemaster_qte_seq_max')?.value) || 5,
                timeWindowBase: parseInt(document.getElementById('mazemaster_qte_time_base')?.value) || 1500,
                timeWindowMin: parseInt(document.getElementById('mazemaster_qte_time_min')?.value) || 800,
                difficulty: parseInt(document.getElementById('mazemaster_qte_difficulty')?.value) || 5,
                damage: parseInt(document.getElementById('mazemaster_qte_damage')?.value) || 10,
                perfectWindowPercent: parseInt(document.getElementById('mazemaster_qte_perfect')?.value) || 30,
                allowedKeys: allowedKeys,
                onComplete: document.getElementById('mazemaster_qte_on_complete')?.value || '',
                onFail: document.getElementById('mazemaster_qte_on_fail')?.value || '',
            };

            saveQteProfile(profileName, profileData);
            alert(`QTE profile "${profileName}" saved!`);
        });
    }

    // Helper to load QTE profile data into UI
    function loadQteProfileIntoUI(profileName) {
        const profile = getQteProfile(profileName) || {};
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        const setCheck = (id, val) => { const el = document.getElementById(id); if (el) el.checked = val; };
        setVal('mazemaster_qte_main_title', profile.mainTitle);
        setVal('mazemaster_qte_description', profile.description);
        setVal('mazemaster_qte_seq_min', profile.sequenceLengthMin || 3);
        setVal('mazemaster_qte_seq_max', profile.sequenceLengthMax || 5);
        setVal('mazemaster_qte_time_base', profile.timeWindowBase || 1500);
        setVal('mazemaster_qte_time_min', profile.timeWindowMin || 800);
        setVal('mazemaster_qte_difficulty', profile.difficulty || 5);
        setVal('mazemaster_qte_damage', profile.damage || 10);
        setVal('mazemaster_qte_perfect', profile.perfectWindowPercent || 30);
        setVal('mazemaster_qte_on_complete', profile.onComplete);
        setVal('mazemaster_qte_on_fail', profile.onFail);
        // Allowed keys checkboxes
        const keys = profile.allowedKeys || ['W', 'A', 'S', 'D', 'SPACE'];
        setCheck('mazemaster_qte_key_w', keys.includes('W'));
        setCheck('mazemaster_qte_key_a', keys.includes('A'));
        setCheck('mazemaster_qte_key_s', keys.includes('S'));
        setCheck('mazemaster_qte_key_d', keys.includes('D'));
        setCheck('mazemaster_qte_key_space', keys.includes('SPACE'));
        // Update difficulty display
        const diffVal = document.getElementById('mazemaster_qte_diff_val');
        if (diffVal) diffVal.textContent = `(${profile.difficulty || 5})`;
    }

    // Load initial QTE profile
    if (extensionSettings.currentQteProfile) {
        loadQteProfileIntoUI(extensionSettings.currentQteProfile);
    }

    // =========================================================================
    // DICE HANDLERS
    // =========================================================================

    // Dice profile select
    const diceProfileSelect = document.getElementById('mazemaster_dice_profile_select');
    if (diceProfileSelect) {
        diceProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentDiceProfile = e.target.value;
            saveSettingsDebounced();
            loadDiceProfileIntoUI(e.target.value);
        });
    }

    // Dice new profile
    const diceNewProfileBtn = document.getElementById('mazemaster_dice_new_profile_btn');
    if (diceNewProfileBtn) {
        diceNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new Dice profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.diceProfiles[trimmed]) {
                    // Create with defaults from 'Lucky Roll'
                    const template = getDiceProfile('Lucky Roll') || {};
                    saveDiceProfile(trimmed, { ...template, mainTitle: trimmed });
                    extensionSettings.currentDiceProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="dice"]')?.click();
                        }, 50);
                    }, 100);
                } else {
                    await callGenericPopup(`Dice profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Dice delete profile
    const diceDeleteProfileBtn = document.getElementById('mazemaster_dice_delete_profile_btn');
    if (diceDeleteProfileBtn) {
        diceDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_dice_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete Dice profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteDiceProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="dice"]')?.click();
                        }, 50);
                    }, 100);
                }
            }
        });
    }

    // Dice rename profile
    const diceRenameProfileBtn = document.getElementById('mazemaster_dice_rename_profile_btn');
    if (diceRenameProfileBtn) {
        diceRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_dice_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.diceProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.diceProfiles[trimmed] = extensionSettings.diceProfiles[oldName];
                extensionSettings.diceProfiles[trimmed].mainTitle = trimmed;
                delete extensionSettings.diceProfiles[oldName];
                extensionSettings.currentDiceProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                    setTimeout(() => {
                        document.querySelector('[data-combat="dice"]')?.click();
                    }, 50);
                }, 100);
            }
        });
    }

    // Dice preview button
    const dicePreviewBtn = document.getElementById('mazemaster_preview_dice_btn');
    if (dicePreviewBtn) {
        dicePreviewBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_dice_profile_select')?.value;
            if (!profileName) {
                alert('Please select a Dice profile first');
                return;
            }
            const result = startDice(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
            }
        });
    }

    // Dice difficulty slider
    const diceDifficultySlider = document.getElementById('mazemaster_dice_difficulty');
    const diceDifficultyVal = document.getElementById('mazemaster_dice_diff_val');
    if (diceDifficultySlider && diceDifficultyVal) {
        diceDifficultySlider.addEventListener('input', (e) => {
            diceDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // Dice save button
    const diceSaveBtn = document.getElementById('mazemaster_dice_save_btn');
    if (diceSaveBtn) {
        diceSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_dice_profile_select')?.value;
            if (!profileName) {
                alert('Please create a Dice profile first');
                return;
            }

            const profileData = {
                mainTitle: document.getElementById('mazemaster_dice_main_title')?.value || '',
                description: document.getElementById('mazemaster_dice_description')?.value || '',
                diceCount: parseInt(document.getElementById('mazemaster_dice_count')?.value) || 2,
                diceType: parseInt(document.getElementById('mazemaster_dice_type')?.value) || 6,
                targetNumber: parseInt(document.getElementById('mazemaster_dice_target')?.value) || 7,
                modifier: parseInt(document.getElementById('mazemaster_dice_modifier')?.value) || 0,
                difficulty: parseInt(document.getElementById('mazemaster_dice_difficulty')?.value) || 5,
                damage: parseInt(document.getElementById('mazemaster_dice_damage')?.value) || 15,
                rerolls: parseInt(document.getElementById('mazemaster_dice_rerolls')?.value) || 1,
                onSuccess: document.getElementById('mazemaster_dice_on_success')?.value || '',
                onFail: document.getElementById('mazemaster_dice_on_fail')?.value || '',
                onCritical: document.getElementById('mazemaster_dice_on_crit')?.value || '',
            };

            saveDiceProfile(profileName, profileData);
            alert(`Dice profile "${profileName}" saved!`);
        });
    }

    // Helper to load Dice profile data into UI
    function loadDiceProfileIntoUI(profileName) {
        const profile = getDiceProfile(profileName) || {};
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        setVal('mazemaster_dice_main_title', profile.mainTitle);
        setVal('mazemaster_dice_description', profile.description);
        setVal('mazemaster_dice_count', profile.diceCount || 2);
        setVal('mazemaster_dice_type', profile.diceType || 6);
        setVal('mazemaster_dice_target', profile.targetNumber || 7);
        setVal('mazemaster_dice_modifier', profile.modifier || 0);
        setVal('mazemaster_dice_difficulty', profile.difficulty || 5);
        setVal('mazemaster_dice_damage', profile.damage || 15);
        setVal('mazemaster_dice_rerolls', profile.rerolls || 1);
        setVal('mazemaster_dice_on_success', profile.onSuccess);
        setVal('mazemaster_dice_on_fail', profile.onFail);
        setVal('mazemaster_dice_on_crit', profile.onCritical);
        // Update difficulty display
        const diffVal = document.getElementById('mazemaster_dice_diff_val');
        if (diffVal) diffVal.textContent = `(${profile.difficulty || 5})`;
    }

    // Load initial Dice profile
    if (extensionSettings.currentDiceProfile) {
        loadDiceProfileIntoUI(extensionSettings.currentDiceProfile);
    }

    // =========================================================================
    // STEALTH HANDLERS
    // =========================================================================

    // Stealth profile select
    const stealthProfileSelect = document.getElementById('mazemaster_stealth_profile_select');
    if (stealthProfileSelect) {
        stealthProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentStealthProfile = e.target.value;
            saveSettingsDebounced();
            loadStealthProfileIntoUI(e.target.value);
        });
    }

    // Stealth new profile
    const stealthNewProfileBtn = document.getElementById('mazemaster_stealth_new_profile_btn');
    if (stealthNewProfileBtn) {
        stealthNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new Stealth profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.stealthProfiles[trimmed]) {
                    // Create with defaults from 'Simple Sneak'
                    const template = getStealthProfile('Simple Sneak') || {};
                    saveStealthProfile(trimmed, { ...template, mainTitle: trimmed });
                    extensionSettings.currentStealthProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="stealth"]')?.click();
                        }, 50);
                    }, 100);
                } else {
                    await callGenericPopup(`Stealth profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Stealth delete profile
    const stealthDeleteProfileBtn = document.getElementById('mazemaster_stealth_delete_profile_btn');
    if (stealthDeleteProfileBtn) {
        stealthDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_stealth_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete Stealth profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteStealthProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="stealth"]')?.click();
                        }, 50);
                    }, 100);
                }
            }
        });
    }

    // Stealth rename profile
    const stealthRenameProfileBtn = document.getElementById('mazemaster_stealth_rename_profile_btn');
    if (stealthRenameProfileBtn) {
        stealthRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_stealth_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.stealthProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.stealthProfiles[trimmed] = extensionSettings.stealthProfiles[oldName];
                extensionSettings.stealthProfiles[trimmed].mainTitle = trimmed;
                delete extensionSettings.stealthProfiles[oldName];
                extensionSettings.currentStealthProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                    setTimeout(() => {
                        document.querySelector('[data-combat="stealth"]')?.click();
                    }, 50);
                }, 100);
            }
        });
    }

    // Stealth preview button
    const stealthPreviewBtn = document.getElementById('mazemaster_preview_stealth_btn');
    if (stealthPreviewBtn) {
        stealthPreviewBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_stealth_profile_select')?.value;
            if (!profileName) {
                alert('Please select a Stealth profile first');
                return;
            }
            const result = startStealth(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
            }
        });
    }

    // Stealth difficulty slider
    const stealthDifficultySlider = document.getElementById('mazemaster_stealth_difficulty');
    const stealthDifficultyVal = document.getElementById('mazemaster_stealth_diff_val');
    if (stealthDifficultySlider && stealthDifficultyVal) {
        stealthDifficultySlider.addEventListener('input', (e) => {
            stealthDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // Stealth save button
    const stealthSaveBtn = document.getElementById('mazemaster_stealth_save_btn');
    if (stealthSaveBtn) {
        stealthSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_stealth_profile_select')?.value;
            if (!profileName) {
                alert('Please create a Stealth profile first');
                return;
            }

            const profileData = {
                mainTitle: document.getElementById('mazemaster_stealth_main_title')?.value || '',
                guardName: document.getElementById('mazemaster_stealth_guard_name')?.value || 'Guard',
                description: document.getElementById('mazemaster_stealth_description')?.value || '',
                sections: parseInt(document.getElementById('mazemaster_stealth_sections')?.value) || 3,
                detectionLimit: parseInt(document.getElementById('mazemaster_stealth_detection_limit')?.value) || 100,
                baseDetection: parseInt(document.getElementById('mazemaster_stealth_base_detection')?.value) || 15,
                damage: parseInt(document.getElementById('mazemaster_stealth_damage')?.value) || 20,
                difficulty: parseInt(document.getElementById('mazemaster_stealth_difficulty')?.value) || 5,
                hideReduction: parseInt(document.getElementById('mazemaster_stealth_hide_reduce')?.value) || 10,
                distractMax: parseInt(document.getElementById('mazemaster_stealth_distract_max')?.value) || 25,
                onSuccess: document.getElementById('mazemaster_stealth_on_success')?.value || '',
                onCaught: document.getElementById('mazemaster_stealth_on_caught')?.value || '',
            };

            saveStealthProfile(profileName, profileData);
            alert(`Stealth profile "${profileName}" saved!`);
        });
    }

    // Helper to load Stealth profile data into UI
    function loadStealthProfileIntoUI(profileName) {
        const profile = getStealthProfile(profileName) || {};
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        setVal('mazemaster_stealth_main_title', profile.mainTitle);
        setVal('mazemaster_stealth_guard_name', profile.guardName || 'Guard');
        setVal('mazemaster_stealth_description', profile.description);
        setVal('mazemaster_stealth_sections', profile.sections || 3);
        setVal('mazemaster_stealth_detection_limit', profile.detectionLimit || 100);
        setVal('mazemaster_stealth_base_detection', profile.baseDetection || 15);
        setVal('mazemaster_stealth_damage', profile.damage || 20);
        setVal('mazemaster_stealth_difficulty', profile.difficulty || 5);
        setVal('mazemaster_stealth_hide_reduce', profile.hideReduction || 10);
        setVal('mazemaster_stealth_distract_max', profile.distractMax || 25);
        setVal('mazemaster_stealth_on_success', profile.onSuccess);
        setVal('mazemaster_stealth_on_caught', profile.onCaught);
        // Update difficulty display
        const diffVal = document.getElementById('mazemaster_stealth_diff_val');
        if (diffVal) diffVal.textContent = `(${profile.difficulty || 5})`;
    }

    // Load initial Stealth profile
    if (extensionSettings.currentStealthProfile) {
        loadStealthProfileIntoUI(extensionSettings.currentStealthProfile);
    }

    // =========================================================================
    // PUZZLE HANDLERS
    // =========================================================================

    // Puzzle profile select
    const puzzleProfileSelect = document.getElementById('mazemaster_puzzle_profile_select');
    if (puzzleProfileSelect) {
        puzzleProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentPuzzleProfile = e.target.value;
            saveSettingsDebounced();
            loadPuzzleProfileIntoUI(e.target.value);
        });
    }

    // Puzzle new profile
    const puzzleNewProfileBtn = document.getElementById('mazemaster_puzzle_new_profile_btn');
    if (puzzleNewProfileBtn) {
        puzzleNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new Puzzle profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.puzzleProfiles[trimmed]) {
                    // Create with defaults from 'Simple Riddle'
                    const template = getPuzzleProfile('Simple Riddle') || {};
                    savePuzzleProfile(trimmed, { ...template, mainTitle: trimmed });
                    extensionSettings.currentPuzzleProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="puzzle"]')?.click();
                        }, 50);
                    }, 100);
                } else {
                    await callGenericPopup(`Puzzle profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Puzzle delete profile
    const puzzleDeleteProfileBtn = document.getElementById('mazemaster_puzzle_delete_profile_btn');
    if (puzzleDeleteProfileBtn) {
        puzzleDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_puzzle_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete Puzzle profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deletePuzzleProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="puzzle"]')?.click();
                        }, 50);
                    }, 100);
                }
            }
        });
    }

    // Puzzle rename profile
    const puzzleRenameProfileBtn = document.getElementById('mazemaster_puzzle_rename_profile_btn');
    if (puzzleRenameProfileBtn) {
        puzzleRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_puzzle_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.puzzleProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.puzzleProfiles[trimmed] = extensionSettings.puzzleProfiles[oldName];
                extensionSettings.puzzleProfiles[trimmed].mainTitle = trimmed;
                delete extensionSettings.puzzleProfiles[oldName];
                extensionSettings.currentPuzzleProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                    setTimeout(() => {
                        document.querySelector('[data-combat="puzzle"]')?.click();
                    }, 50);
                }, 100);
            }
        });
    }

    // Puzzle preview button
    const puzzlePreviewBtn = document.getElementById('mazemaster_preview_puzzle_btn');
    if (puzzlePreviewBtn) {
        puzzlePreviewBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_puzzle_profile_select')?.value;
            if (!profileName) {
                alert('Please select a Puzzle profile first');
                return;
            }
            const result = startPuzzle(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
            }
        });
    }

    // Puzzle difficulty slider
    const puzzleDifficultySlider = document.getElementById('mazemaster_puzzle_difficulty');
    const puzzleDifficultyVal = document.getElementById('mazemaster_puzzle_diff_val');
    if (puzzleDifficultySlider && puzzleDifficultyVal) {
        puzzleDifficultySlider.addEventListener('input', (e) => {
            puzzleDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // Puzzle save button
    const puzzleSaveBtn = document.getElementById('mazemaster_puzzle_save_btn');
    if (puzzleSaveBtn) {
        puzzleSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_puzzle_profile_select')?.value;
            if (!profileName) {
                alert('Please create a Puzzle profile first');
                return;
            }

            const profileData = {
                mainTitle: document.getElementById('mazemaster_puzzle_main_title')?.value || '',
                description: document.getElementById('mazemaster_puzzle_description')?.value || '',
                gridSize: parseInt(document.getElementById('mazemaster_puzzle_grid_size')?.value) || 3,
                sequenceLength: parseInt(document.getElementById('mazemaster_puzzle_seq_length')?.value) || 4,
                maxMistakes: parseInt(document.getElementById('mazemaster_puzzle_max_mistakes')?.value) || 5,
                hints: parseInt(document.getElementById('mazemaster_puzzle_hints')?.value) || 3,
                difficulty: parseInt(document.getElementById('mazemaster_puzzle_difficulty')?.value) || 5,
                damage: parseInt(document.getElementById('mazemaster_puzzle_damage')?.value) || 15,
                timeLimit: parseInt(document.getElementById('mazemaster_puzzle_time_limit')?.value) || 60,
                onSolve: document.getElementById('mazemaster_puzzle_on_solve')?.value || '',
                onFail: document.getElementById('mazemaster_puzzle_on_fail')?.value || '',
            };

            savePuzzleProfile(profileName, profileData);
            alert(`Puzzle profile "${profileName}" saved!`);
        });
    }

    // Helper to load Puzzle profile data into UI
    function loadPuzzleProfileIntoUI(profileName) {
        const profile = getPuzzleProfile(profileName) || {};
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        setVal('mazemaster_puzzle_main_title', profile.mainTitle);
        setVal('mazemaster_puzzle_description', profile.description);
        setVal('mazemaster_puzzle_grid_size', profile.gridSize || 3);
        setVal('mazemaster_puzzle_seq_length', profile.sequenceLength || 4);
        setVal('mazemaster_puzzle_max_mistakes', profile.maxMistakes || 5);
        setVal('mazemaster_puzzle_hints', profile.hints || 3);
        setVal('mazemaster_puzzle_difficulty', profile.difficulty || 5);
        setVal('mazemaster_puzzle_damage', profile.damage || 15);
        setVal('mazemaster_puzzle_time_limit', profile.timeLimit || 60);
        setVal('mazemaster_puzzle_on_solve', profile.onSolve);
        setVal('mazemaster_puzzle_on_fail', profile.onFail);
        // Update difficulty display
        const diffVal = document.getElementById('mazemaster_puzzle_diff_val');
        if (diffVal) diffVal.textContent = `(${profile.difficulty || 5})`;
    }

    // Load initial Puzzle profile
    if (extensionSettings.currentPuzzleProfile) {
        loadPuzzleProfileIntoUI(extensionSettings.currentPuzzleProfile);
    }

    // =========================================================================
    // NEGOTIATION HANDLERS
    // =========================================================================

    // Negotiation profile select
    const negotiationProfileSelect = document.getElementById('mazemaster_negotiation_profile_select');
    if (negotiationProfileSelect) {
        negotiationProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentNegotiationProfile = e.target.value;
            saveSettingsDebounced();
            loadNegotiationProfileIntoUI(e.target.value);
        });
    }

    // Negotiation new profile
    const negotiationNewProfileBtn = document.getElementById('mazemaster_negotiation_new_profile_btn');
    if (negotiationNewProfileBtn) {
        negotiationNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new Negotiation profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.negotiationProfiles[trimmed]) {
                    // Create with defaults from 'Friendly Chat'
                    const template = getNegotiationProfile('Friendly Chat') || {};
                    saveNegotiationProfile(trimmed, { ...template, mainTitle: trimmed });
                    extensionSettings.currentNegotiationProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="negotiation"]')?.click();
                        }, 50);
                    }, 100);
                } else {
                    await callGenericPopup(`Negotiation profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Negotiation delete profile
    const negotiationDeleteProfileBtn = document.getElementById('mazemaster_negotiation_delete_profile_btn');
    if (negotiationDeleteProfileBtn) {
        negotiationDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_negotiation_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete Negotiation profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteNegotiationProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_combat')?.click();
                        setTimeout(() => {
                            document.querySelector('[data-combat="negotiation"]')?.click();
                        }, 50);
                    }, 100);
                }
            }
        });
    }

    // Negotiation rename profile
    const negotiationRenameProfileBtn = document.getElementById('mazemaster_negotiation_rename_profile_btn');
    if (negotiationRenameProfileBtn) {
        negotiationRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_negotiation_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.negotiationProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.negotiationProfiles[trimmed] = extensionSettings.negotiationProfiles[oldName];
                extensionSettings.negotiationProfiles[trimmed].mainTitle = trimmed;
                delete extensionSettings.negotiationProfiles[oldName];
                extensionSettings.currentNegotiationProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_combat')?.click();
                    setTimeout(() => {
                        document.querySelector('[data-combat="negotiation"]')?.click();
                    }, 50);
                }, 100);
            }
        });
    }

    // Negotiation preview button
    const negotiationPreviewBtn = document.getElementById('mazemaster_preview_negotiation_btn');
    if (negotiationPreviewBtn) {
        negotiationPreviewBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_negotiation_profile_select')?.value;
            if (!profileName) {
                alert('Please select a Negotiation profile first');
                return;
            }
            const result = startNegotiation(profileName);
            if (result.error) {
                alert(`Error: ${result.error}`);
            }
        });
    }

    // Negotiation difficulty slider
    const negotiateDifficultySlider = document.getElementById('mazemaster_negotiate_difficulty');
    const negotiateDifficultyVal = document.getElementById('mazemaster_negotiate_diff_val');
    if (negotiateDifficultySlider && negotiateDifficultyVal) {
        negotiateDifficultySlider.addEventListener('input', (e) => {
            negotiateDifficultyVal.textContent = `(${e.target.value})`;
        });
    }

    // Negotiation save button
    const negotiateSaveBtn = document.getElementById('mazemaster_negotiate_save_btn');
    if (negotiateSaveBtn) {
        negotiateSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_negotiation_profile_select')?.value;
            if (!profileName) {
                alert('Please create a Negotiation profile first');
                return;
            }

            const profileData = {
                mainTitle: document.getElementById('mazemaster_negotiate_main_title')?.value || '',
                npcName: document.getElementById('mazemaster_negotiate_npc_name')?.value || 'NPC',
                description: document.getElementById('mazemaster_negotiate_description')?.value || '',
                favorTarget: parseInt(document.getElementById('mazemaster_negotiate_favor_target')?.value) || 75,
                startingFavor: parseInt(document.getElementById('mazemaster_negotiate_starting_favor')?.value) || 25,
                maxTurns: parseInt(document.getElementById('mazemaster_negotiate_max_turns')?.value) || 6,
                damage: parseInt(document.getElementById('mazemaster_negotiate_damage')?.value) || 10,
                difficulty: parseInt(document.getElementById('mazemaster_negotiate_difficulty')?.value) || 5,
                persuadeAvg: parseInt(document.getElementById('mazemaster_negotiate_persuade')?.value) || 12,
                flatterAvg: parseInt(document.getElementById('mazemaster_negotiate_flatter')?.value) || 10,
                startingMood: document.getElementById('mazemaster_negotiate_mood')?.value || 'unfriendly',
                intimidateRisk: document.getElementById('mazemaster_negotiate_intimidate')?.value || 'medium',
                bribeCost: document.getElementById('mazemaster_negotiate_bribe_cost')?.value || 'gold',
                onSuccess: document.getElementById('mazemaster_negotiate_on_success')?.value || '',
                onFail: document.getElementById('mazemaster_negotiate_on_fail')?.value || '',
            };

            saveNegotiationProfile(profileName, profileData);
            alert(`Negotiation profile "${profileName}" saved!`);
        });
    }

    // Helper to load Negotiation profile data into UI
    function loadNegotiationProfileIntoUI(profileName) {
        const profile = getNegotiationProfile(profileName) || {};
        const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val ?? ''; };
        setVal('mazemaster_negotiate_main_title', profile.mainTitle);
        setVal('mazemaster_negotiate_npc_name', profile.npcName || 'NPC');
        setVal('mazemaster_negotiate_description', profile.description);
        setVal('mazemaster_negotiate_favor_target', profile.favorTarget || 75);
        setVal('mazemaster_negotiate_starting_favor', profile.startingFavor || 25);
        setVal('mazemaster_negotiate_max_turns', profile.maxTurns || 6);
        setVal('mazemaster_negotiate_damage', profile.damage || 10);
        setVal('mazemaster_negotiate_difficulty', profile.difficulty || 5);
        setVal('mazemaster_negotiate_persuade', profile.persuadeAvg || 12);
        setVal('mazemaster_negotiate_flatter', profile.flatterAvg || 10);
        setVal('mazemaster_negotiate_mood', profile.startingMood || 'unfriendly');
        setVal('mazemaster_negotiate_intimidate', profile.intimidateRisk || 'medium');
        setVal('mazemaster_negotiate_bribe_cost', profile.bribeCost || 'gold');
        setVal('mazemaster_negotiate_on_success', profile.onSuccess);
        setVal('mazemaster_negotiate_on_fail', profile.onFail);
        // Update difficulty display
        const diffVal = document.getElementById('mazemaster_negotiate_diff_val');
        if (diffVal) diffVal.textContent = `(${profile.difficulty || 5})`;
    }

    // Load initial Negotiation profile
    if (extensionSettings.currentNegotiationProfile) {
        loadNegotiationProfileIntoUI(extensionSettings.currentNegotiationProfile);
    }

    // =========================================================================
    // MAZE HANDLERS
    // =========================================================================

    // Maze profile select
    const mazeProfileSelect = document.getElementById('mazemaster_maze_profile_select');
    if (mazeProfileSelect) {
        mazeProfileSelect.addEventListener('change', (e) => {
            extensionSettings.currentMazeProfile = e.target.value;
            saveSettingsDebounced();
            updateMazeSettings();
        });
    }

    // Maze new profile
    const mazeNewProfileBtn = document.getElementById('mazemaster_maze_new_profile_btn');
    if (mazeNewProfileBtn) {
        mazeNewProfileBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = await callGenericPopup('Enter new maze profile name:', POPUP_TYPE.INPUT, '');
            if (name && name.trim()) {
                const trimmed = name.trim();
                if (!extensionSettings.mazeProfiles[trimmed]) {
                    saveMazeProfile(trimmed, { gridSize: 10 });
                    extensionSettings.currentMazeProfile = trimmed;
                    saveSettingsDebounced();
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_maze')?.click();
                    }, 100);
                } else {
                    await callGenericPopup(`Maze profile "${trimmed}" already exists.`, POPUP_TYPE.TEXT);
                }
            }
        });
    }

    // Maze delete profile
    const mazeDeleteProfileBtn = document.getElementById('mazemaster_maze_delete_profile_btn');
    if (mazeDeleteProfileBtn) {
        mazeDeleteProfileBtn.addEventListener('click', async () => {
            const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
            if (profileName) {
                const confirmed = await callGenericPopup(`Delete maze profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
                if (confirmed) {
                    deleteMazeProfile(profileName);
                    refreshPanel();
                    setTimeout(() => {
                        document.getElementById('mazemaster_show_maze')?.click();
                    }, 100);
                }
            }
        });
    }

    // Maze rename profile
    const mazeRenameProfileBtn = document.getElementById('mazemaster_maze_rename_profile_btn');
    if (mazeRenameProfileBtn) {
        mazeRenameProfileBtn.addEventListener('click', async () => {
            const oldName = document.getElementById('mazemaster_maze_profile_select')?.value;
            if (!oldName) {
                alert('No profile selected to rename');
                return;
            }
            const newName = await callGenericPopup('Enter new profile name:', POPUP_TYPE.INPUT, oldName);
            if (newName && newName.trim() && newName.trim() !== oldName) {
                const trimmed = newName.trim();
                if (extensionSettings.mazeProfiles[trimmed]) {
                    alert('A profile with that name already exists');
                    return;
                }
                // Copy profile data to new name
                extensionSettings.mazeProfiles[trimmed] = extensionSettings.mazeProfiles[oldName];
                delete extensionSettings.mazeProfiles[oldName];
                extensionSettings.currentMazeProfile = trimmed;
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_maze')?.click();
                }, 100);
            }
        });
    }

    // Maze save profile
    const mazeSaveBtn = document.getElementById('mazemaster_maze_save_btn');
    if (mazeSaveBtn) {
        mazeSaveBtn.addEventListener('click', () => {
            const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
            if (!profileName) {
                alert('Please create a maze profile first');
                return;
            }

            const profileData = collectMazeDataFromUI();

            // Validate required fields
            const errors = [];
            if (!profileData.gridSize || profileData.gridSize < 5 || profileData.gridSize > 20) {
                errors.push('Grid Size must be between 5 and 20');
            }

            // Validate encounter percentages don't exceed 100%
            if (profileData.minionEncounters && profileData.minionEncounters.length > 0) {
                const totalPercent = profileData.minionEncounters.reduce((sum, enc) => sum + (enc.percent || 0), 0);
                if (totalPercent > 100) {
                    errors.push(`Encounter percentages total ${totalPercent}% (max 100%)`);
                }
            }

            if (errors.length > 0) {
                alert('Validation Error:\n\n' + errors.join('\n'));
                return;
            }

            saveMazeProfile(profileName, profileData);
            alert(`Maze profile "${profileName}" saved!`);
        });
    }

    // Story Milestones button
    const storyBtn = document.getElementById('mazemaster_maze_story_btn');
    if (storyBtn) {
        storyBtn.addEventListener('click', () => {
            showStoryMilestonesModal();
        });
    }

    // Collapsible section toggles
    document.querySelectorAll('.mazemaster-collapsible-header').forEach(header => {
        header.addEventListener('click', () => {
            const targetId = header.getAttribute('data-target');
            const content = document.getElementById(targetId);
            const collapsible = header.closest('.mazemaster-collapsible');

            if (content) {
                const isExpanded = content.style.display !== 'none';
                content.style.display = isExpanded ? 'none' : 'block';
                collapsible?.classList.toggle('expanded', !isExpanded);
            }
        });
    });

    // Render saved games list
    renderSavedGamesList();

    // Intelligent Distribute button
    const distributeBtn = document.getElementById('mazemaster_intelligent_distribute');
    if (distributeBtn) {
        distributeBtn.addEventListener('click', handleIntelligentDistribute);
    }

    // Maze win image upload
    const mazeWinImageBtn = document.getElementById('mazemaster_maze_win_image_btn');
    const mazeWinImageFile = document.getElementById('mazemaster_maze_win_image_file');
    if (mazeWinImageBtn && mazeWinImageFile) {
        mazeWinImageBtn.addEventListener('click', () => {
            mazeWinImageFile.click();
        });

        mazeWinImageFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
            if (!profileName) {
                alert('Please create a profile first');
                mazeWinImageFile.value = '';
                return;
            }

            try {
                const imagePath = await uploadImage(file, `maze_win_${profileName}`);
                const profile = getMazeProfile(profileName) || {};
                profile.winImage = imagePath;
                saveMazeProfile(profileName, profile);

                // Update preview
                const previewContainer = document.querySelector('.mazemaster-maze-win-image-preview');
                if (previewContainer) {
                    previewContainer.innerHTML = `<img id="maze_win_image_preview" src="${imagePath}" alt="Victory">`;
                }
            } catch (err) {
                alert(`Image upload failed: ${err.message}`);
            }

            mazeWinImageFile.value = '';
        });
    }

    // Chest image upload
    const chestImageBtn = document.getElementById('mazemaster_chest_image_btn');
    const chestImageFile = document.getElementById('mazemaster_chest_image_file');
    if (chestImageBtn && chestImageFile) {
        chestImageBtn.addEventListener('click', () => {
            chestImageFile.click();
        });

        chestImageFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            const profileName = document.getElementById('mazemaster_maze_profile_select')?.value;
            if (!profileName) {
                alert('Please create a profile first');
                chestImageFile.value = '';
                return;
            }

            try {
                const imagePath = await uploadImage(file, `chest_${profileName}`);
                const profile = getMazeProfile(profileName);
                if (profile) {
                    profile.chestImage = imagePath;
                    saveMazeProfile(profileName, profile);

                    // Update preview
                    const previewContainer = document.querySelector('.mazemaster-chest-preview');
                    if (previewContainer) {
                        previewContainer.innerHTML = `<img id="mazemaster_chest_preview_img" src="${imagePath}" style="width: 100%; height: 100%; object-fit: cover;">`;
                    }
                }
            } catch (err) {
                alert(`Image upload failed: ${err.message}`);
            }

            chestImageFile.value = '';
        });
    }

    // Main minion select - toggle settings visibility
    const mainMinionSelect = document.getElementById('mazemaster_maze_main_minion');
    if (mainMinionSelect) {
        mainMinionSelect.addEventListener('change', (e) => {
            const settingsDiv = document.getElementById('mazemaster_main_minion_settings');
            if (settingsDiv) {
                settingsDiv.style.display = e.target.value ? '' : 'none';
            }
        });
    }

    // Exit type select - update profile dropdown
    const exitTypeSelect = document.getElementById('mazemaster_maze_exit_type');
    if (exitTypeSelect) {
        exitTypeSelect.addEventListener('change', () => {
            const currentType = exitTypeSelect.value;
            updateExitProfileDropdown(currentType, '');
        });
    }

    // Add portal button
    const addPortalBtn = document.getElementById('mazemaster_add_portal_btn');
    if (addPortalBtn) {
        addPortalBtn.addEventListener('click', () => {
            const list = document.getElementById('mazemaster_portals_list');
            if (!list) return;

            const portalIndex = list.children.length;
            const portalItem = document.createElement('div');
            portalItem.className = 'mazemaster-portal-item';
            portalItem.dataset.portalIndex = portalIndex;
            portalItem.innerHTML = `
                <div class="portal-header">
                    <span class="portal-color" style="background: #9b59b6"></span>
                    <span class="portal-name">Portal ${portalIndex + 1}</span>
                    <button class="menu_button remove-portal-btn" title="Remove Portal">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
                <div class="portal-details">
                    <div class="portal-row">
                        <label>ID:</label>
                        <input type="text" class="portal-id mazemaster-input" value="" placeholder="portal${portalIndex + 1}">
                    </div>
                    <div class="portal-row">
                        <label>Color:</label>
                        <input type="color" class="portal-color-input" value="#9b59b6">
                    </div>
                    <div class="portal-row">
                        <label>Bidirectional:</label>
                        <input type="checkbox" class="portal-bidirectional" checked>
                    </div>
                    <div class="portal-row coords-row">
                        <span>Start: X</span>
                        <input type="number" class="portal-start-x mazemaster-input" value="" placeholder="auto" min="0">
                        <span>Y</span>
                        <input type="number" class="portal-start-y mazemaster-input" value="" placeholder="auto" min="0">
                    </div>
                    <div class="portal-row coords-row">
                        <span>End: X</span>
                        <input type="number" class="portal-end-x mazemaster-input" value="" placeholder="auto" min="0">
                        <span>Y</span>
                        <input type="number" class="portal-end-y mazemaster-input" value="" placeholder="auto" min="0">
                    </div>
                </div>
            `;

            // Add remove handler
            portalItem.querySelector('.remove-portal-btn').addEventListener('click', () => {
                portalItem.remove();
                updatePortalHint();
            });

            // Update color preview when color input changes
            portalItem.querySelector('.portal-color-input').addEventListener('input', (e) => {
                portalItem.querySelector('.portal-color').style.background = e.target.value;
            });

            // Update name when ID changes
            portalItem.querySelector('.portal-id').addEventListener('input', (e) => {
                portalItem.querySelector('.portal-name').textContent = e.target.value || `Portal ${portalIndex + 1}`;
            });

            list.appendChild(portalItem);
            updatePortalHint();
        });
    }

    // Update portal count hint in section header
    function updatePortalHint() {
        const list = document.getElementById('mazemaster_portals_list');
        const hint = document.querySelector('[data-target="portals_section"]')?.closest('.mazemaster-collapsible')?.querySelector('.mazemaster-collapse-hint');
        if (list && hint) {
            hint.textContent = `(${list.children.length} portal pairs)`;
        }
    }

    // Add remove handlers to existing portal items
    document.querySelectorAll('#mazemaster_portals_list .remove-portal-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            btn.closest('.mazemaster-portal-item').remove();
            updatePortalHint();
        });
    });

    // Add color preview update for existing portals
    document.querySelectorAll('#mazemaster_portals_list .portal-color-input').forEach(input => {
        input.addEventListener('input', (e) => {
            e.target.closest('.mazemaster-portal-item').querySelector('.portal-color').style.background = e.target.value;
        });
    });

    // Add objective button
    const addObjectiveBtn = document.getElementById('mazemaster_add_objective_btn');
    if (addObjectiveBtn) {
        addObjectiveBtn.addEventListener('click', () => {
            const list = document.getElementById('mazemaster_objectives_list');
            if (!list) return;

            const objIndex = list.children.length;
            const objectiveItem = document.createElement('div');
            objectiveItem.className = 'mazemaster-objective-item';
            objectiveItem.dataset.objectiveIndex = objIndex;
            objectiveItem.innerHTML = `
                <div class="objective-config-header">
                    <span class="objective-name">Objective ${objIndex + 1}</span>
                    <button class="menu_button remove-objective-btn" title="Remove Objective">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
                <div class="objective-config-details">
                    <div class="objective-config-row">
                        <label>ID:</label>
                        <input type="text" class="objective-id mazemaster-input" value="" placeholder="obj${objIndex + 1}">
                    </div>
                    <div class="objective-config-row">
                        <label>Type:</label>
                        <select class="objective-type mazemaster-select">
                            <option value="collect">Collect Item</option>
                            <option value="defeat">Defeat Minion</option>
                            <option value="explore">Explore %</option>
                        </select>
                    </div>
                    <div class="objective-config-row objective-target-row">
                        <label>Target:</label>
                        <input type="text" class="objective-target mazemaster-input" value="" placeholder="key, strike, stealth...">
                    </div>
                    <div class="objective-config-row">
                        <label>Count:</label>
                        <input type="number" class="objective-count mazemaster-input" value="1" min="1">
                    </div>
                    <div class="objective-config-row">
                        <label>Description:</label>
                        <input type="text" class="objective-description mazemaster-input" value="" placeholder="Find 3 Keys">
                    </div>
                    <div class="objective-config-row">
                        <label>Required:</label>
                        <input type="checkbox" class="objective-required" checked>
                    </div>
                    <div class="objective-config-row">
                        <label>Reward Script:</label>
                        <input type="text" class="objective-reward mazemaster-input" value="" placeholder="/echo Objective complete!">
                    </div>
                </div>
            `;

            // Add remove handler
            objectiveItem.querySelector('.remove-objective-btn').addEventListener('click', () => {
                objectiveItem.remove();
                updateObjectiveHint();
            });

            // Add type change handler to show/hide target row
            const typeSelect = objectiveItem.querySelector('.objective-type');
            const targetRow = objectiveItem.querySelector('.objective-target-row');
            typeSelect.addEventListener('change', () => {
                targetRow.style.display = typeSelect.value === 'explore' ? 'none' : 'flex';
            });

            // Update description when description changes
            objectiveItem.querySelector('.objective-description').addEventListener('input', (e) => {
                objectiveItem.querySelector('.objective-name').textContent = e.target.value || `Objective ${objIndex + 1}`;
            });

            list.appendChild(objectiveItem);
            updateObjectiveHint();
        });
    }

    // Update objective count hint in section header
    function updateObjectiveHint() {
        const list = document.getElementById('mazemaster_objectives_list');
        const hint = document.querySelector('[data-target="objectives_section"]')?.closest('.mazemaster-collapsible')?.querySelector('.mazemaster-collapse-hint');
        if (list && hint) {
            hint.textContent = `(${list.children.length} objectives)`;
        }
    }

    // Add remove handlers to existing objective items
    document.querySelectorAll('#mazemaster_objectives_list .remove-objective-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            btn.closest('.mazemaster-objective-item').remove();
            updateObjectiveHint();
        });
    });

    // Add type change handlers to existing objectives
    document.querySelectorAll('#mazemaster_objectives_list .objective-type').forEach(select => {
        const item = select.closest('.mazemaster-objective-item');
        const targetRow = item.querySelector('.objective-target-row');
        select.addEventListener('change', () => {
            targetRow.style.display = select.value === 'explore' ? 'none' : 'flex';
        });
    });

    // Add encounter button
    const addEncounterBtn = document.getElementById('mazemaster_add_encounter_btn');
    if (addEncounterBtn) {
        addEncounterBtn.addEventListener('click', () => {
            const list = document.getElementById('mazemaster_maze_encounters_list');
            if (!list) return;

            const minionOptions = Object.keys(extensionSettings.minions || {}).map(id => {
                const m = extensionSettings.minions[id];
                return `<option value="${id}">${m.name || id}</option>`;
            }).join('');

            const row = document.createElement('div');
            row.className = 'mazemaster-encounter-row';
            row.innerHTML = `
                <select class="encounter-minion-select">
                    <option value="">Select Minion</option>
                    ${minionOptions}
                </select>
                <input type="number" class="encounter-percent-input" min="1" max="100" value="5" placeholder="%">
                <span class="encounter-percent-label">%</span>
                <button class="encounter-remove-btn menu_button"><i class="fa-solid fa-trash"></i></button>
            `;

            // Add remove handler
            row.querySelector('.encounter-remove-btn').addEventListener('click', () => {
                row.remove();
            });

            list.appendChild(row);
        });
    }

    // Add trap encounter button
    const addTrapEncounterBtn = document.getElementById('mazemaster_add_trap_encounter_btn');
    if (addTrapEncounterBtn) {
        addTrapEncounterBtn.addEventListener('click', () => {
            const list = document.getElementById('mazemaster_maze_traps_list');
            if (!list) return;

            const trapOptions = getTrapNames().map(id => {
                const t = getTrap(id);
                return `<option value="${escapeHtml(id)}">${escapeHtml(t?.name || id)}</option>`;
            }).join('');

            if (!trapOptions) {
                alert('No traps available. Create traps in the Traps tab first.');
                return;
            }

            const row = document.createElement('div');
            row.className = 'mazemaster-encounter-row mazemaster-trap-encounter-row';
            row.innerHTML = `
                <select class="trap-encounter-select">
                    <option value="">Select Trap</option>
                    ${trapOptions}
                </select>
                <input type="number" class="trap-encounter-percent-input" min="1" max="100" value="5" placeholder="%">
                <span class="encounter-percent-label">%</span>
                <button class="trap-encounter-remove-btn menu_button"><i class="fa-solid fa-trash"></i></button>
            `;

            // Add remove handler
            row.querySelector('.trap-encounter-remove-btn').addEventListener('click', () => {
                row.remove();
            });

            list.appendChild(row);
        });
    }

    // =========================================================================
    // MINION HANDLERS
    // =========================================================================

    // Add minion button
    const addMinionBtn = document.getElementById('mazemaster_add_minion_btn');
    const minionImageFile = document.getElementById('mazemaster_minion_image_file');
    if (addMinionBtn && minionImageFile) {
        addMinionBtn.addEventListener('click', () => {
            minionImageFile.click();
        });

        minionImageFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            try {
                const minionId = `minion_${Date.now()}`;
                const imagePath = await uploadImage(file, minionId);
                const minionName = await callGenericPopup('Enter minion name:', POPUP_TYPE.INPUT, 'New Minion');

                if (minionName && minionName.trim()) {
                    saveMinion(minionId, {
                        name: minionName.trim(),
                        imagePath: imagePath,
                    });
                    renderMinionsList();
                }
            } catch (err) {
                alert(`Image upload failed: ${err.message}`);
            }

            minionImageFile.value = '';
        });
    }

    // Minion profile select change - filter displayed minions
    const minionProfileSelect = document.getElementById('mazemaster_minion_profile_select');
    if (minionProfileSelect) {
        minionProfileSelect.addEventListener('change', () => {
            renderMinionsList();
        });
    }

    // Minion profile save button
    const minionProfileSaveBtn = document.getElementById('mazemaster_minion_profile_save_btn');
    if (minionProfileSaveBtn) {
        minionProfileSaveBtn.addEventListener('click', async () => {
            const profileName = await callGenericPopup('Enter profile name:', POPUP_TYPE.INPUT, 'My Minions');
            if (profileName && profileName.trim()) {
                const trimmed = profileName.trim();
                extensionSettings.minionProfiles[trimmed] = JSON.parse(JSON.stringify(extensionSettings.minions || {}));
                saveSettingsDebounced();
                alert(`Minion profile "${trimmed}" saved!`);
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_minions')?.click();
                }, 100);
            }
        });
    }

    // Minion profile load button
    const minionProfileLoadBtn = document.getElementById('mazemaster_minion_profile_load_btn');
    if (minionProfileLoadBtn) {
        minionProfileLoadBtn.addEventListener('click', async () => {
            const profileSelect = document.getElementById('mazemaster_minion_profile_select');
            const profileName = profileSelect?.value;
            if (!profileName) {
                alert('Select a profile to load');
                return;
            }
            const confirmed = await callGenericPopup(`Load minion profile "${profileName}"? This will replace your current minions.`, POPUP_TYPE.CONFIRM);
            if (confirmed) {
                extensionSettings.minions = JSON.parse(JSON.stringify(extensionSettings.minionProfiles[profileName] || {}));
                saveSettingsDebounced();
                renderMinionsList();
                alert(`Minion profile "${profileName}" loaded!`);
            }
        });
    }

    // Minion profile delete button
    const minionProfileDeleteBtn = document.getElementById('mazemaster_minion_profile_delete_btn');
    if (minionProfileDeleteBtn) {
        minionProfileDeleteBtn.addEventListener('click', async () => {
            const profileSelect = document.getElementById('mazemaster_minion_profile_select');
            const profileName = profileSelect?.value;
            if (!profileName) {
                alert('Select a profile to delete');
                return;
            }
            const confirmed = await callGenericPopup(`Delete minion profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
            if (confirmed) {
                delete extensionSettings.minionProfiles[profileName];
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_minions')?.click();
                }, 100);
            }
        });
    }

    // =========================================================================
    // TRAP HANDLERS
    // =========================================================================

    // Add trap button
    const addTrapBtn = document.getElementById('mazemaster_add_trap_btn');
    const trapImageFile = document.getElementById('mazemaster_trap_image_file');
    if (addTrapBtn && trapImageFile) {
        addTrapBtn.addEventListener('click', () => {
            trapImageFile.click();
        });

        trapImageFile.addEventListener('change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;

            try {
                const trapId = `trap_${Date.now()}`;
                const imagePath = await uploadImage(file, trapId);
                const trapName = await callGenericPopup('Enter trap name:', POPUP_TYPE.INPUT, 'New Trap');

                if (trapName && trapName.trim()) {
                    saveTrap(trapId, {
                        name: trapName.trim(),
                        imagePath: imagePath,
                        message: 'You triggered a trap!',
                        script: '',
                    });
                    renderTrapsList();
                }
            } catch (err) {
                alert(`Image upload failed: ${err.message}`);
            }

            trapImageFile.value = '';
        });
    }

    // Trap profile save button
    const trapProfileSaveBtn = document.getElementById('mazemaster_trap_profile_save_btn');
    if (trapProfileSaveBtn) {
        trapProfileSaveBtn.addEventListener('click', async () => {
            const profileName = await callGenericPopup('Enter profile name:', POPUP_TYPE.INPUT, 'My Traps');
            if (profileName && profileName.trim()) {
                const trimmed = profileName.trim();
                extensionSettings.trapProfiles[trimmed] = JSON.parse(JSON.stringify(extensionSettings.traps || {}));
                saveSettingsDebounced();
                alert(`Trap profile "${trimmed}" saved!`);
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_traps')?.click();
                }, 100);
            }
        });
    }

    // Trap profile load button
    const trapProfileLoadBtn = document.getElementById('mazemaster_trap_profile_load_btn');
    if (trapProfileLoadBtn) {
        trapProfileLoadBtn.addEventListener('click', async () => {
            const profileSelect = document.getElementById('mazemaster_trap_profile_select');
            const profileName = profileSelect?.value;
            if (!profileName) {
                alert('Select a profile to load');
                return;
            }
            const confirmed = await callGenericPopup(`Load trap profile "${profileName}"? This will replace your current traps.`, POPUP_TYPE.CONFIRM);
            if (confirmed) {
                extensionSettings.traps = JSON.parse(JSON.stringify(extensionSettings.trapProfiles[profileName] || {}));
                saveSettingsDebounced();
                renderTrapsList();
                alert(`Trap profile "${profileName}" loaded!`);
            }
        });
    }

    // Trap profile delete button
    const trapProfileDeleteBtn = document.getElementById('mazemaster_trap_profile_delete_btn');
    if (trapProfileDeleteBtn) {
        trapProfileDeleteBtn.addEventListener('click', async () => {
            const profileSelect = document.getElementById('mazemaster_trap_profile_select');
            const profileName = profileSelect?.value;
            if (!profileName) {
                alert('Select a profile to delete');
                return;
            }
            const confirmed = await callGenericPopup(`Delete trap profile "${profileName}"?`, POPUP_TYPE.CONFIRM);
            if (confirmed) {
                delete extensionSettings.trapProfiles[profileName];
                saveSettingsDebounced();
                refreshPanel();
                setTimeout(() => {
                    document.getElementById('mazemaster_show_traps')?.click();
                }, 100);
            }
        });
    }
}

function refreshPanel() {
    const drawer = document.getElementById('mazemaster_drawer');
    if (drawer) {
        drawer.innerHTML = getPanelHtml();
        setupEventHandlers();
        renderSegmentsList();
        renderBattlebarImages();
        renderMinionsList();
        renderTrapsList();
        updateMazeSettings();
    }
}

// =============================================================================
// MACRO PROCESSING (like TPLink pattern)
// =============================================================================

/**
 * Process a message element for MazeMaster macros
 * {{wheel:profileName}} - spins the wheel
 * {{battlebar:profileName}} - starts the battlebar
 * {{maze:profileName}} - starts the maze
 */
async function processMacroMessage(mesElement) {
    if (processedMacroMessages.has(mesElement)) return;

    // Skip streaming messages
    if (mesElement.classList.contains('streaming') ||
        mesElement.classList.contains('is-typing') ||
        mesElement.querySelector('.mes_text.streaming')) {
        return;
    }

    const mesText = mesElement.querySelector('.mes_text .stle--content') || mesElement.querySelector('.mes_text');
    if (!mesText) return;

    const text = mesText.textContent || '';

    // Match {{wheel:profileName}}, {{battlebar:profileName}}, and {{maze:profileName}}
    const wheelPattern = /\{\{wheel:([^}]+)\}\}/gi;
    const battlebarPattern = /\{\{battlebar:([^}]+)\}\}/gi;
    const mazePattern = /\{\{maze:([^}]+)\}\}/gi;

    const wheelMatches = [];
    const battlebarMatches = [];
    const mazeMatches = [];

    let match;
    while ((match = wheelPattern.exec(text)) !== null) {
        wheelMatches.push({ full: match[0], profile: match[1].trim() });
    }
    while ((match = battlebarPattern.exec(text)) !== null) {
        battlebarMatches.push({ full: match[0], profile: match[1].trim() });
    }
    while ((match = mazePattern.exec(text)) !== null) {
        mazeMatches.push({ full: match[0], profile: match[1].trim() });
    }

    if (wheelMatches.length === 0 && battlebarMatches.length === 0 && mazeMatches.length === 0) return;

    // Mark as processed
    processedMacroMessages.add(mesElement);

    const context = SillyTavern.getContext();
    const mesId = mesElement.getAttribute('mesid');

    // Process wheel macros
    for (const m of wheelMatches) {
        console.log(`[MazeMaster] Processing wheel macro: ${m.full}`);

        // Trigger the wheel (same as slash command)
        const result = loadWheelFromProfile(m.profile);
        if (!result.error) {
            const validation = validateWheelBalance();
            if (validation.valid) {
                showWheelModal();
            }
        }

        const replacement = `[ Wheel: ${m.profile}]`;

        // Update chat context and DOM
        if (context.chat && mesId !== null) {
            const msgIndex = parseInt(mesId);
            if (context.chat[msgIndex]) {
                const originalMes = context.chat[msgIndex].mes;
                // Strip macro from context (AI never sees it)
                const contextMes = originalMes.replace(m.full, '').replace(/\s+/g, ' ').trim();
                // Visual replacement for user
                const visualMes = originalMes.replace(m.full, replacement);

                context.chat[msgIndex].mes = contextMes;

                const mesTextEl = mesElement.querySelector('.mes_text');
                if (mesTextEl) {
                    mesTextEl.innerHTML = visualMes;
                }
            }
        }
    }

    // Process battlebar macros
    for (const m of battlebarMatches) {
        console.log(`[MazeMaster] Processing battlebar macro: ${m.full}`);

        // Trigger the battlebar (same as slash command)
        startBattlebar(m.profile);

        const replacement = `[ Battlebar: ${m.profile}]`;

        // Update chat context and DOM
        if (context.chat && mesId !== null) {
            const msgIndex = parseInt(mesId);
            if (context.chat[msgIndex]) {
                const originalMes = context.chat[msgIndex].mes;
                // Strip macro from context
                const contextMes = originalMes.replace(m.full, '').replace(/\s+/g, ' ').trim();
                // Visual replacement
                const visualMes = originalMes.replace(m.full, replacement);

                context.chat[msgIndex].mes = contextMes;

                const mesTextEl = mesElement.querySelector('.mes_text');
                if (mesTextEl) {
                    mesTextEl.innerHTML = visualMes;
                }
            }
        }
    }

    // Process maze macros
    for (const m of mazeMatches) {
        console.log(`[MazeMaster] Processing maze macro: ${m.full}`);

        // Trigger the maze (same as slash command)
        startMaze(m.profile);

        const replacement = `[ Maze: ${m.profile}]`;

        // Update chat context and DOM
        if (context.chat && mesId !== null) {
            const msgIndex = parseInt(mesId);
            if (context.chat[msgIndex]) {
                const originalMes = context.chat[msgIndex].mes;
                // Strip macro from context
                const contextMes = originalMes.replace(m.full, '').replace(/\s+/g, ' ').trim();
                // Visual replacement
                const visualMes = originalMes.replace(m.full, replacement);

                context.chat[msgIndex].mes = contextMes;

                const mesTextEl = mesElement.querySelector('.mes_text');
                if (mesTextEl) {
                    mesTextEl.innerHTML = visualMes;
                }
            }
        }
    }
}

/**
 * Register message hooks to intercept and process MazeMaster macros
 */
function registerMacroHooks() {
    const context = SillyTavern.getContext();

    if (!context || !context.eventSource || !context.eventTypes) {
        console.warn('[MazeMaster] Context not ready for macro hooks, retrying...');
        setTimeout(registerMacroHooks, 500);
        return;
    }

    // Listen for user messages
    if (context.eventTypes.USER_MESSAGE_RENDERED) {
        context.eventSource.on(context.eventTypes.USER_MESSAGE_RENDERED, (messageId) => {
            setTimeout(() => {
                const mesElement = document.querySelector(`#chat .mes[mesid="${messageId}"]`);
                if (mesElement) processMacroMessage(mesElement);
            }, 500);
        });
    }

    // Listen for AI messages
    if (context.eventTypes.CHARACTER_MESSAGE_RENDERED) {
        context.eventSource.on(context.eventTypes.CHARACTER_MESSAGE_RENDERED, (messageId) => {
            const tryProcess = (attempt = 1) => {
                const mesElement = document.querySelector(`#chat .mes[mesid="${messageId}"]`);
                if (!mesElement) return;

                const isStreaming = mesElement.classList.contains('streaming') ||
                                   mesElement.classList.contains('is-typing');

                if (isStreaming && attempt < 5) {
                    setTimeout(() => tryProcess(attempt + 1), 1000);
                } else {
                    processMacroMessage(mesElement);
                }
            };
            setTimeout(() => tryProcess(), 500);
        });
    }

    console.log('[MazeMaster] Macro hooks registered');
}

// =============================================================================
// INITIALIZATION
// =============================================================================

(function init() {
    loadSettings();

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            initUI();
            registerSlashCommands();
            registerMacroHooks();
        });
    } else {
        initUI();
        registerSlashCommands();
        registerMacroHooks();
    }

    console.log(`[${MODULE_NAME}] Extension loaded (folder: ${EXTENSION_FOLDER_NAME})`);
})();
